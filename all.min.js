function dragInteraction(t) {
    var e = null,
        i = null,
        n = null,
        r = "",
        o = document.getElementById("dragTooltip"),
        s = new ol.Overlay({ element: o, offset: [10, 0], positioning: "bottom-left" });
    t.addOverlay(s), this.handleDownEvent = function(r) {
        var o = t.forEachFeatureAtPixel(r.pixel, function(t, e) { if (e == vectorLayer) return t });
        if (o) {
            var s = o.getGeometry(),
                a = s.getCoordinates();
            return i = r.coordinate, e = o, n = getFeatureMaxCoords(a), !0
        }
        return !1
    }, this.handleDragEvent = function(t) {
        var r = Math.round(t.coordinate[0] - i[0]),
            o = Math.round(t.coordinate[1] - i[1]);
        if (e.setStyle(drawStyle), n[0] = n[0] + o, n[1] = n[1] + o, n[2] = n[2] + r, n[3] = n[3] + r, !(n[0] < fence[0] || n[1] > fence[1] || n[2] < fence[2] || n[3] > fence[3])) {
            var s = e.getGeometry();
            s.translate(r, o), i[0] = t.coordinate[0], i[1] = t.coordinate[1]
        }
    }, this.handleMoveEvent = function(t) {
        var e = t.map,
            i = e.forEachFeatureAtPixel(t.pixel, function(t, e) { if (e == vectorLayer) return t });
        if (i) {
            if ($(".ol-unselectable").css("cursor", "move"), "undefined" != typeof i.getId() && (s.setPosition(t.coordinate), i.getId() != r)) {
                o.style.display = "inline-block", r = i.getId();
                var n = $.grep(perimetersArray, function(t) { return t.id == i.getId() }),
                    a = n[0].verboseScales.join(" ");
                o.innerHTML = a
            }
        } else $(".ol-unselectable").css("cursor", "default"), o.style.display = "none", r = ""
    }, this.handleUpEvent = function(t) {
        var n = $.grep(perimetersArray, function(t) { return t.id == e.getId() }),
            r = recalculateEstimatedSize(e, n[0]);
        return setRecalculatedEstimatedSize(r, n[0]), o.innerHTML = n[0].verboseScales.join(" "), i = null, e.setStyle(null), e = null, !1
    }, this.init = function() { this.drag = new ol.interaction.Pointer({ handleDownEvent: this.handleDownEvent, handleDragEvent: this.handleDragEvent, handleMoveEvent: this.handleMoveEvent, handleUpEvent: this.handleUpEvent }), t.addInteraction(this.drag) }, this.setActive = function(t) { o.style.display = "none", r = "", this.drag.setActive(t) }
}

function getDragNdropInteraction() {
    var t = new ol.interaction.DragAndDrop({ formatConstructors: [ol.format.KML], projection: "EPSG:21781" });
    return t.on("addfeatures", function(t) {
        if ("application/vnd.google-earth.kml+xml" != t.file.type && "" != t.file.type) return log("File type is not: application/vnd.google-earth.kml+xml"), log(t.file.type), void showAlertView("lingua.alertAttention", lingua.kmlImportError);
        var e = new FileReader;
        e.readAsText(t.file, "UTF-8"), e.onload = function(e) {
            var i = e.target || eveent.srcElement,
                n = $($.parseXML(i.result)),
                r = n.find("scale"),
                o = r.length > 0;
            try {
                var s = [];
                t.features.forEach(function(t) {
                    var e = "",
                        i = [],
                        n = t.clone(),
                        a = "_" + Math.random().toString(36).substr(2, 9);
                    n.setId(a), n.setStyle(null);
                    var h = [];
                    if (n.getGeometry().getCoordinates()[0].forEach(function(t) { h.push([Math.round(t[0]), Math.round(t[1])]) }, this), n.getGeometry().setCoordinates([h]), s.push(n), !checkPerpendicularityAndEqualPoints(n.getGeometry().getCoordinates()[0])) return void showAlertView(lingua.alertAttention, lingua.notPerpendicularError);
                    if (o) {
                        var l = $.grep($(r), function(e) { return $(e).attr("featureid") == t.getId() }),
                            u = [];
                        $.each(l, function(t, n) {
                            u.push([$(n).attr("name"), n.innerHTML]);
                            var r = $.grep($(".btn-checkbox-layer"), function(t) { return $(n).attr("name") == $(t).attr("id") })[0].innerHTML;
                            e != $(n).attr("name") && ("" == e ? i.push(r) : i.push("<br>" + r), e = $(n).attr("name")), i.push(" " + n.innerHTML)
                        });
                        var p = _.groupBy(u, function(t) { return t[0] });
                        $.each(p, function(t, e) { e.forEach(function(t, i) { e[i] = t[1] }) });
                        var c = recalculateEstimatedSize(t, { scales: p });
                        c < 1 && (c = "< 1"), i.push("<br>" + lingua.estimatedSize + c + " MB"), perimetersArray.push({ id: a, scales: p, verboseScales: i })
                    }
                }), vectorSource.addFeatures(s), o || showSetScaleView(s)
            } catch (t) { alert("KML reading error"), log(t) }
        }
    }), t
}

function drawInteraction(t) {
    var e = [
            [0, 0],
            [0, 0]
        ],
        i = new ol.Feature({ geometry: new ol.geom.LineString(e) });
    i.setStyle(lineStyle);
    var n = document.getElementById("drawTooltip"),
        r = new ol.Overlay({ element: n, offset: [5, -5], positioning: "bottom-left" });
    t.addOverlay(r);
    var o = !1,
        s = 0,
        a = 0,
        h = !1,
        l = !1,
        u = null,
        p = !1,
        c = !1;
    this.geometryFunction = function(e, l) {
        l || (l = new ol.geom.Polygon(null));
        var u = _.clone(_.last(e[0])),
            f = t.getPixelFromCoordinate(u);
        f[0] = Math.round(f[0] / 10), f[1] = Math.round(f[1] / 10);
        var g = t.getPixelFromCoordinate(e[0][0]);
        g[0] = Math.round(g[0] / 10), g[1] = Math.round(g[1] / 10), canFinishStyle = f[0] == g[0] && f[1] == g[1], 2 == e[0].length && (e[0][0][1] < fence[0] ? (e[0][0][1] = fence[0], e[0][1][1] = fence[0]) : e[0][0][1] > fence[1] && (e[0][0][1] = fence[1], e[0][1][1] = fence[1]), e[0][0][0] < fence[2] ? (e[0][0][0] = fence[2], e[0][1][0] = fence[2]) : e[0][0][0] > fence[3] && (e[0][0][0] = fence[3], e[0][1][0] = fence[3])), e[0].length <= 2 && l.setCoordinates(e), e[0].length > 1 && (l = strightGeometry(e, l));
        var d = _.last(e[0]);
        illegalStyle = !1;
        var y = !1;
        if (d[1] < fence[0] || d[1] > fence[1] || d[0] < fence[2] || d[0] > fence[3] ? (illegalStyle = !0, y = !0, e[0].length > 1 && "none" == n.style.display && (r.setPosition(d), n.style.display = "inline-block", n.innerHTML = lingua.outsideFenceError, c = !0)) : (n.style.display = "none", c = !1), e[0].length !== s && (s = e[0].length, s > 2 && e[0][s - 2][0] == e[0][s - 3][0] && e[0][s - 2][1] == e[0][s - 3][1] && (log("two equal points"), y = !0), (y || p) && (e[0].splice(s - 1, 1), l.setCoordinates(e), s = e[0].length)), e[0].length > 3) {
            var m = d,
                v = e[0][e[0].length - 2],
                b = l.clone().getCoordinates()[0];
            b.pop();
            var w = { x: m[0], y: m[1] },
                x = { x: v[0], y: v[1] };
            ({ x: u[0], y: u[1] });
            e[0].length !== a && (a = e[0].length, newPointOverlaps(w, x, b) && draw.draw.removeLastPoint()), hasIntersections(w, x, null, b) ? (illegalStyle = !0, y = !0, p = !0, r.setPosition(u), n.style.display = "inline-block", n.innerHTML = lingua.intersectionError) : (p = !1, c || (n.style.display = "none")), e[0][s - 1][0] != startCoordinate[0] && e[0][s - 1][1] != startCoordinate[1] || e[0][s - 1][0] != e[0][s - 2][0] || e[0][s - 1][1] != e[0][s - 2][1] || (illegalStyle = !0)
        }
        return i.getGeometry().setCoordinates([_.last(e[0]), u]), h && (o && (l = geometryMovePointCorrector(e, l)), h = !1, canFinishStyle = !1), l
    }, this.finishCondition = function() { return log("finish condition"), !illegalStyle && (o = !1, (currentCoordinate[0] == startCoordinate[0] || currentCoordinate[1] == startCoordinate[1]) && (currentCoordinate[0] != firstCoordinate[0] && currentCoordinate[1] != firstCoordinate[1] && (o = !0), h = !0, !0)) }, this.init = function() { this.draw = new ol.interaction.Draw({ source: vectorSource, type: "Polygon", style: drawStyle, minPoints: 3, geometryFunction: this.geometryFunction, finishCondition: this.finishCondition, freehandCondition: ol.events.condition.never }), t.addInteraction(this.draw), this.setEvents() }, this.setEvents = function() { this.draw.on("propertychange", function(t) { _.isEqual(i.getGeometry().getCoordinates(), e) || (log("set to null"), vectorSource.removeFeature(i), i.getGeometry().setCoordinates(e)), i.getGeometry().setCoordinates(e) }), this.draw.on("drawend", function(t) { vectorSource.removeFeature(i), i.getGeometry().setCoordinates(e), showSetScaleView([t.feature]) }), this.draw.on("drawstart", function(t) { vectorSource.addFeature(i) }) }, this.setActive = function(t) { this.draw.setActive(t), canFinishStyle = !1, illegalPoint = !1, l = !1, canFinishStyle = !1, u = null, p = !1, t ? $(".ol-unselectable").css("cursor", "crosshair") : $(".tooltip").css("display", "none") }
}

function addGuiActions(t) {
    function e() { $("#kmlLoading").fadeOut(2e3, function() { $("#kmlLoading").hide() }) }
    $(".ol-unselectable").on("dragenter", function() { $("#dragndrop").fadeIn(200) }).on("drop dragleave", function() { $("#dragndrop").fadeOut(200, function() { $("#dragndrop").hide() }) }), $("#btn-download").click(function() {
        return vectorLayer.getSource().getFeatures().length < 1 ? void showAlertView(lingua.alertAttention, lingua.downloadErrorText) : void $("#kmlLoading").fadeIn(200, function() {
            draw.draw.getActive() && (draw.draw.setActive(!1), draw.draw.setActive(!0));
            var t = navigator.userAgent.indexOf("Safari") != -1 && navigator.userAgent.indexOf("Chrome") == -1,
                i = vectorLayer.getSource(),
                n = [],
                r = [],
                o = [];
            i.forEachFeature(function(t) {
                var e = "",
                    i = t.clone();
                i.setId(t.getId()), i.setStyle(vectorLayerStyle), i.getGeometry().getCoordinates()[0].forEach(function(t, i) { e = e + t[0] + "," + t[1] + " " }), r.push(e);
                var s = $.grep(perimetersArray, function(e) { return e.id == t.getId() }),
                    a = "";
                $.each(s[0].scales, function(e, i) { log(e), a = a + "<" + e + ">", s[0].scales[e].forEach(function(i) { a = a + '<scale name="' + e + '" featureId="' + t.getId() + '">' + i + "</scale>" }), a = a + "</" + e + ">" }), o.push(a), n.push(i)
            }), kmlFormatter = new ol.format.KML({ writeStyles: !1 });
            var s = kmlFormatter.writeFeatures(n, { dataProjection: "EPSG:4326", featureProjection: "EPSG:21781" }),
                a = $($.parseXML(s)),
                h = a.find("Placemark");
            if (h.each(function(t) {
                    var e = "<ExtendedData>";
                    e = e + "<coordinates>" + r[t] + "</coordinates>", e = e + "<layers>" + o[t] + "</layers>", e += "</ExtendedData>", $(this).append($(e))
                }), window.XMLSerializer) var s = (new XMLSerializer).serializeToString(a[0]);
            s = vkbeautify.xml(s);
            var l = /^([a-zA-Z0-9 _-äöüëéèêçÄÖÜËÉÈÊÇß]+)$/;
            do { var u = prompt(lingua.enterFilename, "perimeter"); if (t && "" == u || null === u) return e(); "" != u && null != u || (u = DEFAULT_KML_NAME) } while (!u.match(l));
            if (u.length > MAX_LENGTH_KML_NAME) return alert(lingua.filenameMaxLength + ": " + MAX_LENGTH_KML_NAME), e();
            if (t) {
                var p = document.createElement("form");
                p.setAttribute("method", "post"), p.setAttribute("action", "/files"), p.setAttribute("id", "kmlFormToDelete");
                var c = document.createElement("input");
                c.setAttribute("id", "kmlDataInput"), c.setAttribute("type", "hidden"), c.setAttribute("name", "content"), c.setAttribute("value", s);
                var f = document.createElement("input");
                f.setAttribute("id", "kmlNameInput"), f.setAttribute("type", "hidden"), f.setAttribute("name", "name"), f.setAttribute("value", u), p.appendChild(c), p.appendChild(f), document.body.appendChild(p), p.submit(), document.body.removeChild(p)
            } else {
                var g = new Blob([s], { type: "application/vnd.google-earth.kml+xml" });
                saveAs(g, u + ".kml")
            }
            return e()
        })
    });
    var i = "btn-draw";
    $(document).on("keyup", function(t) {
        if (27 === t.keyCode && draw.draw.U.length >= 2) try { draw.draw.removeLastPoint() } catch (t) {}
        68 === t.keyCode && (i = changeMode(i, "btn-draw")), 77 === t.keyCode && (log("mod"), i = changeMode(i, "btn-modify")), 83 === t.keyCode && (i = changeMode(i, "btn-dragSelect"))
    }), $(document).on("keyup", function(t) { 65 === t.keyCode && "btn-dragSelect" == i && (log("ok A"), log(select), select.select.getFeatures().clear(), vectorLayer.getSource().forEachFeature(function(t) { select.select.getFeatures().push(t) })) }), $(".mode").click(function() { i = changeMode(i, this.id) }), $("#btn-zoom-in").click(function() { t.beforeRender(ol.animation.zoom({ resolution: t.getView().getResolution(), duration: 200 })), t.getView().setZoom(t.getView().getZoom() + 1) }), $("#btn-zoom-out").click(function() { t.beforeRender(ol.animation.zoom({ resolution: t.getView().getResolution(), duration: 200 })), t.getView().setZoom(t.getView().getZoom() - 1) });
    var n = 500;
    $("#help-btn").click(function() { $("#help").show(n), $("#btn-modify-delete").show(n), $("#btn-dragSelect-delete").show(n), $("#btn-union").show(n), $("#btn-setScale").show(n), $(".controlImage").addClass("no-pointer-events"), $(".help-text").show(n).css("display", "inline"), $(".p").addClass("helpP") }), $("#help-btn-close").click(function() { $(".controlImage").removeClass("no-pointer-events"), $(".p").removeClass("helpP"), $("#help").hide(n), "btn-modify" == i ? ($("#btn-dragSelect-delete").hide(), $("#btn-union").hide(), $("#btn-setScale").hide()) : "btn-dragSelect" == i ? $("#btn-modify-delete").hide() : ($("#btn-modify-delete").hide(), $("#btn-dragSelect-delete").hide(), $("#btn-union").hide(), $("#btn-setScale").hide()), $(".help-text").hide() }), $("#backgroudSelect").change(function() {
        var e = ga.layer.create(this.value);
        t.setLayerGroup(new ol.layer.Group({ layers: [e, vectorLayer, fenceLayer] }))
    }), $("#alertViewBtnOk").click(function() { hideAlertView() })
}

function addSelectGuiActions(t, e) {
    $("#btn-union").click(function() {
        if (2 != e.getArray().length) return void showAlertView("lingua.alertAttention", lingua.unionErrorText);
        var t = e.getArray()[0].getGeometry(),
            i = e.getArray()[1].getGeometry(),
            n = turf.polygon([t.getCoordinates()[0]]),
            r = turf.polygon([i.getCoordinates()[0]]),
            o = turf.union(n, r);
        return "MultiPolygon" == o.geometry.type ? (log(o.geometry.coordinates), void showAlertView(lingua.alertAttention, lingua.noIntersection)) : (t.setCoordinates([o.geometry.coordinates[0]]), vectorSource.removeFeature(e.getArray()[1]), void e.clear())
    }), $("#btn-dragSelect-delete").click(function() { deleteSelectedFeature(e) }), $("#btn-setScale").click(function() {
        if (e.getArray().length >= 1) {
            var i = [];
            e.forEach(function(t) { i.push(t.getGeometry().getCoordinates()) }), t.beforeRender(ol.animation.zoom({ resolution: t.getView().getResolution(), duration: 200 })), t.getView().fit(new ol.geom.MultiPolygon(i).getExtent(), t.getSize()), showSetScaleView(e.getArray())
        } else showAlertView(lingua.alertAttention, lingua.noPerimeterErrorText)
    }), $("#btn-setScaleCancel").click(function() { hideSetScaleView() }), $(document).on("keyup", function(t) { 46 !== t.keyCode && 8 !== t.keyCode || e.getArray().length >= 1 && deleteSelectedFeature(e) })
}

function addModifyGuiActions(t) { $("#btn-modify-delete").click(function() { deleteSelectedFeature(t) }), $(document).on("keyup", function(e) { 46 !== e.keyCode && 8 !== e.keyCode || t.getArray().length >= 1 && deleteSelectedFeature(t) }) }

function addInteractions(t) { modify = new modifyInteraction(t), modify.init(), drag = new dragInteraction(t), drag.init(), draw = new drawInteraction(t), draw.init(), select = new selectInteraction(t), select.init(), t.addInteraction(new ol.interaction.Translate({ layer: vectorLayer })), t.on("dblclick", function(e) { if (drag.drag.getActive()) { var i = t.forEachFeatureAtPixel(e.pixel, function(t, e) { if (e == vectorLayer) return t }); "undefined" != typeof i && ($("#dragTooltip").css("display", "none"), t.beforeRender(ol.animation.zoom({ resolution: t.getView().getResolution(), duration: 200 })), t.getView().fit(new ol.geom.MultiPolygon([i.getGeometry().getCoordinates()]).getExtent(), t.getSize()), showSetScaleView([i])) } }), modify.setActive(!1), drag.setActive(!1), select.setActive(!1), draw.setActive(!0) }

function WGStoCHy(t, e) {
    t = DECtoSEX(t), e = DECtoSEX(e), t = DEGtoSEC(t), e = DEGtoSEC(e);
    var i = (t - 169028.66) / 1e4,
        n = (e - 26782.5) / 1e4,
        r = 600072.37 + 211455.93 * n - 10938.51 * n * i - .36 * n * Math.pow(i, 2) - 44.54 * Math.pow(n, 3);
    return r
}

function WGStoCHx(t, e) {
    t = DECtoSEX(t), e = DECtoSEX(e), t = DEGtoSEC(t), e = DEGtoSEC(e);
    var i = (t - 169028.66) / 1e4,
        n = (e - 26782.5) / 1e4,
        r = 200147.07 + 308807.95 * i + 3745.25 * Math.pow(n, 2) + 76.63 * Math.pow(i, 2) - 194.56 * Math.pow(n, 2) * i + 119.79 * Math.pow(i, 3);
    return r
}

function CHtoWGSlat(t, e) {
    var i = (t - 6e5) / 1e6,
        n = (e - 2e5) / 1e6,
        r = 16.9023892 + 3.238272 * n - .270978 * Math.pow(i, 2) - .002528 * Math.pow(n, 2) - .0447 * Math.pow(i, 2) * n - .014 * Math.pow(n, 3);
    return r = 100 * r / 36
}

function CHtoWGSlng(t, e) {
    var i = (t - 6e5) / 1e6,
        n = (e - 2e5) / 1e6,
        r = 2.6779094 + 4.728982 * i + .791484 * i * n + .1306 * i * Math.pow(n, 2) - .0436 * Math.pow(i, 3);
    return r = 100 * r / 36
}

function SEXtoDEC(t) {
    var e = parseInt(t, 10),
        i = parseInt(100 * (t - e), 10),
        n = 100 * (100 * (t - e) - i);
    return e + (n / 60 + i) / 60
}

function DECtoSEX(t) {
    var e = parseInt(t, 10),
        i = parseInt(60 * (t - e), 10),
        n = 60 * (60 * (t - e) - i);
    return e + i / 100 + n / 1e4
}

function DEGtoSEC(t) {
    var e = parseInt(t, 10),
        i = parseInt(100 * (t - e), 10),
        n = 100 * (100 * (t - e) - i),
        r = String(t).split(".");
    return 2 == r.length && 2 == r[1].length && (i = Number(r[1]), n = 0), n + 60 * i + 3600 * e
}

function lineLineIntersection(t, e, i, n) {
    var r = (n.x - i.x) * (t.y - i.y) - (n.y - i.y) * (t.x - i.x),
        o = (e.x - t.x) * (t.y - i.y) - (e.y - t.y) * (t.x - i.x),
        s = (n.y - i.y) * (e.x - t.x) - (n.x - i.x) * (e.y - t.y);
    if (0 != s) {
        var a = r / s,
            h = o / s;
        if (0 < a && a < 1 && 0 < h && h < 1) return !0
    }
    return !1
}

function linelineOverlap(t, e, i, n) {
    var r = (n.x - i.x) * (t.y - i.y) - (n.y - i.y) * (t.x - i.x),
        o = (e.x - t.x) * (t.y - i.y) - (e.y - t.y) * (t.x - i.x),
        s = (n.y - i.y) * (e.x - t.x) - (n.x - i.x) * (e.y - t.y);
    return 0 == s && (0 == r || 0 == o)
}

function modifyInteraction(t) {
    var e = null;
    this.init = function() { this.select = new ol.interaction.Select({ filter: function(t) { return "Polygon" == t.getGeometry().getType() }, style: drawStyle, multi: !1, toggleCondition: ol.events.condition.never, condition: ol.events.condition.click, layers: [vectorLayer] }), this.modify = new ol.interaction.Modify({ features: this.select.getFeatures(), style: modifyStyle, deleteCondition: ol.events.condition.never }), this.pointer = new ol.interaction.Pointer({ handleMoveEvent: this.handleMoveEvent }), this.setEvents() }, this.handleMoveEvent = function(i) {
        var n = t.forEachFeatureAtPixel(i.pixel, function(t, e) { if (e == vectorLayer) return t });
        n ? n === e || "Point" == n.getGeometry().getType() ? $(".ol-unselectable").css("cursor", "crosshair") : $(".ol-unselectable").css("cursor", "pointer") : $(".ol-unselectable").css("cursor", "default")
    }, this.setEvents = function() {
        function t(t) {
            var e = t.getCoordinates();
            illegalModify ? (o = !1, illegalStyle = !1, illegalModify = !1, t.setCoordinates(i.getCoordinates())) : r < 0 ? (o = !1, t.setCoordinates(i.getCoordinates())) : checkPerpendicularityAndEqualPoints(e[0]) ? (s && e[0].splice(r, 1), o = !1, t.setCoordinates(e)) : (log("reset to old"), o = !1, illegalStyle = !1, illegalModify = !1, t.setCoordinates(i.getCoordinates()))
        }
        var i, n, r = null,
            o = !1,
            s = null,
            a = this.select.getFeatures(),
            h = null,
            l = !1;
        this.modify.on("modifystart", function(t) { l = !0, r = null, n = t.features.getArray()[0].getGeometry().getCoordinates(), i = t.features.getArray()[0].getGeometry().clone() }), this.modify.on("modifyend", function(e) { t(e.features.getArray()[0].getGeometry()), l = !1 }), a.on("remove", function(i) {
            var n = i.element;
            l && t(n.getGeometry()), illegalModify = !1, e = null, n.unByKey(h), $(".ol-unselectable").css("cursor", "default"), 0 == a.getArray().length && $("#btn-modify-delete").removeClass("modeActivable");
            var r = $.grep(perimetersArray, function(t) { return t.id == n.getId() }),
                o = recalculateEstimatedSize(n, r[0]);
            setRecalculatedEstimatedSize(o, r[0])
        }), a.on("add", function(t) {
            var i = t.element;
            e = i, $(".ol-unselectable").css("cursor", "crosshair"), 1 == a.getArray().length && $("#btn-modify-delete").addClass("modeActivable"), h = i.on("change", function(t) {
                if (!o) return void(o = !0);
                o = !1;
                var e = i.getGeometry(),
                    a = e.getCoordinates();
                if (null == r && (r = getIndexModifiedCoord(n, a), s = n[0].length < a[0].length), illegalStyle = !1, illegalModify = !1, r >= 0) {
                    a = straightenModifiedLines(n, a, r, s), e.setCoordinates(a), n = a;
                    var h = turf.polygon([a[0]]),
                        l = turf.kinks(h).features.length;
                    l > 0 && (illegalStyle = !0, illegalModify = !0);
                    var u = a[0][r];
                    (u[1] < fence[0] || u[1] > fence[1] || u[0] < fence[2] || u[0] > fence[3]) && (illegalStyle = !0, illegalModify = !0)
                }
            })
        }), this.select.on("change:active", function() { selectedFeaturesLenght = a.getArray().length; for (var t = 0; t < selectedFeaturesLenght; t++) a.remove(a.getArray()[0]) }), addModifyGuiActions(a)
    }, this.setActive = function(e) { t.removeInteraction(this.select), t.removeInteraction(this.modify), t.removeInteraction(this.pointer), e && (t.addInteraction(this.select), t.addInteraction(this.modify), t.addInteraction(this.pointer), $(".ol-unselectable").css("cursor", "default")), this.select.setActive(e) }
}

function selectInteraction(t) {
    this.init = function() { this.select = new ol.interaction.Select({ style: drawStyle, condition: ol.events.condition.click, layers: [vectorLayer] }), this.setEvents() }, this.setEvents = function() {
        var e = null;
        e = this.select.getFeatures(), e.on("add", function(t) { 1 == e.getArray().length ? ($("#btn-dragSelect-delete").addClass("modeActivable"), $("#btn-setScale").addClass("modeActivable")) : 2 == e.getArray().length ? $("#btn-union").addClass("modeActivable") : $("#btn-union").removeClass("modeActivable") }), e.on("remove", function(t) { 0 == e.getArray().length && ($("#btn-dragSelect-delete").removeClass("modeActivable"), $("#btn-setScale").removeClass("modeActivable")), 2 != e.getArray().length && $("#btn-union").removeClass("modeActivable") }), this.select.on("change:active", function() { selectedFeaturesLenght = e.getArray().length; for (var t = 0; t < selectedFeaturesLenght; t++) e.remove(e.getArray()[0]) }), addSelectGuiActions(t, e)
    }, this.setActive = function(e) { t.removeInteraction(this.select), e && (t.addInteraction(this.select), $(".ol-unselectable").css("cursor", "default")), this.select.setActive(e) }
}

function strightGeometry(t, e) { return t = t[0].length > 2 ? straightenLines(t) : straightFirstLine(t), e.setCoordinates(t), e }

function geometryMovePointCorrector(t, e) { return t[0][0] = startCoordinate, t[0].push(startCoordinate), e.setCoordinates(t), e }

function straightFirstLine(t) {
    var e = t[0].length - 1,
        i = Math.abs(t[0][e - 1][1] - t[0][e][1]),
        n = Math.abs(t[0][e - 1][0] - t[0][e][0]);
    return i > n ? (t[0][e][0] = Math.round(t[0][e - 1][0]), t[0][e][1] = Math.round(t[0][e][1])) : (t[0][e][1] = Math.round(t[0][e - 1][1]), t[0][e][0] = Math.round(t[0][e][0])), t[0][e - 1][0] = Math.round(t[0][e - 1][0]), t[0][e - 1][1] = Math.round(t[0][e - 1][1]), startCoordinate = [t[0][e - 1][0], t[0][e - 1][1]], currentCoordinate = [t[0][e][0], t[0][e][1]], firstCoordinate = [t[0][e][0], t[0][e][1]], t
}

function straightenLines(t) { var e = t[0].length - 1; return t[0][e - 1][0] == t[0][e - 2][0] ? (t[0][e][1] = Math.round(t[0][e - 1][1]), t[0][e][0] = Math.round(t[0][e][0])) : (t[0][e][0] = Math.round(t[0][e - 1][0]), t[0][e][1] = Math.round(t[0][e][1])), currentCoordinate = [t[0][e][0], t[0][e][1]], t }

function getIndexModifiedCoord(t, e) {
    if (t[0].length <= e[0].length)
        for (var i = 0; i < t[0].length; i++)
            if (t[0][i][0] != e[0][i][0] || t[0][i][1] != e[0][i][1]) return i;
    return -1
}

function getFeatureMaxCoords(t) {
    var e, i, n, r;
    e = t[0][0][1], i = t[0][0][1], n = t[0][0][0], r = t[0][0][0];
    for (var o = 1; o < t[0].length; o++) t[0][o][0] < n, e = t[0][o][1] < e ? t[0][o][1] : e, i = t[0][o][1] > i ? t[0][o][1] : i, n = t[0][o][0] < n ? t[0][o][0] : n, r = t[0][o][0] > r ? t[0][o][0] : r;
    return [e, i, n, r]
}

function straightenModifiedLines(t, e, i, n) { e[0].pop(), t[0].pop(); var r, o, s = e[0][i]; return s[0] = Math.round(s[0]), s[1] = Math.round(s[1]), 0 == i ? (r = e[0][i + 1], o = _.last(e[0])) : i == e[0].length - 1 ? (r = _.first(e[0]), o = e[0][i - 1]) : (r = e[0][i + 1], o = e[0][i - 1]), n ? r[1] == o[1] ? (o[1] = s[1], r[1] = s[1]) : r[0] == o[0] ? (o[0] = s[0], r[0] = s[0]) : (illegalModify = !0, illegalStyle = !0) : t[0][i][0] == r[0] && t[0][i][1] == o[1] ? (o[1] = s[1], r[0] = s[0]) : t[0][i][1] == r[1] && t[0][i][0] == o[0] ? (o[0] = s[0], r[1] = s[1]) : (illegalModify = !0, illegalStyle = !0), e[0].push(_.first(e[0])), t[0].push(_.first(t[0])), e }

function hasIntersections(t, e, i, n) {
    for (var r = 1; r < n.length; r++) {
        var o = { x: n[r - 1][0], y: n[r - 1][1] },
            s = { x: n[r][0], y: n[r][1] };
        if (lineLineIntersection(t, e, o, s)) return !0;
        if (null != i && lineLineIntersection(i, t, o, s)) return !0
    }
    return !1
}

function newPointOverlaps(t, e, i) {
    for (var n = 1; n < i.length; n++) {
        var r = { x: i[n - 1][0], y: i[n - 1][1] },
            o = { x: i[n][0], y: i[n][1] };
        if (linelineOverlap(t, e, r, o)) return !0
    }
    return !1
}

function deleteSelectedFeature(t) {
    if (t.getArray().length < 1) return void showAlertView(lingua.alertAttention, lingua.deleteErrorText);
    for (var e in t.getArray()) perimetersArray.forEach(function(i, n, r) { i.id == t.getArray()[e].getId() && r.splice(n, 1) }), vectorSource.removeFeature(t.getArray()[e]);
    t.clear()
}

function internationalize(t) {
    switch (log("language"), $("#firstAcceptedLanguages").attr("name")) {
        case "DE":
            languageURL = "de.json";
            break;
        case "FR":
            languageURL = "fr.json";
            break;
        case "IT":
            languageURL = "it.json";
            break;
        case "EN":
            languageURL = "en.json";
            break;
        default:
            languageURL = "de.json"
    }
    var e = "#lang" + $("#firstAcceptedLanguages").attr("name");
    log(e), $(e).addClass(".default-language"), $(e).addClass("active"), $.getJSON(languageURL, function(e) { lingua = e, t() }).fail(function() { alert("Could not load languages, please contact the support"), t() })
}

function checkBrowser() { Modernizr.touchevents && window.matchMedia("(max-device-width: 800px)").matches && $(".isTouch").removeClass("infoTooltip").addClass("infoTooltipNoTouch"), Modernizr.canvas || showAlertView(lingua.alertAttention, lingua.browserSupportError), (window.navigator.userAgent.indexOf("MSIE") > 0 || navigator.userAgent.match(/Trident.*rv\:11\./)) && $("#uploadKMLimg").remove() }

function checkPerpendicularityAndEqualPoints(t) { if (t.length < 2) return log("checkPerpendicularity: wrong coords array"), !1; for (var e = 0; e < t.length - 1; e++) { if (t[e][0] != t[e + 1][0] && t[e][1] != t[e + 1][1]) return log("line is not straight"), !1; if (Math.round(t[e][0]) == Math.round(t[e + 1][0]) && Math.round(t[e][1]) == Math.round(t[e + 1][1])) return log("two points are equal"), !1 } return !0 }

function checkAndCutScalaForFeatures(t, e) {
    var i = [];
    t.forEach(function(t) {
        var n = turf.polygon([t.getGeometry().getCoordinates()[0]]),
            r = e,
            o = turf.intersect(n, r);
        if ("undefined" != typeof o && "Polygon" == o.geometry.type) t.getGeometry().setCoordinates([o.geometry.coordinates[0]]);
        else if ("undefined" != typeof o && "MultiPolygon" == o.geometry.type) {
            var s = null,
                a = null,
                h = null;
            perimetersArray.forEach(function(e, i, n) { e.id == t.getId() && (h = e, s = e.scales, a = e.verboseScales, n.splice(i, 1)) }), vectorSource.removeFeature(t), select.select.getFeatures().clear(), o.geometry.coordinates.forEach(function(t) {
                var e = a.slice(0),
                    n = new ol.Feature({ geometry: new ol.geom.Polygon(t) }),
                    r = recalculateEstimatedSize(n, h);
                e.pop(), e.push("<br>" + lingua.estimatedSize + r + " MB");
                var o = "_" + Math.random().toString(36).substr(2, 9);
                perimetersArray.push({ id: o, scales: s, verboseScales: e }), n.setId(o), n.setStyle(null), i.push(n)
            })
        } else "undefined" == typeof o && log("outside_________________ should be impossible")
    }), i.forEach(function(t) { vectorSource.addFeature(t) }, this)
}

function checkScalaAllOutsideForFeatures(t, e) {
    var i = !1;
    return t.forEach(function(t) {
        var n = turf.polygon([t.getGeometry().getCoordinates()[0]]),
            r = e,
            o = turf.intersect(n, r);
        "undefined" == typeof o && (i = !0)
    }), !i
}

function checkScalaWithFeature(t, e) {
    var i = !1,
        n = turf.polygon([t.getGeometry().getCoordinates()[0]]),
        r = e,
        o = turf.intersect(n, r);
    return "undefined" != typeof o && "Polygon" == o.geometry.type ? turf.area(n) != turf.area(o) && (i = !0) : i = !0, !i
}

function areaForCuttedFeatureWithScale(t, e) {
    var i = turf.polygon([t.getGeometry().getCoordinates()[0]]),
        n = e,
        r = turf.intersect(i, n);
    if ("undefined" != typeof r) {
        if ("MultiPolygon" == r.geometry.type) {
            var o = 0;
            return r.geometry.coordinates.forEach(function(t) {
                var e = [];
                t[0].forEach(function(t) { e.push([CHtoWGSlng(t[0], t[1]), CHtoWGSlat(t[0], t[1])]) }), o += turf.area(turf.polygon([e]))
            }), o
        }
        var s = [];
        return r.geometry.coordinates[0].forEach(function(t) { s.push([CHtoWGSlng(t[0], t[1]), CHtoWGSlat(t[0], t[1])]) }), turf.area(turf.polygon([s]))
    }
    return 0
}

function setLayerAndScale(t) {
    var e = null,
        i = !1;
    return $.each($(".cb"), function(t, e) { if (e.checked) return void(i = !0) }), i ? (t.forEach(function(i) {
        perimetersArray.forEach(function(t, e, n) { t.id == i.getId() && n.splice(e, 1) });
        var n = [],
            r = "",
            o = [],
            s = 0;
        $.each($(".btn-checkbox-scala"), function(t, e) {
            var a = $(this).attr("name");
            if (e.children[0].checked) {
                switch (e.children[0].name) {
                    case "25000":
                        s += Math.round(areaForCuttedFeatureWithScale(i, extent25) / TILE25 * a / 1e3);
                        break;
                    case "50000":
                        s += Math.round(areaForCuttedFeatureWithScale(i, extent50) / TILE50 * a / 1e3);
                        break;
                    case "100000":
                        s += Math.round(areaForCuttedFeatureWithScale(i, extent100) / TILE100 * a / 1e3);
                        break;
                    case "300000":
                        s += Math.round(areaForCuttedFeatureWithScale(i, extent100) / TILE300 * a / 1e3);
                        break;
                    case "500000":
                        s += Math.round(areaForCuttedFeatureWithScale(i, extent100) / TILE500 * a / 1e3)
                }
                o.push(e.children[0].id), r != $(this).parent().attr("name") && ("" == r ? n.push($(this).parent().attr("name") + ":") : n.push("<br>" + $(this).parent().attr("name") + ":"), r = $(this).parent().attr("name")), n.push(" " + $(this)[0].innerText)
            }
        }), s < 1 && (s = "< 1"), n.push("<br>" + lingua.estimatedSize + s + " MB");
        var a = "_" + Math.random().toString(36).substr(2, 9);
        i.setId(a);
        var h = _.groupBy(o, function(t) { return t.split("_")[0] });
        for (var l in h) h[l].forEach(function(t, e) { h[l][e] = t.split("_")[1] });
        perimetersArray.push({ id: a, scales: h, verboseScales: n });
        var u = null,
            p = null;
        if (!e && !checkScalaWithFeature(i, extent25))
            for (var l in h) h[l].forEach(function(i) { if (log(i), "25000" == i) return e = " 25'000 ", u = t, void(p = extent25) });
        if (!e && !checkScalaWithFeature(i, extent50))
            for (var l in h) h[l].forEach(function(i) { if ("50000" == i) return e = " 50'000 ", u = t, void(p = extent50) });
        if (!e && !checkScalaWithFeature(i, extent100))
            for (var l in h) h[l].forEach(function(i) { if ("100000" == i) return e = " 100'000 ", u = t, void(p = extent100) });
        if (null != e) {
            var c = lingua.perimeterScale1 + e + lingua.perimeterScale2 + e + lingua.perimeterScale3;
            0 == areaForCuttedFeatureWithScale(i, extent100) ? showAlertView(lingua.alertAttention, lingua.alertOutside100) : (showAlertView(lingua.alertAttention, c, !0), $("#alertViewBtnYes").unbind("click"), $("#alertViewBtnYes").click(function() { checkAndCutScalaForFeatures(u, p), hideAlertView() }))
        }
    }), void(i && hideSetScaleView())) : void showAlertView(lingua.alertAttention, lingua.noScaleErrorText)
}

function recalculateEstimatedSize(t, e) {
    var i = null;
    for (var n in e.scales) {
        var r = $.grep($(".btn-checkbox-layer"), function(t) { return t.id == n }),
            o = $(r[0]).attr("name");
        e.scales[n].forEach(function(e) {
            switch (e) {
                case "25000":
                    i += Math.round(areaForCuttedFeatureWithScale(t, extent25) / TILE25 * o / 1e3);
                    break;
                case "50000":
                    i += Math.round(areaForCuttedFeatureWithScale(t, extent50) / TILE50 * o / 1e3);
                    break;
                case "100000":
                    i += Math.round(areaForCuttedFeatureWithScale(t, extent100) / TILE100 * o / 1e3);
                    break;
                case "300000":
                    i += Math.round(areaForCuttedFeatureWithScale(t, extent100) / TILE300 * o / 1e3);
                    break;
                case "500000":
                    i += Math.round(areaForCuttedFeatureWithScale(t, extent100) / TILE500 * o / 1e3)
            }
        })
    }
    return i
}

function setRecalculatedEstimatedSize(t, e) { e.verboseScales.pop(), e.verboseScales.push("<br>" + lingua.estimatedSize + t + " MB") }

function showSetScaleView(t) {
    t.forEach(function(t) {
        var e = $.grep(perimetersArray, function(e) { return e.id == t.getId() });
        if ("undefined" != typeof e[0])
            for (var i in e[0].scales) e[0].scales[i].forEach(function(t) { $("#" + i + "_" + t).prop("checked", !0), $("#" + i + "_" + t).parent().addClass("active"), $("#btn-setScaleCancel").show() })
    }), checkScalaAllOutsideForFeatures(t, extent50) ? checkScalaAllOutsideForFeatures(t, extent25) || $.each($(".btn-checkbox-scala"), function(t, e) { "25000" == $(e.children[0]).attr("name") && ($(e).removeClass("active"), $(e.children[0]).prop("checked", !1), $(e).addClass("disabledCB")) }) : $.each($(".btn-checkbox-scala"), function(t, e) { "25000" != $(e.children[0]).attr("name") && "50000" != $(e.children[0]).attr("name") || ($(e).removeClass("active"), $(e.children[0]).prop("checked", !1), $(e).addClass("disabledCB")) }), $("#setScale").fadeIn(500), $("#btn-setScaleDone").css("pointer-events", "visible"), $("#btn-setScaleDone").unbind("click"), $("#btn-setScaleDone").click(function() { setLayerAndScale(t) })
}

function hideSetScaleView() { $("#btn-setScaleDone").css("pointer-events", "none"), resetCheckboxes(), $("#setScale").fadeOut(500), $("#btn-setScaleCancel").delay(500).fadeOut() }

function resetCheckboxes() { $(".btn-checkbox-scala").removeClass("active"), $(".btn-checkbox-scala").removeClass("disabledCB"), $(".cb").prop("checked", !1) }

function showAlertView(t, e, i) { "undefined" != typeof i && ($("#alertViewBtnOk")[0].innerText = lingua.alertNo, $("#alertViewBtnYes").show(0)), $("#alertViewTitle")[0].innerText = t, $("#alertViewText")[0].innerText = e, $("#alertView").fadeIn(500) }

function hideAlertView() { $("#alertView").fadeOut(500, function() { $("#alertViewBtnOk")[0].innerText = lingua.alertOk, $("#alertViewBtnYes").css("display", "none") }) }

function changeMode(t, e) { var i = 500; return t != e && ($("#" + t).removeClass("selectedMode"), $(".modeAction").hide(i), t = e, $("#" + t).addClass("selectedMode")), illegalStyle = !1, drag.setActive("btn-dragSelect" == t), select.setActive("btn-dragSelect" == t), modify.setActive("btn-modify" == t), draw.setActive("btn-draw" == t), "btn-modify" == t ? $("#btn-modify-delete").show(i) : "btn-dragSelect" == t && ($("#btn-dragSelect-delete").show(i), $("#btn-union").show(i), $("#btn-setScale").show(i)), t }

function setMouseCoords(t) {
    return function(e) {
        var i = [];
        switch ($("#mousepositionSelect")[0].value) {
            case "1":
                i[1] = (1e6 + e[1]).toFixed(t).replace(/\B(?=(\d{3})+(?!\d))/g, "'"), i[0] = (2e6 + e[0]).toFixed(t).replace(/\B(?=(\d{3})+(?!\d))/g, "'");
                break;
            case "2":
                i[1] = " " + CHtoWGSlng(e[0], e[1]).toFixed(t + 5), i[0] = CHtoWGSlat(e[0], e[1]).toFixed(t + 5);
                break;
            default:
                i[1] = " " + e[1].toFixed(t).replace(/\B(?=(\d{3})+(?!\d))/g, "'"), i[0] = e[0].toFixed(t).replace(/\B(?=(\d{3})+(?!\d))/g, "'")
        }
        return i
    }
}

function log(t) {
    var e = !1;
    e && console.log(t)
}! function() {
    "undefined" == typeof window.GeoAdmin && (window.GeoAdmin = {}), window.GeoAdmin.lang = "de", window.GeoAdmin.serviceUrl = "https://mf-chsdi3.dev.bgdi.ch/mom_update_ol3", window.GeoAdmin.getConfig = function() {
        return {
            "ch.bafu.flussordnungszahlen-strahler": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.flussordnungszahlen-strahler", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Flussordnung", highlightable: !0, background: !1, timestamps: ["20140805"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.bafu.gewaesserschutz-diffuse_eintraege_stickstoff": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.gewaesserschutz-diffuse_eintraege_stickstoff", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Diffuse Stickstoffeinträge", highlightable: !0, background: !1, timestamps: ["20150701"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10] },
            "ch.swisstopo.hiks-siegfried-ta25.metadata": {
                wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0",
                shop: ["mapsheet"],
                attribution: "swisstopo",
                chargeable: !1,
                searchable: !1,
                format: "png",
                timeEnabled: !1,
                serverLayerName: "ch.swisstopo.hiks-siegfried-ta25.metadata",
                attributionUrl: "https://www.swisstopo.admin.ch/de/home.html",
                timeBehaviour: "last",
                tooltip: !0,
                label: "ch.swisstopo.hiks-siegfried-ta25.metadata",
                wmsLayers: "ch.swisstopo.hiks-siegfried-ta25.metadata",
                singleTile: !0,
                highlightable: !0,
                background: !1,
                hasLegend: !0,
                type: "wms",
                topics: "api,ech,inspire,swisstopo,wms-bgdi_prod"
            },
            "ch.blw.bodeneignung-kulturtyp": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.bodeneignung-kulturtyp", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Bodeneignung: Kulturtyp", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.blw.bodeneignung-gruendigkeit": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.bodeneignung-gruendigkeit", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Gründigkeit", highlightable: !0, background: !1, timestamps: ["20120601"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.astra.strassenverkehrszaehlung_messstellen-uebergeordnet": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.astra.strassenverkehrszaehlung_messstellen-uebergeordnet-status_netz,ch.astra.strassenverkehrszaehlung_messstellen-uebergeordnet-typ", gutter: 15, attribution: "ASTRA + Kanton", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.astra.strassenverkehrszaehlung_messstellen-uebergeordnet", attributionUrl: "ch.astra.kt.url", timeBehaviour: "last", tooltip: !0, label: "Verkehrszählung (Übergeordnet)", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["zaehlstellen_bezeichnung", "id"], topics: "api,astra,ech,inspire,wms-bgdi_prod" },
            "ch.bafu.fauna-steinbockkolonien": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.fauna-steinbockkolonien", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Steinbockkolonien", highlightable: !0, background: !1, timestamps: ["20150506"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,sachplan,swissmaponline,wms-bgdi_prod" },
            "ch.bakom.downlink20": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.downlink20", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Download ≥ 20 Mbit/s", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.swisstopo-vd.spannungsarme-gebiete": { opacity: .75, attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.spannungsarme-gebiete", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Spannungsarme Gebiete", highlightable: !0, background: !1, timestamps: ["20151101", "20141101"], hasLegend: !0, type: "wmts", topics: "api,cadastre,ech,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.bfe.windenergie-geschwindigkeit_h75": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BFE", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfe.windenergie-geschwindigkeit_h75", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Windgeschwindigkeit 75 m Höhe", wmsLayers: "ch.bfe.windenergie-geschwindigkeit_h75", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,energie,inspire,wms-bgdi_prod" },
            "ch.bafu.laerm-strassenlaerm_tag": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.laerm-strassenlaerm_tag", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Strassenverkehrslärm Tag", highlightable: !0, background: !1, timestamps: ["20101231"], hasLegend: !0, type: "wmts", topics: "api,astra,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bazl.laermbelastungskataster-zivilflugplaetze_letzte-nachtstunde": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BAZL", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bazl.laermbelastungskataster-zivilflugplaetze_letzte-nachtstunde", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Lärmbelastung letzte Nachtstunde", wmsLayers: "ch.bazl.laermbelastungskataster-zivilflugplaetze_letzte-nachtstunde", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.swisstopo.hebungsraten": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.swisstopo.hebungsraten", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Vertikalbewegungen", wmsLayers: "ch.swisstopo.hebungsraten", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["ord_nr", "ort"], topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.blw.emapis-entwaesserung": { wmsUrl: "//wms-bod.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.blw.emapis-entwaesserung", gutter: 30, attribution: "BLW + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.emapis-entwaesserung", attributionUrl: "ch.blw.kt.url", timeBehaviour: "last", tooltip: !0, label: "Entwässerung, Bodenstruktur", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "ech,emapis,inspire,wms-bgdi_prod" },
            "ch.bazl.laermbelastungskataster-zivilflugplaetze_zweite-nachtstunde": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BAZL", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bazl.laermbelastungskataster-zivilflugplaetze_zweite-nachtstunde", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Lärmbelastung 2. Nachtstunde", wmsLayers: "ch.bazl.laermbelastungskataster-zivilflugplaetze_zweite-nachtstunde", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.bafu.sturm-staudruck_30": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.sturm-staudruck_30", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Sturmgefährdung Staudruck 30", highlightable: !0, background: !1, timestamps: ["20141107"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bfe.bikesharing_upto_zoom4": { attribution: "BFE", chargeable: !1, searchable: !1, format: "png", serverLayerName: "ch.bfe.bikesharing", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ch.bfe.bikesharing_upto_zoom4", styleUrl: "//mf-chsdi3.dev.bgdi.ch/mom_update_ol3/static/vectorStyles/ch.bfe.bikesharing_upto_zoom4.json", geojsonUrl: "https://mf-chsdi3.dev.bgdi.ch/~ltfrr/bikesharing/bikesharing_de.json", background: !1, parentLayerId: "ch.bfe.bikesharing", topics: "api,ech,energie,inspire,wms-bgdi_prod", hasLegend: !0, minResolution: 100, type: "geojson", timeEnabled: !1, highlightable: !0 },
            "ch.bag.zecken-lyme": { opacity: .75, attribution: "BAG", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bag.zecken-lyme", attributionUrl: "http://www.bag.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Borreliose Risikogebiete", highlightable: !0, background: !1, timestamps: ["20110613"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.blw.klimaeignung-typ": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.klimaeignung-typ", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Klimaeignung Übersicht", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.hydroweb-messstationen_gefahren": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.hydroweb-messstationen_gefahren", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Hochwasser Gefahrenstufen", styleUrl: "//mf-chsdi3.dev.bgdi.ch/mom_update_ol3/static/vectorStyles/ch.bafu.hydroweb-messstationen_gefahren.json", geojsonUrl: "https://data.geo.admin.ch/ch.bafu.hydroweb-messstationen_gefahren/ch.bafu.hydroweb-messstationen_gefahren_de.json", background: !1, updateDelay: 3e5, hasLegend: !1, type: "geojson", topics: "api,bafu,ech,gewiss,inspire,kgs,swissmaponline,wms-bgdi_prod", highlightable: !0 },
            "ch.bazl.laermbelastungskataster-zivilflugplaetze_helikopter-maximalpegel": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BAZL", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bazl.laermbelastungskataster-zivilflugplaetze_helikopter-maximalpegel", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Lärmbelastung Helikopter Lmax", wmsLayers: "ch.bazl.laermbelastungskataster-zivilflugplaetze_helikopter-maximalpegel", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.bafu.hydrologie-niedrigwasserstatistik": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.hydrologie-niedrigwasserstatistik", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Niedrigwasserstatistik", highlightable: !0, background: !1, timestamps: ["20130101"], hasLegend: !0, queryableAttributes: ["name"], topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.bfs.arealstatistik-bodenbedeckung-1985": { opacity: .75, attribution: "BFS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfs.arealstatistik-bodenbedeckung-1985", attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", timeBehaviour: "last", tooltip: !0, label: "Arealstatistik 1979/85 NOLC04", highlightable: !0, background: !1, timestamps: ["20131121"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.hydrologie-hintergrundkarte_wmts2": { topics: "api,swissmaponline,wms-naz,wms-swisstopowms_prod", attribution: "swisstopo", chargeable: !0, searchable: !1, format: "jpeg", serverLayerName: "ch.swisstopo.pixelkarte-grau", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "ch.bafu.hydrologie-hintergrundkarte_wmts2", parentLayerId: "ch.bafu.hydrologie-hintergrundkarte", highlightable: !0, background: !1, maxResolution: 50, timestamps: ["current"], hasLegend: !0, type: "wmts", timeEnabled: !1, resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, .5, .25], minResolution: 0 },
            "ch.bafu.ren-feuchtgebiete": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.ren-feuchtgebiete", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "REN  Feuchtgebiet", highlightable: !0, background: !1, timestamps: ["20110214"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.hydrologie-hintergrundkarte_wmts1": { topics: "api,ech,inspire,swissmaponline,wms-bgdi_prod", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", serverLayerName: "ch.bafu.hydrologie-hintergrundkarte", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ch.bafu.hydrologie-hintergrundkarte_wmts1", parentLayerId: "ch.bafu.hydrologie-hintergrundkarte", highlightable: !0, background: !1, maxResolution: 750, timestamps: ["20141023"], hasLegend: !1, type: "wmts", timeEnabled: !1, resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50], minResolution: 50 },
            "ch.swisstopo.landeskarte-grau-10": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.landeskarte-grau-10", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Landeskarte 1:10'000 (grau)", highlightable: !1, background: !1, timestamps: ["current"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swisstopo,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, .5, .25] },
            "ch.swisstopo.pixelkarte-farbe": { attribution: "swisstopo", searchable: !1, subLayersIds: ["ch.swisstopo.pixelkarte-farbe_wmts", "ch.swisstopo.landeskarte-farbe-10_wmts"], timeEnabled: !1, serverLayerName: "ch.swisstopo.pixelkarte-farbe", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Landeskarten (farbig)", chargeable: !0, highlightable: !0, background: !0, hasLegend: !1, config3d: "ch.swisstopo.swisstlm3d-karte-farbe_3d", type: "aggregate", topics: "api,swissmaponline,wms-naz,wms-swisstopowms_prod" },
            "ch.vbs.patrouilledesglaciers-z_rennen": { opacity: .75, attribution: "VBS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.vbs.patrouilledesglaciers-z_rennen", attributionUrl: "http://www.vbs.admin.ch/internet/vbs/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Patrouille des Glaciers (Z Rennen)", highlightable: !0, background: !1, timestamps: ["20150508"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,verteidigung,wms-bgdi_prod" },
            "ch.bafu.hydroweb-messstationen_temperatur": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.hydroweb-messstationen_temperatur", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Wassertemperatur der Flüsse", styleUrl: "//mf-chsdi3.dev.bgdi.ch/mom_update_ol3/static/vectorStyles/ch.bafu.hydroweb-messstationen_temperatur.json", geojsonUrl: "https://data.geo.admin.ch/ch.bafu.hydroweb-messstationen_temperatur/ch.bafu.hydroweb-messstationen_temperatur_de.json", background: !1, updateDelay: 3e5, hasLegend: !1, type: "geojson", topics: "api,bafu,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod", highlightable: !0 },
            "ch.swisstopo-vd.geometa-los_wms": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", chargeable: !1, searchable: !1, timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.geometa-los", highlightable: !0, parentLayerId: "ch.swisstopo-vd.geometa-los", minResolution: 0, attributionUrl: "http://www.cadastre.ch", tooltip: !1, label: "ch.swisstopo-vd.geometa-los_wms", singleTile: !1, type: "wms", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod", opacity: .75, attribution: "Amtliche Vermessung Schweiz", format: "png", background: !1, maxResolution: 20, wmsLayers: "ch.swisstopo-vd.geometa-los", gutter: 15, timeBehaviour: "last", hasLegend: !0 },
            "ch.swisstopo.lotabweichungen": { attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.lotabweichungen", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Lotabweichungen", highlightable: !0, background: !1, timestamps: ["20160606"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.bafu.bundesinventare-bln": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.bundesinventare-bln", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "BLN", highlightable: !0, background: !1, timestamps: ["20010809"], hasLegend: !0, queryableAttributes: ["bln_name"], topics: "api,bafu,blw,ech,energie,geothermie,gewiss,inspire,kgs,sachplan,swissmaponline,wms-bgdi_prod,wms-naz" },
            "ch.swisstopo.geologie-geolkarten500.metadata": { opacity: .75, attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geolkarten500.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Geologie 500 - Papier", highlightable: !0, background: !1, timestamps: ["20070425"], hasLegend: !0, type: "wmts", topics: "api,ech,swisstopo,wms-bgdi_prod" },
            "ch.bfe.bikesharing": { attribution: "BFE", searchable: !1, subLayersIds: ["ch.bfe.bikesharing_upto_zoom4", "ch.bfe.bikesharing_from_zoom4"], timeEnabled: !1, serverLayerName: "ch.bfe.bikesharing", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ch.bfe.bikesharing", chargeable: !1, highlightable: !0, background: !1, hasLegend: !0, type: "aggregate", topics: "api,ech,energie,inspire,wms-bgdi_prod" },
            "ch.swisstopo.geologie-gravimetrischer_atlas.messpunkte": { attribution: "swisstopo, sgpk", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.swisstopo.geologie-gravimetrischer_atlas.messpunkte", attributionUrl: "ch.swisstopo.sgpk.url", timeBehaviour: "last", tooltip: !0, label: "Gravimetrische Messpunkte 100", highlightable: !0, background: !1, timestamps: ["20150731"], hasLegend: !0, queryableAttributes: ["stationnam"], topics: "api,ech,geol,geothermie,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bafu.bundesinventare-flachmoore": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.bundesinventare-flachmoore", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Flachmoore", highlightable: !0, background: !1, timestamps: ["20100623"], hasLegend: !0, type: "wmts", topics: "api,are,bafu,blw,ech,energie,gewiss,inspire,kgs,sachplan,swissmaponline,wms-bgdi_prod,wms-naz" },
            "ch.bafu.hydrologischer-atlas_basisgebiete": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.hydrologischer-atlas_basisgebiete", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Basisgebiet", highlightable: !0, background: !1, timestamps: ["20040101"], hasLegend: !0, queryableAttributes: ["shape_area", "mit_ns", "jahrtemp_g", "max_hoe", "mit_hoe", "bemerkung", "s_w_ns", "winttemp_g", "min_hoe", "gebietskennzahl", "flussgebiet"], topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.swisstopo.swissnames3d_wms": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.swisstopo.swissnames3d", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod,wms-naz", attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", serverLayerName: "ch.swisstopo.swissnames3d", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "ch.swisstopo.swissnames3d_wms", singleTile: !1, highlightable: !0, background: !1, parentLayerId: "ch.swisstopo.swissnames3d", maxResolution: 1.2, hasLegend: !1, type: "wms", timeEnabled: !1, minResolution: 0 },
            "ch.swisstopo.vec200-miscellaneous": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec200-miscellaneous", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Einzelobjekte VECTOR200", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.swisstopo.swisstlm3d-karte-grau": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.swisstlm3d-karte-grau", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Karte swissTLM (grau)", highlightable: !0, background: !1, timestamps: ["current", "20150401"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, .5, .25] },
            "ch.bakom.mobil-antennenstandorte-gsm": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bakom.mobil-antennenstandorte-gsm", gutter: 15, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.mobil-antennenstandorte-gsm", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Antennenstandorte GSM", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,funksender,inspire,kgs,wms-bgdi_prod" },
            "ch.bafu.wrz-jagdbanngebiete_select": { opacity: 1, wmsLayers: "", attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.wrz-jagdbanngebiete_select", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Wildschutzgebiete", highlightable: !0, background: !1, timestamps: ["20160106", "20151103", "20150106"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,schneesport,swissmaponline,wildruhezonen,wms-bgdi_prod" },
            "ch.swisstopo.vec200-miscellaneous-geodpoint": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec200-miscellaneous-geodpoint", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Höhenkoten VECTOR200", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,kgs,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.swisstopo.geologie-spezialkarten_schweiz_papier.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", shop: ["mapsheet"], attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-spezialkarten_schweiz_papier.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "ch.swisstopo.geologie-spezialkarten_schweiz_papier.metadata", wmsLayers: "ch.swisstopo.geologie-spezialkarten_schweiz_papier.metadata", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bfs.arealstatistik-1997": { opacity: .75, attribution: "BFS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfs.arealstatistik-1997", attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", timeBehaviour: "last", tooltip: !0, label: "Arealstatistik 1992/97 NOAS04", highlightable: !0, background: !1, timestamps: ["20131121"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline" },
            "ch.swisstopo.landeskarte-farbe-10": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.landeskarte-farbe-10", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Landeskarte 1:10'000 (farbig)", highlightable: !1, background: !1, timestamps: ["current"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swisstopo,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, .5, .25] },
            "ch.bafu.sturm-staudruck_100": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.sturm-staudruck_100", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Sturmgefährdung Staudruck 100", highlightable: !0, background: !1, timestamps: ["20141107"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.vec25-einzelobjekte": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec25-einzelobjekte", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Einzelobjekte VECTOR25", highlightable: !0, background: !1, timestamps: ["19980101"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo" },
            "ch.bafu.auen-vegetationskarten": { attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.auen-vegetationskarten", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Auen Vegetationskarten", highlightable: !0, background: !1, timestamps: ["20150302"], hasLegend: !0, queryableAttributes: ["auveg_jahr", "auveg_obj", "auveg_name", "auveg_k22"], topics: "api,bafu,ech,inspire,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geotechnik-gk200": { opacity: .75, attribution: "swisstopo, sgtk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geotechnik-gk200", attributionUrl: "ch.swisstopo.sgtk.url", timeBehaviour: "last", tooltip: !0, label: "Geotechnische Karte 200", highlightable: !0, background: !1, timestamps: ["19670101"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,wms-bgdi_prod" },
            "ch.bfe.sachplan-uebertragungsleitungen_anhoerung": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bfe.sachplan-uebertragungsleitungen_anhoerung", gutter: 25, attribution: "BFE", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bfe.sachplan-uebertragungsleitungen_anhoerung", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "SÜL Anhörung", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["plname_de", "facname_de"], topics: "api,sachplan,wms-bgdi_prod" },
            "ch.bafu.schutzgebiete-ramsar": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.schutzgebiete-ramsar", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Ramsar", highlightable: !0, background: !1, timestamps: ["20110830"], hasLegend: !0, type: "wmts", topics: "api,are,bafu,ech,inspire,sachplan,swissmaponline,wms-bgdi_prod" },
            "ch.blw.emapis-oekologie": { wmsUrl: "//wms-bod.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.blw.emapis-oekologie", gutter: 30, attribution: "BLW + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.emapis-oekologie", attributionUrl: "ch.blw.kt.url", timeBehaviour: "last", tooltip: !0, label: "Oekologie", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "ech,emapis,inspire,wms-bgdi_prod" },
            "ch.bafu.gefahren-basiskarte": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BAFU / EUA", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.gefahren-basiskarte", attributionUrl: "http://www.eea.europa.eu", timeBehaviour: "last", tooltip: !1, label: "Basiskarte GIN", wmsLayers: "ch.bafu.gefahren-basiskarte", singleTile: !1, highlightable: !1, background: !1, hasLegend: !1, type: "wms", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.swisstopo.vec25-strassennetz": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec25-strassennetz", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Strassennetz VECTOR25", highlightable: !0, background: !1, timestamps: ["20090401"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo" },
            "ch.bakom.downlink1": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.downlink1", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Download ≥ 1 Mbit/s", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.bakom.downlink2": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.downlink2", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Download ≥ 2 Mbit/s", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.bakom.verfuegbarkeit-tv": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.verfuegbarkeit-tv", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "TV-Verfügbarkeit via Festnetz", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.swisstopo-vd.geometa-standav_wms": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", chargeable: !1, searchable: !1, timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.geometa-standav", highlightable: !0, parentLayerId: "ch.swisstopo-vd.geometa-standav", minResolution: 0, attributionUrl: "http://www.cadastre.ch", tooltip: !1, label: "ch.swisstopo-vd.geometa-standav_wms", singleTile: !1, type: "wms", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod", opacity: .75, attribution: "Amtliche Vermessung Schweiz", format: "png", background: !1, maxResolution: 20, wmsLayers: "ch.swisstopo-vd.geometa-standav", gutter: 15, timeBehaviour: "last", hasLegend: !0 },
            "ch.bafu.oekomorphologie-f_abstuerze": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.oekomorphologie-f_abstuerze", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Ökomorphologie F - Abstürze", highlightable: !0, background: !1, timestamps: ["20110912"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.bazl.laermbelastungskataster-zivilflugplaetze_militaer-gesamt": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BAZL", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bazl.laermbelastungskataster-zivilflugplaetze_militaer-gesamt", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Lärmbelast. Militärflugpl. (gesamt)", wmsLayers: "ch.bazl.laermbelastungskataster-zivilflugplaetze_militaer-gesamt", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.bafu.showme-gemeinden_sturzprozesse": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.showme-gemeinden_sturzprozesse", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ShowMe Gemeinden: Sturzprozesse", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2] },
            "ch.bfs.arealstatistik-waldmischungsgrad": {
                opacity: .75,
                attribution: "BFS",
                chargeable: !1,
                searchable: !1,
                format: "png",
                timeEnabled: !1,
                serverLayerName: "ch.bfs.arealstatistik-waldmischungsgrad",
                attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html",
                timeBehaviour: "last",
                tooltip: !1,
                label: "Waldmischungsgrad 1990/1992",
                highlightable: !0,
                background: !1,
                timestamps: ["19970901"],
                hasLegend: !0,
                type: "wmts",
                topics: "api,ech,inspire,swissmaponline,wms-bgdi_prod"
            },
            "ch.swisstopo-vd.geometa-gemeinde": { opacity: .75, attribution: "Amtliche Vermessung Schweiz", searchable: !1, subLayersIds: ["ch.swisstopo-vd.geometa-gemeinde_wmstile", "ch.swisstopo-vd.geometa-gemeinde_wms"], timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.geometa-gemeinde", attributionUrl: "http://www.cadastre.ch", timeBehaviour: "last", tooltip: !0, label: "Gemeindeinformationen", chargeable: !1, highlightable: !0, background: !1, hasLegend: !0, type: "aggregate", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bav.kataster-belasteter-standorte-oev": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, gutter: 15, attribution: "BAV", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bav.kataster-belasteter-standorte-oev", attributionUrl: "http://www.bav.admin.ch/?lang=de", timeBehaviour: "last", tooltip: !0, label: "Altlasten/belastete Standorte öV", wmsLayers: "ch.bav.kataster-belasteter-standorte-oev", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["katasternummer"], topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.swisstopo.fixpunkte-lfp1": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.swisstopo.fixpunkte-lfp1", gutter: 100, attribution: "swisstopo, Kt.", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.swisstopo.fixpunkte-lfp1", attributionUrl: "http://www.swisstopo.admin.ch/internet/swisstopo/de/home/swisstopo/org/cartography.html", timeBehaviour: "last", tooltip: !0, label: "Lagefixpunkte LFP1", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["id"], topics: "api,ech,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.fixpunkte-lfp2": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.swisstopo.fixpunkte-lfp2", gutter: 100, attribution: "swisstopo, Kt.", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.swisstopo.fixpunkte-lfp2", attributionUrl: "http://www.swisstopo.admin.ch/internet/swisstopo/de/home/swisstopo/org/cartography.html", timeBehaviour: "last", tooltip: !0, label: "Lagefixpunkte LFP2", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["id"], topics: "api,ech,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.vbs.patrouilledesglaciers-a_rennen": { opacity: .75, attribution: "VBS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.vbs.patrouilledesglaciers-a_rennen", attributionUrl: "http://www.vbs.admin.ch/internet/vbs/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Patrouille des Glaciers (A Rennen)", highlightable: !0, background: !1, timestamps: ["20150511"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,verteidigung,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geodaesie-bouguer_anomalien": { attribution: "swisstopo, sgpk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geodaesie-bouguer_anomalien", attributionUrl: "ch.swisstopo.sgpk.url", timeBehaviour: "last", tooltip: !0, label: "Bouguer-Anomalien 500", highlightable: !0, background: !1, timestamps: ["20110406"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,geothermie,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.astra.ivs-nat_abgrenzungen": { attribution: "ASTRA", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.astra.ivs-nat_abgrenzungen", attributionUrl: "http://www.astra.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "IVS Abgrenzungen", highlightable: !0, background: !1, timestamps: ["20151231", "20100414"], hasLegend: !0, type: "wmts", topics: "api,astra,ech,inspire,ivs,wms-bgdi_prod" },
            "ch.bfs.arealstatistik-bodennutzung": { opacity: .75, attribution: "BFS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfs.arealstatistik-bodennutzung", attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", timeBehaviour: "last", tooltip: !0, label: "Arealstatistik 2004/09 NOLU04 ", highlightable: !0, background: !1, timestamps: ["20131121"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bag.zecken-fsme-faelle": { opacity: .75, attribution: "BAG", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bag.zecken-fsme-faelle", attributionUrl: "http://www.bag.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "FSME - Lokale Häufungen", highlightable: !0, background: !1, timestamps: ["20151231", "20141231"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline" },
            "ch.bafu.hydrologie-hintergrundkarte": { attribution: "BAFU", searchable: !1, subLayersIds: ["ch.bafu.hydrologie-hintergrundkarte_wmts2", "ch.bafu.hydrologie-hintergrundkarte_wmts1"], timeEnabled: !1, serverLayerName: "ch.bafu.hydrologie-hintergrundkarte", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Hintergrundkarte hydrol. Daten", chargeable: !1, highlightable: !0, background: !1, hasLegend: !1, type: "aggregate", topics: "api,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.hydrologie-untersuchungsgebiete_stationen": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.hydrologie-untersuchungsgebiete_stationen", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "HUG-Messstationen", highlightable: !0, background: !1, timestamps: ["20130101"], hasLegend: !0, queryableAttributes: ["hoehe", "einzugsgebietsflaeche", "name", "flussgebiet", "betriebsbeginn"], topics: "api,bafu,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bfe.energiestaedte-energieregionen": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bfe.energiestaedte-energieregionen", gutter: 15, attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bfe.energiestaedte-energieregionen", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Energie-Regionen", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["name"], topics: "api,ech,energie,inspire,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geotechnik-gk500-lithologie_hauptgruppen": { opacity: .75, attribution: "swisstopo, sgtk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geotechnik-gk500-lithologie_hauptgruppen", attributionUrl: "ch.swisstopo.sgtk.url", timeBehaviour: "last", tooltip: !0, label: "Lithologie (Hauptgruppen) 500", highlightable: !0, background: !1, timestamps: ["20060304"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.vec200-adminboundaries-protectedarea": { opacity: .75, attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec200-adminboundaries-protectedarea", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Schutzgebiete VECTOR200", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.vbs.territorialregionen": { opacity: .6, attribution: "VBS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.vbs.territorialregionen", attributionUrl: "http://www.vbs.admin.ch/internet/vbs/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Territorialregionen", highlightable: !0, background: !1, timestamps: ["20110501"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,verteidigung" },
            "ch.swisstopo.swisstlm3d-wanderwege": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.swisstlm3d-wanderwege", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Wanderwege", highlightable: !0, background: !1, timestamps: ["20160315", "20150101"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,kgs,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod" },
            "ch.ensi.zonenplan-notfallschutz-kernanlagen": { opacity: .6, attribution: "ENSI", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.ensi.zonenplan-notfallschutz-kernanlagen", attributionUrl: "https://www.ensi.ch/de/", timeBehaviour: "last", tooltip: !0, label: "Zonenpläne für den Notfallschutz", highlightable: !0, background: !1, timestamps: ["20120101"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,kgs,swissmaponline,wms-bgdi_prod,wms-naz" },
            "ch.bazl.kataster-belasteter-standorte-zivilflugplaetze": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, gutter: 15, attribution: "BAZL", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bazl.kataster-belasteter-standorte-zivilflugplaetze", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Belastete Standorte Zivilflugplätze", wmsLayers: "ch.bazl.kataster-belasteter-standorte-zivilflugplaetze", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["katasternummer"], topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.astra.ivs-nat-verlaeufe": { attribution: "ASTRA", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.astra.ivs-nat-verlaeufe", attributionUrl: "http://www.astra.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "IVS nationale Bed.hist. Verlauf.", highlightable: !0, background: !1, timestamps: ["20100416"], hasLegend: !0, queryableAttributes: ["ivs_slaname", "ivs_signatur", "ivs_nummer"], topics: "api,astra,ech,inspire,ivs,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.ren-fliessgewaesser_seen": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.ren-fliessgewaesser_seen", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "REN  Fliessgewässer / Seen", highlightable: !0, background: !1, timestamps: ["20110214"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bfe.kernkraftwerke": { attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.bfe.kernkraftwerke", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Kernkraftwerke", highlightable: !0, background: !1, timestamps: ["20120911"], hasLegend: !0, type: "wmts", topics: "api,ech,energie,inspire,kgs,wms-bgdi_prod,wms-naz" },
            "ch.bafu.schutzgebiete-paerke_nationaler_bedeutung": { opacity: .85, attribution: "BAFU + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.schutzgebiete-paerke_nationaler_bedeutung", attributionUrl: "ch.bafu.kt.url", timeBehaviour: "last", tooltip: !0, label: "Pärke", highlightable: !0, background: !1, timestamps: ["20160301"], hasLegend: !0, type: "wmts", topics: "api,bafu,blw,ech,inspire,kgs,sachplan,swissmaponline,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2] },
            "ch.vbs.milairspacechart": { attribution: "VBS", chargeable: !1, searchable: !1, format: "jpeg", timeEnabled: !1, serverLayerName: "ch.vbs.milairspacechart", attributionUrl: "http://www.vbs.admin.ch/internet/vbs/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Mil Airspace Chart", highlightable: !0, background: !1, timestamps: ["20160331"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,verteidigung,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5] },
            "ch.bfs.arealstatistik-bodenbedeckung": { opacity: .75, attribution: "BFS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfs.arealstatistik-bodenbedeckung", attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", timeBehaviour: "last", tooltip: !0, label: "Arealstatistik 2004/09 NOLC04", highlightable: !0, background: !1, timestamps: ["20131121"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.blw.erosion": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.erosion", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Erosionsrisiko qualitativ 1", highlightable: !0, background: !1, timestamps: ["20100103"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bazl.sachplan-infrastruktur-luftfahrt_kraft": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bazl.sachplan-infrastruktur-luftfahrt_kraft", gutter: 25, attribution: "BAZL", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bazl.sachplan-infrastruktur-luftfahrt_kraft", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "SP Infrastruktur Luftfahrt", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,sachplan,wms-bgdi_prod" },
            "ch.bfe.sachplan-geologie-tiefenlager-thematische-darstellung": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, gutter: 25, attribution: "BFE", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfe.sachplan-geologie-tiefenlager-thematische-darstellung", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "SP Geologische Tiefenlager: t.D.", wmsLayers: "ch.bfe.sachplan-geologie-tiefenlager-thematische-darstellung", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,wms-bgdi_prod" },
            "ch.bfe.statistik-wasserkraftanlagen": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bfe.statistik-wasserkraftanlagen", gutter: 15, attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.bfe.statistik-wasserkraftanlagen", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Statistik Wasserkraft", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,energie,gewiss,inspire,wms-bgdi_prod" },
            "org.epsg.grid_21781": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "org.epsg.grid_21781", attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "org.epsg.grid_21781", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Koordinatennetz CH1903/LV03", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.bafu.bundesinventare-trockenwiesen_trockenweiden": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.bundesinventare-trockenwiesen_trockenweiden", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Trockenwiesen und -weiden (TWW)", highlightable: !0, background: !1, timestamps: ["20130624"], hasLegend: !0, type: "wmts", topics: "api,bafu,blw,ech,energie,inspire,sachplan,wms-bgdi_prod" },
            "ch.astra.skatingland": { attribution: "ASTRA + Kanton", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.astra.skatingland", attributionUrl: "ch.astra.kt.url", timeBehaviour: "last", tooltip: !0, label: "Skatingland", highlightable: !0, background: !1, timestamps: ["20160518"], hasLegend: !0, type: "wmts", topics: "api,astra,ech,inspire" },
            "ch.are.agglomerationen_isolierte_staedte": { opacity: .75, attribution: "ARE", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.are.agglomerationen_isolierte_staedte", attributionUrl: "http://www.are.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Agglomerationen und isolierte Städte", highlightable: !0, background: !1, timestamps: ["20140101"], hasLegend: !0, type: "wmts", topics: "api,are,ech,geothermie,inspire,swissmaponline,wms-naz" },
            "ch.swisstopo.swissbuildings3d": { shop: ["commune", "district", "canton", "rectangle", "whole"], attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.swissbuildings3d", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Vereinfachte 3D-Gebäude", highlightable: !1, background: !1, timestamps: ["19980101"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,kgs,swissmaponline,swisstopo" },
            "ch.swisstopo.geologie-geologische_karte_papier.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", shop: ["mapsheet"], attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geologische_karte_papier.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "ch.swisstopo.geologie-geologische_karte_papier.metadata", wmsLayers: "ch.swisstopo.geologie-geologische_karte_papier.metadata", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bafu.oekomorphologie-f_abschnitte": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.oekomorphologie-f_abschnitte", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Ökomorphologie F - Abschnitte", highlightable: !0, background: !1, timestamps: ["20080913"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.bakom.downlink100": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.downlink100", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Download ≥ 100 Mbit/s", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.bak.schutzgebiete-unesco_weltkulturerbe": { opacity: .75, attribution: "BAK", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bak.schutzgebiete-unesco_weltkulturerbe", attributionUrl: "http://www.bak.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "UNESCO-Welterbe Kulturstätten", highlightable: !0, background: !1, timestamps: ["20120203"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,kgs,wms-bgdi_prod" },
            "ch.bafu.unesco-weltnaturerbe": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.unesco-weltnaturerbe", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "UNESCO-Welterbe Naturstätten", highlightable: !0, background: !1, timestamps: ["20080724"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,kgs,sachplan,wms-bgdi_prod" },
            "ch.bakom.mobil-antennenstandorte-umts": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bakom.mobil-antennenstandorte-umts", gutter: 15, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.mobil-antennenstandorte-umts", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Antennenstandorte 3G (UMTS)", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,funksender,inspire,kgs,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geophysik-totalintensitaet": { attribution: "swisstopo, sgpk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geophysik-totalintensitaet", attributionUrl: "ch.swisstopo.sgpk.url", timeBehaviour: "last", tooltip: !0, label: "Magnetfeldstärke 500", highlightable: !0, background: !1, timestamps: ["19800101"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.bundesinventare-amphibien_wanderobjekte": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.bundesinventare-amphibien_wanderobjekte", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Amphibien Wanderobjekte", highlightable: !0, background: !1, timestamps: ["20070702"], hasLegend: !0, type: "wmts", topics: "api,bafu,blw,ech,energie,inspire,sachplan,swissmaponline,wms-bgdi_prod" },
            "ch.blw.klimaeignung-koernermais": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.klimaeignung-koernermais", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Klimaeignung Körnermais", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.blw.hang_steillagen": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.hang_steillagen", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Hanglagen", highlightable: !0, background: !1, timestamps: ["20121231"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod,wms-naz" },
            "ch.meteoschweiz.globalstrahlung-monatlich": { wmsUrl: "//wms-bod.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.meteoschweiz.globalstrahlung-monatlich", attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.meteoschweiz.globalstrahlung-monatlich", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "ch.meteoschweiz.globalstrahlung-monatlich", singleTile: !0, highlightable: !1, background: !1, hasLegend: !1, type: "wms", topics: "api" },
            "ch.bafu.gewaesserschutz-chemischer_zustand_phosphor_gesamt": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bafu.gewaesserschutz-chemischer_zustand_phosphor_gesamt", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !0, serverLayerName: "ch.bafu.gewaesserschutz-chemischer_zustand_phosphor_gesamt", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "all", tooltip: !0, label: "Gesamt-Phosphor", singleTile: !0, highlightable: !0, background: !1, timestamps: ["2013", "2012", "2011"], hasLegend: !0, type: "wms", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.swisstopo.vec25-gebaeude": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec25-gebaeude", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Gebäude VECTOR25", highlightable: !0, background: !1, timestamps: ["20090401"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo,wms-naz" },
            "ch.swisstopo.geologie-geodaesie-bouguer_anomalien_papier.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", shop: ["mapsheet"], attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geodaesie-bouguer_anomalien_papier.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "ch.swisstopo.geologie-geodaesie-bouguer_anomalien_papier.metadata", wmsLayers: "ch.swisstopo.geologie-geodaesie-bouguer_anomalien_papier.metadata", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geotechnik-gk500-genese": { opacity: .75, attribution: "swisstopo, sgtk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geotechnik-gk500-genese", attributionUrl: "ch.swisstopo.sgtk.url", timeBehaviour: "last", tooltip: !0, label: "Entstehung der Gesteine 500", highlightable: !0, background: !1, timestamps: ["20060304"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.verschiebungsvektoren-tsp2": { attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.swisstopo.verschiebungsvektoren-tsp2", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "LV95 Verschiebungsvektoren TSP2", highlightable: !0, background: !1, timestamps: ["20070101"], hasLegend: !0, queryableAttributes: ["name", "id"], topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.verschiebungsvektoren-tsp1": { attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.swisstopo.verschiebungsvektoren-tsp1", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "LV95 Verschiebungsvektoren TSP1", highlightable: !0, background: !1, timestamps: ["20061231"], hasLegend: !0, queryableAttributes: ["name"], topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.vec200-transportation-oeffentliche-verkehr": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec200-transportation-oeffentliche-verkehr", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Öffentlicher Verkehr VECTOR200", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.swisstopo.lubis-bildstreifen": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", shop: ["mapsheet"], chargeable: !1, searchable: !0, serverLayerName: "ch.swisstopo.lubis-bildstreifen", highlightable: !0, timeEnabled: !0, attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", tooltip: !0, label: "Luftbildstreifen swisstopo", singleTile: !1, timestamps: ["2015", "2014", "2013", "2012", "2011", "2010", "2009", "2008", "2007", "2006", "2005"], type: "wms", topics: "api,ech,luftbilder,swisstopo,wms-bgdi_prod", attribution: "swisstopo", format: "png", background: !1, wmsLayers: "ch.swisstopo.lubis-bildstreifen", gutter: 20, timeBehaviour: "all", hasLegend: !0, queryableAttributes: ["id"] },
            "ch.blw.emapis-projektschwerpunkt": { wmsUrl: "//wms-bod.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.blw.emapis-projektschwerpunkt", gutter: 30, attribution: "BLW + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.emapis-projektschwerpunkt", attributionUrl: "ch.blw.kt.url", timeBehaviour: "last", tooltip: !0, label: "Projektschwerpunkt", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "ech,emapis,inspire,wms-bgdi_prod" },
            "ch.vbs.logistikraeume-armeelogistikcenter": { opacity: .75, attribution: "VBS", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.vbs.logistikraeume-armeelogistikcenter", attributionUrl: "http://www.vbs.admin.ch/internet/vbs/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Logistikräume ALC", highlightable: !0, background: !1, timestamps: ["20141217"], hasLegend: !0, queryableAttributes: ["region", "kanton"], topics: "api,ech,inspire,swissmaponline,verteidigung,wms-bgdi_prod" },
            "ch.swisstopo.lubis-luftbilder_infrarot": { shop: ["mapsheet"], attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !0, type: "wmts", serverLayerName: "ch.swisstopo.lubis-luftbilder_infrarot", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Luftbilder swisstopo infrarot", highlightable: !0, background: !1, timestamps: ["99991231", "20091231", "20081231", "20071231", "20061231", "20051231", "20041231", "20031231", "20021231", "20011231", "20001231", "19991231", "19981231", "19971231", "19961231", "19951231", "19941231", "19931231", "19921231", "19911231", "19901231", "19891231", "19881231", "19871231", "19861231", "19851231", "19841231", "19831231", "19811231"], hasLegend: !0, queryableAttributes: ["ort", "id"], topics: "api,ech,geol,luftbilder,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.geologie-eiszeit-lgm-raster": { attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-eiszeit-lgm-raster", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Letzteiszeitl. Max. (Karte) 500", highlightable: !0, background: !1, timestamps: ["20081231"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.bag.zecken-fsme-impfung": { opacity: .75, attribution: "BAG", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bag.zecken-fsme-impfung", attributionUrl: "http://www.bag.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "FSME - Impfempfehlung", highlightable: !0, background: !1, timestamps: ["20151231", "20141231"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline" },
            "ch.bazl.laermbelastungskataster-zivilflugplaetze_erste-nachtstunde": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BAZL", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bazl.laermbelastungskataster-zivilflugplaetze_erste-nachtstunde", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Lärmbelastung 1. Nachtstunde", wmsLayers: "ch.bazl.laermbelastungskataster-zivilflugplaetze_erste-nachtstunde", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.bfe.windenergie-geschwindigkeit_h150": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BFE", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfe.windenergie-geschwindigkeit_h150", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Windgeschwindigkeit 150 m Höhe", wmsLayers: "ch.bfe.windenergie-geschwindigkeit_h150", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,energie,inspire,wms-bgdi_prod" },
            "ch.bafu.showme-kantone_hochwasser": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.showme-kantone_hochwasser", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ShowMe Kantone: Hochwasser", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2] },
            "ch.bafu.wasser-gebietsauslaesse": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.wasser-gebietsauslaesse", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Gebietsauslässe", highlightable: !0, background: !1, timestamps: ["20120701"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,gewiss,wms-bgdi_prod" },
            "ch.blw.klimaeignung-spezialkulturen": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.klimaeignung-spezialkulturen", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Klimaeignung Spezialkulturen", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.ren-extensive_landwirtschaftsgebiete": {
                opacity: .75,
                attribution: "BAFU",
                chargeable: !1,
                searchable: !1,
                format: "png",
                timeEnabled: !1,
                serverLayerName: "ch.bafu.ren-extensive_landwirtschaftsgebiete",
                attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de",
                timeBehaviour: "last",
                tooltip: !1,
                label: "REN  Extensives Landwirtschaftsgebiet",
                highlightable: !0,
                background: !1,
                timestamps: ["20110214"],
                hasLegend: !0,
                type: "wmts",
                topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod"
            },
            "ch.blw.ursprungsbezeichnungen-spirituosen": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.ursprungsbezeichnungen-spirituosen", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "GUB Spirituosen", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geotechnik-steine_historische_bauwerke": { attribution: "swisstopo, sgtk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geotechnik-steine_historische_bauwerke", attributionUrl: "ch.swisstopo.sgtk.url", timeBehaviour: "last", tooltip: !0, label: "Steine an hist. Bauwerken", highlightable: !0, background: !1, timestamps: ["20130620"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,kgs,swissmaponline,wms-bgdi_prod,wms-naz" },
            "ch.bazl.laermbelastungskataster-zivilflugplaetze_helikopter": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BAZL", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bazl.laermbelastungskataster-zivilflugplaetze_helikopter", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Lärmbelastung Helikopter Lr", wmsLayers: "ch.bazl.laermbelastungskataster-zivilflugplaetze_helikopter", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.blw.alpprodukte": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.alpprodukte", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Alpprodukte", highlightable: !0, background: !1, timestamps: ["20150422"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.vec200-building": { opacity: .75, attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec200-building", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Einzelgebäude gen. VECTOR200", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.bfe.stauanlagen-bundesaufsicht": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bfe.stauanlagen-bundesaufsicht", gutter: 15, attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bfe.stauanlagen-bundesaufsicht", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Stauanlagen", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["damname", "damtype_de"], topics: "api,ech,energie,gewiss,inspire,kgs,wms-bgdi_prod,wms-naz" },
            "ch.bakom.downlink10": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.downlink10", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Download ≥ 10 Mbit/s", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.blw.emapis-beizugsgebiet": { wmsUrl: "//wms-bod.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.blw.emapis-beizugsgebiet", gutter: 30, attribution: "BLW + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.emapis-beizugsgebiet", attributionUrl: "ch.blw.kt.url", timeBehaviour: "last", tooltip: !0, label: "Beizugsgebiet", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "ech,emapis,inspire,wms-bgdi_prod" },
            "ch.bakom.anschlussart-kupferdraht": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.anschlussart-kupferdraht", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Kupfer-Draht", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.bfe.solarenergie-eignung-daecher": { attribution: "BFE", searchable: !1, subLayersIds: ["ch.bfe.solarenergie-eignung-daecher_wmts", "ch.bfe.solarenergie-eignung-daecher_wms"], timeEnabled: !1, type: "aggregate", serverLayerName: "ch.bfe.solarenergie-eignung-daecher", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Solarenergie: Eignung Dächer", chargeable: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["building_id", "df_uid"], topics: "api,ech,energie,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.sturm-boeenspitzen_300": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.sturm-boeenspitzen_300", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Sturmgefährdung Böenspitzen 300", highlightable: !0, background: !1, timestamps: ["20141107"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.pixelkarte-farbe_wmts": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "jpeg", type: "wmts", serverLayerName: "ch.swisstopo.pixelkarte-farbe", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "ch.swisstopo.pixelkarte-farbe_wmts", highlightable: !0, background: !0, parentLayerId: "ch.swisstopo.pixelkarte-farbe", timestamps: ["current"], hasLegend: !0, topics: "api,swissmaponline,wms-naz,wms-swisstopowms_prod", timeEnabled: !1, resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, .5, .25], minResolution: 1.5 },
            "ch.swisstopo-vd.geometa-los_wmstile": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "Amtliche Vermessung Schweiz", chargeable: !1, searchable: !1, format: "png", serverLayerName: "ch.swisstopo-vd.geometa-los", attributionUrl: "http://www.cadastre.ch", timeBehaviour: "last", tooltip: !1, label: "ch.swisstopo-vd.geometa-los_wmstile", wmsLayers: "ch.swisstopo-vd.geometa-los", singleTile: !1, highlightable: !0, background: !1, parentLayerId: "ch.swisstopo-vd.geometa-los", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod", hasLegend: !0, type: "wms", timeEnabled: !1, minResolution: 20 },
            "ch.bfs.gebaeude_wohnungs_register_wmts": { attribution: "BFS", chargeable: !1, searchable: !1, format: "png", type: "wmts", serverLayerName: "ch.bfs.gebaeude_wohnungs_register", attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", timeBehaviour: "last", tooltip: !1, label: "ch.bfs.gebaeude_wohnungs_register_wmts", highlightable: !0, background: !1, parentLayerId: "ch.bfs.gebaeude_wohnungs_register", timestamps: ["20160208", "20130212"], hasLegend: !0, topics: "api,ech,inspire,kgs,swissmaponline", timeEnabled: !1, resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5], minResolution: 10 },
            "ch.bafu.moose": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.moose", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Rote Liste Moose", highlightable: !0, background: !1, timestamps: ["20120416"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,wms-bgdi_prod" },
            "ch.swisstopo-vd.ortschaftenverzeichnis_plz": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.swisstopo-vd.ortschaftenverzeichnis_plz", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "PLZ und Ortschaften", wmsLayers: "ch.swisstopo-vd.ortschaftenverzeichnis_plz", singleTile: !1, highlightable: !0, background: !1, hasLegend: !1, queryableAttributes: ["langtext", "plz"], topics: "api,cadastre,ech,inspire,kgs,swissmaponline,swisstopo,wms-bgdi_prod,wms-naz" },
            "ch.bfe.windenergieanlagen": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bfe.windenergieanlagen", gutter: 15, attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bfe.windenergieanlagen", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Windenergieanlagen", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["fac_name"], topics: "api,ech,energie,inspire,kgs,wms-bgdi_prod" },
            "ch.babs.kulturgueter": { opacity: .75, attribution: "BABS", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.babs.kulturgueter", attributionUrl: "http://www.babs.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "KGS Inventar", highlightable: !0, background: !1, timestamps: ["20160101", "20150101"], hasLegend: !0, queryableAttributes: ["zkob"], topics: "api,ech,inspire,kgs,swissmaponline,wms-bgdi_prod,wms-naz" },
            "ch.swisstopo.zeitreihen": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "pngjpeg", timeEnabled: !0, serverLayerName: "ch.swisstopo.zeitreihen", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "18641231", tooltip: !0, label: "Zeitreise - Kartenwerke", highlightable: !0, background: !1, timestamps: ["20131231", "20121231", "20111231", "20101231", "20091231", "20081231", "20071231", "20061231", "20051231", "20041231", "20031231", "20021231", "20011231", "20001231", "19991231", "19981231", "19971231", "19961231", "19951231", "19941231", "19931231", "19921231", "19911231", "19901231", "19891231", "19881231", "19871231", "19861231", "19851231", "19841231", "19831231", "19821231", "19811231", "19801231", "19791231", "19781231", "19771231", "19761231", "19751231", "19741231", "19731231", "19721231", "19711231", "19701231", "19691231", "19681231", "19671231", "19661231", "19651231", "19641231", "19631231", "19621231", "19611231", "19601231", "19591231", "19581231", "19571231", "19561231", "19551231", "19541231", "19531231", "19521231", "19511231", "19501231", "19491231", "19481231", "19471231", "19461231", "19451231", "19441231", "19431231", "19421231", "19411231", "19401231", "19391231", "19381231", "19371231", "19361231", "19351231", "19341231", "19331231", "19321231", "19311231", "19301231", "19291231", "19281231", "19271231", "19261231", "19251231", "19241231", "19231231", "19221231", "19211231", "19201231", "19191231", "19181231", "19171231", "19161231", "19151231", "19141231", "19131231", "19121231", "19111231", "19101231", "19091231", "19081231", "19071231", "19061231", "19051231", "19041231", "19031231", "19021231", "19011231", "19001231", "18991231", "18981231", "18971231", "18961231", "18951231", "18941231", "18931231", "18921231", "18911231", "18901231", "18891231", "18881231", "18871231", "18861231", "18851231", "18841231", "18831231", "18821231", "18811231", "18801231", "18791231", "18781231", "18771231", "18761231", "18751231", "18741231", "18731231", "18721231", "18711231", "18701231", "18691231", "18681231", "18671231", "18661231", "18651231", "18641231", "18631231", "18621231", "18611231", "18601231", "18591231", "18581231", "18571231", "18561231", "18551231", "18541231", "18531231", "18521231", "18511231", "18501231", "18491231", "18481231", "18471231", "18461231", "18451231", "18441231"], hasLegend: !1, type: "wmts", topics: "api,ech,energie,geol,inspire,kgs,swisstopo", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2] },
            "ch.bafu.sturm-staudruck_50": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.sturm-staudruck_50", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Sturmgefährdung Staudruck 50", highlightable: !0, background: !1, timestamps: ["20141107"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.vbs.grunddispositiv-zeus": { attribution: "VBS", chargeable: !1, searchable: !1, format: "jpeg", timeEnabled: !1, serverLayerName: "ch.vbs.grunddispositiv-zeus", attributionUrl: "http://www.vbs.admin.ch/internet/vbs/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Zeus Karte", highlightable: !0, background: !1, timestamps: ["20140116"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,verteidigung,wms-bgdi_prod" },
            "ch.blw.bodeneignung-naehrstoffspeichervermoegen": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.bodeneignung-naehrstoffspeichervermoegen", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Nährstoffspeichervermögen", highlightable: !0, background: !1, timestamps: ["20120601"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.nabelstationen": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.nabelstationen", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Messstationen Luftqualität", highlightable: !0, background: !1, timestamps: ["20110309"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.vbs.retablierungsstellen": { opacity: .75, attribution: "VBS", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.vbs.retablierungsstellen", attributionUrl: "http://www.vbs.admin.ch/internet/vbs/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Retablierungsstellen", highlightable: !0, background: !1, timestamps: ["20150615"], hasLegend: !0, queryableAttributes: ["name"], topics: "api,ech,inspire,kgs,swissmaponline,verteidigung,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geocover": { opacity: .75, shop: ["mapsheet"], attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.swisstopo.geologie-geocover", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "GeoCover - Vektordaten", highlightable: !0, background: !1, timestamps: ["20161231"], hasLegend: !1, queryableAttributes: ["release", "name_de", "number"], topics: "api,ech,geol,geothermie,gewiss,inspire,swisstopo,wms-naz,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2] },
            "ch.bafu.showme-kantone_rutschungen": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.showme-kantone_rutschungen", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ShowMe Kantone: Rutschungen", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2] },
            "ch.bak.bundesinventar-schuetzenswerte-ortsbilder": { attribution: "BAK", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bak.bundesinventar-schuetzenswerte-ortsbilder", attributionUrl: "http://www.bak.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Bundesinventar ISOS", highlightable: !0, background: !1, timestamps: ["20161001", "20160222", "20150511"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,energie,inspire,kgs,sachplan,swissmaponline,wms-bgdi_prod,wms-naz" },
            "ch.blw.bodeneignung-wasserspeichervermoegen": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.bodeneignung-wasserspeichervermoegen", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Wasserspeichervermögen", highlightable: !0, background: !1, timestamps: ["20120601"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.lubis-luftbilder_schwarzweiss": { shop: ["mapsheet"], attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !0, type: "wmts", serverLayerName: "ch.swisstopo.lubis-luftbilder_schwarzweiss", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Luftbilder swisstopo s/w", highlightable: !0, background: !1, timestamps: ["99991231", "20101231", "20091231", "20081231", "20071231", "20061231", "20051231", "20041231", "20031231", "20021231", "20011231", "20001231", "19991231", "19981231", "19971231", "19961231", "19951231", "19941231", "19931231", "19921231", "19911231", "19901231", "19891231", "19881231", "19871231", "19861231", "19851231", "19841231", "19831231", "19821231", "19811231", "19801231", "19791231", "19781231", "19771231", "19761231", "19751231", "19741231", "19731231", "19721231", "19711231", "19701231", "19691231", "19681231", "19671231", "19661231", "19651231", "19641231", "19631231", "19621231", "19611231", "19601231", "19591231", "19581231", "19571231", "19561231", "19551231", "19541231", "19531231", "19521231", "19511231", "19501231", "19491231", "19481231", "19471231", "19461231", "19451231", "19441231", "19431231", "19421231", "19411231", "19401231", "19391231", "19381231", "19371231", "19361231", "19351231", "19341231", "19331231", "19321231", "19311231", "19301231", "19291231", "19281231", "19271231", "19261231"], hasLegend: !0, queryableAttributes: ["bgdi_flugjahr", "ort", "id", "filmart"], topics: "api,ech,geol,kgs,luftbilder,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.geologie-gravimetrischer_atlas.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", shop: ["mapsheet"], attribution: "swisstopo, sgpk", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.swisstopo.geologie-gravimetrischer_atlas.metadata", attributionUrl: "ch.swisstopo.sgpk.url", timeBehaviour: "last", tooltip: !0, label: "Gravimetrischer Atlas 100 - Papier", wmsLayers: "ch.swisstopo.geologie-gravimetrischer_atlas.metadata", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["release"], topics: "api,wms-bgdi_prod" },
            "ch.bfs.arealstatistik-bodennutzung-1997": { opacity: .75, attribution: "BFS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfs.arealstatistik-bodennutzung-1997", attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", timeBehaviour: "last", tooltip: !0, label: "Arealstatistik 1992/97 NOLU04", highlightable: !0, background: !1, timestamps: ["20131121"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.astra.veloland": { attribution: "ASTRA + Kanton", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.astra.veloland", attributionUrl: "ch.astra.kt.url", timeBehaviour: "last", tooltip: !0, label: "Veloland", highlightable: !0, background: !1, timestamps: ["20160518"], hasLegend: !0, type: "wmts", topics: "api,astra,ech,inspire,kgs" },
            "ch.swisstopo.landeskarte-farbe-10_wmts": { topics: "api,ech,inspire,swisstopo,wms-swisstopowms_prod", attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", serverLayerName: "ch.swisstopo.landeskarte-farbe-10", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "ch.swisstopo.landeskarte-farbe-10_wmts", parentLayerId: "ch.swisstopo.pixelkarte-farbe", highlightable: !1, background: !0, maxResolution: 1.5, timestamps: ["current"], hasLegend: !1, type: "wmts", timeEnabled: !1, resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, .5, .25] },
            "ch.bakom.uplink2": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.uplink2", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Upload ≥ 2 Mbit/s", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.bafu.neophyten-japanisches_geissblatt": { opacity: .75, wmsLayers: "", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.neophyten-japanisches_geissblatt", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Japanisches Geissblatt", highlightable: !0, background: !1, timestamps: ["20140825"], hasLegend: !1, type: "wmts", topics: "api,bafu,ech,inspire,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5] },
            "ch.bav.sachplan-infrastruktur-schiene_kraft": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bav.sachplan-infrastruktur-schiene_kraft", gutter: 25, attribution: "BAV", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bav.sachplan-infrastruktur-schiene_kraft", attributionUrl: "http://www.bav.admin.ch/?lang=de", timeBehaviour: "last", tooltip: !0, label: "SP Infrastruktur Schiene", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["doc_title", "facname_de", "plname_de"], topics: "api,ech,inspire,sachplan,wms-bgdi_prod" },
            "ch.swisstopo-vd.geometa-periodische_nachfuehrung": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "Amtliche Vermessung Schweiz", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.geometa-periodische_nachfuehrung", attributionUrl: "http://www.cadastre.ch", timeBehaviour: "last", tooltip: !0, label: "Periodische Nachführung", wmsLayers: "ch.swisstopo-vd.geometa-periodische_nachfuehrung", singleTile: !0, highlightable: !0, background: !1, hasLegend: !1, type: "wms", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geologischer_atlas": { opacity: .75, shop: ["mapsheet"], attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.swisstopo.geologie-geologischer_atlas", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Geologischer Atlas GA25", highlightable: !0, background: !1, timestamps: ["20131120"], hasLegend: !1, queryableAttributes: ["release", "name_de", "number"], topics: "api,ech,geol,geothermie,gewiss,inspire,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod" },
            "ch.blw.emapis-elektrizitaetsversorgung": { wmsUrl: "//wms-bod.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.blw.emapis-elektrizitaetsversorgung", gutter: 30, attribution: "BLW + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.emapis-elektrizitaetsversorgung", attributionUrl: "ch.blw.kt.url", timeBehaviour: "last", tooltip: !0, label: "Elektrizitätsversorgung", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "ech,emapis,inspire,wms-bgdi_prod" },
            "ch.blw.emapis-wegebau": { wmsUrl: "//wms-bod.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.blw.emapis-wegebau", gutter: 30, attribution: "BLW + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.emapis-wegebau", attributionUrl: "ch.blw.kt.url", timeBehaviour: "last", tooltip: !0, label: "Wegebau", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "ech,emapis,inspire,wms-bgdi_prod" },
            "ch.bafu.bundesinventare-auen": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.bundesinventare-auen", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Auengebiete", highlightable: !0, background: !1, timestamps: ["20070701"], hasLegend: !0, queryableAttributes: ["au_obj", "au_name"], topics: "api,are,bafu,blw,ech,energie,geothermie,gewiss,inspire,sachplan,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.bundesinventare-vogelreservate": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.bundesinventare-vogelreservate", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Wasser- und Zugvogelreservate", highlightable: !0, background: !1, timestamps: ["20150923", "20150622"], hasLegend: !0, type: "wmts", topics: "api,are,bafu,blw,ech,energie,gewiss,inspire,sachplan,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.pixelkarte-farbe-pk200.noscale": { shop: ["mapsheet", "district", "canton", "rectangle", "whole"], attribution: "swisstopo", chargeable: !0, searchable: !1, format: "jpeg", timeEnabled: !1, serverLayerName: "ch.swisstopo.pixelkarte-farbe-pk200.noscale", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Landeskarte 1:200'000 | LK200", highlightable: !1, background: !1, timestamps: ["current", "20151231"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo" },
            "ch.swisstopo.vec200-hydrography": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec200-hydrography", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Gewässernetz VECTOR200", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,ech,gewiss,inspire,swissmaponline,swisstopo", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.bakom.anschlussart-glasfaser": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.anschlussart-glasfaser", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Glasfaser", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.bfs.arealstatistik-hintergrund": { opacity: .75, attribution: "BFS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfs.arealstatistik-hintergrund", attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", timeBehaviour: "last", tooltip: !1, label: "Vereinfachte Bodennutzung", highlightable: !0, background: !1, timestamps: ["20070116"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline" },
            "ch.bafu.laerm-bahnlaerm_tag": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.laerm-bahnlaerm_tag", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Eisenbahnlärm Tag", highlightable: !0, background: !1, timestamps: ["20111231", "20061231"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.gewaesserschutz-biologischer_zustand_makrophyten": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bafu.gewaesserschutz-biologischer_zustand_makrophyten", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !0, serverLayerName: "ch.bafu.gewaesserschutz-biologischer_zustand_makrophyten", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "all", tooltip: !0, label: "Wasserpflanzen (Makrophyten)", singleTile: !0, highlightable: !0, background: !1, timestamps: ["2013", "2012", "2011"], hasLegend: !0, type: "wms", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geophysik-deklination": { attribution: "swisstopo, sgpk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geophysik-deklination", attributionUrl: "ch.swisstopo.sgpk.url", timeBehaviour: "last", tooltip: !0, label: "Deklination 500", highlightable: !0, background: !1, timestamps: ["20011203"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,geothermie,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.fixpunkte-agnes": { attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.fixpunkte-agnes", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "AGNES", highlightable: !0, background: !1, timestamps: ["20140924"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.blw.bewaesserungsbeduerftigkeit": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.bewaesserungsbeduerftigkeit", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Bewässerungsbedürftigkeit", highlightable: !0, background: !1, timestamps: ["20091110"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.vec25-gewaessernetz": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec25-gewaessernetz", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Gewässernetz VECTOR25", highlightable: !0, background: !1, timestamps: ["20090401"], hasLegend: !0, type: "wmts", topics: "api,ech,gewiss,inspire,swissmaponline,swisstopo,wms-naz" },
            "ch.bfe.energiestaedte-2000watt-aufdemweg": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bfe.energiestaedte-2000watt-aufdemweg", gutter: 25, attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bfe.energiestaedte-2000watt-aufdemweg", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Energiestädte auf dem Weg 2000-Watt", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["name"], topics: "api,ech,energie,inspire,wms-bgdi_prod" },
            "ch.swisstopo.geologie-gravimetrischer_atlas": { attribution: "swisstopo, sgpk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-gravimetrischer_atlas", attributionUrl: "ch.swisstopo.sgpk.url", timeBehaviour: "last", tooltip: !1, label: "Gravimetrischer Atlas 100", highlightable: !0, background: !1, timestamps: ["20021231"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,geothermie,inspire,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.images-swissimage.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.swisstopo.images-swissimage.metadata", gutter: 25, attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.images-swissimage.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Kachelung SWISSIMAGE", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,luftbilder,swisstopo,wms-bgdi_prod,wms-swisstopowms_prod" },
            "ch.blw.bodeneignung-kulturland": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.bodeneignung-kulturland", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Bodeneignung für Kulturland", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod,wms-naz" },
            "ch.bafu.bundesinventare-amphibien": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.bundesinventare-amphibien", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Amphibien Ortsfeste Objekte", highlightable: !0, background: !1, timestamps: ["20070702"], hasLegend: !0, type: "wmts", topics: "api,are,bafu,blw,ech,energie,inspire,sachplan,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.hiks-siegfried-ta50.metadata": {
                wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0",
                shop: ["mapsheet"],
                attribution: "swisstopo",
                chargeable: !1,
                searchable: !1,
                format: "png",
                timeEnabled: !1,
                serverLayerName: "ch.swisstopo.hiks-siegfried-ta50.metadata",
                attributionUrl: "https://www.swisstopo.admin.ch/de/home.html",
                timeBehaviour: "last",
                tooltip: !0,
                label: "ch.swisstopo.hiks-siegfried-ta50.metadata",
                wmsLayers: "ch.swisstopo.hiks-siegfried-ta50.metadata",
                singleTile: !0,
                highlightable: !0,
                background: !1,
                hasLegend: !0,
                type: "wms",
                topics: "api,ech,inspire,swisstopo,wms-bgdi_prod"
            },
            "ch.swisstopo.pixelkarte-farbe-pk25.noscale": { shop: ["mapsheet", "commune", "district", "canton", "rectangle", "whole"], attribution: "swisstopo", chargeable: !0, searchable: !1, format: "jpeg", timeEnabled: !1, serverLayerName: "ch.swisstopo.pixelkarte-farbe-pk25.noscale", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Landeskarte 1:25'000 | LK25", highlightable: !1, background: !1, timestamps: ["current", "20151231"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo" },
            "ch.swisstopo-vd.geometa-nfgeom_wms": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", chargeable: !1, searchable: !1, timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.geometa-nfgeom", highlightable: !0, parentLayerId: "ch.swisstopo-vd.geometa-nfgeom", minResolution: 0, attributionUrl: "http://www.cadastre.ch", tooltip: !1, label: "ch.swisstopo-vd.geometa-nfgeom_wms", singleTile: !1, type: "wms", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod", opacity: .75, attribution: "Amtliche Vermessung Schweiz", format: "png", background: !1, maxResolution: 20, wmsLayers: "ch.swisstopo-vd.geometa-nfgeom", gutter: 15, timeBehaviour: "last", hasLegend: !0 },
            "ch.bfe.abgeltung-wasserkraftnutzung": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, gutter: 15, attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bfe.abgeltung-wasserkraftnutzung", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Verzicht Wasserkraftnutzung", wmsLayers: "ch.bfe.abgeltung-wasserkraftnutzung", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["name"], topics: "api,ech,energie,gewiss,inspire,wms-bgdi_prod" },
            "ch.bfs.arealstatistik-bodennutzung-1985": { opacity: .75, attribution: "BFS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfs.arealstatistik-bodennutzung-1985", attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", timeBehaviour: "last", tooltip: !0, label: "Arealstatistik 1979/85 NOLU04", highlightable: !0, background: !1, timestamps: ["20131121"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.gewaesserschutz-biologischer_zustand_makrozoobenthos": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bafu.gewaesserschutz-biologischer_zustand_makrozoobenthos", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !0, serverLayerName: "ch.bafu.gewaesserschutz-biologischer_zustand_makrozoobenthos", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "all", tooltip: !0, label: "Makrozoobenthos", singleTile: !0, highlightable: !0, background: !1, timestamps: ["2013", "2012", "2011"], hasLegend: !0, type: "wms", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.bfe.windenergie-geschwindigkeit_h125": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BFE", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfe.windenergie-geschwindigkeit_h125", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Windgeschwindigkeit 125 m Höhe", wmsLayers: "ch.bfe.windenergie-geschwindigkeit_h125", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,energie,inspire,wms-bgdi_prod" },
            "ch.blw.ursprungsbezeichnungen-fleisch": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.ursprungsbezeichnungen-fleisch", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "GGA Fleischware", highlightable: !0, background: !1, timestamps: ["20110805"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.sturm-staudruck_300": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.sturm-staudruck_300", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Sturmgefährdung Staudruck 300", highlightable: !0, background: !1, timestamps: ["20141107"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.blw.emapis-seilbahnen": { wmsUrl: "//wms-bod.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.blw.emapis-seilbahnen", gutter: 30, attribution: "BLW + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.emapis-seilbahnen", attributionUrl: "ch.blw.kt.url", timeBehaviour: "last", tooltip: !0, label: "Seilbahnen", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "ech,emapis,inspire,wms-bgdi_prod" },
            "ch.bafu.gewaesserschutz-chemischer_zustand_doc": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bafu.gewaesserschutz-chemischer_zustand_doc", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !0, serverLayerName: "ch.bafu.gewaesserschutz-chemischer_zustand_doc", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "all", tooltip: !0, label: "Gelöster organ. Kohlenstoff (DOC)", singleTile: !0, highlightable: !0, background: !1, timestamps: ["2013", "2012", "2011"], hasLegend: !0, type: "wms", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.blw.bodeneignung-wasserdurchlaessigkeit": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.bodeneignung-wasserdurchlaessigkeit", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Wasserdurchlässigkeit", highlightable: !0, background: !1, timestamps: ["20120601"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.swissprtr": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.swissprtr", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Schadstoff-Freisetzungen (SwissPRTR)", highlightable: !0, background: !1, timestamps: ["20150226"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,kgs,swissmaponline,wms-naz" },
            "ch.bafu.ren-wald": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.ren-wald", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "REN  Wald", highlightable: !0, background: !1, timestamps: ["20110214"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.swissnames3d_wmts": { attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", type: "wmts", serverLayerName: "ch.swisstopo.swissnames3d", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "ch.swisstopo.swissnames3d_wmts", highlightable: !0, background: !1, parentLayerId: "ch.swisstopo.swissnames3d", timestamps: ["20160101", "20150101"], hasLegend: !1, topics: "api,ech,inspire,swisstopo,wms-bgdi_prod,wms-naz", timeEnabled: !1, resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5], minResolution: 1.2 },
            "ch.blw.gewaesseranschlusskarte-direkt": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.gewaesseranschlusskarte-direkt", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Gewässeranschluss erweitert", highlightable: !0, background: !1, timestamps: ["20121201"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.bakom.uplink1": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.uplink1", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Upload ≥ 1 Mbit/s", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.bfe.windenergie-geschwindigkeit_h100": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BFE", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfe.windenergie-geschwindigkeit_h100", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Windgeschwindigkeit 100 m Höhe", wmsLayers: "ch.bfe.windenergie-geschwindigkeit_h100", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,energie,inspire,wms-bgdi_prod" },
            "ch.bav.haltestellen-oev": { opacity: 1, attribution: "BAV", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bav.haltestellen-oev", attributionUrl: "http://www.bav.admin.ch/?lang=de", timeBehaviour: "last", tooltip: !0, label: "öV-Haltestellen", highlightable: !0, background: !1, timestamps: ["20151213", "20150127"], hasLegend: !0, queryableAttributes: ["id", "name"], topics: "api,ech,inspire,kgs,schneesport,wms-bgdi_prod" },
            "ch.astra.ivs-nat_wegbegleiter": { attribution: "ASTRA", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.astra.ivs-nat_wegbegleiter", attributionUrl: "http://www.astra.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "IVS Wegbegleiter", highlightable: !0, background: !1, timestamps: ["20151231", "20100414"], hasLegend: !0, type: "wmts", topics: "api,astra,ech,inspire,ivs,wms-bgdi_prod" },
            "ch.swisstopo-vd.geometa-standav_wmstile": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "Amtliche Vermessung Schweiz", chargeable: !1, searchable: !1, format: "png", serverLayerName: "ch.swisstopo-vd.geometa-standav", attributionUrl: "http://www.cadastre.ch", timeBehaviour: "last", tooltip: !1, label: "ch.swisstopo-vd.geometa-standav_wmstile", wmsLayers: "ch.swisstopo-vd.geometa-standav", singleTile: !1, highlightable: !0, background: !1, parentLayerId: "ch.swisstopo-vd.geometa-standav", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod", hasLegend: !0, type: "wms", timeEnabled: !1, minResolution: 20 },
            "ch.swisstopo.transformation-bezugsrahmen_hoehe": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.swisstopo.transformation-bezugsrahmen_hoehe", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "HTRANS LHN95-LN02", wmsLayers: "ch.swisstopo.transformation-bezugsrahmen_hoehe", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["name"], topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.bazl.luftfahrtkarten-icao": { shop: ["mapsheet"], attribution: "BAZL", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bazl.luftfahrtkarten-icao", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Luftfahrtkarte ICAO", highlightable: !0, background: !1, timestamps: ["20160331"], hasLegend: !0, queryableAttributes: ["release"], topics: "api,aviation,ech,inspire,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10] },
            "ch.swisstopo-vd.geometa-grundbuch": { opacity: .75, attribution: "Amtliche Vermessung Schweiz", searchable: !1, subLayersIds: ["ch.swisstopo-vd.geometa-grundbuch_wmstile", "ch.swisstopo-vd.geometa-grundbuch_wms"], timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.geometa-grundbuch", attributionUrl: "http://www.cadastre.ch", timeBehaviour: "last", tooltip: !0, label: "Grundbuchinformationen", chargeable: !1, highlightable: !0, background: !1, hasLegend: !0, type: "aggregate", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bafu.showme-kantone_lawinen": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.showme-kantone_lawinen", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ShowMe Kantone: Lawinen", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2] },
            "ch.bafu.gewaesserschutz-chemischer_zustand_ammonium": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bafu.gewaesserschutz-chemischer_zustand_ammonium", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !0, serverLayerName: "ch.bafu.gewaesserschutz-chemischer_zustand_ammonium", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "all", tooltip: !0, label: "Ammonium", singleTile: !0, highlightable: !0, background: !1, timestamps: ["2013", "2012", "2011"], hasLegend: !0, type: "wms", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.swisstopo.geologie-grundwasservorkommen_papier.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", shop: ["mapsheet"], attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-grundwasservorkommen_papier.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "ch.swisstopo.geologie-grundwasservorkommen_papier.metadata", wmsLayers: "ch.swisstopo.geologie-grundwasservorkommen_papier.metadata", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bafu.hydrologie-daueruntersuchung_fliessgewaesser": { attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.hydrologie-daueruntersuchung_fliessgewaesser", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Messstandorte Gewässerzustand Bund", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, queryableAttributes: ["name", "einzugsgebietsflaeche", "betriebsbeginn", "vergletscherung", "stationierung", "mittlerehoehe", "hoehe", "flussgebiet"], topics: "api,bafu,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo-vd.geometa-grundbuch_wmstile": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "Amtliche Vermessung Schweiz", chargeable: !1, searchable: !1, format: "png", serverLayerName: "ch.swisstopo-vd.geometa-grundbuch", attributionUrl: "http://www.cadastre.ch", timeBehaviour: "last", tooltip: !1, label: "ch.swisstopo-vd.geometa-grundbuch_wmstile", wmsLayers: "ch.swisstopo-vd.geometa-grundbuch", singleTile: !1, highlightable: !0, background: !1, parentLayerId: "ch.swisstopo-vd.geometa-grundbuch", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod", hasLegend: !0, type: "wms", timeEnabled: !1, minResolution: 20 },
            "ch.bafu.hydroweb-messstationen_grundwasser": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.hydroweb-messstationen_grundwasser", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Grundwasserstände/Quellschüttungen", styleUrl: "//mf-chsdi3.dev.bgdi.ch/mom_update_ol3/static/vectorStyles/ch.bafu.hydroweb-messstationen_grundwasser.json", geojsonUrl: "https://data.geo.admin.ch/ch.bafu.hydroweb-messstationen_grundwasser/ch.bafu.hydroweb-messstationen_grundwasser_de.json", background: !1, updateDelay: 18e5, hasLegend: !1, type: "geojson", topics: "api,bafu,ech,geol,gewiss,inspire,swissmaponline,wms-bgdi_prod", highlightable: !0 },
            "ch.swisstopo.pixelkarte-grau_wmts": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "jpeg", type: "wmts", serverLayerName: "ch.swisstopo.pixelkarte-grau", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "ch.swisstopo.pixelkarte-grau_wmts", highlightable: !0, background: !0, parentLayerId: "ch.swisstopo.pixelkarte-grau", timestamps: ["current"], hasLegend: !0, topics: "api,swissmaponline,wms-naz,wms-swisstopowms_prod", timeEnabled: !1, resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, .5, .25], minResolution: 1.5 },
            "ch.bakom.radio-fernsehsender": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bakom.radio-fernsehsender", gutter: 25, attribution: "BAKOM", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bakom.radio-fernsehsender", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Radio- und Fernsehsender", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["code", "name"], topics: "api,ech,funksender,inspire,wms-bgdi_prod" },
            "ch.blw.ursprungsbezeichnungen-pflanzen": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.ursprungsbezeichnungen-pflanzen", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "GUB Pflanzliche Produkte", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.astra.nationalstrassenachsen": { attribution: "ASTRA", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.astra.nationalstrassenachsen", attributionUrl: "http://www.astra.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "ch.astra.nationalstrassenachsen", highlightable: !0, background: !1, timestamps: ["20160707"], hasLegend: !0, type: "wmts", topics: "api,astra,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.laerm-bahnlaerm_nacht": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.laerm-bahnlaerm_nacht", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Eisenbahnlärm Nacht", highlightable: !0, background: !1, timestamps: ["20111231", "20061231"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.sturm-boeenspitzen_50": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.sturm-boeenspitzen_50", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Sturmgefährdung Böenspitzen 50", highlightable: !0, background: !1, timestamps: ["20141107"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.ren-trockenstandorte": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.ren-trockenstandorte", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "REN  Trockenstandort", highlightable: !0, background: !1, timestamps: ["20110214"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.astra.ausnahmetransportrouten": { attribution: "ASTRA", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.astra.ausnahmetransportrouten", attributionUrl: "http://www.astra.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Ausnahmetransportrouten", highlightable: !0, background: !1, timestamps: ["20160713", "20150211"], hasLegend: !0, type: "wmts", topics: "api,astra,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.vec25-heckenbaeume": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec25-heckenbaeume", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Hecken und Bäume VECTOR25", highlightable: !0, background: !1, timestamps: ["19980101"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo" },
            "ch.swisstopo.swissboundaries3d-land-flaeche.fill": { attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.swissboundaries3d-land-flaeche.fill", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Landesgrenzen", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,are,blw,ech,energie,funksender,gewiss,inspire,ivs,kgs,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.astra.wanderland": { attribution: "ASTRA + Kanton", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.astra.wanderland", attributionUrl: "ch.astra.kt.url", timeBehaviour: "last", tooltip: !0, label: "Wanderland", highlightable: !0, background: !1, timestamps: ["20160518"], hasLegend: !0, type: "wmts", topics: "api,astra,ech,inspire,kgs" },
            "ch.bav.schienennetz": { opacity: 1, attribution: "BAV", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bav.schienennetz", attributionUrl: "http://www.bav.admin.ch/?lang=de", timeBehaviour: "last", tooltip: !0, label: "Schienennetz", highlightable: !0, background: !1, timestamps: ["20151213"], hasLegend: !0, queryableAttributes: ["nom_point", "nom_segment", "numero", "abreviation"], topics: "api,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.geoidmodell-etrs89": { opacity: .75, attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geoidmodell-etrs89", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Geoidmodell in ETRS89", highlightable: !0, background: !1, timestamps: ["20041231"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.pixelkarte-farbe-pk100.noscale": { shop: ["mapsheet", "district", "canton", "rectangle", "whole"], attribution: "swisstopo", chargeable: !0, searchable: !1, format: "jpeg", timeEnabled: !1, serverLayerName: "ch.swisstopo.pixelkarte-farbe-pk100.noscale", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Landeskarte 1:100'000 | LK100", highlightable: !1, background: !1, timestamps: ["current", "20151231"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo" },
            "ch.bafu.showme-gemeinden_rutschungen": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.showme-gemeinden_rutschungen", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ShowMe Gemeinden: Rutschungen", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2] },
            "ch.bafu.gewaesserschutz-biologischer_zustand_diatomeen": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bafu.gewaesserschutz-biologischer_zustand_diatomeen", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !0, serverLayerName: "ch.bafu.gewaesserschutz-biologischer_zustand_diatomeen", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "all", tooltip: !0, label: "Kieselalgen (Diatomeen)", singleTile: !0, highlightable: !0, background: !1, timestamps: ["2013", "2012", "2011"], hasLegend: !0, type: "wms", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.bafu.gewaesserschutz-chemischer_zustand_phosphat": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bafu.gewaesserschutz-chemischer_zustand_phosphat", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !0, serverLayerName: "ch.bafu.gewaesserschutz-chemischer_zustand_phosphat", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "all", tooltip: !0, label: "Phosphat", singleTile: !0, highlightable: !0, background: !1, timestamps: ["2013", "2012", "2011"], hasLegend: !0, type: "wms", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.blw.emapis-bewaesserung": { wmsUrl: "//wms-bod.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.blw.emapis-bewaesserung", gutter: 30, attribution: "BLW + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.emapis-bewaesserung", attributionUrl: "ch.blw.kt.url", timeBehaviour: "last", tooltip: !0, label: "Bewässerung", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "ech,emapis,inspire,wms-bgdi_prod" },
            "ch.bafu.hydroweb-messstationen_vorhersage": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.hydroweb-messstationen_vorhersage", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Hydrol. Stationen Vorhersagen", styleUrl: "//mf-chsdi3.dev.bgdi.ch/mom_update_ol3/static/vectorStyles/ch.bafu.hydroweb-messstationen_vorhersage.json", geojsonUrl: "https://data.geo.admin.ch/ch.bafu.hydroweb-messstationen_vorhersage/ch.bafu.hydroweb-messstationen_vorhersage_de.json", background: !1, updateDelay: 3e5, hasLegend: !1, type: "geojson", topics: "api,bafu,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod", highlightable: !0 },
            "ch.swisstopo.geologie-geologische_karte": { attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geologische_karte", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Geologie 500", highlightable: !0, background: !1, timestamps: ["20080630"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,geothermie,gewiss,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.bfe.sachplan-geologie-tiefenlager": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, gutter: 25, attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bfe.sachplan-geologie-tiefenlager", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "SP Geologische Tiefenlager", wmsLayers: "ch.bfe.sachplan-geologie-tiefenlager", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["facname_de"], topics: "api,ech,energie,geol,geothermie,inspire,kgs,sachplan,wms-bgdi_prod" },
            "ch.are.gemeindetypen": { opacity: .6, attribution: "ARE", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.are.gemeindetypen", attributionUrl: "http://www.are.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Gemeindetypologie ARE", highlightable: !0, background: !1, timestamps: ["20140101"], hasLegend: !0, type: "wmts", topics: "api,are,ech,geothermie,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.hydrologie-hochwasserstatistik": { attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.hydrologie-hochwasserstatistik", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Hochwasserstatistik", highlightable: !0, background: !1, timestamps: ["20140101"], hasLegend: !0, queryableAttributes: ["name"], topics: "api,bafu,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bfe.bikesharing_from_zoom4": { topics: "api,ech,energie,inspire,wms-bgdi_prod", attribution: "BFE", chargeable: !1, searchable: !1, format: "png", serverLayerName: "ch.bfe.bikesharing", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ch.bfe.bikesharing_from_zoom4", styleUrl: "//mf-chsdi3.dev.bgdi.ch/mom_update_ol3/static/vectorStyles/ch.bfe.bikesharing_from_zoom4.json", geojsonUrl: "https://mf-chsdi3.dev.bgdi.ch/~ltfrr/bikesharing/bikesharing_de.json", background: !1, parentLayerId: "ch.bfe.bikesharing", maxResolution: 100, hasLegend: !0, minResolution: 0, type: "geojson", timeEnabled: !1, highlightable: !0 },
            "ch.bazl.laermbelastungskataster-zivilflugplaetze_kleinluftfahrzeuge": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BAZL", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bazl.laermbelastungskataster-zivilflugplaetze_kleinluftfahrzeuge", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Lärmbelastung Kleinluftfahrzeuge", wmsLayers: "ch.bazl.laermbelastungskataster-zivilflugplaetze_kleinluftfahrzeuge", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.bazl.laermbelastungskataster-zivilflugplaetze_klein-grossflugzeuge": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BAZL", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bazl.laermbelastungskataster-zivilflugplaetze_klein-grossflugzeuge", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Lärmbelast. Klein- / Grossflugzeuge", wmsLayers: "ch.bazl.laermbelastungskataster-zivilflugplaetze_klein-grossflugzeuge", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.bazl.sicherheitszonenplan": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, gutter: 15, attribution: "BAZL", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bazl.sicherheitszonenplan", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Sicherheitszonenplan", wmsLayers: "ch.bazl.sicherheitszonenplan", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,kgs,wms-bgdi_prod" },
            "ch.bfe.energieforschung": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bfe.energieforschung", gutter: 25, attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bfe.energieforschung", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Cleantech-Projekte", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["projektnummer", "titel"], topics: "api,ech,energie,inspire,wms-bgdi_prod" },
            "ch.bafu.hydrologischer-atlas_bilanzgebiete": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.hydrologischer-atlas_bilanzgebiete", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Bilanzgebiet", highlightable: !0, background: !1, timestamps: ["20040101"], hasLegend: !0, queryableAttributes: ["shape_area", "name", "flussgebiet"], topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.bafu.wasser-entnahme": { attribution: "BAFU + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.wasser-entnahme", attributionUrl: "ch.bafu.kt.url", timeBehaviour: "last", tooltip: !0, label: "Wasserentnahme", highlightable: !0, background: !1, timestamps: ["20040101"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,energie,gewiss,inspire,swissmaponline" },
            "ch.bafu.hydroweb-warnkarte_regional": {
                opacity: .75,
                attribution: "BAFU",
                chargeable: !1,
                searchable: !1,
                format: "png",
                timeEnabled: !1,
                serverLayerName: "ch.bafu.hydroweb-warnkarte_regional",
                attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de",
                timeBehaviour: "last",
                tooltip: !0,
                label: "Warnkarte regionale Flüsse",
                styleUrl: "//mf-chsdi3.dev.bgdi.ch/mom_update_ol3/static/vectorStyles/ch.bafu.hydroweb-warnkarte_regional.json",
                geojsonUrl: "https://data.geo.admin.ch/ch.bafu.hydroweb-warnkarte_regional/ch.bafu.hydroweb-warnkarte_regional_de.json",
                background: !1,
                updateDelay: 72e5,
                hasLegend: !1,
                type: "geojson",
                topics: "api,bafu,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod",
                highlightable: !0
            },
            "ch.swisstopo-vd.geometa-gemeinde_wms": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", chargeable: !1, searchable: !1, timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.geometa-gemeinde", highlightable: !0, parentLayerId: "ch.swisstopo-vd.geometa-gemeinde", minResolution: 0, attributionUrl: "http://www.cadastre.ch", tooltip: !1, label: "ch.swisstopo-vd.geometa-gemeinde_wms", singleTile: !1, type: "wms", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod", opacity: .75, attribution: "Amtliche Vermessung Schweiz", format: "png", background: !1, maxResolution: 20, wmsLayers: "ch.swisstopo-vd.geometa-gemeinde", gutter: 15, timeBehaviour: "last", hasLegend: !0 },
            "ch.swisstopo.pixelkarte-grau": { attribution: "swisstopo", searchable: !1, subLayersIds: ["ch.swisstopo.pixelkarte-grau_wmts", "ch.swisstopo.landeskarte-grau-10_wmts"], timeEnabled: !1, serverLayerName: "ch.swisstopo.pixelkarte-grau", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Landeskarten (grau)", chargeable: !0, highlightable: !0, background: !0, hasLegend: !1, config3d: "ch.swisstopo.swisstlm3d-karte-grau_3d", type: "aggregate", topics: "api,swissmaponline,wms-naz,wms-swisstopowms_prod" },
            "ch.swisstopo.hiks-siegfried": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.hiks-siegfried", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Siegfriedkarte Erstausgabe", highlightable: !0, background: !1, timestamps: ["19260101"], hasLegend: !1, type: "wmts", topics: "api,ech,inspire,ivs,kgs,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.blw.klimaeignung-zwischenfruchtbau": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.klimaeignung-zwischenfruchtbau", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Klimaeignung Zwischenfruchtbau", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.gewaesserschutz-chemischer_zustand_nitrit": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bafu.gewaesserschutz-chemischer_zustand_nitrit", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !0, serverLayerName: "ch.bafu.gewaesserschutz-chemischer_zustand_nitrit", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "all", tooltip: !0, label: "Nitrit", singleTile: !0, highlightable: !0, background: !1, timestamps: ["2013", "2012", "2011"], hasLegend: !0, type: "wms", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.bfs.arealstatistik-1985": { opacity: .75, attribution: "BFS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfs.arealstatistik-1985", attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", timeBehaviour: "last", tooltip: !0, label: "Arealstatistik 1979/85 NOAS04", highlightable: !0, background: !1, timestamps: ["20131121"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline" },
            "ch.swisstopo.koordinatenaenderung": { opacity: .75, attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.koordinatenaenderung", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "LV95 Koordinatenänderung", highlightable: !0, background: !1, timestamps: ["20061231"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.blw.ursprungsbezeichnungen-konditoreiwaren": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.ursprungsbezeichnungen-konditoreiwaren", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "GGA Konditoreiware", highlightable: !0, background: !1, timestamps: ["20150306"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.blw.bodeneignung-vernaessung": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.bodeneignung-vernaessung", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Vernässung", highlightable: !0, background: !1, timestamps: ["20120601"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo-vd.geometa-nfgeom": { opacity: .75, attribution: "Amtliche Vermessung Schweiz", searchable: !1, subLayersIds: ["ch.swisstopo-vd.geometa-nfgeom_wmstile", "ch.swisstopo-vd.geometa-nfgeom_wms"], timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.geometa-nfgeom", attributionUrl: "http://www.cadastre.ch", timeBehaviour: "last", tooltip: !0, label: "Nachführungsgeometer/in", chargeable: !1, highlightable: !0, background: !1, hasLegend: !0, type: "aggregate", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bakom.versorgungsgebiet-tv": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bakom.versorgungsgebiet-tv", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Versorgungsgebiete TV", highlightable: !0, background: !1, timestamps: ["20070704"], hasLegend: !0, queryableAttributes: ["prog"], topics: "api,ech,funksender,inspire,wms-bgdi_prod" },
            "ch.bfe.windenergie-geschwindigkeit_h50": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "BFE", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfe.windenergie-geschwindigkeit_h50", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Windgeschwindigkeit 50 m Höhe", wmsLayers: "ch.bfe.windenergie-geschwindigkeit_h50", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,energie,inspire,wms-bgdi_prod" },
            "ch.bafu.laerm-strassenlaerm_nacht": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.laerm-strassenlaerm_nacht", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Strassenverkehrslärm Nacht", highlightable: !0, background: !1, timestamps: ["20101231"], hasLegend: !0, type: "wmts", topics: "api,astra,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.showme-gemeinden_lawinen": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.showme-gemeinden_lawinen", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ShowMe Gemeinden : Lawinen", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2] },
            "ch.swisstopo.geologie-geowege": { attribution: "swisstopo, scnat", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geowege", attributionUrl: "ch.swisstopo.scnat.url", timeBehaviour: "last", tooltip: !0, label: "Geologische Wanderwege", highlightable: !0, background: !1, timestamps: ["20120903"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,wms-bgdi_prod" },
            "ch.swisstopo.vec25-primaerflaechen": { opacity: .75, attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec25-primaerflaechen", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Primärflächen VECTOR25", highlightable: !0, background: !1, timestamps: ["20090401"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo,wms-naz" },
            "ch.astra.ivs-reg_loc": { attribution: "ASTRA + Kanton", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.astra.ivs-reg_loc", attributionUrl: "ch.astra.kt.url", timeBehaviour: "last", tooltip: !0, label: "IVS Regional und Lokal", highlightable: !0, background: !1, timestamps: ["20151231", "20100416"], hasLegend: !0, queryableAttributes: ["ivs_slaname", "ivs_signatur", "ivs_nummer"], topics: "api,astra,blw,ech,energie,inspire,ivs,kgs,sachplan,swissmaponline,wms-bgdi_prod,wms-naz" },
            "ch.bafu.schutzgebiete-paerke_nationaler_bedeutung_perimeter": { opacity: .85, attribution: "BAFU + Kanton", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.schutzgebiete-paerke_nationaler_bedeutung_perimeter", attributionUrl: "ch.bafu.kt.url", timeBehaviour: "last", tooltip: !0, label: "Pärke (Perimeter)", highlightable: !0, background: !1, timestamps: ["20160301"], hasLegend: !0, type: "wmts", topics: "api,bafu,blw,ech,inspire,kgs,sachplan,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2] },
            "ch.bafu.gewaesserschutz-badewasserqualitaet": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.gewaesserschutz-badewasserqualitaet", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Badegewässerqualität", highlightable: !0, background: !1, timestamps: ["20141231"], hasLegend: !0, queryableAttributes: ["rbdsuname", "bwname", "groupid", "bwatercat", "qualitaet_ch", "nwunitname", "gemeinde", "canton", "id"], topics: "api,bafu,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bakom.anschlussart-koaxialkabel": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.anschlussart-koaxialkabel", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Koaxial-Kabel", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.bafu.gewaesserschutz-biologischer_zustand_fische": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bafu.gewaesserschutz-biologischer_zustand_fische", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !0, serverLayerName: "ch.bafu.gewaesserschutz-biologischer_zustand_fische", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "all", tooltip: !0, label: "Fische", singleTile: !0, highlightable: !0, background: !1, timestamps: ["2013", "2012", "2011"], hasLegend: !0, type: "wms", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.swisstopo.hiks-dufour.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", shop: ["mapsheet"], attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.hiks-dufour.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "ch.swisstopo.hiks-dufour.metadata", wmsLayers: "ch.swisstopo.hiks-dufour.metadata", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bfe.energiestaedte-2000watt-areale": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bfe.energiestaedte-2000watt-areale", gutter: 25, attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bfe.energiestaedte-2000watt-areale", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "2000-Watt-Areale", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["name"], topics: "api,ech,energie,inspire,wms-bgdi_prod" },
            "ch.bazl.segelflugkarte": { shop: ["mapsheet"], attribution: "BAZL", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bazl.segelflugkarte", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Segelflugkarte", highlightable: !0, background: !1, timestamps: ["20160331"], hasLegend: !0, queryableAttributes: ["release"], topics: "api,aviation,ech,inspire,swisstopo,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10] },
            "ch.swisstopo.geologie-spezialkarten_schweiz.metadata": { opacity: .75, attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-spezialkarten_schweiz.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Geologische Spezialkarten", highlightable: !0, background: !1, timestamps: ["20110101"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.blw.klimaeignung-getreidebau": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.klimaeignung-getreidebau", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Klimaeignung Getreidebau", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.hydrologie-messstationen_gefahren": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.hydrologie-messstationen_gefahren", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Hochwasser Gefahrenstufen 24h", styleUrl: "//mf-chsdi3.dev.bgdi.ch/mom_update_ol3/static/vectorStyles/ch.bafu.hydrologie-messstationen_gefahren.json", geojsonUrl: "https://data.geo.admin.ch/ch.bafu.hydrologie-messstationen_gefahren/ch.bafu.hydroweb-messstationen_gefahren_24h_de.json", background: !1, updateDelay: 6e4, hasLegend: !0, type: "geojson", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod", highlightable: !0 },
            "ch.swisstopo.swissboundaries3d-bezirk-flaeche.fill": { attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.swisstopo.swissboundaries3d-bezirk-flaeche.fill", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Bezirksgrenzen", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, queryableAttributes: ["name"], topics: "api,are,blw,ech,energie,funksender,gewiss,inspire,kgs,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.blw.erosion-mit_bergzonen": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.erosion-mit_bergzonen", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Erosionsrisiko qualitativ 2", highlightable: !0, background: !1, timestamps: ["20100103"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bazl.projektierungszonen-flughafenanlagen": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, gutter: 20, attribution: "BAZL", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bazl.projektierungszonen-flughafenanlagen", attributionUrl: "https://www.bazl.admin.ch/bazl/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Projektierungszonen: Flughäfen", wmsLayers: "ch.bazl.projektierungszonen-flughafenanlagen", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.vec200-names-namedlocation": { attribution: "swisstopo", chargeable: !0, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.swisstopo.vec200-names-namedlocation", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Namen VECTOR200", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, queryableAttributes: ["id", "objname1"], topics: "api,ech,inspire,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.swisstopo.geologie-geodaesie-isostatische_anomalien": { attribution: "swisstopo, sgpk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geodaesie-isostatische_anomalien", attributionUrl: "ch.swisstopo.sgpk.url", timeBehaviour: "last", tooltip: !0, label: "Isostatische Anomalien 500", highlightable: !0, background: !1, timestamps: ["19791231"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.lubis-luftbilder-dritte-firmen": { attribution: "swisstopo, Prv.", chargeable: !1, searchable: !0, format: "png", timeEnabled: !0, type: "wmts", serverLayerName: "ch.swisstopo.lubis-luftbilder-dritte-firmen", attributionUrl: "ch.swisstopo.private.url", timeBehaviour: "last", tooltip: !0, label: "Luftbilder Privater", highlightable: !0, background: !1, timestamps: ["99991231", "20091231", "20081231", "20071231", "20061231", "20051231", "20041231", "20031231", "20021231", "20011231", "20001231", "19991231", "19981231", "19971231", "19961231", "19951231", "19941231", "19931231", "19921231", "19911231", "19901231", "19891231"], hasLegend: !0, queryableAttributes: ["bgdi_flugjahr", "ort", "id", "filmart"], topics: "api,ech,geol,luftbilder,wms-bgdi_prod" },
            "ch.are.alpenkonvention": { opacity: .75, attribution: "ARE", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.are.alpenkonvention", attributionUrl: "http://www.are.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Alpenkonvention", highlightable: !0, background: !1, timestamps: ["20090101"], hasLegend: !0, type: "wmts", topics: "api,are,ech,inspire,kgs,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.neophyten-riesenbaerenklau": { opacity: .75, wmsLayers: "", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.neophyten-riesenbaerenklau", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Riesenbärenklau", highlightable: !0, background: !1, timestamps: ["20140825"], hasLegend: !1, type: "wmts", topics: "api,bafu,ech,inspire,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5] },
            "ch.blw.klimaeignung-futterbau": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.klimaeignung-futterbau", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Klimaeignung Futterbau", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.hydrogeologische-karte_100": { wmsLayers: "", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.hydrogeologische-karte_100", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Hydrogeologische Karte 100", highlightable: !0, background: !1, timestamps: ["20141231"], hasLegend: !0, queryableAttributes: ["pdf_list", "name"], topics: "api,bafu,ech,geol,gewiss,inspire,wms-bgdi_prod" },
            "ch.bfe.solarenergie-eignung-daecher_wms": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bfe.solarenergie-eignung-daecher", gutter: 5, attribution: "BFE", chargeable: !1, searchable: !1, format: "png", serverLayerName: "ch.bfe.solarenergie-eignung-daecher", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ch.bfe.solarenergie-eignung-daecher_wms", singleTile: !1, topics: "api,ech,energie,inspire,swissmaponline,wms-bgdi_prod", highlightable: !0, background: !1, parentLayerId: "ch.bfe.solarenergie-eignung-daecher", maxResolution: .5, hasLegend: !0, type: "wms", timeEnabled: !1 },
            "ch.swisstopo.swisstlm3d-karte-farbe": { shop: ["commune", "district", "canton", "rectangle", "whole"], attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.swisstlm3d-karte-farbe", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Karte swissTLM (farbig)", highlightable: !1, background: !1, timestamps: ["current", "20150401"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, .5, .25] },
            "ch.swisstopo.landesschwerenetz": { attribution: "ch.swisstopo.atlas", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.swisstopo.landesschwerenetz", attributionUrl: "ch.swisstopo.atlas.url", timeBehaviour: "last", tooltip: !0, label: "Schweregrundnetz", highlightable: !0, background: !1, timestamps: ["20150731"], hasLegend: !0, queryableAttributes: ["type", "name", "nr_lsn2004"], topics: "api,ech,geol,inspire,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geophysik-geothermie": { attribution: "swisstopo, sgpk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geophysik-geothermie", attributionUrl: "ch.swisstopo.sgpk.url", timeBehaviour: "last", tooltip: !0, label: "Wärmestromdichte 500", highlightable: !0, background: !1, timestamps: ["20111121"], hasLegend: !0, type: "wmts", topics: "api,ech,energie,geol,geothermie,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo-vd.geometa-grundbuch_wms": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", chargeable: !1, searchable: !1, timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.geometa-grundbuch", highlightable: !0, parentLayerId: "ch.swisstopo-vd.geometa-grundbuch", minResolution: 0, attributionUrl: "http://www.cadastre.ch", tooltip: !1, label: "ch.swisstopo-vd.geometa-grundbuch_wms", singleTile: !1, type: "wms", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod", opacity: .75, attribution: "Amtliche Vermessung Schweiz", format: "png", background: !1, maxResolution: 20, wmsLayers: "ch.swisstopo-vd.geometa-grundbuch", gutter: 15, timeBehaviour: "last", hasLegend: !0 },
            "ch.bafu.sturm-boeenspitzen_100": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.sturm-boeenspitzen_100", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Sturmgefährdung Böenspitzen 100", highlightable: !0, background: !1, timestamps: ["20141107"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.hangneigung-ueber_30": { opacity: .75, attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.hangneigung-ueber_30", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Hangneigungsklassen ab 30°", highlightable: !0, background: !1, timestamps: ["20130101"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,gewiss,inspire,kgs,schneesport,swisstopo,wms-naz,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.bafu.schutzgebiete-schweizerischer_nationalpark": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.schutzgebiete-schweizerischer_nationalpark", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Nationalpark", highlightable: !0, background: !1, timestamps: ["20010117"], hasLegend: !0, type: "wmts", topics: "api,bafu,blw,ech,geothermie,inspire,kgs,sachplan,swissmaponline,wms-bgdi_prod,wms-naz" },
            "ch.swisstopo.swissimage": { attribution: "CNES, Spot Image, swisstopo, NPOC", chargeable: !0, searchable: !1, format: "jpeg", timeEnabled: !1, serverLayerName: "ch.swisstopo.swissimage", attributionUrl: "http://www.swisstopo.admin.ch/internet/swisstopo/de/home.html", timeBehaviour: "last", tooltip: !1, label: "SWISSIMAGE", highlightable: !0, background: !0, timestamps: ["current", "20151231", "20140620", "20131107", "20130916", "20130422", "20120809", "20120225", "20110914"], hasLegend: !1, type: "wmts", topics: "api,swissmaponline", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, .5, .25] },
            "ch.swisstopo.vec25-anlagen": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec25-anlagen", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Anlagen VECTOR25", highlightable: !0, background: !1, timestamps: ["20090401"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo,wms-naz" },
            "ch.bafu.showme-kantone_sturzprozesse": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.showme-kantone_sturzprozesse", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ShowMe Kantone: Sturzprozesse", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2] },
            "ch.bakom.versorgungsgebiet-ukw": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bakom.versorgungsgebiet-ukw", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Versorgungsgebiete Radio", highlightable: !0, background: !1, timestamps: ["20070704"], hasLegend: !0, queryableAttributes: ["prog"], topics: "api,ech,funksender,inspire,wms-bgdi_prod" },
            "ch.swisstopo.geologie-tektonische_karte_papier.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", shop: ["mapsheet"], attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-tektonische_karte_papier.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "ch.swisstopo.geologie-tektonische_karte_papier.metadata", wmsLayers: "ch.swisstopo.geologie-tektonische_karte_papier.metadata", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.hiks-dufour": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.hiks-dufour", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Dufourkarte Erstausgabe", highlightable: !0, background: !1, timestamps: ["18650101"], hasLegend: !1, type: "wmts", topics: "api,ech,inspire,ivs,kgs,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod" },
            "ch.astra.strassenverkehrszaehlung_messstellen-regional_lokal": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.astra.strassenverkehrszaehlung_messstellen-regional_lokal-status_netz,ch.astra.strassenverkehrszaehlung_messstellen-regional_lokal-typ", gutter: 15, attribution: "ASTRA + Kanton", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.astra.strassenverkehrszaehlung_messstellen-regional_lokal", attributionUrl: "ch.astra.kt.url", timeBehaviour: "last", tooltip: !0, label: "Verkehrszählung (Regional)", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["zaehlstellen_bezeichnung", "id"], topics: "api,astra,ech,inspire,wms-bgdi_prod" },
            "ch.bafu.wasser-teileinzugsgebiete_2": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.wasser-teileinzugsgebiete_2", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Teileinzugsgebiete 2km2", highlightable: !0, background: !1, timestamps: ["20121231", "20120701"], hasLegend: !0, queryableAttributes: ["ext_ezg_flussgb", "id", "gwlnr"], topics: "api,bafu,ech,gewiss,wms-bgdi_prod" },
            "ch.bfe.sachplan-uebertragungsleitungen_kraft": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bfe.sachplan-uebertragungsleitungen_kraft", gutter: 25, attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bfe.sachplan-uebertragungsleitungen_kraft", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "SP Übertragungsleitungen", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["plname_de", "facname_de"], topics: "api,ech,energie,inspire,sachplan,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geotope": { attribution: "swisstopo, scnat", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geotope", attributionUrl: "ch.swisstopo.scnat.url", timeBehaviour: "last", tooltip: !0, label: "Geotope der Schweiz", highlightable: !0, background: !1, timestamps: ["20130107"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,kgs,swissmaponline" },
            "ch.swisstopo.geologie-dosisleistung-terrestrisch": { opacity: .75, chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.swisstopo.geologie-dosisleistung-terrestrisch", timeBehaviour: "last", tooltip: !0, label: "Terrestrische Strahlung", highlightable: !0, background: !1, timestamps: ["19961231"], hasLegend: !0, queryableAttributes: ["contour"], topics: "api,ech,geol,inspire,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geophysik-aeromagnetische_karte_jura": { attribution: "swisstopo, sgpk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geophysik-aeromagnetische_karte_jura", attributionUrl: "ch.swisstopo.sgpk.url", timeBehaviour: "last", tooltip: !0, label: "Aeromagnetik Mittelland/Jura 500", highlightable: !0, background: !1, timestamps: ["19831231"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,wms-bgdi_prod" },
            "ch.swisstopo-vd.stand-oerebkataster": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, gutter: 10, attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.stand-oerebkataster", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Verfügbarkeit des ÖREB-Katasters", wmsLayers: "ch.swisstopo-vd.stand-oerebkataster", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,cadastre,ech,geothermie,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bakom.uplink100": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.uplink100", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Upload ≥ 100 Mbit/s", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.astra.mountainbikeland": { attribution: "ASTRA + Kanton", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.astra.mountainbikeland", attributionUrl: "ch.astra.kt.url", timeBehaviour: "last", tooltip: !0, label: "Mountainbikeland", highlightable: !0, background: !1, timestamps: ["20160518"], hasLegend: !0, type: "wmts", topics: "api,astra,ech,inspire,kgs" },
            "ch.swisstopo.geologie-eiszeit-lgm": {
                attribution: "swisstopo",
                chargeable: !1,
                searchable: !1,
                format: "png",
                timeEnabled: !1,
                serverLayerName: "ch.swisstopo.geologie-eiszeit-lgm",
                attributionUrl: "https://www.swisstopo.admin.ch/de/home.html",
                timeBehaviour: "last",
                tooltip: !0,
                label: "Letzteiszeitl. Max. (Vektor) 500",
                highlightable: !0,
                background: !1,
                timestamps: ["20110318"],
                hasLegend: !0,
                type: "wmts",
                topics: "api,ech,geol,inspire,swisstopo,wms-bgdi_prod"
            },
            "ch.vbs.waldschadenkarte": { wmsUrl: "http://wms-bod.dev.bgdi.ch/ltdai/", wmsLayers: "ch.vbs.waldschadenkarte", attribution: "VBS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.vbs.waldschadenkarte", attributionUrl: "http://www.vbs.admin.ch/internet/vbs/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Waldschadenkarte - Projektil", highlightable: !0, background: !1, timestamps: ["20110525"], hasLegend: !0, queryableAttributes: ["y_koord", "lokalname", "lauf_nr", "gde_name", "x_koord", "jahr_schad"], topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.bafu.oekomorphologie-f_bauwerke": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.oekomorphologie-f_bauwerke", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Ökomorphologie F - Bauwerke", highlightable: !0, background: !1, timestamps: ["20110912"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.bakom.uplink10": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.uplink10", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Upload ≥ 10 Mbit/s", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.swisstopo.lubis-luftbilder_schraegaufnahmen": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.swisstopo.lubis-luftbilder_schraegaufnahmen", gutter: 20, attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !0, type: "wms", serverLayerName: "ch.swisstopo.lubis-luftbilder_schraegaufnahmen", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "all", tooltip: !0, label: "Luftbilder swisstopo schräg", singleTile: !1, highlightable: !0, background: !1, timestamps: ["1954", "1953", "1951", "1950", "1949", "1948", "1947", "1946", "1945", "1944", "1943", "1942", "1941", "1940", "1939", "1938", "1937", "1936", "1935", "1934", "1933", "1932", "1931", "1930", "1929", "1928", "1927"], hasLegend: !0, queryableAttributes: ["bgdi_flugjahr", "medium_format", "id"], topics: "api,ech,inspire,kgs,luftbilder,swisstopo" },
            "ch.blw.emapis-wasserversorgung": { wmsUrl: "//wms-bod.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.blw.emapis-wasserversorgung", gutter: 30, attribution: "BLW + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.emapis-wasserversorgung", attributionUrl: "ch.blw.kt.url", timeBehaviour: "last", tooltip: !0, label: "Wasserversorgung", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "ech,emapis,inspire,wms-bgdi_prod" },
            "ch.bakom.verfuegbarkeit-hdtv": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.verfuegbarkeit-hdtv", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "HDTV-Verfügbarkeit Festnetz", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.bafu.bundesinventare-jagdbanngebiete": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.bundesinventare-jagdbanngebiete", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Jagdbanngebiete", highlightable: !0, background: !1, timestamps: ["20131202"], hasLegend: !0, queryableAttributes: ["jb_name"], topics: "api,are,bafu,blw,ech,energie,inspire,sachplan,swissmaponline,wms-bgdi_prod" },
            "ch.blw.niederschlagshaushalt": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.niederschlagshaushalt", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Niederschlagshaushalt", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.blw.feldblockkarte": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.feldblockkarte", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Feldblockkarte", highlightable: !0, background: !1, timestamps: ["20120601"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,wms-bgdi_prod" },
            "ch.swisstopo.swissboundaries3d-kanton-flaeche.fill": { attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.swisstopo.swissboundaries3d-kanton-flaeche.fill", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Kantonsgrenzen", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, queryableAttributes: ["ak", "id", "name"], topics: "api,are,aviation,blw,ech,energie,funksender,gewiss,inspire,ivs,kgs,sachplan,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.blw.bodeneignung-skelettgehalt": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.bodeneignung-skelettgehalt", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Skelettgehalt", highlightable: !0, background: !1, timestamps: ["20120601"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bakom.mobil-antennenstandorte-lte": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bakom.mobil-antennenstandorte-lte", gutter: 15, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.mobil-antennenstandorte-lte", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Antennenstandorte 4G (LTE)", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,funksender,inspire,kgs,wms-bgdi_prod" },
            "ch.bfs.arealstatistik-bodenbedeckung-1997": { opacity: .75, attribution: "BFS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfs.arealstatistik-bodenbedeckung-1997", attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", timeBehaviour: "last", tooltip: !0, label: "Arealstatistik 1992/97 NOLC04", highlightable: !0, background: !1, timestamps: ["20131121"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.wasser-teileinzugsgebiete_40": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.wasser-teileinzugsgebiete_40", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Teileinzugsgebiete 40km2", highlightable: !0, background: !1, timestamps: ["20120701"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,gewiss,wms-bgdi_prod" },
            "ch.blw.bergprodukte": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.bergprodukte", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Bergprodukte", highlightable: !0, background: !1, timestamps: ["20150422"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.wasser-rueckgabe": { attribution: "BAFU + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.wasser-rueckgabe", attributionUrl: "ch.bafu.kt.url", timeBehaviour: "last", tooltip: !0, label: "Wasserrückgabe", highlightable: !0, background: !1, timestamps: ["20040101"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,energie,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.swissalti3d-reliefschattierung": { shop: ["commune", "district", "canton", "rectangle", "whole"], attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.swissalti3d-reliefschattierung", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "swissALTI3D Reliefschattierung", highlightable: !1, background: !1, timestamps: ["20160101", "20150101"], hasLegend: !1, type: "wmts", topics: "api,blw,ech,energie,funksender,geol,gewiss,inspire,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5] },
            "ch.swisstopo.geologie-tektonische_karte": { attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-tektonische_karte", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Tektonik 500", highlightable: !0, background: !1, timestamps: ["20080522"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,geothermie,gewiss,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo-karto.hangneigung": { opacity: .2, attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo-karto.hangneigung", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Hangneigung ab 30°", highlightable: !0, background: !1, timestamps: ["20151202", "20081107"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,schneesport,swissmaponline,wildruhezonen", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.swisstopo.vec200-landcover": { opacity: .75, attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec200-landcover", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Prim. Bodenbedeckung VECTOR200", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo,wms-naz,wms-swisstopowms_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.swisstopo.dreiecksvermaschung": { attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.dreiecksvermaschung", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "LV95 Dreiecksvermaschung", highlightable: !0, background: !1, timestamps: ["20061231"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.blw.emapis-hochbau": { wmsUrl: "//wms-bod.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.blw.emapis-hochbau", gutter: 30, attribution: "BLW + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.emapis-hochbau", attributionUrl: "ch.blw.kt.url", timeBehaviour: "last", tooltip: !0, label: "Hochbau", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "ech,emapis,inspire,wms-bgdi_prod" },
            "ch.swisstopo-vd.geometa-los": { opacity: .75, attribution: "Amtliche Vermessung Schweiz", searchable: !1, subLayersIds: ["ch.swisstopo-vd.geometa-los_wmstile", "ch.swisstopo-vd.geometa-los_wms"], timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.geometa-los", attributionUrl: "http://www.cadastre.ch", timeBehaviour: "last", tooltip: !0, label: "Gebiete in Arbeit", chargeable: !1, highlightable: !0, background: !1, hasLegend: !0, type: "aggregate", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bafu.wasser-leitungen": { attribution: "BAFU + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.wasser-leitungen", attributionUrl: "ch.bafu.kt.url", timeBehaviour: "last", tooltip: !0, label: "Zuleitung", highlightable: !0, background: !1, timestamps: ["20040101"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.hydroweb-warnkarte_national": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.hydroweb-warnkarte_national", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Warnkarte nationale Gewässer", styleUrl: "//mf-chsdi3.dev.bgdi.ch/mom_update_ol3/static/vectorStyles/ch.bafu.hydroweb-warnkarte_national.json", geojsonUrl: "https://data.geo.admin.ch/ch.bafu.hydroweb-warnkarte_national/ch.bafu.hydroweb-warnkarte_national_de.json", background: !1, updateDelay: 72e5, hasLegend: !1, type: "geojson", topics: "api,bafu,ech,gewiss,inspire,kgs,swissmaponline,wms-bgdi_prod", highlightable: !0 },
            "ch.blw.klimaeignung-kartoffeln": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.klimaeignung-kartoffeln", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Klimaeignung Kartoffeln", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.geologie-hydrogeologische_karte-grundwasservulnerabilitaet": { attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-hydrogeologische_karte-grundwasservulnerabilitaet", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Grundwasservulnerabilität 500", highlightable: !0, background: !1, timestamps: ["20081016"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,geol,geothermie,gewiss,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.pixelkarte-farbe-pk50.noscale": { shop: ["mapsheet", "district", "canton", "rectangle", "whole"], attribution: "swisstopo", chargeable: !0, searchable: !1, format: "jpeg", timeEnabled: !1, serverLayerName: "ch.swisstopo.pixelkarte-farbe-pk50.noscale", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Landeskarte 1:50'000 | LK50", highlightable: !1, background: !1, timestamps: ["current", "20151231"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,schneesport,swissmaponline,swisstopo" },
            "ch.swisstopo.swissimage-product": { shop: ["commune", "district", "canton", "rectangle"], attribution: "swisstopo", chargeable: !0, searchable: !1, format: "jpeg", timeEnabled: !1, serverLayerName: "ch.swisstopo.swissimage-product", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "SWISSIMAGE", highlightable: !1, background: !1, timestamps: ["current", "20151231"], hasLegend: !1, config3d: "ch.swisstopo.swissimage-product_3d", type: "wmts", topics: "api,ech,inspire,luftbilder,swisstopo", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, .5, .25] },
            "ch.bfe.kleinwasserkraftpotentiale": { attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.bfe.kleinwasserkraftpotentiale", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Kleinwasserkraftpotentiale", highlightable: !0, background: !1, timestamps: ["20120531"], hasLegend: !0, type: "wmts", topics: "api,ech,energie,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.pixelkarte-farbe-pk500.noscale": { attribution: "swisstopo", chargeable: !0, searchable: !0, format: "jpeg", timeEnabled: !1, type: "wmts", serverLayerName: "ch.swisstopo.pixelkarte-farbe-pk500.noscale", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Landeskarte 1:500'000 | LK500", highlightable: !0, background: !1, timestamps: ["current", "20151231"], hasLegend: !0, queryableAttributes: ["release"], topics: "api,ech,inspire,swissmaponline,swisstopo" },
            "ch.bakom.downlink50": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.downlink50", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Download ≥ 50 Mbit/s", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.swisstopo.geologie-eiszeit-lgm-raster_papier.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", shop: ["mapsheet"], attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-eiszeit-lgm-raster_papier.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "ch.swisstopo.geologie-eiszeit-lgm-raster_papier.metadata", wmsLayers: "ch.swisstopo.geologie-eiszeit-lgm-raster_papier.metadata", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bafu.hydrologie-hydromessstationen": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.hydrologie-hydromessstationen", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Hydrologische Messstationen", highlightable: !0, background: !1, timestamps: ["20141201"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.wrz-wildruhezonen_portal": { opacity: 1, wmsLayers: "", attribution: "Kt. [BAFU]", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.wrz-wildruhezonen_portal", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Wildruhezonen", highlightable: !0, background: !1, timestamps: ["20160106", "20151103", "20150106"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,schneesport,wildruhezonen,wms-bgdi_prod" },
            "ch.bafu.permafrost": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.permafrost", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Permafrosthinweiskarte", highlightable: !0, background: !1, timestamps: ["20110317"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,geol,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.sturm-boeenspitzen_30": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.sturm-boeenspitzen_30", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Sturmgefährdung Böenspitzen 30", highlightable: !0, background: !1, timestamps: ["20141107"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.lubis-luftbilder-dritte-kantone": { attribution: "swisstopo, Kt.", chargeable: !1, searchable: !0, format: "png", timeEnabled: !0, type: "wmts", serverLayerName: "ch.swisstopo.lubis-luftbilder-dritte-kantone", attributionUrl: "http://www.swisstopo.admin.ch/internet/swisstopo/de/home/swisstopo/org/cartography.html", timeBehaviour: "last", tooltip: !0, label: "Luftbilder Kantone", highlightable: !0, background: !1, timestamps: ["99991231", "20141231", "20131231", "20121231", "20111231", "20091231", "19841231", "19671231", "19661231", "19651231", "19641231", "19631231", "19621231"], hasLegend: !0, queryableAttributes: ["bgdi_flugjahr", "ort", "id", "filmart"], topics: "api,ech,geol,luftbilder,wms-bgdi_prod" },
            "ch.bafu.bundesinventare-hochmoore": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.bundesinventare-hochmoore", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Hochmoore", highlightable: !0, background: !1, timestamps: ["20080721"], hasLegend: !0, type: "wmts", topics: "api,are,bafu,blw,ech,energie,gewiss,inspire,kgs,sachplan,swissmaponline,wms-bgdi_prod,wms-naz" },
            "ch.bakom.uplink50": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.uplink50", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Upload ≥ 50 Mbit/s", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geotechnik-gk500-gesteinsklassierung": { opacity: .75, attribution: "swisstopo, sgtk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geotechnik-gk500-gesteinsklassierung", attributionUrl: "ch.swisstopo.sgtk.url", timeBehaviour: "last", tooltip: !0, label: "Gesteinsklassen 500", highlightable: !0, background: !1, timestamps: ["20060304"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.swissnames3d": { attribution: "swisstopo", searchable: !1, subLayersIds: ["ch.swisstopo.swissnames3d_wms", "ch.swisstopo.swissnames3d_wmts"], timeEnabled: !1, serverLayerName: "ch.swisstopo.swissnames3d", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Geografische Namen swissNAMES3D", chargeable: !1, highlightable: !0, background: !1, hasLegend: !1, type: "aggregate", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod,wms-naz" },
            "ch.swisstopo.geologie-geocover.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, gutter: 15, attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.swisstopo.geologie-geocover.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Einteilung GeoCover / GA25", wmsLayers: "ch.swisstopo.geologie-geocover.metadata", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["release", "name_de", "number"], topics: "api,ech,geol,inspire,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geophysik-inklination": { attribution: "swisstopo, sgpk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geophysik-inklination", attributionUrl: "ch.swisstopo.sgpk.url", timeBehaviour: "last", tooltip: !0, label: "Inklination 500", highlightable: !0, background: !1, timestamps: ["20111128"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,geothermie,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.bafu.hydrologie-gewaesserzustandsmessstationen": { attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.hydrologie-gewaesserzustandsmessstationen", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Messstandorte Gewässerzustand CH", highlightable: !0, background: !1, timestamps: ["20130301"], hasLegend: !0, queryableAttributes: ["nr", "name", "gewaesser"], topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.vbs.armeelogistikcenter": { opacity: .75, attribution: "VBS", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.vbs.armeelogistikcenter", attributionUrl: "http://www.vbs.admin.ch/internet/vbs/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Armeelogistikcenter ALC", highlightable: !0, background: !1, timestamps: ["20150330"], hasLegend: !0, queryableAttributes: ["abkuerzung", "name"], topics: "api,ech,inspire,swissmaponline,verteidigung,wms-bgdi_prod" },
            "ch.swisstopo-vd.geometa-standav": { opacity: .75, attribution: "Amtliche Vermessung Schweiz", searchable: !1, subLayersIds: ["ch.swisstopo-vd.geometa-standav_wmstile", "ch.swisstopo-vd.geometa-standav_wms"], timeEnabled: !1, serverLayerName: "ch.swisstopo-vd.geometa-standav", attributionUrl: "http://www.cadastre.ch", timeBehaviour: "last", tooltip: !1, label: "Stand der amtlichen Vermessung", chargeable: !1, highlightable: !0, background: !1, hasLegend: !0, type: "aggregate", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.blw.landwirtschaftliche-zonengrenzen": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.landwirtschaftliche-zonengrenzen", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Landwirtschaftliche Zonengrenzen", highlightable: !0, background: !1, timestamps: ["20150708"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.astra.ivs-nat": { attribution: "ASTRA", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.astra.ivs-nat", attributionUrl: "http://www.astra.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "IVS National", highlightable: !0, background: !1, timestamps: ["20100416"], hasLegend: !0, queryableAttributes: ["ivs_slaname", "ivs_signatur", "ivs_nummer"], topics: "api,astra,blw,ech,energie,inspire,ivs,kgs,sachplan,swissmaponline,wms-bgdi_prod,wms-naz" },
            "ch.blw.erosion-quantitativ": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.erosion-quantitativ", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Erosionsrisiko quantitativ", highlightable: !0, background: !1, timestamps: ["20100601"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,kgs,wms-bgdi_prod" },
            "ch.swisstopo.swissimage-product_3d": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "jpeg", timeEnabled: !1, serverLayerName: "ch.swisstopo.swissimage-product", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "ch.swisstopo.swissimage-product_3d", highlightable: !0, background: !1, timestamps: ["current", "20151231"], hasLegend: !1, type: "wmts", topics: "api,ech,inspire,luftbilder,swisstopo" },
            "ch.bafu.hydroweb-messstationen_zustand": { attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.hydroweb-messstationen_zustand", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Lage Fliessgewässer und Seen", styleUrl: "//mf-chsdi3.dev.bgdi.ch/mom_update_ol3/static/vectorStyles/ch.bafu.hydroweb-messstationen_zustand.json", geojsonUrl: "https://data.geo.admin.ch/ch.bafu.hydroweb-messstationen_zustand/ch.bafu.hydroweb-messstationen_zustand_de.json", background: !1, updateDelay: 3e5, hasLegend: !1, type: "geojson", topics: "api,bafu,ech,gewiss,inspire,kgs,swissmaponline,wms-bgdi_prod", highlightable: !0 },
            "ch.swisstopo.swissboundaries3d-gemeinde-flaeche.fill": { attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.swisstopo.swissboundaries3d-gemeinde-flaeche.fill", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Gemeindegrenzen", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, queryableAttributes: ["gemname", "id"], topics: "api,are,aviation,blw,ech,energie,funksender,gewiss,inspire,ivs,kgs,sachplan,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.bafu.showme-gemeinden_hochwasser": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.showme-gemeinden_hochwasser", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ShowMe Gemeinden: Hochwasser", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2] },
            "ch.kantone.cadastralwebmap-farbe": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.swisstopo.swisstlm3d-karte-farbe.mapproxy,ch.kantone.cadastralwebmap-farbe", attribution: "Amtliche Vermessung Schweiz / FL", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.kantone.cadastralwebmap-farbe", attributionUrl: "http://www.cadastre.ch/internet/kataster/de/home/services/service/wms/cwm.html", timeBehaviour: "last", tooltip: !0, label: "CadastralWebMap", singleTile: !1, highlightable: !1, background: !1, hasLegend: !0, type: "wms", topics: "api,blw,cadastre,ech,energie,funksender,geol,geothermie,inspire,kgs,swissmaponline,swisstopo" },
            "ch.blw.steil_terrassenlagen_rebbau": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.steil_terrassenlagen_rebbau", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Rebflächen in Hanglagen", highlightable: !0, background: !1, timestamps: ["20121231"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.lubis-luftbilder_farbe": { shop: ["mapsheet"], attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !0, type: "wmts", serverLayerName: "ch.swisstopo.lubis-luftbilder_farbe", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Luftbilder swisstopo farbig", highlightable: !0, background: !1, timestamps: ["99991231", "20101231", "20091231", "20081231", "20071231", "20061231", "20051231", "20041231", "20031231", "20021231", "20011231", "20001231", "19991231", "19981231", "19971231", "19961231", "19951231", "19941231", "19931231", "19921231", "19911231", "19901231", "19891231", "19881231", "19871231", "19861231", "19851231", "19841231", "19831231", "19821231", "19811231"], hasLegend: !0, queryableAttributes: ["ort", "id"], topics: "api,ech,geol,luftbilder,swisstopo,wms-bgdi_prod" },
            "ch.bafu.hydrologie-wassertemperaturmessstationen": { attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.hydrologie-wassertemperaturmessstationen", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Messstationen Wassertemperatur", highlightable: !0, background: !1, timestamps: ["20141201"], hasLegend: !0, queryableAttributes: ["id", "name"], topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.blw.emapis-milchleitung": { wmsUrl: "//wms-bod.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.blw.emapis-milchleitung", gutter: 30, attribution: "BLW + Kanton", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.emapis-milchleitung", attributionUrl: "ch.blw.kt.url", timeBehaviour: "last", tooltip: !0, label: "Milchleitung", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "ech,emapis,inspire,wms-bgdi_prod" },
            "ch.swisstopo.landeskarte-grau-10_wmts": { topics: "api,ech,inspire,swisstopo,wms-swisstopowms_prod", attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", serverLayerName: "ch.swisstopo.landeskarte-grau-10", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "ch.swisstopo.landeskarte-grau-10_wmts", parentLayerId: "ch.swisstopo.pixelkarte-grau", highlightable: !1, background: !0, maxResolution: 1.5, timestamps: ["current"], hasLegend: !1, type: "wmts", timeEnabled: !1, resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, .5, .25] },
            "ch.bfs.gebaeude_wohnungs_register": { attribution: "BFS", searchable: !0, subLayersIds: ["ch.bfs.gebaeude_wohnungs_register_wms", "ch.bfs.gebaeude_wohnungs_register_wmts"], timeEnabled: !1, type: "aggregate", serverLayerName: "ch.bfs.gebaeude_wohnungs_register", attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", timeBehaviour: "last", tooltip: !0, label: "Gebäude- und Wohnungsregister", chargeable: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["gdename", "strname1", "egid", "plz4", "plzname", "deinr"], topics: "api,ech,inspire,kgs,swissmaponline" },
            "ch.swisstopo.geologie-hydrogeologische_karte-grundwasservorkommen": { attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-hydrogeologische_karte-grundwasservorkommen", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Grundwasservorkommen 500", highlightable: !0, background: !1, timestamps: ["20081103"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,geol,geothermie,gewiss,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.transformationsgenauigkeit": {
                opacity: .75,
                attribution: "swisstopo",
                chargeable: !1,
                searchable: !1,
                format: "png",
                timeEnabled: !1,
                serverLayerName: "ch.swisstopo.transformationsgenauigkeit",
                attributionUrl: "https://www.swisstopo.admin.ch/de/home.html",
                timeBehaviour: "last",
                tooltip: !0,
                label: "LV95 Transformationsgenauigkeit",
                highlightable: !0,
                background: !1,
                timestamps: ["20151101"],
                hasLegend: !0,
                type: "wmts",
                topics: "api,ech,inspire,swisstopo,wms-bgdi_prod",
                resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1]
            },
            "ch.bfe.solarenergie-eignung-daecher_wmts": { attribution: "BFE", chargeable: !1, searchable: !1, format: "png", type: "wmts", serverLayerName: "ch.bfe.solarenergie-eignung-daecher", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "ch.bfe.solarenergie-eignung-daecher_wmts", highlightable: !0, background: !1, parentLayerId: "ch.bfe.solarenergie-eignung-daecher", timestamps: ["20160613"], hasLegend: !0, topics: "api,ech,energie,inspire,swissmaponline,wms-bgdi_prod", timeEnabled: !1, minResolution: .5 },
            "ch.bakom.uplink20": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.uplink20", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Upload ≥ 20 Mbit/s", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.swisstopo.geologie-generalkarte-ggk200.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.swisstopo.geologie-generalkarte-ggk200.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Geol. Generalkarte 200", wmsLayers: "ch.swisstopo.geologie-generalkarte-ggk200.metadata", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["jahr", "nr", "titel", "author"], topics: "api,ech,geol,inspire,swisstopo,wms-bgdi_prod" },
            "ch.astra.ivs-gelaendekarte": { opacity: .75, attribution: "ASTRA", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.astra.ivs-gelaendekarte", attributionUrl: "http://www.astra.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "IVS Geländekarte", highlightable: !0, background: !1, timestamps: ["19980816"], hasLegend: !0, type: "wmts", topics: "api,astra,ech,inspire,ivs,swissmaponline,wms-bgdi_prod" },
            "org.epsg.grid_4326": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "org.epsg.grid_4326", attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "org.epsg.grid_4326", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Koordinatennetz WGS84", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,wms-bgdi_prod" },
            "ch.bafu.gewaesserschutz-chemischer_zustand_nitrat": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.bafu.gewaesserschutz-chemischer_zustand_nitrat", attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !0, serverLayerName: "ch.bafu.gewaesserschutz-chemischer_zustand_nitrat", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "all", tooltip: !0, label: "Nitrat", singleTile: !0, highlightable: !0, background: !1, timestamps: ["2013", "2012", "2011"], hasLegend: !0, type: "wms", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.bafu.hydrologie-untersuchungsgebiete": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.hydrologie-untersuchungsgebiete", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "HUG Hydro. Untersuchungsgebiete", highlightable: !0, background: !1, timestamps: ["20160111", "20130101"], hasLegend: !0, queryableAttributes: ["name", "einzugsgebietsflaeche", "max_hoe", "mit_hoe", "min_hoe", "antv_ab86", "regimtyp"], topics: "api,bafu,ech,gewiss,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.vbs.bundestankstellen-bebeco": { opacity: .75, attribution: "VBS", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.vbs.bundestankstellen-bebeco", attributionUrl: "http://www.vbs.admin.ch/internet/vbs/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Tankstellen BEBECO", highlightable: !0, background: !1, timestamps: ["20150909"], hasLegend: !0, queryableAttributes: ["strasse", "ort", "plz"], topics: "api,ech,inspire,kgs,swissmaponline,verteidigung,wms-bgdi_prod" },
            "ch.bfe.energiestaedte": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .6, gutter: 15, attribution: "BFE", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.bfe.energiestaedte", attributionUrl: "http://www.bfe.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Energiestädte", wmsLayers: "ch.bfe.energiestaedte", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["name"], topics: "api,ech,energie,inspire,wms-bgdi_prod" },
            "ch.swisstopo.geologie-geophysik-aeromagnetische_karte_schweiz": { attribution: "swisstopo, sgpk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geophysik-aeromagnetische_karte_schweiz", attributionUrl: "ch.swisstopo.sgpk.url", timeBehaviour: "last", tooltip: !0, label: "Aeromagnetik 500", highlightable: !0, background: !1, timestamps: ["20120628"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,geothermie,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.vec200-transportation-strassennetz": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec200-transportation-strassennetz", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Strassennetz VECTOR200", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,ech,geothermie,inspire,swissmaponline,swisstopo", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.swisstopo.geologie-geologischer_atlas_papier.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", shop: ["mapsheet"], attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geologischer_atlas_papier.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "ch.swisstopo.geologie-geologischer_atlas_papier.metadata", wmsLayers: "ch.swisstopo.geologie-geologischer_atlas_papier.metadata", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, type: "wms", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bfs.gebaeude_wohnungs_register_wms": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", chargeable: !1, searchable: !1, timeEnabled: !1, serverLayerName: "ch.bfs.gebaeude_wohnungs_register", highlightable: !0, parentLayerId: "ch.bfs.gebaeude_wohnungs_register", minResolution: 0, attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", tooltip: !1, label: "ch.bfs.gebaeude_wohnungs_register_wms", singleTile: !1, type: "wms", topics: "api,ech,inspire,kgs,swissmaponline", attribution: "BFS", format: "png", background: !1, maxResolution: 10, wmsLayers: "ch.bfs.gebaeude_wohnungs_register", gutter: 20, timeBehaviour: "last", hasLegend: !0 },
            "ch.swisstopo-vd.geometa-nfgeom_wmstile": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "Amtliche Vermessung Schweiz", chargeable: !1, searchable: !1, format: "png", serverLayerName: "ch.swisstopo-vd.geometa-nfgeom", attributionUrl: "http://www.cadastre.ch", timeBehaviour: "last", tooltip: !1, label: "ch.swisstopo-vd.geometa-nfgeom_wmstile", wmsLayers: "ch.swisstopo-vd.geometa-nfgeom", singleTile: !1, highlightable: !0, background: !1, parentLayerId: "ch.swisstopo-vd.geometa-nfgeom", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod", hasLegend: !0, type: "wms", timeEnabled: !1, minResolution: 20 },
            "ch.swisstopo.geologie-geotechnik-mineralische_rohstoffe200": { opacity: .75, attribution: "swisstopo, sgtk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geologie-geotechnik-mineralische_rohstoffe200", attributionUrl: "ch.swisstopo.sgtk.url", timeBehaviour: "last", tooltip: !0, label: "Mineralische Rohstoffe 200", highlightable: !0, background: !1, timestamps: ["19900101"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,wms-bgdi_prod" },
            "ch.bakom.anbieter-eigenes_festnetz": { opacity: .75, attribution: "BAKOM", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bakom.anbieter-eigenes_festnetz", attributionUrl: "https://www.bakom.admin.ch/bakom/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Anzahl Leitungsanbieter", highlightable: !0, background: !1, timestamps: ["20160622", "20151120"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,nga,wms-bgdi_prod" },
            "ch.swisstopo.vec200-landcover-wald": { opacity: .75, attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec200-landcover-wald", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Waldflächen", highlightable: !0, background: !1, timestamps: ["20160101"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,inspire,swisstopo,wms-naz", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1] },
            "ch.sgpk.maechtigkeit-lockergesteine": { opacity: .75, attribution: "swisstopo, sgpk", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.sgpk.maechtigkeit-lockergesteine", attributionUrl: "ch.swisstopo.sgpk.url", timeBehaviour: "last", tooltip: !0, label: "Mächtigkeit der Lockergesteine", highlightable: !0, background: !1, timestamps: ["20120918"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,geothermie,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo-vd.geometa-gemeinde_wmstile": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "Amtliche Vermessung Schweiz", chargeable: !1, searchable: !1, format: "png", serverLayerName: "ch.swisstopo-vd.geometa-gemeinde", attributionUrl: "http://www.cadastre.ch", timeBehaviour: "last", tooltip: !1, label: "ch.swisstopo-vd.geometa-gemeinde_wmstile", wmsLayers: "ch.swisstopo-vd.geometa-gemeinde", singleTile: !1, highlightable: !0, background: !1, parentLayerId: "ch.swisstopo-vd.geometa-gemeinde", topics: "api,cadastre,ech,inspire,swisstopo,wms-bgdi_prod", hasLegend: !0, type: "wms", timeEnabled: !1, minResolution: 20 },
            "ch.bafu.hydrologischer-atlas_flussgebiete": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wmts", serverLayerName: "ch.bafu.hydrologischer-atlas_flussgebiete", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Flussgebiet", highlightable: !0, background: !1, timestamps: ["20040101"], hasLegend: !0, queryableAttributes: ["nummer", "shape_area", "name", "umfang"], topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.swisstopo.images-spot-5.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", opacity: .75, attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.images-spot-5.metadata", singleTile: !0, attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Spot Mosaic Ausdehnung", wmsLayers: "ch.swisstopo.images-spot-5.metadata", shop: ["district", "canton", "rectangle", "whole"], highlightable: !1, background: !1, hasLegend: !1, type: "wms", topics: "api,ech,inspire,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.geoidmodell-ch1903": { opacity: .75, attribution: "swisstopo", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.geoidmodell-ch1903", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Geoidmodell in CH1903", highlightable: !0, background: !1, timestamps: ["20041231"], hasLegend: !0, type: "wmts", topics: "api,ech,geol,inspire,swisstopo,wms-bgdi_prod" },
            "ch.bafu.gewaesserschutz-diffuse_eintraege_phosphor": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.gewaesserschutz-diffuse_eintraege_phosphor", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Diffuse Phosphoreinträge", highlightable: !0, background: !1, timestamps: ["20150701"], hasLegend: !0, type: "wmts", topics: "api,bafu,ech,gewiss,inspire,wms-bgdi_prod", resolutions: [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10] },
            "ch.blw.gewaesseranschlusskarte": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.gewaesseranschlusskarte", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "Gewässeranschluss", highlightable: !0, background: !1, timestamps: ["20121201"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,gewiss,inspire,wms-bgdi_prod" },
            "ch.swisstopo.gkwvul500-papierkarte.metadata": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", shop: ["mapsheet"], attribution: "swisstopo", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.swisstopo.gkwvul500-papierkarte.metadata", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Grundwasservulnerabilität 500 - Papier", wmsLayers: "ch.swisstopo.gkwvul500-papierkarte.metadata", singleTile: !0, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["release"], topics: "api,wms-bgdi_prod" },
            "ch.blw.klimaeignung-kulturland": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.klimaeignung-kulturland", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Klimaeignung Kulturland", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.pixelkarte-farbe-pk1000.noscale": { attribution: "swisstopo", chargeable: !1, searchable: !1, format: "jpeg", timeEnabled: !1, serverLayerName: "ch.swisstopo.pixelkarte-farbe-pk1000.noscale", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !1, label: "Landeskarte 1:1 Million | LK1000", highlightable: !0, background: !1, timestamps: ["current", "20140106"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.vec25-uebrigerverkehr": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec25-uebrigerverkehr", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Übriger Verkehr VECTOR25", highlightable: !0, background: !1, timestamps: ["20090401"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo,wms-naz" },
            "ch.swisstopo.vec25-eisenbahnnetz": { attribution: "swisstopo", chargeable: !0, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.swisstopo.vec25-eisenbahnnetz", attributionUrl: "https://www.swisstopo.admin.ch/de/home.html", timeBehaviour: "last", tooltip: !0, label: "Eisenbahnnetz VECTOR25", highlightable: !0, background: !1, timestamps: ["20090401"], hasLegend: !0, type: "wmts", topics: "api,ech,inspire,swissmaponline,swisstopo,wms-naz" },
            "ch.blw.ursprungsbezeichnungen-kaese": { opacity: .75, attribution: "BLW", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.blw.ursprungsbezeichnungen-kaese", attributionUrl: "http://www.blw.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !1, label: "GUB Käse", highlightable: !0, background: !1, timestamps: ["20081024"], hasLegend: !0, type: "wmts", topics: "api,blw,ech,inspire,swissmaponline,wms-bgdi_prod" },
            "ch.swisstopo.fixpunkte-hfp1": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.swisstopo.fixpunkte-hfp1", gutter: 100, attribution: "swisstopo, Kt.", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.swisstopo.fixpunkte-hfp1", attributionUrl: "http://www.swisstopo.admin.ch/internet/swisstopo/de/home/swisstopo/org/cartography.html", timeBehaviour: "last", tooltip: !0, label: "Höhenfixpunkte HFP1", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["bgdi_label", "id"], topics: "api,ech,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.swisstopo.fixpunkte-hfp2": { wmsUrl: "//wms-bgdi.dev.bgdi.ch/?REQUEST=GetCapabilities&SERVICE=WMS&VERSION=1.0.0", wmsLayers: "ch.swisstopo.fixpunkte-hfp2", gutter: 100, attribution: "swisstopo, Kt.", chargeable: !1, searchable: !0, format: "png", timeEnabled: !1, type: "wms", serverLayerName: "ch.swisstopo.fixpunkte-hfp2", attributionUrl: "http://www.swisstopo.admin.ch/internet/swisstopo/de/home/swisstopo/org/cartography.html", timeBehaviour: "last", tooltip: !0, label: "Höhenfixpunkte HFP2", singleTile: !1, highlightable: !0, background: !1, hasLegend: !0, queryableAttributes: ["id"], topics: "api,ech,inspire,swissmaponline,swisstopo,wms-bgdi_prod" },
            "ch.bfs.arealstatistik": { opacity: .75, attribution: "BFS", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bfs.arealstatistik", attributionUrl: "http://www.bfs.admin.ch/bfs/portal/de/index.html", timeBehaviour: "last", tooltip: !0, label: "Arealstatistik 2004/09 NOAS04", highlightable: !0, background: !1, timestamps: ["20131121"], hasLegend: !0, type: "wmts", topics: "api,ech,gewiss,inspire,swissmaponline" },
            "ch.bafu.bundesinventare-moorlandschaften": { opacity: .75, attribution: "BAFU", chargeable: !1, searchable: !1, format: "png", timeEnabled: !1, serverLayerName: "ch.bafu.bundesinventare-moorlandschaften", attributionUrl: "http://www.bafu.admin.ch/index.html?lang=de", timeBehaviour: "last", tooltip: !0, label: "Moorlandschaften", highlightable: !0, background: !1, timestamps: ["20150202"], hasLegend: !0, type: "wmts", topics: "api,are,bafu,blw,ech,energie,geothermie,gewiss,inspire,kgs,sachplan,swissmaponline,wms-bgdi_prod,wms-naz" }
        }
    }
}(),
function(t, e) { "use strict"; "object" == typeof module && "object" == typeof module.exports ? module.exports = t.document ? e(t, !0) : function(t) { if (!t.document) throw new Error("jQuery requires a window with a document"); return e(t) } : e(t) }("undefined" != typeof window ? window : this, function(t, e) {
    "use strict";

    function i(t, e) {
        e = e || Q;
        var i = e.createElement("script");
        i.text = t, e.head.appendChild(i).parentNode.removeChild(i)
    }

    function n(t) {
        var e = !!t && "length" in t && t.length,
            i = ct.type(t);
        return "function" !== i && !ct.isWindow(t) && ("array" === i || 0 === e || "number" == typeof e && e > 0 && e - 1 in t)
    }

    function r(t, e, i) {
        if (ct.isFunction(e)) return ct.grep(t, function(t, n) { return !!e.call(t, n, t) !== i });
        if (e.nodeType) return ct.grep(t, function(t) { return t === e !== i });
        if ("string" == typeof e) {
            if (Et.test(e)) return ct.filter(e, t, i);
            e = ct.filter(e, t)
        }
        return ct.grep(t, function(t) { return rt.call(e, t) > -1 !== i && 1 === t.nodeType })
    }

    function o(t, e) {
        for (;
            (t = t[e]) && 1 !== t.nodeType;);
        return t
    }

    function s(t) { var e = {}; return ct.each(t.match(It) || [], function(t, i) { e[i] = !0 }), e }

    function a(t) { return t }

    function h(t) { throw t }

    function l(t, e, i) { var n; try { t && ct.isFunction(n = t.promise) ? n.call(t).done(e).fail(i) : t && ct.isFunction(n = t.then) ? n.call(t, e, i) : e.call(void 0, t) } catch (t) { i.call(void 0, t) } }

    function u() { Q.removeEventListener("DOMContentLoaded", u), t.removeEventListener("load", u), ct.ready() }

    function p() { this.expando = ct.expando + p.uid++ }

    function c(t, e, i) {
        var n;
        if (void 0 === i && 1 === t.nodeType)
            if (n = "data-" + e.replace(Dt, "-$&").toLowerCase(), i = t.getAttribute(n), "string" == typeof i) {
                try { i = "true" === i || "false" !== i && ("null" === i ? null : +i + "" === i ? +i : Ot.test(i) ? JSON.parse(i) : i) } catch (t) {}
                Pt.set(t, e, i)
            } else i = void 0;
        return i
    }

    function f(t, e, i, n) {
        var r, o = 1,
            s = 20,
            a = n ? function() { return n.cur() } : function() { return ct.css(t, e, "") },
            h = a(),
            l = i && i[3] || (ct.cssNumber[e] ? "" : "px"),
            u = (ct.cssNumber[e] || "px" !== l && +h) && Ut.exec(ct.css(t, e));
        if (u && u[3] !== l) {
            l = l || u[3], i = i || [], u = +h || 1;
            do o = o || ".5", u /= o, ct.style(t, e, u + l); while (o !== (o = a() / h) && 1 !== o && --s)
        }
        return i && (u = +u || +h || 0, r = i[1] ? u + (i[1] + 1) * i[2] : +i[2], n && (n.unit = l, n.start = u, n.end = r)), r
    }

    function g(t) {
        var e, i = t.ownerDocument,
            n = t.nodeName,
            r = Gt[n];
        return r ? r : (e = i.body.appendChild(i.createElement(n)), r = ct.css(e, "display"), e.parentNode.removeChild(e), "none" === r && (r = "block"), Gt[n] = r, r)
    }

    function d(t, e) { for (var i, n, r = [], o = 0, s = t.length; o < s; o++) n = t[o], n.style && (i = n.style.display, e ? ("none" === i && (r[o] = _t.get(n, "display") || null, r[o] || (n.style.display = "")), "" === n.style.display && jt(n) && (r[o] = g(n))) : "none" !== i && (r[o] = "none", _t.set(n, "display", i))); for (o = 0; o < s; o++) null != r[o] && (t[o].style.display = r[o]); return t }

    function y(t, e) { var i = "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e || "*") : "undefined" != typeof t.querySelectorAll ? t.querySelectorAll(e || "*") : []; return void 0 === e || e && ct.nodeName(t, e) ? ct.merge([t], i) : i }

    function m(t, e) { for (var i = 0, n = t.length; i < n; i++) _t.set(t[i], "globalEval", !e || _t.get(e[i], "globalEval")) }

    function v(t, e, i, n, r) {
        for (var o, s, a, h, l, u, p = e.createDocumentFragment(), c = [], f = 0, g = t.length; f < g; f++)
            if (o = t[f], o || 0 === o)
                if ("object" === ct.type(o)) ct.merge(c, o.nodeType ? [o] : o);
                else if (Ht.test(o)) {
            for (s = s || p.appendChild(e.createElement("div")), a = (Vt.exec(o) || ["", ""])[1].toLowerCase(), h = Xt[a] || Xt._default, s.innerHTML = h[1] + ct.htmlPrefilter(o) + h[2], u = h[0]; u--;) s = s.lastChild;
            ct.merge(c, s.childNodes), s = p.firstChild, s.textContent = ""
        } else c.push(e.createTextNode(o));
        for (p.textContent = "", f = 0; o = c[f++];)
            if (n && ct.inArray(o, n) > -1) r && r.push(o);
            else if (l = ct.contains(o.ownerDocument, o), s = y(p.appendChild(o), "script"), l && m(s), i)
            for (u = 0; o = s[u++];) Wt.test(o.type || "") && i.push(o);
        return p
    }

    function b() { return !0 }

    function w() { return !1 }

    function x() { try { return Q.activeElement } catch (t) {} }

    function E(t, e, i, n, r, o) {
        var s, a;
        if ("object" == typeof e) { "string" != typeof i && (n = n || i, i = void 0); for (a in e) E(t, a, i, n, e[a], o); return t }
        if (null == n && null == r ? (r = i, n = i = void 0) : null == r && ("string" == typeof i ? (r = n, n = void 0) : (r = n, n = i, i = void 0)), r === !1) r = w;
        else if (!r) return t;
        return 1 === o && (s = r, r = function(t) { return ct().off(t), s.apply(this, arguments) }, r.guid = s.guid || (s.guid = ct.guid++)), t.each(function() { ct.event.add(this, e, r, n, i) })
    }

    function S(t, e) { return ct.nodeName(t, "table") && ct.nodeName(11 !== e.nodeType ? e : e.firstChild, "tr") ? t.getElementsByTagName("tbody")[0] || t : t }

    function N(t) { return t.type = (null !== t.getAttribute("type")) + "/" + t.type, t }

    function L(t) { var e = ee.exec(t.type); return e ? t.type = e[1] : t.removeAttribute("type"), t }

    function C(t, e) {
        var i, n, r, o, s, a, h, l;
        if (1 === e.nodeType) {
            if (_t.hasData(t) && (o = _t.access(t), s = _t.set(e, o), l = o.events)) {
                delete s.handle, s.events = {};
                for (r in l)
                    for (i = 0, n = l[r].length; i < n; i++) ct.event.add(e, r, l[r][i])
            }
            Pt.hasData(t) && (a = Pt.access(t), h = ct.extend({}, a), Pt.set(e, h))
        }
    }

    function M(t, e) { var i = e.nodeName.toLowerCase(); "input" === i && qt.test(t.type) ? e.checked = t.checked : "input" !== i && "textarea" !== i || (e.defaultValue = t.defaultValue) }

    function I(t, e, n, r) {
        e = it.apply([], e);
        var o, s, a, h, l, u, p = 0,
            c = t.length,
            f = c - 1,
            g = e[0],
            d = ct.isFunction(g);
        if (d || c > 1 && "string" == typeof g && !ut.checkClone && te.test(g)) return t.each(function(i) {
            var o = t.eq(i);
            d && (e[0] = g.call(this, i, o.html())), I(o, e, n, r)
        });
        if (c && (o = v(e, t[0].ownerDocument, !1, t, r), s = o.firstChild, 1 === o.childNodes.length && (o = s), s || r)) {
            for (a = ct.map(y(o, "script"), N), h = a.length; p < c; p++) l = o, p !== f && (l = ct.clone(l, !0, !0), h && ct.merge(a, y(l, "script"))), n.call(t[p], l, p);
            if (h)
                for (u = a[a.length - 1].ownerDocument, ct.map(a, L), p = 0; p < h; p++) l = a[p], Wt.test(l.type || "") && !_t.access(l, "globalEval") && ct.contains(u, l) && (l.src ? ct._evalUrl && ct._evalUrl(l.src) : i(l.textContent.replace(ie, ""), u))
        }
        return t
    }

    function k(t, e, i) { for (var n, r = e ? ct.filter(e, t) : t, o = 0; null != (n = r[o]); o++) i || 1 !== n.nodeType || ct.cleanData(y(n)), n.parentNode && (i && ct.contains(n.ownerDocument, n) && m(y(n, "script")), n.parentNode.removeChild(n)); return t }

    function T(t, e, i) { var n, r, o, s, a = t.style; return i = i || oe(t), i && (s = i.getPropertyValue(e) || i[e], "" !== s || ct.contains(t.ownerDocument, t) || (s = ct.style(t, e)), !ut.pixelMarginRight() && re.test(s) && ne.test(e) && (n = a.width, r = a.minWidth, o = a.maxWidth, a.minWidth = a.maxWidth = a.width = s, s = i.width, a.width = n, a.minWidth = r, a.maxWidth = o)), void 0 !== s ? s + "" : s }

    function A(t, e) { return { get: function() { return t() ? void delete this.get : (this.get = e).apply(this, arguments) } } }

    function R(t) {
        if (t in ue) return t;
        for (var e = t[0].toUpperCase() + t.slice(1), i = le.length; i--;)
            if (t = le[i] + e, t in ue) return t
    }

    function _(t, e, i) { var n = Ut.exec(e); return n ? Math.max(0, n[2] - (i || 0)) + (n[3] || "px") : e }

    function P(t, e, i, n, r) { for (var o = i === (n ? "border" : "content") ? 4 : "width" === e ? 1 : 0, s = 0; o < 4; o += 2) "margin" === i && (s += ct.css(t, i + Bt[o], !0, r)), n ? ("content" === i && (s -= ct.css(t, "padding" + Bt[o], !0, r)), "margin" !== i && (s -= ct.css(t, "border" + Bt[o] + "Width", !0, r))) : (s += ct.css(t, "padding" + Bt[o], !0, r), "padding" !== i && (s += ct.css(t, "border" + Bt[o] + "Width", !0, r))); return s }

    function O(t, e, i) {
        var n, r = !0,
            o = oe(t),
            s = "border-box" === ct.css(t, "boxSizing", !1, o);
        if (t.getClientRects().length && (n = t.getBoundingClientRect()[e]), n <= 0 || null == n) {
            if (n = T(t, e, o), (n < 0 || null == n) && (n = t.style[e]), re.test(n)) return n;
            r = s && (ut.boxSizingReliable() || n === t.style[e]), n = parseFloat(n) || 0
        }
        return n + P(t, e, i || (s ? "border" : "content"), r, o) + "px"
    }

    function D(t, e, i, n, r) { return new D.prototype.init(t, e, i, n, r) }

    function F() { ce && (t.requestAnimationFrame(F), ct.fx.tick()) }

    function U() { return t.setTimeout(function() { pe = void 0 }), pe = ct.now() }

    function B(t, e) {
        var i, n = 0,
            r = { height: t };
        for (e = e ? 1 : 0; n < 4; n += 2 - e) i = Bt[n], r["margin" + i] = r["padding" + i] = t;
        return e && (r.opacity = r.width = t), r
    }

    function j(t, e, i) {
        for (var n, r = (q.tweeners[e] || []).concat(q.tweeners["*"]), o = 0, s = r.length; o < s; o++)
            if (n = r[o].call(i, e, t)) return n
    }

    function z(t, e, i) {
        var n, r, o, s, a, h, l, u, p = "width" in e || "height" in e,
            c = this,
            f = {},
            g = t.style,
            y = t.nodeType && jt(t),
            m = _t.get(t, "fxshow");
        i.queue || (s = ct._queueHooks(t, "fx"), null == s.unqueued && (s.unqueued = 0, a = s.empty.fire, s.empty.fire = function() { s.unqueued || a() }), s.unqueued++, c.always(function() { c.always(function() { s.unqueued--, ct.queue(t, "fx").length || s.empty.fire() }) }));
        for (n in e)
            if (r = e[n], fe.test(r)) {
                if (delete e[n], o = o || "toggle" === r, r === (y ? "hide" : "show")) {
                    if ("show" !== r || !m || void 0 === m[n]) continue;
                    y = !0
                }
                f[n] = m && m[n] || ct.style(t, n)
            }
        if (h = !ct.isEmptyObject(e), h || !ct.isEmptyObject(f)) { p && 1 === t.nodeType && (i.overflow = [g.overflow, g.overflowX, g.overflowY], l = m && m.display, null == l && (l = _t.get(t, "display")), u = ct.css(t, "display"), "none" === u && (l ? u = l : (d([t], !0), l = t.style.display || l, u = ct.css(t, "display"), d([t]))), ("inline" === u || "inline-block" === u && null != l) && "none" === ct.css(t, "float") && (h || (c.done(function() { g.display = l }), null == l && (u = g.display, l = "none" === u ? "" : u)), g.display = "inline-block")), i.overflow && (g.overflow = "hidden", c.always(function() { g.overflow = i.overflow[0], g.overflowX = i.overflow[1], g.overflowY = i.overflow[2] })), h = !1; for (n in f) h || (m ? "hidden" in m && (y = m.hidden) : m = _t.access(t, "fxshow", { display: l }), o && (m.hidden = !y), y && d([t], !0), c.done(function() { y || d([t]), _t.remove(t, "fxshow"); for (n in f) ct.style(t, n, f[n]) })), h = j(y ? m[n] : 0, n, c), n in m || (m[n] = h.start, y && (h.end = h.start, h.start = 0)) }
    }

    function G(t, e) {
        var i, n, r, o, s;
        for (i in t)
            if (n = ct.camelCase(i), r = e[n], o = t[i], ct.isArray(o) && (r = o[1], o = t[i] = o[0]), i !== n && (t[n] = o, delete t[i]), s = ct.cssHooks[n], s && "expand" in s) { o = s.expand(o), delete t[n]; for (i in o) i in t || (t[i] = o[i], e[i] = r) } else e[n] = r
    }

    function q(t, e, i) {
        var n, r, o = 0,
            s = q.prefilters.length,
            a = ct.Deferred().always(function() { delete h.elem }),
            h = function() { if (r) return !1; for (var e = pe || U(), i = Math.max(0, l.startTime + l.duration - e), n = i / l.duration || 0, o = 1 - n, s = 0, h = l.tweens.length; s < h; s++) l.tweens[s].run(o); return a.notifyWith(t, [l, o, i]), o < 1 && h ? i : (a.resolveWith(t, [l]), !1) },
            l = a.promise({
                elem: t,
                props: ct.extend({}, e),
                opts: ct.extend(!0, { specialEasing: {}, easing: ct.easing._default }, i),
                originalProperties: e,
                originalOptions: i,
                startTime: pe || U(),
                duration: i.duration,
                tweens: [],
                createTween: function(e, i) { var n = ct.Tween(t, l.opts, e, i, l.opts.specialEasing[e] || l.opts.easing); return l.tweens.push(n), n },
                stop: function(e) {
                    var i = 0,
                        n = e ? l.tweens.length : 0;
                    if (r) return this;
                    for (r = !0; i < n; i++) l.tweens[i].run(1);
                    return e ? (a.notifyWith(t, [l, 1, 0]), a.resolveWith(t, [l, e])) : a.rejectWith(t, [l, e]), this
                }
            }),
            u = l.props;
        for (G(u, l.opts.specialEasing); o < s; o++)
            if (n = q.prefilters[o].call(l, t, u, l.opts)) return ct.isFunction(n.stop) && (ct._queueHooks(l.elem, l.opts.queue).stop = ct.proxy(n.stop, n)), n;
        return ct.map(u, j, l), ct.isFunction(l.opts.start) && l.opts.start.call(t, l), ct.fx.timer(ct.extend(h, { elem: t, anim: l, queue: l.opts.queue })), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always)
    }

    function V(t) { return t.getAttribute && t.getAttribute("class") || "" }

    function W(t, e, i, n) {
        var r;
        if (ct.isArray(e)) ct.each(e, function(e, r) { i || Ce.test(t) ? n(t, r) : W(t + "[" + ("object" == typeof r && null != r ? e : "") + "]", r, i, n) });
        else if (i || "object" !== ct.type(e)) n(t, e);
        else
            for (r in e) W(t + "[" + r + "]", e[r], i, n)
    }

    function X(t) {
        return function(e, i) {
            "string" != typeof e && (i = e, e = "*");
            var n, r = 0,
                o = e.toLowerCase().match(It) || [];
            if (ct.isFunction(i))
                for (; n = o[r++];) "+" === n[0] ? (n = n.slice(1) || "*", (t[n] = t[n] || []).unshift(i)) : (t[n] = t[n] || []).push(i)
        }
    }

    function H(t, e, i, n) {
        function r(a) { var h; return o[a] = !0, ct.each(t[a] || [], function(t, a) { var l = a(e, i, n); return "string" != typeof l || s || o[l] ? s ? !(h = l) : void 0 : (e.dataTypes.unshift(l), r(l), !1) }), h }
        var o = {},
            s = t === Ue;
        return r(e.dataTypes[0]) || !o["*"] && r("*")
    }

    function Y(t, e) { var i, n, r = ct.ajaxSettings.flatOptions || {}; for (i in e) void 0 !== e[i] && ((r[i] ? t : n || (n = {}))[i] = e[i]); return n && ct.extend(!0, t, n), t }

    function K(t, e, i) {
        for (var n, r, o, s, a = t.contents, h = t.dataTypes;
            "*" === h[0];) h.shift(), void 0 === n && (n = t.mimeType || e.getResponseHeader("Content-Type"));
        if (n)
            for (r in a)
                if (a[r] && a[r].test(n)) { h.unshift(r); break }
        if (h[0] in i) o = h[0];
        else {
            for (r in i) {
                if (!h[0] || t.converters[r + " " + h[0]]) { o = r; break }
                s || (s = r)
            }
            o = o || s
        }
        if (o) return o !== h[0] && h.unshift(o), i[o]
    }

    function $(t, e, i, n) {
        var r, o, s, a, h, l = {},
            u = t.dataTypes.slice();
        if (u[1])
            for (s in t.converters) l[s.toLowerCase()] = t.converters[s];
        for (o = u.shift(); o;)
            if (t.responseFields[o] && (i[t.responseFields[o]] = e), !h && n && t.dataFilter && (e = t.dataFilter(e, t.dataType)), h = o, o = u.shift())
                if ("*" === o) o = h;
                else if ("*" !== h && h !== o) {
            if (s = l[h + " " + o] || l["* " + o], !s)
                for (r in l)
                    if (a = r.split(" "), a[1] === o && (s = l[h + " " + a[0]] || l["* " + a[0]])) { s === !0 ? s = l[r] : l[r] !== !0 && (o = a[0], u.unshift(a[1])); break }
            if (s !== !0)
                if (s && t.throws) e = s(e);
                else try { e = s(e) } catch (t) { return { state: "parsererror", error: s ? t : "No conversion from " + h + " to " + o } }
        }
        return { state: "success", data: e }
    }

    function Z(t) { return ct.isWindow(t) ? t : 9 === t.nodeType && t.defaultView }
    var J = [],
        Q = t.document,
        tt = Object.getPrototypeOf,
        et = J.slice,
        it = J.concat,
        nt = J.push,
        rt = J.indexOf,
        ot = {},
        st = ot.toString,
        at = ot.hasOwnProperty,
        ht = at.toString,
        lt = ht.call(Object),
        ut = {},
        pt = "3.1.0",
        ct = function(t, e) { return new ct.fn.init(t, e) },
        ft = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
        gt = /^-ms-/,
        dt = /-([a-z])/g,
        yt = function(t, e) { return e.toUpperCase() };
    ct.fn = ct.prototype = {
        jquery: pt,
        constructor: ct,
        length: 0,
        toArray: function() { return et.call(this) },
        get: function(t) { return null != t ? t < 0 ? this[t + this.length] : this[t] : et.call(this) },
        pushStack: function(t) { var e = ct.merge(this.constructor(), t); return e.prevObject = this, e },
        each: function(t) { return ct.each(this, t) },
        map: function(t) { return this.pushStack(ct.map(this, function(e, i) { return t.call(e, i, e) })) },
        slice: function() { return this.pushStack(et.apply(this, arguments)) },
        first: function() { return this.eq(0) },
        last: function() { return this.eq(-1) },
        eq: function(t) {
            var e = this.length,
                i = +t + (t < 0 ? e : 0);
            return this.pushStack(i >= 0 && i < e ? [this[i]] : [])
        },
        end: function() { return this.prevObject || this.constructor() },
        push: nt,
        sort: J.sort,
        splice: J.splice
    }, ct.extend = ct.fn.extend = function() {
        var t, e, i, n, r, o, s = arguments[0] || {},
            a = 1,
            h = arguments.length,
            l = !1;
        for ("boolean" == typeof s && (l = s, s = arguments[a] || {}, a++), "object" == typeof s || ct.isFunction(s) || (s = {}), a === h && (s = this, a--); a < h; a++)
            if (null != (t = arguments[a]))
                for (e in t) i = s[e], n = t[e], s !== n && (l && n && (ct.isPlainObject(n) || (r = ct.isArray(n))) ? (r ? (r = !1, o = i && ct.isArray(i) ? i : []) : o = i && ct.isPlainObject(i) ? i : {}, s[e] = ct.extend(l, o, n)) : void 0 !== n && (s[e] = n));
        return s
    }, ct.extend({
        expando: "jQuery" + (pt + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(t) { throw new Error(t) },
        noop: function() {},
        isFunction: function(t) { return "function" === ct.type(t) },
        isArray: Array.isArray,
        isWindow: function(t) { return null != t && t === t.window },
        isNumeric: function(t) { var e = ct.type(t); return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t)) },
        isPlainObject: function(t) { var e, i; return !(!t || "[object Object]" !== st.call(t)) && (!(e = tt(t)) || (i = at.call(e, "constructor") && e.constructor, "function" == typeof i && ht.call(i) === lt)) },
        isEmptyObject: function(t) { var e; for (e in t) return !1; return !0 },
        type: function(t) { return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? ot[st.call(t)] || "object" : typeof t },
        globalEval: function(t) { i(t) },
        camelCase: function(t) { return t.replace(gt, "ms-").replace(dt, yt) },
        nodeName: function(t, e) { return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase() },
        each: function(t, e) {
            var i, r = 0;
            if (n(t))
                for (i = t.length; r < i && e.call(t[r], r, t[r]) !== !1; r++);
            else
                for (r in t)
                    if (e.call(t[r], r, t[r]) === !1) break; return t
        },
        trim: function(t) { return null == t ? "" : (t + "").replace(ft, "") },
        makeArray: function(t, e) { var i = e || []; return null != t && (n(Object(t)) ? ct.merge(i, "string" == typeof t ? [t] : t) : nt.call(i, t)), i },
        inArray: function(t, e, i) { return null == e ? -1 : rt.call(e, t, i) },
        merge: function(t, e) { for (var i = +e.length, n = 0, r = t.length; n < i; n++) t[r++] = e[n]; return t.length = r, t },
        grep: function(t, e, i) { for (var n, r = [], o = 0, s = t.length, a = !i; o < s; o++) n = !e(t[o], o), n !== a && r.push(t[o]); return r },
        map: function(t, e, i) {
            var r, o, s = 0,
                a = [];
            if (n(t))
                for (r = t.length; s < r; s++) o = e(t[s], s, i), null != o && a.push(o);
            else
                for (s in t) o = e(t[s], s, i), null != o && a.push(o);
            return it.apply([], a)
        },
        guid: 1,
        proxy: function(t, e) { var i, n, r; if ("string" == typeof e && (i = t[e], e = t, t = i), ct.isFunction(t)) return n = et.call(arguments, 2), r = function() { return t.apply(e || this, n.concat(et.call(arguments))) }, r.guid = t.guid = t.guid || ct.guid++, r },
        now: Date.now,
        support: ut
    }), "function" == typeof Symbol && (ct.fn[Symbol.iterator] = J[Symbol.iterator]), ct.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(t, e) { ot["[object " + e + "]"] = e.toLowerCase() });
    var mt = function(t) {
        function e(t, e, i, n) {
            var r, o, s, a, h, l, u, c = e && e.ownerDocument,
                g = e ? e.nodeType : 9;
            if (i = i || [], "string" != typeof t || !t || 1 !== g && 9 !== g && 11 !== g) return i;
            if (!n && ((e ? e.ownerDocument || e : z) !== _ && R(e), e = e || _, O)) {
                if (11 !== g && (h = mt.exec(t)))
                    if (r = h[1]) { if (9 === g) { if (!(s = e.getElementById(r))) return i; if (s.id === r) return i.push(s), i } else if (c && (s = c.getElementById(r)) && B(e, s) && s.id === r) return i.push(s), i } else { if (h[2]) return J.apply(i, e.getElementsByTagName(t)), i; if ((r = h[3]) && E.getElementsByClassName && e.getElementsByClassName) return J.apply(i, e.getElementsByClassName(r)), i }
                if (E.qsa && !X[t + " "] && (!D || !D.test(t))) {
                    if (1 !== g) c = e, u = t;
                    else if ("object" !== e.nodeName.toLowerCase()) {
                        for ((a = e.getAttribute("id")) ? a = a.replace(xt, Et) : e.setAttribute("id", a = j), l = C(t), o = l.length; o--;) l[o] = "#" + a + " " + f(l[o]);
                        u = l.join(","), c = vt.test(t) && p(e.parentNode) || e
                    }
                    if (u) try { return J.apply(i, c.querySelectorAll(u)), i } catch (t) {} finally { a === j && e.removeAttribute("id") }
                }
            }
            return I(t.replace(at, "$1"), e, i, n)
        }

        function i() {
            function t(i, n) { return e.push(i + " ") > S.cacheLength && delete t[e.shift()], t[i + " "] = n }
            var e = [];
            return t
        }

        function n(t) { return t[j] = !0, t }

        function r(t) { var e = _.createElement("fieldset"); try { return !!t(e) } catch (t) { return !1 } finally { e.parentNode && e.parentNode.removeChild(e), e = null } }

        function o(t, e) { for (var i = t.split("|"), n = i.length; n--;) S.attrHandle[i[n]] = e }

        function s(t, e) {
            var i = e && t,
                n = i && 1 === t.nodeType && 1 === e.nodeType && t.sourceIndex - e.sourceIndex;
            if (n) return n;
            if (i)
                for (; i = i.nextSibling;)
                    if (i === e) return -1;
            return t ? 1 : -1
        }

        function a(t) { return function(e) { var i = e.nodeName.toLowerCase(); return "input" === i && e.type === t } }

        function h(t) { return function(e) { var i = e.nodeName.toLowerCase(); return ("input" === i || "button" === i) && e.type === t } }

        function l(t) { return function(e) { return "label" in e && e.disabled === t || "form" in e && e.disabled === t || "form" in e && e.disabled === !1 && (e.isDisabled === t || e.isDisabled !== !t && ("label" in e || !Nt(e)) !== t) } }

        function u(t) { return n(function(e) { return e = +e, n(function(i, n) { for (var r, o = t([], i.length, e), s = o.length; s--;) i[r = o[s]] && (i[r] = !(n[r] = i[r])) }) }) }

        function p(t) { return t && "undefined" != typeof t.getElementsByTagName && t }

        function c() {}

        function f(t) { for (var e = 0, i = t.length, n = ""; e < i; e++) n += t[e].value; return n }

        function g(t, e, i) {
            var n = e.dir,
                r = e.next,
                o = r || n,
                s = i && "parentNode" === o,
                a = q++;
            return e.first ? function(e, i, r) {
                for (; e = e[n];)
                    if (1 === e.nodeType || s) return t(e, i, r)
            } : function(e, i, h) {
                var l, u, p, c = [G, a];
                if (h) {
                    for (; e = e[n];)
                        if ((1 === e.nodeType || s) && t(e, i, h)) return !0
                } else
                    for (; e = e[n];)
                        if (1 === e.nodeType || s)
                            if (p = e[j] || (e[j] = {}), u = p[e.uniqueID] || (p[e.uniqueID] = {}), r && r === e.nodeName.toLowerCase()) e = e[n] || e;
                            else { if ((l = u[o]) && l[0] === G && l[1] === a) return c[2] = l[2]; if (u[o] = c, c[2] = t(e, i, h)) return !0 }
            }
        }

        function d(t) {
            return t.length > 1 ? function(e, i, n) {
                for (var r = t.length; r--;)
                    if (!t[r](e, i, n)) return !1;
                return !0
            } : t[0]
        }

        function y(t, i, n) { for (var r = 0, o = i.length; r < o; r++) e(t, i[r], n); return n }

        function m(t, e, i, n, r) { for (var o, s = [], a = 0, h = t.length, l = null != e; a < h; a++)(o = t[a]) && (i && !i(o, n, r) || (s.push(o), l && e.push(a))); return s }

        function v(t, e, i, r, o, s) {
            return r && !r[j] && (r = v(r)), o && !o[j] && (o = v(o, s)), n(function(n, s, a, h) {
                var l, u, p, c = [],
                    f = [],
                    g = s.length,
                    d = n || y(e || "*", a.nodeType ? [a] : a, []),
                    v = !t || !n && e ? d : m(d, c, t, a, h),
                    b = i ? o || (n ? t : g || r) ? [] : s : v;
                if (i && i(v, b, a, h), r)
                    for (l = m(b, f), r(l, [], a, h), u = l.length; u--;)(p = l[u]) && (b[f[u]] = !(v[f[u]] = p));
                if (n) {
                    if (o || t) {
                        if (o) {
                            for (l = [], u = b.length; u--;)(p = b[u]) && l.push(v[u] = p);
                            o(null, b = [], l, h)
                        }
                        for (u = b.length; u--;)(p = b[u]) && (l = o ? tt(n, p) : c[u]) > -1 && (n[l] = !(s[l] = p))
                    }
                } else b = m(b === s ? b.splice(g, b.length) : b), o ? o(null, s, b, h) : J.apply(s, b)
            })
        }

        function b(t) {
            for (var e, i, n, r = t.length, o = S.relative[t[0].type], s = o || S.relative[" "], a = o ? 1 : 0, h = g(function(t) { return t === e }, s, !0), l = g(function(t) { return tt(e, t) > -1 }, s, !0), u = [function(t, i, n) { var r = !o && (n || i !== k) || ((e = i).nodeType ? h(t, i, n) : l(t, i, n)); return e = null, r }]; a < r; a++)
                if (i = S.relative[t[a].type]) u = [g(d(u), i)];
                else {
                    if (i = S.filter[t[a].type].apply(null, t[a].matches), i[j]) { for (n = ++a; n < r && !S.relative[t[n].type]; n++); return v(a > 1 && d(u), a > 1 && f(t.slice(0, a - 1).concat({ value: " " === t[a - 2].type ? "*" : "" })).replace(at, "$1"), i, a < n && b(t.slice(a, n)), n < r && b(t = t.slice(n)), n < r && f(t)) }
                    u.push(i)
                }
            return d(u)
        }

        function w(t, i) {
            var r = i.length > 0,
                o = t.length > 0,
                s = function(n, s, a, h, l) {
                    var u, p, c, f = 0,
                        g = "0",
                        d = n && [],
                        y = [],
                        v = k,
                        b = n || o && S.find.TAG("*", l),
                        w = G += null == v ? 1 : Math.random() || .1,
                        x = b.length;
                    for (l && (k = s === _ || s || l); g !== x && null != (u = b[g]); g++) {
                        if (o && u) {
                            for (p = 0, s || u.ownerDocument === _ || (R(u), a = !O); c = t[p++];)
                                if (c(u, s || _, a)) { h.push(u); break }
                            l && (G = w)
                        }
                        r && ((u = !c && u) && f--, n && d.push(u))
                    }
                    if (f += g, r && g !== f) {
                        for (p = 0; c = i[p++];) c(d, y, s, a);
                        if (n) {
                            if (f > 0)
                                for (; g--;) d[g] || y[g] || (y[g] = $.call(h));
                            y = m(y)
                        }
                        J.apply(h, y), l && !n && y.length > 0 && f + i.length > 1 && e.uniqueSort(h)
                    }
                    return l && (G = w, k = v), d
                };
            return r ? n(s) : s
        }
        var x, E, S, N, L, C, M, I, k, T, A, R, _, P, O, D, F, U, B, j = "sizzle" + 1 * new Date,
            z = t.document,
            G = 0,
            q = 0,
            V = i(),
            W = i(),
            X = i(),
            H = function(t, e) { return t === e && (A = !0), 0 },
            Y = {}.hasOwnProperty,
            K = [],
            $ = K.pop,
            Z = K.push,
            J = K.push,
            Q = K.slice,
            tt = function(t, e) {
                for (var i = 0, n = t.length; i < n; i++)
                    if (t[i] === e) return i;
                return -1
            },
            et = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            it = "[\\x20\\t\\r\\n\\f]",
            nt = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
            rt = "\\[" + it + "*(" + nt + ")(?:" + it + "*([*^$|!~]?=)" + it + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + nt + "))|)" + it + "*\\]",
            ot = ":(" + nt + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + rt + ")*)|.*)\\)|)",
            st = new RegExp(it + "+", "g"),
            at = new RegExp("^" + it + "+|((?:^|[^\\\\])(?:\\\\.)*)" + it + "+$", "g"),
            ht = new RegExp("^" + it + "*," + it + "*"),
            lt = new RegExp("^" + it + "*([>+~]|" + it + ")" + it + "*"),
            ut = new RegExp("=" + it + "*([^\\]'\"]*?)" + it + "*\\]", "g"),
            pt = new RegExp(ot),
            ct = new RegExp("^" + nt + "$"),
            ft = { ID: new RegExp("^#(" + nt + ")"), CLASS: new RegExp("^\\.(" + nt + ")"), TAG: new RegExp("^(" + nt + "|[*])"), ATTR: new RegExp("^" + rt), PSEUDO: new RegExp("^" + ot), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + it + "*(even|odd|(([+-]|)(\\d*)n|)" + it + "*(?:([+-]|)" + it + "*(\\d+)|))" + it + "*\\)|)", "i"), bool: new RegExp("^(?:" + et + ")$", "i"), needsContext: new RegExp("^" + it + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + it + "*((?:-\\d)?\\d*)" + it + "*\\)|)(?=[^-]|$)", "i") },
            gt = /^(?:input|select|textarea|button)$/i,
            dt = /^h\d$/i,
            yt = /^[^{]+\{\s*\[native \w/,
            mt = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            vt = /[+~]/,
            bt = new RegExp("\\\\([\\da-f]{1,6}" + it + "?|(" + it + ")|.)", "ig"),
            wt = function(t, e, i) { var n = "0x" + e - 65536; return n !== n || i ? e : n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320) },
            xt = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,
            Et = function(t, e) { return e ? "\0" === t ? "�" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t },
            St = function() { R() },
            Nt = g(function(t) { return t.disabled === !0 }, { dir: "parentNode", next: "legend" });
        try { J.apply(K = Q.call(z.childNodes), z.childNodes), K[z.childNodes.length].nodeType } catch (t) {
            J = {
                apply: K.length ? function(t, e) { Z.apply(t, Q.call(e)) } : function(t, e) {
                    for (var i = t.length, n = 0; t[i++] = e[n++];);
                    t.length = i - 1
                }
            }
        }
        E = e.support = {}, L = e.isXML = function(t) { var e = t && (t.ownerDocument || t).documentElement; return !!e && "HTML" !== e.nodeName }, R = e.setDocument = function(t) {
            var e, i, n = t ? t.ownerDocument || t : z;
            return n !== _ && 9 === n.nodeType && n.documentElement ? (_ = n, P = _.documentElement, O = !L(_), z !== _ && (i = _.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", St, !1) : i.attachEvent && i.attachEvent("onunload", St)), E.attributes = r(function(t) { return t.className = "i", !t.getAttribute("className") }), E.getElementsByTagName = r(function(t) { return t.appendChild(_.createComment("")), !t.getElementsByTagName("*").length }), E.getElementsByClassName = yt.test(_.getElementsByClassName), E.getById = r(function(t) { return P.appendChild(t).id = j, !_.getElementsByName || !_.getElementsByName(j).length }), E.getById ? (S.find.ID = function(t, e) { if ("undefined" != typeof e.getElementById && O) { var i = e.getElementById(t); return i ? [i] : [] } }, S.filter.ID = function(t) { var e = t.replace(bt, wt); return function(t) { return t.getAttribute("id") === e } }) : (delete S.find.ID, S.filter.ID = function(t) { var e = t.replace(bt, wt); return function(t) { var i = "undefined" != typeof t.getAttributeNode && t.getAttributeNode("id"); return i && i.value === e } }), S.find.TAG = E.getElementsByTagName ? function(t, e) { return "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t) : E.qsa ? e.querySelectorAll(t) : void 0 } : function(t, e) {
                var i, n = [],
                    r = 0,
                    o = e.getElementsByTagName(t);
                if ("*" === t) { for (; i = o[r++];) 1 === i.nodeType && n.push(i); return n }
                return o
            }, S.find.CLASS = E.getElementsByClassName && function(t, e) { if ("undefined" != typeof e.getElementsByClassName && O) return e.getElementsByClassName(t) }, F = [], D = [], (E.qsa = yt.test(_.querySelectorAll)) && (r(function(t) { P.appendChild(t).innerHTML = "<a id='" + j + "'></a><select id='" + j + "-\r\\' msallowcapture=''><option selected=''></option></select>", t.querySelectorAll("[msallowcapture^='']").length && D.push("[*^$]=" + it + "*(?:''|\"\")"), t.querySelectorAll("[selected]").length || D.push("\\[" + it + "*(?:value|" + et + ")"), t.querySelectorAll("[id~=" + j + "-]").length || D.push("~="), t.querySelectorAll(":checked").length || D.push(":checked"), t.querySelectorAll("a#" + j + "+*").length || D.push(".#.+[+~]") }), r(function(t) {
                t.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var e = _.createElement("input");
                e.setAttribute("type", "hidden"), t.appendChild(e).setAttribute("name", "D"), t.querySelectorAll("[name=d]").length && D.push("name" + it + "*[*^$|!~]?="), 2 !== t.querySelectorAll(":enabled").length && D.push(":enabled", ":disabled"), P.appendChild(t).disabled = !0, 2 !== t.querySelectorAll(":disabled").length && D.push(":enabled", ":disabled"), t.querySelectorAll("*,:x"), D.push(",.*:")
            })), (E.matchesSelector = yt.test(U = P.matches || P.webkitMatchesSelector || P.mozMatchesSelector || P.oMatchesSelector || P.msMatchesSelector)) && r(function(t) { E.disconnectedMatch = U.call(t, "*"), U.call(t, "[s!='']:x"), F.push("!=", ot) }), D = D.length && new RegExp(D.join("|")), F = F.length && new RegExp(F.join("|")), e = yt.test(P.compareDocumentPosition), B = e || yt.test(P.contains) ? function(t, e) {
                var i = 9 === t.nodeType ? t.documentElement : t,
                    n = e && e.parentNode;
                return t === n || !(!n || 1 !== n.nodeType || !(i.contains ? i.contains(n) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(n)))
            } : function(t, e) {
                if (e)
                    for (; e = e.parentNode;)
                        if (e === t) return !0;
                return !1
            }, H = e ? function(t, e) { if (t === e) return A = !0, 0; var i = !t.compareDocumentPosition - !e.compareDocumentPosition; return i ? i : (i = (t.ownerDocument || t) === (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1, 1 & i || !E.sortDetached && e.compareDocumentPosition(t) === i ? t === _ || t.ownerDocument === z && B(z, t) ? -1 : e === _ || e.ownerDocument === z && B(z, e) ? 1 : T ? tt(T, t) - tt(T, e) : 0 : 4 & i ? -1 : 1) } : function(t, e) {
                if (t === e) return A = !0, 0;
                var i, n = 0,
                    r = t.parentNode,
                    o = e.parentNode,
                    a = [t],
                    h = [e];
                if (!r || !o) return t === _ ? -1 : e === _ ? 1 : r ? -1 : o ? 1 : T ? tt(T, t) - tt(T, e) : 0;
                if (r === o) return s(t, e);
                for (i = t; i = i.parentNode;) a.unshift(i);
                for (i = e; i = i.parentNode;) h.unshift(i);
                for (; a[n] === h[n];) n++;
                return n ? s(a[n], h[n]) : a[n] === z ? -1 : h[n] === z ? 1 : 0
            }, _) : _
        }, e.matches = function(t, i) { return e(t, null, null, i) }, e.matchesSelector = function(t, i) {
            if ((t.ownerDocument || t) !== _ && R(t), i = i.replace(ut, "='$1']"), E.matchesSelector && O && !X[i + " "] && (!F || !F.test(i)) && (!D || !D.test(i))) try { var n = U.call(t, i); if (n || E.disconnectedMatch || t.document && 11 !== t.document.nodeType) return n } catch (t) {}
            return e(i, _, null, [t]).length > 0
        }, e.contains = function(t, e) { return (t.ownerDocument || t) !== _ && R(t), B(t, e) }, e.attr = function(t, e) {
            (t.ownerDocument || t) !== _ && R(t);
            var i = S.attrHandle[e.toLowerCase()],
                n = i && Y.call(S.attrHandle, e.toLowerCase()) ? i(t, e, !O) : void 0;
            return void 0 !== n ? n : E.attributes || !O ? t.getAttribute(e) : (n = t.getAttributeNode(e)) && n.specified ? n.value : null
        }, e.escape = function(t) { return (t + "").replace(xt, Et) }, e.error = function(t) { throw new Error("Syntax error, unrecognized expression: " + t) }, e.uniqueSort = function(t) {
            var e, i = [],
                n = 0,
                r = 0;
            if (A = !E.detectDuplicates, T = !E.sortStable && t.slice(0), t.sort(H), A) { for (; e = t[r++];) e === t[r] && (n = i.push(r)); for (; n--;) t.splice(i[n], 1) }
            return T = null, t
        }, N = e.getText = function(t) {
            var e, i = "",
                n = 0,
                r = t.nodeType;
            if (r) { if (1 === r || 9 === r || 11 === r) { if ("string" == typeof t.textContent) return t.textContent; for (t = t.firstChild; t; t = t.nextSibling) i += N(t) } else if (3 === r || 4 === r) return t.nodeValue } else
                for (; e = t[n++];) i += N(e);
            return i
        }, S = e.selectors = {
            cacheLength: 50,
            createPseudo: n,
            match: ft,
            attrHandle: {},
            find: {},
            relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } },
            preFilter: { ATTR: function(t) { return t[1] = t[1].replace(bt, wt), t[3] = (t[3] || t[4] || t[5] || "").replace(bt, wt), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4) }, CHILD: function(t) { return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || e.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && e.error(t[0]), t }, PSEUDO: function(t) { var e, i = !t[6] && t[2]; return ft.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : i && pt.test(i) && (e = C(i, !0)) && (e = i.indexOf(")", i.length - e) - i.length) && (t[0] = t[0].slice(0, e), t[2] = i.slice(0, e)), t.slice(0, 3)) } },
            filter: {
                TAG: function(t) { var e = t.replace(bt, wt).toLowerCase(); return "*" === t ? function() { return !0 } : function(t) { return t.nodeName && t.nodeName.toLowerCase() === e } },
                CLASS: function(t) { var e = V[t + " "]; return e || (e = new RegExp("(^|" + it + ")" + t + "(" + it + "|$)")) && V(t, function(t) { return e.test("string" == typeof t.className && t.className || "undefined" != typeof t.getAttribute && t.getAttribute("class") || "") }) },
                ATTR: function(t, i, n) { return function(r) { var o = e.attr(r, t); return null == o ? "!=" === i : !i || (o += "", "=" === i ? o === n : "!=" === i ? o !== n : "^=" === i ? n && 0 === o.indexOf(n) : "*=" === i ? n && o.indexOf(n) > -1 : "$=" === i ? n && o.slice(-n.length) === n : "~=" === i ? (" " + o.replace(st, " ") + " ").indexOf(n) > -1 : "|=" === i && (o === n || o.slice(0, n.length + 1) === n + "-")) } },
                CHILD: function(t, e, i, n, r) {
                    var o = "nth" !== t.slice(0, 3),
                        s = "last" !== t.slice(-4),
                        a = "of-type" === e;
                    return 1 === n && 0 === r ? function(t) { return !!t.parentNode } : function(e, i, h) {
                        var l, u, p, c, f, g, d = o !== s ? "nextSibling" : "previousSibling",
                            y = e.parentNode,
                            m = a && e.nodeName.toLowerCase(),
                            v = !h && !a,
                            b = !1;
                        if (y) {
                            if (o) {
                                for (; d;) {
                                    for (c = e; c = c[d];)
                                        if (a ? c.nodeName.toLowerCase() === m : 1 === c.nodeType) return !1;
                                    g = d = "only" === t && !g && "nextSibling"
                                }
                                return !0
                            }
                            if (g = [s ? y.firstChild : y.lastChild], s && v) {
                                for (c = y, p = c[j] || (c[j] = {}), u = p[c.uniqueID] || (p[c.uniqueID] = {}), l = u[t] || [], f = l[0] === G && l[1], b = f && l[2], c = f && y.childNodes[f]; c = ++f && c && c[d] || (b = f = 0) || g.pop();)
                                    if (1 === c.nodeType && ++b && c === e) { u[t] = [G, f, b]; break }
                            } else if (v && (c = e, p = c[j] || (c[j] = {}), u = p[c.uniqueID] || (p[c.uniqueID] = {}), l = u[t] || [], f = l[0] === G && l[1], b = f), b === !1)
                                for (;
                                    (c = ++f && c && c[d] || (b = f = 0) || g.pop()) && ((a ? c.nodeName.toLowerCase() !== m : 1 !== c.nodeType) || !++b || (v && (p = c[j] || (c[j] = {}), u = p[c.uniqueID] || (p[c.uniqueID] = {}), u[t] = [G, b]), c !== e)););
                            return b -= r, b === n || b % n === 0 && b / n >= 0
                        }
                    }
                },
                PSEUDO: function(t, i) { var r, o = S.pseudos[t] || S.setFilters[t.toLowerCase()] || e.error("unsupported pseudo: " + t); return o[j] ? o(i) : o.length > 1 ? (r = [t, t, "", i], S.setFilters.hasOwnProperty(t.toLowerCase()) ? n(function(t, e) { for (var n, r = o(t, i), s = r.length; s--;) n = tt(t, r[s]), t[n] = !(e[n] = r[s]) }) : function(t) { return o(t, 0, r) }) : o }
            },
            pseudos: {
                not: n(function(t) {
                    var e = [],
                        i = [],
                        r = M(t.replace(at, "$1"));
                    return r[j] ? n(function(t, e, i, n) { for (var o, s = r(t, null, n, []), a = t.length; a--;)(o = s[a]) && (t[a] = !(e[a] = o)) }) : function(t, n, o) { return e[0] = t, r(e, null, o, i), e[0] = null, !i.pop() }
                }),
                has: n(function(t) { return function(i) { return e(t, i).length > 0 } }),
                contains: n(function(t) {
                    return t = t.replace(bt, wt),
                        function(e) { return (e.textContent || e.innerText || N(e)).indexOf(t) > -1 }
                }),
                lang: n(function(t) {
                    return ct.test(t || "") || e.error("unsupported lang: " + t), t = t.replace(bt, wt).toLowerCase(),
                        function(e) {
                            var i;
                            do
                                if (i = O ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return i = i.toLowerCase(), i === t || 0 === i.indexOf(t + "-");
                            while ((e = e.parentNode) && 1 === e.nodeType);
                            return !1
                        }
                }),
                target: function(e) { var i = t.location && t.location.hash; return i && i.slice(1) === e.id },
                root: function(t) { return t === P },
                focus: function(t) { return t === _.activeElement && (!_.hasFocus || _.hasFocus()) && !!(t.type || t.href || ~t.tabIndex) },
                enabled: l(!1),
                disabled: l(!0),
                checked: function(t) { var e = t.nodeName.toLowerCase(); return "input" === e && !!t.checked || "option" === e && !!t.selected },
                selected: function(t) { return t.parentNode && t.parentNode.selectedIndex, t.selected === !0 },
                empty: function(t) {
                    for (t = t.firstChild; t; t = t.nextSibling)
                        if (t.nodeType < 6) return !1;
                    return !0
                },
                parent: function(t) { return !S.pseudos.empty(t) },
                header: function(t) { return dt.test(t.nodeName) },
                input: function(t) { return gt.test(t.nodeName) },
                button: function(t) { var e = t.nodeName.toLowerCase(); return "input" === e && "button" === t.type || "button" === e },
                text: function(t) { var e; return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase()) },
                first: u(function() { return [0] }),
                last: u(function(t, e) { return [e - 1] }),
                eq: u(function(t, e, i) { return [i < 0 ? i + e : i] }),
                even: u(function(t, e) { for (var i = 0; i < e; i += 2) t.push(i); return t }),
                odd: u(function(t, e) { for (var i = 1; i < e; i += 2) t.push(i); return t }),
                lt: u(function(t, e, i) { for (var n = i < 0 ? i + e : i; --n >= 0;) t.push(n); return t }),
                gt: u(function(t, e, i) { for (var n = i < 0 ? i + e : i; ++n < e;) t.push(n); return t })
            }
        }, S.pseudos.nth = S.pseudos.eq;
        for (x in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) S.pseudos[x] = a(x);
        for (x in { submit: !0, reset: !0 }) S.pseudos[x] = h(x);
        return c.prototype = S.filters = S.pseudos, S.setFilters = new c, C = e.tokenize = function(t, i) { var n, r, o, s, a, h, l, u = W[t + " "]; if (u) return i ? 0 : u.slice(0); for (a = t, h = [], l = S.preFilter; a;) { n && !(r = ht.exec(a)) || (r && (a = a.slice(r[0].length) || a), h.push(o = [])), n = !1, (r = lt.exec(a)) && (n = r.shift(), o.push({ value: n, type: r[0].replace(at, " ") }), a = a.slice(n.length)); for (s in S.filter) !(r = ft[s].exec(a)) || l[s] && !(r = l[s](r)) || (n = r.shift(), o.push({ value: n, type: s, matches: r }), a = a.slice(n.length)); if (!n) break } return i ? a.length : a ? e.error(t) : W(t, h).slice(0) }, M = e.compile = function(t, e) {
            var i, n = [],
                r = [],
                o = X[t + " "];
            if (!o) {
                for (e || (e = C(t)), i = e.length; i--;) o = b(e[i]), o[j] ? n.push(o) : r.push(o);
                o = X(t, w(r, n)), o.selector = t
            }
            return o
        }, I = e.select = function(t, e, i, n) {
            var r, o, s, a, h, l = "function" == typeof t && t,
                u = !n && C(t = l.selector || t);
            if (i = i || [], 1 === u.length) {
                if (o = u[0] = u[0].slice(0), o.length > 2 && "ID" === (s = o[0]).type && E.getById && 9 === e.nodeType && O && S.relative[o[1].type]) {
                    if (e = (S.find.ID(s.matches[0].replace(bt, wt), e) || [])[0], !e) return i;
                    l && (e = e.parentNode), t = t.slice(o.shift().value.length)
                }
                for (r = ft.needsContext.test(t) ? 0 : o.length; r-- && (s = o[r], !S.relative[a = s.type]);)
                    if ((h = S.find[a]) && (n = h(s.matches[0].replace(bt, wt), vt.test(o[0].type) && p(e.parentNode) || e))) { if (o.splice(r, 1), t = n.length && f(o), !t) return J.apply(i, n), i; break }
            }
            return (l || M(t, u))(n, e, !O, i, !e || vt.test(t) && p(e.parentNode) || e), i
        }, E.sortStable = j.split("").sort(H).join("") === j, E.detectDuplicates = !!A, R(), E.sortDetached = r(function(t) { return 1 & t.compareDocumentPosition(_.createElement("fieldset")) }), r(function(t) { return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href") }) || o("type|href|height|width", function(t, e, i) { if (!i) return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2) }), E.attributes && r(function(t) { return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute("value") }) || o("value", function(t, e, i) { if (!i && "input" === t.nodeName.toLowerCase()) return t.defaultValue }), r(function(t) { return null == t.getAttribute("disabled") }) || o(et, function(t, e, i) { var n; if (!i) return t[e] === !0 ? e.toLowerCase() : (n = t.getAttributeNode(e)) && n.specified ? n.value : null }), e
    }(t);
    ct.find = mt, ct.expr = mt.selectors, ct.expr[":"] = ct.expr.pseudos, ct.uniqueSort = ct.unique = mt.uniqueSort, ct.text = mt.getText, ct.isXMLDoc = mt.isXML, ct.contains = mt.contains, ct.escapeSelector = mt.escape;
    var vt = function(t, e, i) {
            for (var n = [], r = void 0 !== i;
                (t = t[e]) && 9 !== t.nodeType;)
                if (1 === t.nodeType) {
                    if (r && ct(t).is(i)) break;
                    n.push(t)
                }
            return n
        },
        bt = function(t, e) { for (var i = []; t; t = t.nextSibling) 1 === t.nodeType && t !== e && i.push(t); return i },
        wt = ct.expr.match.needsContext,
        xt = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,
        Et = /^.[^:#\[\.,]*$/;
    ct.filter = function(t, e, i) { var n = e[0]; return i && (t = ":not(" + t + ")"), 1 === e.length && 1 === n.nodeType ? ct.find.matchesSelector(n, t) ? [n] : [] : ct.find.matches(t, ct.grep(e, function(t) { return 1 === t.nodeType })) }, ct.fn.extend({
        find: function(t) {
            var e, i, n = this.length,
                r = this;
            if ("string" != typeof t) return this.pushStack(ct(t).filter(function() {
                for (e = 0; e < n; e++)
                    if (ct.contains(r[e], this)) return !0
            }));
            for (i = this.pushStack([]), e = 0; e < n; e++) ct.find(t, r[e], i);
            return n > 1 ? ct.uniqueSort(i) : i
        },
        filter: function(t) { return this.pushStack(r(this, t || [], !1)) },
        not: function(t) { return this.pushStack(r(this, t || [], !0)) },
        is: function(t) { return !!r(this, "string" == typeof t && wt.test(t) ? ct(t) : t || [], !1).length }
    });
    var St, Nt = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
        Lt = ct.fn.init = function(t, e, i) {
            var n, r;
            if (!t) return this;
            if (i = i || St, "string" == typeof t) {
                if (n = "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3 ? [null, t, null] : Nt.exec(t), !n || !n[1] && e) return !e || e.jquery ? (e || i).find(t) : this.constructor(e).find(t);
                if (n[1]) {
                    if (e = e instanceof ct ? e[0] : e, ct.merge(this, ct.parseHTML(n[1], e && e.nodeType ? e.ownerDocument || e : Q, !0)), xt.test(n[1]) && ct.isPlainObject(e))
                        for (n in e) ct.isFunction(this[n]) ? this[n](e[n]) : this.attr(n, e[n]);
                    return this
                }
                return r = Q.getElementById(n[2]), r && (this[0] = r, this.length = 1), this
            }
            return t.nodeType ? (this[0] = t, this.length = 1, this) : ct.isFunction(t) ? void 0 !== i.ready ? i.ready(t) : t(ct) : ct.makeArray(t, this)
        };
    Lt.prototype = ct.fn, St = ct(Q);
    var Ct = /^(?:parents|prev(?:Until|All))/,
        Mt = { children: !0, contents: !0, next: !0, prev: !0 };
    ct.fn.extend({
        has: function(t) {
            var e = ct(t, this),
                i = e.length;
            return this.filter(function() {
                for (var t = 0; t < i; t++)
                    if (ct.contains(this, e[t])) return !0
            })
        },
        closest: function(t, e) {
            var i, n = 0,
                r = this.length,
                o = [],
                s = "string" != typeof t && ct(t);
            if (!wt.test(t))
                for (; n < r; n++)
                    for (i = this[n]; i && i !== e; i = i.parentNode)
                        if (i.nodeType < 11 && (s ? s.index(i) > -1 : 1 === i.nodeType && ct.find.matchesSelector(i, t))) { o.push(i); break }
            return this.pushStack(o.length > 1 ? ct.uniqueSort(o) : o)
        },
        index: function(t) { return t ? "string" == typeof t ? rt.call(ct(t), this[0]) : rt.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 },
        add: function(t, e) { return this.pushStack(ct.uniqueSort(ct.merge(this.get(), ct(t, e)))) },
        addBack: function(t) { return this.add(null == t ? this.prevObject : this.prevObject.filter(t)) }
    }), ct.each({ parent: function(t) { var e = t.parentNode; return e && 11 !== e.nodeType ? e : null }, parents: function(t) { return vt(t, "parentNode") }, parentsUntil: function(t, e, i) { return vt(t, "parentNode", i) }, next: function(t) { return o(t, "nextSibling") }, prev: function(t) { return o(t, "previousSibling") }, nextAll: function(t) { return vt(t, "nextSibling") }, prevAll: function(t) { return vt(t, "previousSibling") }, nextUntil: function(t, e, i) { return vt(t, "nextSibling", i) }, prevUntil: function(t, e, i) { return vt(t, "previousSibling", i) }, siblings: function(t) { return bt((t.parentNode || {}).firstChild, t) }, children: function(t) { return bt(t.firstChild) }, contents: function(t) { return t.contentDocument || ct.merge([], t.childNodes) } }, function(t, e) { ct.fn[t] = function(i, n) { var r = ct.map(this, e, i); return "Until" !== t.slice(-5) && (n = i), n && "string" == typeof n && (r = ct.filter(n, r)), this.length > 1 && (Mt[t] || ct.uniqueSort(r), Ct.test(t) && r.reverse()), this.pushStack(r) } });
    var It = /\S+/g;
    ct.Callbacks = function(t) {
        t = "string" == typeof t ? s(t) : ct.extend({}, t);
        var e, i, n, r, o = [],
            a = [],
            h = -1,
            l = function() {
                for (r = t.once, n = e = !0; a.length; h = -1)
                    for (i = a.shift(); ++h < o.length;) o[h].apply(i[0], i[1]) === !1 && t.stopOnFalse && (h = o.length, i = !1);
                t.memory || (i = !1), e = !1, r && (o = i ? [] : "")
            },
            u = {
                add: function() { return o && (i && !e && (h = o.length - 1, a.push(i)), function e(i) { ct.each(i, function(i, n) { ct.isFunction(n) ? t.unique && u.has(n) || o.push(n) : n && n.length && "string" !== ct.type(n) && e(n) }) }(arguments), i && !e && l()), this },
                remove: function() {
                    return ct.each(arguments, function(t, e) {
                        for (var i;
                            (i = ct.inArray(e, o, i)) > -1;) o.splice(i, 1), i <= h && h--
                    }), this
                },
                has: function(t) { return t ? ct.inArray(t, o) > -1 : o.length > 0 },
                empty: function() { return o && (o = []), this },
                disable: function() { return r = a = [], o = i = "", this },
                disabled: function() { return !o },
                lock: function() { return r = a = [], i || e || (o = i = ""), this },
                locked: function() { return !!r },
                fireWith: function(t, i) { return r || (i = i || [], i = [t, i.slice ? i.slice() : i], a.push(i), e || l()), this },
                fire: function() { return u.fireWith(this, arguments), this },
                fired: function() { return !!n }
            };
        return u
    }, ct.extend({
        Deferred: function(e) {
            var i = [
                    ["notify", "progress", ct.Callbacks("memory"), ct.Callbacks("memory"), 2],
                    ["resolve", "done", ct.Callbacks("once memory"), ct.Callbacks("once memory"), 0, "resolved"],
                    ["reject", "fail", ct.Callbacks("once memory"), ct.Callbacks("once memory"), 1, "rejected"]
                ],
                n = "pending",
                r = {
                    state: function() { return n },
                    always: function() { return o.done(arguments).fail(arguments), this },
                    catch: function(t) { return r.then(null, t) },
                    pipe: function() {
                        var t = arguments;
                        return ct.Deferred(function(e) {
                            ct.each(i, function(i, n) {
                                var r = ct.isFunction(t[n[4]]) && t[n[4]];
                                o[n[1]](function() {
                                    var t = r && r.apply(this, arguments);
                                    t && ct.isFunction(t.promise) ? t.promise().progress(e.notify).done(e.resolve).fail(e.reject) : e[n[0] + "With"](this, r ? [t] : arguments)
                                })
                            }), t = null
                        }).promise()
                    },
                    then: function(e, n, r) {
                        function o(e, i, n, r) {
                            return function() {
                                var l = this,
                                    u = arguments,
                                    p = function() {
                                        var t, p;
                                        if (!(e < s)) {
                                            if (t = n.apply(l, u), t === i.promise()) throw new TypeError("Thenable self-resolution");
                                            p = t && ("object" == typeof t || "function" == typeof t) && t.then, ct.isFunction(p) ? r ? p.call(t, o(s, i, a, r), o(s, i, h, r)) : (s++, p.call(t, o(s, i, a, r), o(s, i, h, r), o(s, i, a, i.notifyWith))) : (n !== a && (l = void 0, u = [t]), (r || i.resolveWith)(l, u))
                                        }
                                    },
                                    c = r ? p : function() { try { p() } catch (t) { ct.Deferred.exceptionHook && ct.Deferred.exceptionHook(t, c.stackTrace), e + 1 >= s && (n !== h && (l = void 0, u = [t]), i.rejectWith(l, u)) } };
                                e ? c() : (ct.Deferred.getStackHook && (c.stackTrace = ct.Deferred.getStackHook()), t.setTimeout(c))
                            }
                        }
                        var s = 0;
                        return ct.Deferred(function(t) { i[0][3].add(o(0, t, ct.isFunction(r) ? r : a, t.notifyWith)), i[1][3].add(o(0, t, ct.isFunction(e) ? e : a)), i[2][3].add(o(0, t, ct.isFunction(n) ? n : h)) }).promise()
                    },
                    promise: function(t) { return null != t ? ct.extend(t, r) : r }
                },
                o = {};
            return ct.each(i, function(t, e) {
                var s = e[2],
                    a = e[5];
                r[e[1]] = s.add, a && s.add(function() { n = a }, i[3 - t][2].disable, i[0][2].lock), s.add(e[3].fire), o[e[0]] = function() { return o[e[0] + "With"](this === o ? void 0 : this, arguments), this }, o[e[0] + "With"] = s.fireWith
            }), r.promise(o), e && e.call(o, o), o
        },
        when: function(t) {
            var e = arguments.length,
                i = e,
                n = Array(i),
                r = et.call(arguments),
                o = ct.Deferred(),
                s = function(t) { return function(i) { n[t] = this, r[t] = arguments.length > 1 ? et.call(arguments) : i, --e || o.resolveWith(n, r) } };
            if (e <= 1 && (l(t, o.done(s(i)).resolve, o.reject), "pending" === o.state() || ct.isFunction(r[i] && r[i].then))) return o.then();
            for (; i--;) l(r[i], s(i), o.reject);
            return o.promise()
        }
    });
    var kt = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    ct.Deferred.exceptionHook = function(e, i) { t.console && t.console.warn && e && kt.test(e.name) && t.console.warn("jQuery.Deferred exception: " + e.message, e.stack, i) }, ct.readyException = function(e) { t.setTimeout(function() { throw e }) };
    var Tt = ct.Deferred();
    ct.fn.ready = function(t) { return Tt.then(t).catch(function(t) { ct.readyException(t) }), this }, ct.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(t) { t ? ct.readyWait++ : ct.ready(!0) },
        ready: function(t) {
            (t === !0 ? --ct.readyWait : ct.isReady) || (ct.isReady = !0, t !== !0 && --ct.readyWait > 0 || Tt.resolveWith(Q, [ct]))
        }
    }), ct.ready.then = Tt.then, "complete" === Q.readyState || "loading" !== Q.readyState && !Q.documentElement.doScroll ? t.setTimeout(ct.ready) : (Q.addEventListener("DOMContentLoaded", u), t.addEventListener("load", u));
    var At = function(t, e, i, n, r, o, s) {
            var a = 0,
                h = t.length,
                l = null == i;
            if ("object" === ct.type(i)) { r = !0; for (a in i) At(t, e, a, i[a], !0, o, s) } else if (void 0 !== n && (r = !0, ct.isFunction(n) || (s = !0), l && (s ? (e.call(t, n), e = null) : (l = e, e = function(t, e, i) { return l.call(ct(t), i) })), e))
                for (; a < h; a++) e(t[a], i, s ? n : n.call(t[a], a, e(t[a], i)));
            return r ? t : l ? e.call(t) : h ? e(t[0], i) : o
        },
        Rt = function(t) { return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType };
    p.uid = 1, p.prototype = {
        cache: function(t) { var e = t[this.expando]; return e || (e = {}, Rt(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, { value: e, configurable: !0 }))), e },
        set: function(t, e, i) {
            var n, r = this.cache(t);
            if ("string" == typeof e) r[ct.camelCase(e)] = i;
            else
                for (n in e) r[ct.camelCase(n)] = e[n];
            return r
        },
        get: function(t, e) { return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][ct.camelCase(e)] },
        access: function(t, e, i) { return void 0 === e || e && "string" == typeof e && void 0 === i ? this.get(t, e) : (this.set(t, e, i), void 0 !== i ? i : e) },
        remove: function(t, e) { var i, n = t[this.expando]; if (void 0 !== n) { if (void 0 !== e) { ct.isArray(e) ? e = e.map(ct.camelCase) : (e = ct.camelCase(e), e = e in n ? [e] : e.match(It) || []), i = e.length; for (; i--;) delete n[e[i]] }(void 0 === e || ct.isEmptyObject(n)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando]) } },
        hasData: function(t) { var e = t[this.expando]; return void 0 !== e && !ct.isEmptyObject(e) }
    };
    var _t = new p,
        Pt = new p,
        Ot = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        Dt = /[A-Z]/g;
    ct.extend({ hasData: function(t) { return Pt.hasData(t) || _t.hasData(t) }, data: function(t, e, i) { return Pt.access(t, e, i) }, removeData: function(t, e) { Pt.remove(t, e) }, _data: function(t, e, i) { return _t.access(t, e, i) }, _removeData: function(t, e) { _t.remove(t, e) } }), ct.fn.extend({
        data: function(t, e) {
            var i, n, r, o = this[0],
                s = o && o.attributes;
            if (void 0 === t) {
                if (this.length && (r = Pt.get(o), 1 === o.nodeType && !_t.get(o, "hasDataAttrs"))) {
                    for (i = s.length; i--;) s[i] && (n = s[i].name, 0 === n.indexOf("data-") && (n = ct.camelCase(n.slice(5)), c(o, n, r[n])));
                    _t.set(o, "hasDataAttrs", !0)
                }
                return r
            }
            return "object" == typeof t ? this.each(function() { Pt.set(this, t) }) : At(this, function(e) { var i; if (o && void 0 === e) { if (i = Pt.get(o, t), void 0 !== i) return i; if (i = c(o, t), void 0 !== i) return i } else this.each(function() { Pt.set(this, t, e) }) }, null, e, arguments.length > 1, null, !0)
        },
        removeData: function(t) { return this.each(function() { Pt.remove(this, t) }) }
    }), ct.extend({
        queue: function(t, e, i) { var n; if (t) return e = (e || "fx") + "queue", n = _t.get(t, e), i && (!n || ct.isArray(i) ? n = _t.access(t, e, ct.makeArray(i)) : n.push(i)), n || [] },
        dequeue: function(t, e) {
            e = e || "fx";
            var i = ct.queue(t, e),
                n = i.length,
                r = i.shift(),
                o = ct._queueHooks(t, e),
                s = function() { ct.dequeue(t, e) };
            "inprogress" === r && (r = i.shift(), n--), r && ("fx" === e && i.unshift("inprogress"), delete o.stop, r.call(t, s, o)), !n && o && o.empty.fire()
        },
        _queueHooks: function(t, e) { var i = e + "queueHooks"; return _t.get(t, i) || _t.access(t, i, { empty: ct.Callbacks("once memory").add(function() { _t.remove(t, [e + "queue", i]) }) }) }
    }), ct.fn.extend({
        queue: function(t, e) {
            var i = 2;
            return "string" != typeof t && (e = t, t = "fx", i--), arguments.length < i ? ct.queue(this[0], t) : void 0 === e ? this : this.each(function() {
                var i = ct.queue(this, t, e);
                ct._queueHooks(this, t), "fx" === t && "inprogress" !== i[0] && ct.dequeue(this, t)
            })
        },
        dequeue: function(t) { return this.each(function() { ct.dequeue(this, t) }) },
        clearQueue: function(t) { return this.queue(t || "fx", []) },
        promise: function(t, e) {
            var i, n = 1,
                r = ct.Deferred(),
                o = this,
                s = this.length,
                a = function() {--n || r.resolveWith(o, [o]) };
            for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; s--;) i = _t.get(o[s], t + "queueHooks"), i && i.empty && (n++, i.empty.add(a));
            return a(), r.promise(e)
        }
    });
    var Ft = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        Ut = new RegExp("^(?:([+-])=|)(" + Ft + ")([a-z%]*)$", "i"),
        Bt = ["Top", "Right", "Bottom", "Left"],
        jt = function(t, e) { return t = e || t, "none" === t.style.display || "" === t.style.display && ct.contains(t.ownerDocument, t) && "none" === ct.css(t, "display") },
        zt = function(t, e, i, n) {
            var r, o, s = {};
            for (o in e) s[o] = t.style[o], t.style[o] = e[o];
            r = i.apply(t, n || []);
            for (o in e) t.style[o] = s[o];
            return r
        },
        Gt = {};
    ct.fn.extend({ show: function() { return d(this, !0) }, hide: function() { return d(this) }, toggle: function(t) { return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each(function() { jt(this) ? ct(this).show() : ct(this).hide() }) } });
    var qt = /^(?:checkbox|radio)$/i,
        Vt = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i,
        Wt = /^$|\/(?:java|ecma)script/i,
        Xt = { option: [1, "<select multiple='multiple'>", "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] };
    Xt.optgroup = Xt.option, Xt.tbody = Xt.tfoot = Xt.colgroup = Xt.caption = Xt.thead, Xt.th = Xt.td;
    var Ht = /<|&#?\w+;/;
    ! function() {
        var t = Q.createDocumentFragment(),
            e = t.appendChild(Q.createElement("div")),
            i = Q.createElement("input");
        i.setAttribute("type", "radio"), i.setAttribute("checked", "checked"), i.setAttribute("name", "t"), e.appendChild(i), ut.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, e.innerHTML = "<textarea>x</textarea>", ut.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue
    }();
    var Yt = Q.documentElement,
        Kt = /^key/,
        $t = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        Zt = /^([^.]*)(?:\.(.+)|)/;
    ct.event = {
        global: {},
        add: function(t, e, i, n, r) {
            var o, s, a, h, l, u, p, c, f, g, d, y = _t.get(t);
            if (y)
                for (i.handler && (o = i, i = o.handler, r = o.selector), r && ct.find.matchesSelector(Yt, r), i.guid || (i.guid = ct.guid++), (h = y.events) || (h = y.events = {}), (s = y.handle) || (s = y.handle = function(e) { return "undefined" != typeof ct && ct.event.triggered !== e.type ? ct.event.dispatch.apply(t, arguments) : void 0 }), e = (e || "").match(It) || [""], l = e.length; l--;) a = Zt.exec(e[l]) || [], f = d = a[1], g = (a[2] || "").split(".").sort(), f && (p = ct.event.special[f] || {}, f = (r ? p.delegateType : p.bindType) || f, p = ct.event.special[f] || {}, u = ct.extend({ type: f, origType: d, data: n, handler: i, guid: i.guid, selector: r, needsContext: r && ct.expr.match.needsContext.test(r), namespace: g.join(".") }, o), (c = h[f]) || (c = h[f] = [], c.delegateCount = 0, p.setup && p.setup.call(t, n, g, s) !== !1 || t.addEventListener && t.addEventListener(f, s)), p.add && (p.add.call(t, u), u.handler.guid || (u.handler.guid = i.guid)), r ? c.splice(c.delegateCount++, 0, u) : c.push(u), ct.event.global[f] = !0)
        },
        remove: function(t, e, i, n, r) {
            var o, s, a, h, l, u, p, c, f, g, d, y = _t.hasData(t) && _t.get(t);
            if (y && (h = y.events)) {
                for (e = (e || "").match(It) || [""], l = e.length; l--;)
                    if (a = Zt.exec(e[l]) || [], f = d = a[1], g = (a[2] || "").split(".").sort(), f) {
                        for (p = ct.event.special[f] || {}, f = (n ? p.delegateType : p.bindType) || f, c = h[f] || [], a = a[2] && new RegExp("(^|\\.)" + g.join("\\.(?:.*\\.|)") + "(\\.|$)"), s = o = c.length; o--;) u = c[o], !r && d !== u.origType || i && i.guid !== u.guid || a && !a.test(u.namespace) || n && n !== u.selector && ("**" !== n || !u.selector) || (c.splice(o, 1), u.selector && c.delegateCount--, p.remove && p.remove.call(t, u));
                        s && !c.length && (p.teardown && p.teardown.call(t, g, y.handle) !== !1 || ct.removeEvent(t, f, y.handle), delete h[f])
                    } else
                        for (f in h) ct.event.remove(t, f + e[l], i, n, !0);
                ct.isEmptyObject(h) && _t.remove(t, "handle events")
            }
        },
        dispatch: function(t) {
            var e, i, n, r, o, s, a = ct.event.fix(t),
                h = new Array(arguments.length),
                l = (_t.get(this, "events") || {})[a.type] || [],
                u = ct.event.special[a.type] || {};
            for (h[0] = a, e = 1; e < arguments.length; e++) h[e] = arguments[e];
            if (a.delegateTarget = this, !u.preDispatch || u.preDispatch.call(this, a) !== !1) {
                for (s = ct.event.handlers.call(this, a, l), e = 0;
                    (r = s[e++]) && !a.isPropagationStopped();)
                    for (a.currentTarget = r.elem, i = 0;
                        (o = r.handlers[i++]) && !a.isImmediatePropagationStopped();) a.rnamespace && !a.rnamespace.test(o.namespace) || (a.handleObj = o, a.data = o.data, n = ((ct.event.special[o.origType] || {}).handle || o.handler).apply(r.elem, h), void 0 !== n && (a.result = n) === !1 && (a.preventDefault(), a.stopPropagation()));
                return u.postDispatch && u.postDispatch.call(this, a), a.result
            }
        },
        handlers: function(t, e) {
            var i, n, r, o, s = [],
                a = e.delegateCount,
                h = t.target;
            if (a && h.nodeType && ("click" !== t.type || isNaN(t.button) || t.button < 1))
                for (; h !== this; h = h.parentNode || this)
                    if (1 === h.nodeType && (h.disabled !== !0 || "click" !== t.type)) {
                        for (n = [], i = 0; i < a; i++) o = e[i], r = o.selector + " ", void 0 === n[r] && (n[r] = o.needsContext ? ct(r, this).index(h) > -1 : ct.find(r, this, null, [h]).length), n[r] && n.push(o);
                        n.length && s.push({ elem: h, handlers: n })
                    }
            return a < e.length && s.push({ elem: this, handlers: e.slice(a) }), s
        },
        addProp: function(t, e) { Object.defineProperty(ct.Event.prototype, t, { enumerable: !0, configurable: !0, get: ct.isFunction(e) ? function() { if (this.originalEvent) return e(this.originalEvent) } : function() { if (this.originalEvent) return this.originalEvent[t] }, set: function(e) { Object.defineProperty(this, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) } }) },
        fix: function(t) { return t[ct.expando] ? t : new ct.Event(t) },
        special: { load: { noBubble: !0 }, focus: { trigger: function() { if (this !== x() && this.focus) return this.focus(), !1 }, delegateType: "focusin" }, blur: { trigger: function() { if (this === x() && this.blur) return this.blur(), !1 }, delegateType: "focusout" }, click: { trigger: function() { if ("checkbox" === this.type && this.click && ct.nodeName(this, "input")) return this.click(), !1 }, _default: function(t) { return ct.nodeName(t.target, "a") } }, beforeunload: { postDispatch: function(t) { void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result) } } }
    }, ct.removeEvent = function(t, e, i) { t.removeEventListener && t.removeEventListener(e, i) }, ct.Event = function(t, e) { return this instanceof ct.Event ? (t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && t.returnValue === !1 ? b : w, this.target = t.target && 3 === t.target.nodeType ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget) : this.type = t, e && ct.extend(this, e), this.timeStamp = t && t.timeStamp || ct.now(), void(this[ct.expando] = !0)) : new ct.Event(t, e) }, ct.Event.prototype = {
        constructor: ct.Event,
        isDefaultPrevented: w,
        isPropagationStopped: w,
        isImmediatePropagationStopped: w,
        isSimulated: !1,
        preventDefault: function() {
            var t = this.originalEvent;
            this.isDefaultPrevented = b, t && !this.isSimulated && t.preventDefault()
        },
        stopPropagation: function() {
            var t = this.originalEvent;
            this.isPropagationStopped = b, t && !this.isSimulated && t.stopPropagation()
        },
        stopImmediatePropagation: function() {
            var t = this.originalEvent;
            this.isImmediatePropagationStopped = b, t && !this.isSimulated && t.stopImmediatePropagation(), this.stopPropagation()
        }
    }, ct.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, char: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: function(t) { var e = t.button; return null == t.which && Kt.test(t.type) ? null != t.charCode ? t.charCode : t.keyCode : !t.which && void 0 !== e && $t.test(t.type) ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : t.which } }, ct.event.addProp), ct.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function(t, e) {
        ct.event.special[t] = {
            delegateType: e,
            bindType: e,
            handle: function(t) {
                var i, n = this,
                    r = t.relatedTarget,
                    o = t.handleObj;
                return r && (r === n || ct.contains(n, r)) || (t.type = o.origType, i = o.handler.apply(this, arguments), t.type = e), i
            }
        }
    }), ct.fn.extend({ on: function(t, e, i, n) { return E(this, t, e, i, n) }, one: function(t, e, i, n) { return E(this, t, e, i, n, 1) }, off: function(t, e, i) { var n, r; if (t && t.preventDefault && t.handleObj) return n = t.handleObj, ct(t.delegateTarget).off(n.namespace ? n.origType + "." + n.namespace : n.origType, n.selector, n.handler), this; if ("object" == typeof t) { for (r in t) this.off(r, e, t[r]); return this } return e !== !1 && "function" != typeof e || (i = e, e = void 0), i === !1 && (i = w), this.each(function() { ct.event.remove(this, t, i, e) }) } });
    var Jt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
        Qt = /<script|<style|<link/i,
        te = /checked\s*(?:[^=]|=\s*.checked.)/i,
        ee = /^true\/(.*)/,
        ie = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    ct.extend({
        htmlPrefilter: function(t) { return t.replace(Jt, "<$1></$2>") },
        clone: function(t, e, i) {
            var n, r, o, s, a = t.cloneNode(!0),
                h = ct.contains(t.ownerDocument, t);
            if (!(ut.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || ct.isXMLDoc(t)))
                for (s = y(a), o = y(t), n = 0, r = o.length; n < r; n++) M(o[n], s[n]);
            if (e)
                if (i)
                    for (o = o || y(t), s = s || y(a), n = 0, r = o.length; n < r; n++) C(o[n], s[n]);
                else C(t, a);
            return s = y(a, "script"), s.length > 0 && m(s, !h && y(t, "script")), a
        },
        cleanData: function(t) {
            for (var e, i, n, r = ct.event.special, o = 0; void 0 !== (i = t[o]); o++)
                if (Rt(i)) {
                    if (e = i[_t.expando]) {
                        if (e.events)
                            for (n in e.events) r[n] ? ct.event.remove(i, n) : ct.removeEvent(i, n, e.handle);
                        i[_t.expando] = void 0
                    }
                    i[Pt.expando] && (i[Pt.expando] = void 0)
                }
        }
    }), ct.fn.extend({
        detach: function(t) { return k(this, t, !0) },
        remove: function(t) { return k(this, t) },
        text: function(t) { return At(this, function(t) { return void 0 === t ? ct.text(this) : this.empty().each(function() { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t) }) }, null, t, arguments.length) },
        append: function() {
            return I(this, arguments, function(t) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var e = S(this, t);
                    e.appendChild(t)
                }
            })
        },
        prepend: function() {
            return I(this, arguments, function(t) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var e = S(this, t);
                    e.insertBefore(t, e.firstChild)
                }
            })
        },
        before: function() { return I(this, arguments, function(t) { this.parentNode && this.parentNode.insertBefore(t, this) }) },
        after: function() { return I(this, arguments, function(t) { this.parentNode && this.parentNode.insertBefore(t, this.nextSibling) }) },
        empty: function() { for (var t, e = 0; null != (t = this[e]); e++) 1 === t.nodeType && (ct.cleanData(y(t, !1)), t.textContent = ""); return this },
        clone: function(t, e) { return t = null != t && t, e = null == e ? t : e, this.map(function() { return ct.clone(this, t, e) }) },
        html: function(t) {
            return At(this, function(t) {
                var e = this[0] || {},
                    i = 0,
                    n = this.length;
                if (void 0 === t && 1 === e.nodeType) return e.innerHTML;
                if ("string" == typeof t && !Qt.test(t) && !Xt[(Vt.exec(t) || ["", ""])[1].toLowerCase()]) {
                    t = ct.htmlPrefilter(t);
                    try {
                        for (; i < n; i++) e = this[i] || {}, 1 === e.nodeType && (ct.cleanData(y(e, !1)), e.innerHTML = t);
                        e = 0
                    } catch (t) {}
                }
                e && this.empty().append(t)
            }, null, t, arguments.length)
        },
        replaceWith: function() {
            var t = [];
            return I(this, arguments, function(e) {
                var i = this.parentNode;
                ct.inArray(this, t) < 0 && (ct.cleanData(y(this)), i && i.replaceChild(e, this))
            }, t)
        }
    }), ct.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function(t, e) { ct.fn[t] = function(t) { for (var i, n = [], r = ct(t), o = r.length - 1, s = 0; s <= o; s++) i = s === o ? this : this.clone(!0), ct(r[s])[e](i), nt.apply(n, i.get()); return this.pushStack(n) } });
    var ne = /^margin/,
        re = new RegExp("^(" + Ft + ")(?!px)[a-z%]+$", "i"),
        oe = function(e) { var i = e.ownerDocument.defaultView; return i && i.opener || (i = t), i.getComputedStyle(e) };
    ! function() {
        function e() {
            if (a) {
                a.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", a.innerHTML = "", Yt.appendChild(s);
                var e = t.getComputedStyle(a);
                i = "1%" !== e.top, o = "2px" === e.marginLeft, n = "4px" === e.width, a.style.marginRight = "50%", r = "4px" === e.marginRight, Yt.removeChild(s), a = null
            }
        }
        var i, n, r, o, s = Q.createElement("div"),
            a = Q.createElement("div");
        a.style && (a.style.backgroundClip = "content-box", a.cloneNode(!0).style.backgroundClip = "", ut.clearCloneStyle = "content-box" === a.style.backgroundClip, s.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", s.appendChild(a), ct.extend(ut, { pixelPosition: function() { return e(), i }, boxSizingReliable: function() { return e(), n }, pixelMarginRight: function() { return e(), r }, reliableMarginLeft: function() { return e(), o } }))
    }();
    var se = /^(none|table(?!-c[ea]).+)/,
        ae = { position: "absolute", visibility: "hidden", display: "block" },
        he = { letterSpacing: "0", fontWeight: "400" },
        le = ["Webkit", "Moz", "ms"],
        ue = Q.createElement("div").style;
    ct.extend({
        cssHooks: { opacity: { get: function(t, e) { if (e) { var i = T(t, "opacity"); return "" === i ? "1" : i } } } },
        cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 },
        cssProps: { float: "cssFloat" },
        style: function(t, e, i, n) {
            if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
                var r, o, s, a = ct.camelCase(e),
                    h = t.style;
                return e = ct.cssProps[a] || (ct.cssProps[a] = R(a) || a), s = ct.cssHooks[e] || ct.cssHooks[a], void 0 === i ? s && "get" in s && void 0 !== (r = s.get(t, !1, n)) ? r : h[e] : (o = typeof i, "string" === o && (r = Ut.exec(i)) && r[1] && (i = f(t, e, r), o = "number"), null != i && i === i && ("number" === o && (i += r && r[3] || (ct.cssNumber[a] ? "" : "px")), ut.clearCloneStyle || "" !== i || 0 !== e.indexOf("background") || (h[e] = "inherit"), s && "set" in s && void 0 === (i = s.set(t, i, n)) || (h[e] = i)), void 0)
            }
        },
        css: function(t, e, i, n) { var r, o, s, a = ct.camelCase(e); return e = ct.cssProps[a] || (ct.cssProps[a] = R(a) || a), s = ct.cssHooks[e] || ct.cssHooks[a], s && "get" in s && (r = s.get(t, !0, i)), void 0 === r && (r = T(t, e, n)), "normal" === r && e in he && (r = he[e]), "" === i || i ? (o = parseFloat(r), i === !0 || isFinite(o) ? o || 0 : r) : r }
    }), ct.each(["height", "width"], function(t, e) {
        ct.cssHooks[e] = {
            get: function(t, i, n) { if (i) return !se.test(ct.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect().width ? O(t, e, n) : zt(t, ae, function() { return O(t, e, n) }) },
            set: function(t, i, n) {
                var r, o = n && oe(t),
                    s = n && P(t, e, n, "border-box" === ct.css(t, "boxSizing", !1, o), o);
                return s && (r = Ut.exec(i)) && "px" !== (r[3] || "px") && (t.style[e] = i, i = ct.css(t, e)), _(t, i, s)
            }
        }
    }), ct.cssHooks.marginLeft = A(ut.reliableMarginLeft, function(t, e) { if (e) return (parseFloat(T(t, "marginLeft")) || t.getBoundingClientRect().left - zt(t, { marginLeft: 0 }, function() { return t.getBoundingClientRect().left })) + "px" }), ct.each({ margin: "", padding: "", border: "Width" }, function(t, e) { ct.cssHooks[t + e] = { expand: function(i) { for (var n = 0, r = {}, o = "string" == typeof i ? i.split(" ") : [i]; n < 4; n++) r[t + Bt[n] + e] = o[n] || o[n - 2] || o[0]; return r } }, ne.test(t) || (ct.cssHooks[t + e].set = _) }), ct.fn.extend({
        css: function(t, e) {
            return At(this, function(t, e, i) {
                var n, r, o = {},
                    s = 0;
                if (ct.isArray(e)) { for (n = oe(t), r = e.length; s < r; s++) o[e[s]] = ct.css(t, e[s], !1, n); return o }
                return void 0 !== i ? ct.style(t, e, i) : ct.css(t, e)
            }, t, e, arguments.length > 1)
        }
    }), ct.Tween = D, D.prototype = { constructor: D, init: function(t, e, i, n, r, o) { this.elem = t, this.prop = i, this.easing = r || ct.easing._default, this.options = e, this.start = this.now = this.cur(), this.end = n, this.unit = o || (ct.cssNumber[i] ? "" : "px") }, cur: function() { var t = D.propHooks[this.prop]; return t && t.get ? t.get(this) : D.propHooks._default.get(this) }, run: function(t) { var e, i = D.propHooks[this.prop]; return this.options.duration ? this.pos = e = ct.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), i && i.set ? i.set(this) : D.propHooks._default.set(this), this } }, D.prototype.init.prototype = D.prototype, D.propHooks = { _default: { get: function(t) { var e; return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = ct.css(t.elem, t.prop, ""), e && "auto" !== e ? e : 0) }, set: function(t) { ct.fx.step[t.prop] ? ct.fx.step[t.prop](t) : 1 !== t.elem.nodeType || null == t.elem.style[ct.cssProps[t.prop]] && !ct.cssHooks[t.prop] ? t.elem[t.prop] = t.now : ct.style(t.elem, t.prop, t.now + t.unit) } } }, D.propHooks.scrollTop = D.propHooks.scrollLeft = { set: function(t) { t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now) } }, ct.easing = { linear: function(t) { return t }, swing: function(t) { return .5 - Math.cos(t * Math.PI) / 2 }, _default: "swing" }, ct.fx = D.prototype.init, ct.fx.step = {};
    var pe, ce, fe = /^(?:toggle|show|hide)$/,
        ge = /queueHooks$/;
    ct.Animation = ct.extend(q, { tweeners: { "*": [function(t, e) { var i = this.createTween(t, e); return f(i.elem, t, Ut.exec(e), i), i }] }, tweener: function(t, e) { ct.isFunction(t) ? (e = t, t = ["*"]) : t = t.match(It); for (var i, n = 0, r = t.length; n < r; n++) i = t[n], q.tweeners[i] = q.tweeners[i] || [], q.tweeners[i].unshift(e) }, prefilters: [z], prefilter: function(t, e) { e ? q.prefilters.unshift(t) : q.prefilters.push(t) } }), ct.speed = function(t, e, i) { var n = t && "object" == typeof t ? ct.extend({}, t) : { complete: i || !i && e || ct.isFunction(t) && t, duration: t, easing: i && e || e && !ct.isFunction(e) && e }; return ct.fx.off || Q.hidden ? n.duration = 0 : n.duration = "number" == typeof n.duration ? n.duration : n.duration in ct.fx.speeds ? ct.fx.speeds[n.duration] : ct.fx.speeds._default, null != n.queue && n.queue !== !0 || (n.queue = "fx"), n.old = n.complete, n.complete = function() { ct.isFunction(n.old) && n.old.call(this), n.queue && ct.dequeue(this, n.queue) }, n }, ct.fn.extend({
            fadeTo: function(t, e, i, n) { return this.filter(jt).css("opacity", 0).show().end().animate({ opacity: e }, t, i, n) },
            animate: function(t, e, i, n) {
                var r = ct.isEmptyObject(t),
                    o = ct.speed(e, i, n),
                    s = function() {
                        var e = q(this, ct.extend({}, t), o);
                        (r || _t.get(this, "finish")) && e.stop(!0)
                    };
                return s.finish = s, r || o.queue === !1 ? this.each(s) : this.queue(o.queue, s)
            },
            stop: function(t, e, i) {
                var n = function(t) {
                    var e = t.stop;
                    delete t.stop, e(i)
                };
                return "string" != typeof t && (i = e, e = t, t = void 0), e && t !== !1 && this.queue(t || "fx", []), this.each(function() {
                    var e = !0,
                        r = null != t && t + "queueHooks",
                        o = ct.timers,
                        s = _t.get(this);
                    if (r) s[r] && s[r].stop && n(s[r]);
                    else
                        for (r in s) s[r] && s[r].stop && ge.test(r) && n(s[r]);
                    for (r = o.length; r--;) o[r].elem !== this || null != t && o[r].queue !== t || (o[r].anim.stop(i), e = !1, o.splice(r, 1));
                    !e && i || ct.dequeue(this, t)
                })
            },
            finish: function(t) {
                return t !== !1 && (t = t || "fx"), this.each(function() {
                    var e, i = _t.get(this),
                        n = i[t + "queue"],
                        r = i[t + "queueHooks"],
                        o = ct.timers,
                        s = n ? n.length : 0;
                    for (i.finish = !0, ct.queue(this, t, []), r && r.stop && r.stop.call(this, !0), e = o.length; e--;) o[e].elem === this && o[e].queue === t && (o[e].anim.stop(!0), o.splice(e, 1));
                    for (e = 0; e < s; e++) n[e] && n[e].finish && n[e].finish.call(this);
                    delete i.finish
                })
            }
        }), ct.each(["toggle", "show", "hide"], function(t, e) {
            var i = ct.fn[e];
            ct.fn[e] = function(t, n, r) { return null == t || "boolean" == typeof t ? i.apply(this, arguments) : this.animate(B(e, !0), t, n, r) }
        }), ct.each({ slideDown: B("show"), slideUp: B("hide"), slideToggle: B("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function(t, e) { ct.fn[t] = function(t, i, n) { return this.animate(e, t, i, n) } }), ct.timers = [], ct.fx.tick = function() {
            var t, e = 0,
                i = ct.timers;
            for (pe = ct.now(); e < i.length; e++) t = i[e], t() || i[e] !== t || i.splice(e--, 1);
            i.length || ct.fx.stop(), pe = void 0
        }, ct.fx.timer = function(t) { ct.timers.push(t), t() ? ct.fx.start() : ct.timers.pop() }, ct.fx.interval = 13, ct.fx.start = function() { ce || (ce = t.requestAnimationFrame ? t.requestAnimationFrame(F) : t.setInterval(ct.fx.tick, ct.fx.interval)) }, ct.fx.stop = function() { t.cancelAnimationFrame ? t.cancelAnimationFrame(ce) : t.clearInterval(ce), ce = null }, ct.fx.speeds = { slow: 600, fast: 200, _default: 400 }, ct.fn.delay = function(e, i) {
            return e = ct.fx ? ct.fx.speeds[e] || e : e, i = i || "fx", this.queue(i, function(i, n) {
                var r = t.setTimeout(i, e);
                n.stop = function() { t.clearTimeout(r) }
            })
        },
        function() {
            var t = Q.createElement("input"),
                e = Q.createElement("select"),
                i = e.appendChild(Q.createElement("option"));
            t.type = "checkbox", ut.checkOn = "" !== t.value, ut.optSelected = i.selected, t = Q.createElement("input"), t.value = "t", t.type = "radio", ut.radioValue = "t" === t.value
        }();
    var de, ye = ct.expr.attrHandle;
    ct.fn.extend({ attr: function(t, e) { return At(this, ct.attr, t, e, arguments.length > 1) }, removeAttr: function(t) { return this.each(function() { ct.removeAttr(this, t) }) } }), ct.extend({
        attr: function(t, e, i) { var n, r, o = t.nodeType; if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof t.getAttribute ? ct.prop(t, e, i) : (1 === o && ct.isXMLDoc(t) || (r = ct.attrHooks[e.toLowerCase()] || (ct.expr.match.bool.test(e) ? de : void 0)), void 0 !== i ? null === i ? void ct.removeAttr(t, e) : r && "set" in r && void 0 !== (n = r.set(t, i, e)) ? n : (t.setAttribute(e, i + ""), i) : r && "get" in r && null !== (n = r.get(t, e)) ? n : (n = ct.find.attr(t, e), null == n ? void 0 : n)) },
        attrHooks: { type: { set: function(t, e) { if (!ut.radioValue && "radio" === e && ct.nodeName(t, "input")) { var i = t.value; return t.setAttribute("type", e), i && (t.value = i), e } } } },
        removeAttr: function(t, e) {
            var i, n = 0,
                r = e && e.match(It);
            if (r && 1 === t.nodeType)
                for (; i = r[n++];) t.removeAttribute(i)
        }
    }), de = { set: function(t, e, i) { return e === !1 ? ct.removeAttr(t, i) : t.setAttribute(i, i), i } }, ct.each(ct.expr.match.bool.source.match(/\w+/g), function(t, e) {
        var i = ye[e] || ct.find.attr;
        ye[e] = function(t, e, n) { var r, o, s = e.toLowerCase(); return n || (o = ye[s], ye[s] = r, r = null != i(t, e, n) ? s : null, ye[s] = o), r }
    });
    var me = /^(?:input|select|textarea|button)$/i,
        ve = /^(?:a|area)$/i;
    ct.fn.extend({ prop: function(t, e) { return At(this, ct.prop, t, e, arguments.length > 1) }, removeProp: function(t) { return this.each(function() { delete this[ct.propFix[t] || t] }) } }), ct.extend({ prop: function(t, e, i) { var n, r, o = t.nodeType; if (3 !== o && 8 !== o && 2 !== o) return 1 === o && ct.isXMLDoc(t) || (e = ct.propFix[e] || e, r = ct.propHooks[e]), void 0 !== i ? r && "set" in r && void 0 !== (n = r.set(t, i, e)) ? n : t[e] = i : r && "get" in r && null !== (n = r.get(t, e)) ? n : t[e] }, propHooks: { tabIndex: { get: function(t) { var e = ct.find.attr(t, "tabindex"); return e ? parseInt(e, 10) : me.test(t.nodeName) || ve.test(t.nodeName) && t.href ? 0 : -1 } } }, propFix: { for: "htmlFor", class: "className" } }), ut.optSelected || (ct.propHooks.selected = {
        get: function(t) { var e = t.parentNode; return e && e.parentNode && e.parentNode.selectedIndex, null },
        set: function(t) {
            var e = t.parentNode;
            e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex)
        }
    }), ct.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() { ct.propFix[this.toLowerCase()] = this });
    var be = /[\t\r\n\f]/g;
    ct.fn.extend({
        addClass: function(t) {
            var e, i, n, r, o, s, a, h = 0;
            if (ct.isFunction(t)) return this.each(function(e) { ct(this).addClass(t.call(this, e, V(this))) });
            if ("string" == typeof t && t)
                for (e = t.match(It) || []; i = this[h++];)
                    if (r = V(i), n = 1 === i.nodeType && (" " + r + " ").replace(be, " ")) {
                        for (s = 0; o = e[s++];) n.indexOf(" " + o + " ") < 0 && (n += o + " ");
                        a = ct.trim(n), r !== a && i.setAttribute("class", a)
                    }
            return this
        },
        removeClass: function(t) {
            var e, i, n, r, o, s, a, h = 0;
            if (ct.isFunction(t)) return this.each(function(e) { ct(this).removeClass(t.call(this, e, V(this))) });
            if (!arguments.length) return this.attr("class", "");
            if ("string" == typeof t && t)
                for (e = t.match(It) || []; i = this[h++];)
                    if (r = V(i), n = 1 === i.nodeType && (" " + r + " ").replace(be, " ")) {
                        for (s = 0; o = e[s++];)
                            for (; n.indexOf(" " + o + " ") > -1;) n = n.replace(" " + o + " ", " ");
                        a = ct.trim(n), r !== a && i.setAttribute("class", a)
                    }
            return this
        },
        toggleClass: function(t, e) {
            var i = typeof t;
            return "boolean" == typeof e && "string" === i ? e ? this.addClass(t) : this.removeClass(t) : ct.isFunction(t) ? this.each(function(i) { ct(this).toggleClass(t.call(this, i, V(this), e), e) }) : this.each(function() {
                var e, n, r, o;
                if ("string" === i)
                    for (n = 0, r = ct(this), o = t.match(It) || []; e = o[n++];) r.hasClass(e) ? r.removeClass(e) : r.addClass(e);
                else void 0 !== t && "boolean" !== i || (e = V(this), e && _t.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || t === !1 ? "" : _t.get(this, "__className__") || ""))
            })
        },
        hasClass: function(t) {
            var e, i, n = 0;
            for (e = " " + t + " "; i = this[n++];)
                if (1 === i.nodeType && (" " + V(i) + " ").replace(be, " ").indexOf(e) > -1) return !0;
            return !1
        }
    });
    var we = /\r/g,
        xe = /[\x20\t\r\n\f]+/g;
    ct.fn.extend({
        val: function(t) {
            var e, i, n, r = this[0]; {
                if (arguments.length) return n = ct.isFunction(t), this.each(function(i) {
                    var r;
                    1 === this.nodeType && (r = n ? t.call(this, i, ct(this).val()) : t, null == r ? r = "" : "number" == typeof r ? r += "" : ct.isArray(r) && (r = ct.map(r, function(t) { return null == t ? "" : t + "" })), e = ct.valHooks[this.type] || ct.valHooks[this.nodeName.toLowerCase()], e && "set" in e && void 0 !== e.set(this, r, "value") || (this.value = r))
                });
                if (r) return e = ct.valHooks[r.type] || ct.valHooks[r.nodeName.toLowerCase()], e && "get" in e && void 0 !== (i = e.get(r, "value")) ? i : (i = r.value, "string" == typeof i ? i.replace(we, "") : null == i ? "" : i)
            }
        }
    }), ct.extend({
        valHooks: {
            option: { get: function(t) { var e = ct.find.attr(t, "value"); return null != e ? e : ct.trim(ct.text(t)).replace(xe, " ") } },
            select: {
                get: function(t) {
                    for (var e, i, n = t.options, r = t.selectedIndex, o = "select-one" === t.type, s = o ? null : [], a = o ? r + 1 : n.length, h = r < 0 ? a : o ? r : 0; h < a; h++)
                        if (i = n[h], (i.selected || h === r) && !i.disabled && (!i.parentNode.disabled || !ct.nodeName(i.parentNode, "optgroup"))) {
                            if (e = ct(i).val(), o) return e;
                            s.push(e)
                        }
                    return s
                },
                set: function(t, e) { for (var i, n, r = t.options, o = ct.makeArray(e), s = r.length; s--;) n = r[s], (n.selected = ct.inArray(ct.valHooks.option.get(n), o) > -1) && (i = !0); return i || (t.selectedIndex = -1), o }
            }
        }
    }), ct.each(["radio", "checkbox"], function() { ct.valHooks[this] = { set: function(t, e) { if (ct.isArray(e)) return t.checked = ct.inArray(ct(t).val(), e) > -1 } }, ut.checkOn || (ct.valHooks[this].get = function(t) { return null === t.getAttribute("value") ? "on" : t.value }) });
    var Ee = /^(?:focusinfocus|focusoutblur)$/;
    ct.extend(ct.event, {
        trigger: function(e, i, n, r) {
            var o, s, a, h, l, u, p, c = [n || Q],
                f = at.call(e, "type") ? e.type : e,
                g = at.call(e, "namespace") ? e.namespace.split(".") : [];
            if (s = a = n = n || Q, 3 !== n.nodeType && 8 !== n.nodeType && !Ee.test(f + ct.event.triggered) && (f.indexOf(".") > -1 && (g = f.split("."), f = g.shift(), g.sort()), l = f.indexOf(":") < 0 && "on" + f, e = e[ct.expando] ? e : new ct.Event(f, "object" == typeof e && e), e.isTrigger = r ? 2 : 3, e.namespace = g.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + g.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), i = null == i ? [e] : ct.makeArray(i, [e]), p = ct.event.special[f] || {}, r || !p.trigger || p.trigger.apply(n, i) !== !1)) {
                if (!r && !p.noBubble && !ct.isWindow(n)) {
                    for (h = p.delegateType || f, Ee.test(h + f) || (s = s.parentNode); s; s = s.parentNode) c.push(s), a = s;
                    a === (n.ownerDocument || Q) && c.push(a.defaultView || a.parentWindow || t)
                }
                for (o = 0;
                    (s = c[o++]) && !e.isPropagationStopped();) e.type = o > 1 ? h : p.bindType || f, u = (_t.get(s, "events") || {})[e.type] && _t.get(s, "handle"), u && u.apply(s, i), u = l && s[l], u && u.apply && Rt(s) && (e.result = u.apply(s, i), e.result === !1 && e.preventDefault());
                return e.type = f, r || e.isDefaultPrevented() || p._default && p._default.apply(c.pop(), i) !== !1 || !Rt(n) || l && ct.isFunction(n[f]) && !ct.isWindow(n) && (a = n[l], a && (n[l] = null), ct.event.triggered = f, n[f](), ct.event.triggered = void 0, a && (n[l] = a)), e.result
            }
        },
        simulate: function(t, e, i) {
            var n = ct.extend(new ct.Event, i, { type: t, isSimulated: !0 });
            ct.event.trigger(n, null, e)
        }
    }), ct.fn.extend({ trigger: function(t, e) { return this.each(function() { ct.event.trigger(t, e, this) }) }, triggerHandler: function(t, e) { var i = this[0]; if (i) return ct.event.trigger(t, e, i, !0) } }), ct.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(t, e) { ct.fn[e] = function(t, i) { return arguments.length > 0 ? this.on(e, null, t, i) : this.trigger(e) } }), ct.fn.extend({ hover: function(t, e) { return this.mouseenter(t).mouseleave(e || t) } }), ut.focusin = "onfocusin" in t, ut.focusin || ct.each({ focus: "focusin", blur: "focusout" }, function(t, e) {
        var i = function(t) { ct.event.simulate(e, t.target, ct.event.fix(t)) };
        ct.event.special[e] = {
            setup: function() {
                var n = this.ownerDocument || this,
                    r = _t.access(n, e);
                r || n.addEventListener(t, i, !0), _t.access(n, e, (r || 0) + 1)
            },
            teardown: function() {
                var n = this.ownerDocument || this,
                    r = _t.access(n, e) - 1;
                r ? _t.access(n, e, r) : (n.removeEventListener(t, i, !0), _t.remove(n, e))
            }
        }
    });
    var Se = t.location,
        Ne = ct.now(),
        Le = /\?/;
    ct.parseXML = function(e) { var i; if (!e || "string" != typeof e) return null; try { i = (new t.DOMParser).parseFromString(e, "text/xml") } catch (t) { i = void 0 } return i && !i.getElementsByTagName("parsererror").length || ct.error("Invalid XML: " + e), i };
    var Ce = /\[\]$/,
        Me = /\r?\n/g,
        Ie = /^(?:submit|button|image|reset|file)$/i,
        ke = /^(?:input|select|textarea|keygen)/i;
    ct.param = function(t, e) {
        var i, n = [],
            r = function(t, e) {
                var i = ct.isFunction(e) ? e() : e;
                n[n.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == i ? "" : i)
            };
        if (ct.isArray(t) || t.jquery && !ct.isPlainObject(t)) ct.each(t, function() { r(this.name, this.value) });
        else
            for (i in t) W(i, t[i], e, r);
        return n.join("&")
    }, ct.fn.extend({ serialize: function() { return ct.param(this.serializeArray()) }, serializeArray: function() { return this.map(function() { var t = ct.prop(this, "elements"); return t ? ct.makeArray(t) : this }).filter(function() { var t = this.type; return this.name && !ct(this).is(":disabled") && ke.test(this.nodeName) && !Ie.test(t) && (this.checked || !qt.test(t)) }).map(function(t, e) { var i = ct(this).val(); return null == i ? null : ct.isArray(i) ? ct.map(i, function(t) { return { name: e.name, value: t.replace(Me, "\r\n") } }) : { name: e.name, value: i.replace(Me, "\r\n") } }).get() } });
    var Te = /%20/g,
        Ae = /#.*$/,
        Re = /([?&])_=[^&]*/,
        _e = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        Pe = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        Oe = /^(?:GET|HEAD)$/,
        De = /^\/\//,
        Fe = {},
        Ue = {},
        Be = "*/".concat("*"),
        je = Q.createElement("a");
    je.href = Se.href, ct.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: { url: Se.href, type: "GET", isLocal: Pe.test(Se.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Be, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": ct.parseXML }, flatOptions: { url: !0, context: !0 } },
        ajaxSetup: function(t, e) { return e ? Y(Y(t, ct.ajaxSettings), e) : Y(ct.ajaxSettings, t) },
        ajaxPrefilter: X(Fe),
        ajaxTransport: X(Ue),
        ajax: function(e, i) {
            function n(e, i, n, a) {
                var l, c, f, w, x, E = i;
                u || (u = !0, h && t.clearTimeout(h), r = void 0, s = a || "", S.readyState = e > 0 ? 4 : 0, l = e >= 200 && e < 300 || 304 === e, n && (w = K(g, S, n)), w = $(g, w, S, l), l ? (g.ifModified && (x = S.getResponseHeader("Last-Modified"), x && (ct.lastModified[o] = x), x = S.getResponseHeader("etag"), x && (ct.etag[o] = x)), 204 === e || "HEAD" === g.type ? E = "nocontent" : 304 === e ? E = "notmodified" : (E = w.state, c = w.data, f = w.error, l = !f)) : (f = E, !e && E || (E = "error", e < 0 && (e = 0))), S.status = e, S.statusText = (i || E) + "", l ? m.resolveWith(d, [c, E, S]) : m.rejectWith(d, [S, E, f]), S.statusCode(b), b = void 0, p && y.trigger(l ? "ajaxSuccess" : "ajaxError", [S, g, l ? c : f]), v.fireWith(d, [S, E]), p && (y.trigger("ajaxComplete", [S, g]), --ct.active || ct.event.trigger("ajaxStop")))
            }
            "object" == typeof e && (i = e, e = void 0), i = i || {};
            var r, o, s, a, h, l, u, p, c, f, g = ct.ajaxSetup({}, i),
                d = g.context || g,
                y = g.context && (d.nodeType || d.jquery) ? ct(d) : ct.event,
                m = ct.Deferred(),
                v = ct.Callbacks("once memory"),
                b = g.statusCode || {},
                w = {},
                x = {},
                E = "canceled",
                S = {
                    readyState: 0,
                    getResponseHeader: function(t) {
                        var e;
                        if (u) {
                            if (!a)
                                for (a = {}; e = _e.exec(s);) a[e[1].toLowerCase()] = e[2];
                            e = a[t.toLowerCase()]
                        }
                        return null == e ? null : e
                    },
                    getAllResponseHeaders: function() { return u ? s : null },
                    setRequestHeader: function(t, e) { return null == u && (t = x[t.toLowerCase()] = x[t.toLowerCase()] || t, w[t] = e), this },
                    overrideMimeType: function(t) { return null == u && (g.mimeType = t), this },
                    statusCode: function(t) {
                        var e;
                        if (t)
                            if (u) S.always(t[S.status]);
                            else
                                for (e in t) b[e] = [b[e], t[e]];
                        return this
                    },
                    abort: function(t) { var e = t || E; return r && r.abort(e), n(0, e), this }
                };
            if (m.promise(S), g.url = ((e || g.url || Se.href) + "").replace(De, Se.protocol + "//"), g.type = i.method || i.type || g.method || g.type, g.dataTypes = (g.dataType || "*").toLowerCase().match(It) || [""], null == g.crossDomain) { l = Q.createElement("a"); try { l.href = g.url, l.href = l.href, g.crossDomain = je.protocol + "//" + je.host != l.protocol + "//" + l.host } catch (t) { g.crossDomain = !0 } }
            if (g.data && g.processData && "string" != typeof g.data && (g.data = ct.param(g.data, g.traditional)), H(Fe, g, i, S), u) return S;
            p = ct.event && g.global, p && 0 === ct.active++ && ct.event.trigger("ajaxStart"), g.type = g.type.toUpperCase(), g.hasContent = !Oe.test(g.type), o = g.url.replace(Ae, ""), g.hasContent ? g.data && g.processData && 0 === (g.contentType || "").indexOf("application/x-www-form-urlencoded") && (g.data = g.data.replace(Te, "+")) : (f = g.url.slice(o.length), g.data && (o += (Le.test(o) ? "&" : "?") + g.data, delete g.data), g.cache === !1 && (o = o.replace(Re, ""), f = (Le.test(o) ? "&" : "?") + "_=" + Ne++ + f), g.url = o + f), g.ifModified && (ct.lastModified[o] && S.setRequestHeader("If-Modified-Since", ct.lastModified[o]), ct.etag[o] && S.setRequestHeader("If-None-Match", ct.etag[o])),
                (g.data && g.hasContent && g.contentType !== !1 || i.contentType) && S.setRequestHeader("Content-Type", g.contentType), S.setRequestHeader("Accept", g.dataTypes[0] && g.accepts[g.dataTypes[0]] ? g.accepts[g.dataTypes[0]] + ("*" !== g.dataTypes[0] ? ", " + Be + "; q=0.01" : "") : g.accepts["*"]);
            for (c in g.headers) S.setRequestHeader(c, g.headers[c]);
            if (g.beforeSend && (g.beforeSend.call(d, S, g) === !1 || u)) return S.abort();
            if (E = "abort", v.add(g.complete), S.done(g.success), S.fail(g.error), r = H(Ue, g, i, S)) {
                if (S.readyState = 1, p && y.trigger("ajaxSend", [S, g]), u) return S;
                g.async && g.timeout > 0 && (h = t.setTimeout(function() { S.abort("timeout") }, g.timeout));
                try { u = !1, r.send(w, n) } catch (t) {
                    if (u) throw t;
                    n(-1, t)
                }
            } else n(-1, "No Transport");
            return S
        },
        getJSON: function(t, e, i) { return ct.get(t, e, i, "json") },
        getScript: function(t, e) { return ct.get(t, void 0, e, "script") }
    }), ct.each(["get", "post"], function(t, e) { ct[e] = function(t, i, n, r) { return ct.isFunction(i) && (r = r || n, n = i, i = void 0), ct.ajax(ct.extend({ url: t, type: e, dataType: r, data: i, success: n }, ct.isPlainObject(t) && t)) } }), ct._evalUrl = function(t) { return ct.ajax({ url: t, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, throws: !0 }) }, ct.fn.extend({
        wrapAll: function(t) { var e; return this[0] && (ct.isFunction(t) && (t = t.call(this[0])), e = ct(t, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map(function() { for (var t = this; t.firstElementChild;) t = t.firstElementChild; return t }).append(this)), this },
        wrapInner: function(t) {
            return ct.isFunction(t) ? this.each(function(e) { ct(this).wrapInner(t.call(this, e)) }) : this.each(function() {
                var e = ct(this),
                    i = e.contents();
                i.length ? i.wrapAll(t) : e.append(t)
            })
        },
        wrap: function(t) { var e = ct.isFunction(t); return this.each(function(i) { ct(this).wrapAll(e ? t.call(this, i) : t) }) },
        unwrap: function(t) { return this.parent(t).not("body").each(function() { ct(this).replaceWith(this.childNodes) }), this }
    }), ct.expr.pseudos.hidden = function(t) { return !ct.expr.pseudos.visible(t) }, ct.expr.pseudos.visible = function(t) { return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length) }, ct.ajaxSettings.xhr = function() { try { return new t.XMLHttpRequest } catch (t) {} };
    var ze = { 0: 200, 1223: 204 },
        Ge = ct.ajaxSettings.xhr();
    ut.cors = !!Ge && "withCredentials" in Ge, ut.ajax = Ge = !!Ge, ct.ajaxTransport(function(e) {
        var i, n;
        if (ut.cors || Ge && !e.crossDomain) return {
            send: function(r, o) {
                var s, a = e.xhr();
                if (a.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields)
                    for (s in e.xhrFields) a[s] = e.xhrFields[s];
                e.mimeType && a.overrideMimeType && a.overrideMimeType(e.mimeType), e.crossDomain || r["X-Requested-With"] || (r["X-Requested-With"] = "XMLHttpRequest");
                for (s in r) a.setRequestHeader(s, r[s]);
                i = function(t) { return function() { i && (i = n = a.onload = a.onerror = a.onabort = a.onreadystatechange = null, "abort" === t ? a.abort() : "error" === t ? "number" != typeof a.status ? o(0, "error") : o(a.status, a.statusText) : o(ze[a.status] || a.status, a.statusText, "text" !== (a.responseType || "text") || "string" != typeof a.responseText ? { binary: a.response } : { text: a.responseText }, a.getAllResponseHeaders())) } }, a.onload = i(), n = a.onerror = i("error"), void 0 !== a.onabort ? a.onabort = n : a.onreadystatechange = function() { 4 === a.readyState && t.setTimeout(function() { i && n() }) }, i = i("abort");
                try { a.send(e.hasContent && e.data || null) } catch (t) { if (i) throw t }
            },
            abort: function() { i && i() }
        }
    }), ct.ajaxPrefilter(function(t) { t.crossDomain && (t.contents.script = !1) }), ct.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function(t) { return ct.globalEval(t), t } } }), ct.ajaxPrefilter("script", function(t) { void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = "GET") }), ct.ajaxTransport("script", function(t) { if (t.crossDomain) { var e, i; return { send: function(n, r) { e = ct("<script>").prop({ charset: t.scriptCharset, src: t.url }).on("load error", i = function(t) { e.remove(), i = null, t && r("error" === t.type ? 404 : 200, t.type) }), Q.head.appendChild(e[0]) }, abort: function() { i && i() } } } });
    var qe = [],
        Ve = /(=)\?(?=&|$)|\?\?/;
    ct.ajaxSetup({ jsonp: "callback", jsonpCallback: function() { var t = qe.pop() || ct.expando + "_" + Ne++; return this[t] = !0, t } }), ct.ajaxPrefilter("json jsonp", function(e, i, n) { var r, o, s, a = e.jsonp !== !1 && (Ve.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ve.test(e.data) && "data"); if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = ct.isFunction(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Ve, "$1" + r) : e.jsonp !== !1 && (e.url += (Le.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function() { return s || ct.error(r + " was not called"), s[0] }, e.dataTypes[0] = "json", o = t[r], t[r] = function() { s = arguments }, n.always(function() { void 0 === o ? ct(t).removeProp(r) : t[r] = o, e[r] && (e.jsonpCallback = i.jsonpCallback, qe.push(r)), s && ct.isFunction(o) && o(s[0]), s = o = void 0 }), "script" }), ut.createHTMLDocument = function() { var t = Q.implementation.createHTMLDocument("").body; return t.innerHTML = "<form></form><form></form>", 2 === t.childNodes.length }(), ct.parseHTML = function(t, e, i) { if ("string" != typeof t) return []; "boolean" == typeof e && (i = e, e = !1); var n, r, o; return e || (ut.createHTMLDocument ? (e = Q.implementation.createHTMLDocument(""), n = e.createElement("base"), n.href = Q.location.href, e.head.appendChild(n)) : e = Q), r = xt.exec(t), o = !i && [], r ? [e.createElement(r[1])] : (r = v([t], e, o), o && o.length && ct(o).remove(), ct.merge([], r.childNodes)) }, ct.fn.load = function(t, e, i) {
        var n, r, o, s = this,
            a = t.indexOf(" ");
        return a > -1 && (n = ct.trim(t.slice(a)), t = t.slice(0, a)), ct.isFunction(e) ? (i = e, e = void 0) : e && "object" == typeof e && (r = "POST"), s.length > 0 && ct.ajax({ url: t, type: r || "GET", dataType: "html", data: e }).done(function(t) { o = arguments, s.html(n ? ct("<div>").append(ct.parseHTML(t)).find(n) : t) }).always(i && function(t, e) { s.each(function() { i.apply(this, o || [t.responseText, e, t]) }) }), this
    }, ct.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(t, e) { ct.fn[e] = function(t) { return this.on(e, t) } }), ct.expr.pseudos.animated = function(t) { return ct.grep(ct.timers, function(e) { return t === e.elem }).length }, ct.offset = {
        setOffset: function(t, e, i) {
            var n, r, o, s, a, h, l, u = ct.css(t, "position"),
                p = ct(t),
                c = {};
            "static" === u && (t.style.position = "relative"), a = p.offset(), o = ct.css(t, "top"), h = ct.css(t, "left"), l = ("absolute" === u || "fixed" === u) && (o + h).indexOf("auto") > -1, l ? (n = p.position(), s = n.top, r = n.left) : (s = parseFloat(o) || 0, r = parseFloat(h) || 0), ct.isFunction(e) && (e = e.call(t, i, ct.extend({}, a))), null != e.top && (c.top = e.top - a.top + s), null != e.left && (c.left = e.left - a.left + r), "using" in e ? e.using.call(t, c) : p.css(c)
        }
    }, ct.fn.extend({
        offset: function(t) { if (arguments.length) return void 0 === t ? this : this.each(function(e) { ct.offset.setOffset(this, t, e) }); var e, i, n, r, o = this[0]; if (o) return o.getClientRects().length ? (n = o.getBoundingClientRect(), n.width || n.height ? (r = o.ownerDocument, i = Z(r), e = r.documentElement, { top: n.top + i.pageYOffset - e.clientTop, left: n.left + i.pageXOffset - e.clientLeft }) : n) : { top: 0, left: 0 } },
        position: function() {
            if (this[0]) {
                var t, e, i = this[0],
                    n = { top: 0, left: 0 };
                return "fixed" === ct.css(i, "position") ? e = i.getBoundingClientRect() : (t = this.offsetParent(), e = this.offset(), ct.nodeName(t[0], "html") || (n = t.offset()), n = { top: n.top + ct.css(t[0], "borderTopWidth", !0), left: n.left + ct.css(t[0], "borderLeftWidth", !0) }), { top: e.top - n.top - ct.css(i, "marginTop", !0), left: e.left - n.left - ct.css(i, "marginLeft", !0) }
            }
        },
        offsetParent: function() { return this.map(function() { for (var t = this.offsetParent; t && "static" === ct.css(t, "position");) t = t.offsetParent; return t || Yt }) }
    }), ct.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(t, e) {
        var i = "pageYOffset" === e;
        ct.fn[t] = function(n) { return At(this, function(t, n, r) { var o = Z(t); return void 0 === r ? o ? o[e] : t[n] : void(o ? o.scrollTo(i ? o.pageXOffset : r, i ? r : o.pageYOffset) : t[n] = r) }, t, n, arguments.length) }
    }), ct.each(["top", "left"], function(t, e) { ct.cssHooks[e] = A(ut.pixelPosition, function(t, i) { if (i) return i = T(t, e), re.test(i) ? ct(t).position()[e] + "px" : i }) }), ct.each({ Height: "height", Width: "width" }, function(t, e) {
        ct.each({ padding: "inner" + t, content: e, "": "outer" + t }, function(i, n) {
            ct.fn[n] = function(r, o) {
                var s = arguments.length && (i || "boolean" != typeof r),
                    a = i || (r === !0 || o === !0 ? "margin" : "border");
                return At(this, function(e, i, r) { var o; return ct.isWindow(e) ? 0 === n.indexOf("outer") ? e["inner" + t] : e.document.documentElement["client" + t] : 9 === e.nodeType ? (o = e.documentElement, Math.max(e.body["scroll" + t], o["scroll" + t], e.body["offset" + t], o["offset" + t], o["client" + t])) : void 0 === r ? ct.css(e, i, a) : ct.style(e, i, r, a) }, e, s ? r : void 0, s)
            }
        })
    }), ct.fn.extend({ bind: function(t, e, i) { return this.on(t, null, e, i) }, unbind: function(t, e) { return this.off(t, null, e) }, delegate: function(t, e, i, n) { return this.on(e, t, i, n) }, undelegate: function(t, e, i) { return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", i) } }), ct.parseJSON = JSON.parse, "function" == typeof define && define.amd && define("jquery", [], function() { return ct });
    var We = t.jQuery,
        Xe = t.$;
    return ct.noConflict = function(e) { return t.$ === ct && (t.$ = Xe), e && t.jQuery === ct && (t.jQuery = We), ct }, e || (t.jQuery = t.$ = ct), ct
}),
function(t) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = t();
    else if ("function" == typeof define && define.amd) define([], t);
    else {
        var e;
        e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, e.proj4 = t()
    }
}(function() {
    return function t(e, i, n) {
        function r(s, a) {
            if (!i[s]) {
                if (!e[s]) { var h = "function" == typeof require && require; if (!a && h) return h(s, !0); if (o) return o(s, !0); var l = new Error("Cannot find module '" + s + "'"); throw l.code = "MODULE_NOT_FOUND", l }
                var u = i[s] = { exports: {} };
                e[s][0].call(u.exports, function(t) { var i = e[s][1][t]; return r(i ? i : t) }, u, u.exports, t, e, i, n)
            }
            return i[s].exports
        }
        for (var o = "function" == typeof require && require, s = 0; s < n.length; s++) r(n[s]);
        return r
    }({
        "./includedProjections": [function(t, e, i) {
            var n = [t("./lib/projections/tmerc"), t("./lib/projections/utm"), t("./lib/projections/sterea"), t("./lib/projections/stere"), t("./lib/projections/somerc"), t("./lib/projections/omerc"), t("./lib/projections/lcc"), t("./lib/projections/krovak"), t("./lib/projections/cass"), t("./lib/projections/laea"), t("./lib/projections/aea"), t("./lib/projections/gnom"), t("./lib/projections/cea"), t("./lib/projections/eqc"), t("./lib/projections/poly"), t("./lib/projections/nzmg"), t("./lib/projections/mill"), t("./lib/projections/sinu"), t("./lib/projections/moll"), t("./lib/projections/eqdc"), t("./lib/projections/vandg"), t("./lib/projections/aeqd"), t("./lib/projections/ortho")];
            e.exports = function(t) { n.forEach(function(e) { t.Proj.projections.add(e) }) }
        }, { "./lib/projections/aea": 40, "./lib/projections/aeqd": 41, "./lib/projections/cass": 42, "./lib/projections/cea": 43, "./lib/projections/eqc": 44, "./lib/projections/eqdc": 45, "./lib/projections/gnom": 47, "./lib/projections/krovak": 48, "./lib/projections/laea": 49, "./lib/projections/lcc": 50, "./lib/projections/mill": 53, "./lib/projections/moll": 54, "./lib/projections/nzmg": 55, "./lib/projections/omerc": 56, "./lib/projections/ortho": 57, "./lib/projections/poly": 58, "./lib/projections/sinu": 59, "./lib/projections/somerc": 60, "./lib/projections/stere": 61, "./lib/projections/sterea": 62, "./lib/projections/tmerc": 63, "./lib/projections/utm": 64, "./lib/projections/vandg": 65 }],
        1: [function(t, e, i) {
            function n(t, e, i) {
                if (!(this instanceof n)) return new n(t, e, i);
                if (Array.isArray(t)) this.x = t[0], this.y = t[1], this.z = t[2] || 0;
                else if ("object" == typeof t) this.x = t.x, this.y = t.y, this.z = t.z || 0;
                else if ("string" == typeof t && "undefined" == typeof e) {
                    var r = t.split(",");
                    this.x = parseFloat(r[0], 10), this.y = parseFloat(r[1], 10), this.z = parseFloat(r[2], 10) || 0
                } else this.x = t, this.y = e, this.z = i || 0;
                console.warn("proj4.Point will be removed in version 3, use proj4.toPoint")
            }
            var r = t("mgrs");
            n.fromMGRS = function(t) { return new n(r.toPoint(t)) }, n.prototype.toMGRS = function(t) { return r.forward([this.x, this.y], t) }, e.exports = n
        }, { mgrs: 68 }],
        2: [function(t, e, i) {
            function n(t, e) {
                if (!(this instanceof n)) return new n(t);
                e = e || function(t) { if (t) throw t };
                var i = r(t);
                if ("object" != typeof i) return void e(t);
                var s = a(i),
                    h = n.projections.get(s.projName);
                h ? (o(this, s), o(this, h), this.init(), e(null, this)) : e(t)
            }
            var r = t("./parseCode"),
                o = t("./extend"),
                s = t("./projections"),
                a = t("./deriveConstants");
            n.projections = s, n.projections.start(), e.exports = n
        }, { "./deriveConstants": 33, "./extend": 34, "./parseCode": 37, "./projections": 39 }],
        3: [function(t, e, i) {
            e.exports = function(t, e, i) {
                var n, r, o, s = i.x,
                    a = i.y,
                    h = i.z || 0;
                for (o = 0; o < 3; o++)
                    if (!e || 2 !== o || void 0 !== i.z) switch (0 === o ? (n = s, r = "x") : 1 === o ? (n = a, r = "y") : (n = h, r = "z"), t.axis[o]) {
                        case "e":
                            i[r] = n;
                            break;
                        case "w":
                            i[r] = -n;
                            break;
                        case "n":
                            i[r] = n;
                            break;
                        case "s":
                            i[r] = -n;
                            break;
                        case "u":
                            void 0 !== i[r] && (i.z = n);
                            break;
                        case "d":
                            void 0 !== i[r] && (i.z = -n);
                            break;
                        default:
                            return null
                    }
                return i
            }
        }, {}],
        4: [function(t, e, i) {
            var n = Math.PI / 2,
                r = t("./sign");
            e.exports = function(t) { return Math.abs(t) < n ? t : t - r(t) * Math.PI }
        }, { "./sign": 21 }],
        5: [function(t, e, i) {
            var n = 2 * Math.PI,
                r = 3.14159265359,
                o = t("./sign");
            e.exports = function(t) { return Math.abs(t) <= r ? t : t - o(t) * n }
        }, { "./sign": 21 }],
        6: [function(t, e, i) { e.exports = function(t) { return Math.abs(t) > 1 && (t = t > 1 ? 1 : -1), Math.asin(t) } }, {}],
        7: [function(t, e, i) { e.exports = function(t) { return 1 - .25 * t * (1 + t / 16 * (3 + 1.25 * t)) } }, {}],
        8: [function(t, e, i) { e.exports = function(t) { return .375 * t * (1 + .25 * t * (1 + .46875 * t)) } }, {}],
        9: [function(t, e, i) { e.exports = function(t) { return .05859375 * t * t * (1 + .75 * t) } }, {}],
        10: [function(t, e, i) { e.exports = function(t) { return t * t * t * (35 / 3072) } }, {}],
        11: [function(t, e, i) { e.exports = function(t, e, i) { var n = e * i; return t / Math.sqrt(1 - n * n) } }, {}],
        12: [function(t, e, i) {
            e.exports = function(t, e, i, n, r) {
                var o, s;
                o = t / e;
                for (var a = 0; a < 15; a++)
                    if (s = (t - (e * o - i * Math.sin(2 * o) + n * Math.sin(4 * o) - r * Math.sin(6 * o))) / (e - 2 * i * Math.cos(2 * o) + 4 * n * Math.cos(4 * o) - 6 * r * Math.cos(6 * o)), o += s, Math.abs(s) <= 1e-10) return o;
                return NaN
            }
        }, {}],
        13: [function(t, e, i) {
            var n = Math.PI / 2;
            e.exports = function(t, e) {
                var i = 1 - (1 - t * t) / (2 * t) * Math.log((1 - t) / (1 + t));
                if (Math.abs(Math.abs(e) - i) < 1e-6) return e < 0 ? -1 * n : n;
                for (var r, o, s, a, h = Math.asin(.5 * e), l = 0; l < 30; l++)
                    if (o = Math.sin(h), s = Math.cos(h), a = t * o, r = Math.pow(1 - a * a, 2) / (2 * s) * (e / (1 - t * t) - o / (1 - a * a) + .5 / t * Math.log((1 - a) / (1 + a))), h += r, Math.abs(r) <= 1e-10) return h;
                return NaN
            }
        }, {}],
        14: [function(t, e, i) { e.exports = function(t, e, i, n, r) { return t * r - e * Math.sin(2 * r) + i * Math.sin(4 * r) - n * Math.sin(6 * r) } }, {}],
        15: [function(t, e, i) { e.exports = function(t, e, i) { var n = t * e; return i / Math.sqrt(1 - n * n) } }, {}],
        16: [function(t, e, i) {
            var n = Math.PI / 2;
            e.exports = function(t, e) {
                for (var i, r, o = .5 * t, s = n - 2 * Math.atan(e), a = 0; a <= 15; a++)
                    if (i = t * Math.sin(s), r = n - 2 * Math.atan(e * Math.pow((1 - i) / (1 + i), o)) - s, s += r, Math.abs(r) <= 1e-10) return s;
                return -9999
            }
        }, {}],
        17: [function(t, e, i) {
            var n = 1,
                r = .25,
                o = .046875,
                s = .01953125,
                a = .01068115234375,
                h = .75,
                l = .46875,
                u = .013020833333333334,
                p = .007120768229166667,
                c = .3645833333333333,
                f = .005696614583333333,
                g = .3076171875;
            e.exports = function(t) {
                var e = [];
                e[0] = n - t * (r + t * (o + t * (s + t * a))), e[1] = t * (h - t * (o + t * (s + t * a)));
                var i = t * t;
                return e[2] = i * (l - t * (u + t * p)), i *= t, e[3] = i * (c - t * f), e[4] = i * t * g, e
            }
        }, {}],
        18: [function(t, e, i) {
            var n = t("./pj_mlfn"),
                r = 1e-10,
                o = 20;
            e.exports = function(t, e, i) {
                for (var s = 1 / (1 - e), a = t, h = o; h; --h) {
                    var l = Math.sin(a),
                        u = 1 - e * l * l;
                    if (u = (n(a, l, Math.cos(a), i) - t) * (u * Math.sqrt(u)) * s, a -= u, Math.abs(u) < r) return a
                }
                return a
            }
        }, { "./pj_mlfn": 19 }],
        19: [function(t, e, i) { e.exports = function(t, e, i, n) { return i *= e, e *= e, n[0] * t - i * (n[1] + e * (n[2] + e * (n[3] + e * n[4]))) } }, {}],
        20: [function(t, e, i) { e.exports = function(t, e) { var i; return t > 1e-7 ? (i = t * e, (1 - t * t) * (e / (1 - i * i) - .5 / t * Math.log((1 - i) / (1 + i)))) : 2 * e } }, {}],
        21: [function(t, e, i) { e.exports = function(t) { return t < 0 ? -1 : 1 } }, {}],
        22: [function(t, e, i) { e.exports = function(t, e) { return Math.pow((1 - t) / (1 + t), e) } }, {}],
        23: [function(t, e, i) { e.exports = function(t) { var e = { x: t[0], y: t[1] }; return t.length > 2 && (e.z = t[2]), t.length > 3 && (e.m = t[3]), e } }, {}],
        24: [function(t, e, i) {
            var n = Math.PI / 2;
            e.exports = function(t, e, i) {
                var r = t * i,
                    o = .5 * t;
                return r = Math.pow((1 - r) / (1 + r), o), Math.tan(.5 * (n - e)) / r
            }
        }, {}],
        25: [function(t, e, i) { i.wgs84 = { towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84" }, i.ch1903 = { towgs84: "674.374,15.056,405.346", ellipse: "bessel", datumName: "swiss" }, i.ggrs87 = { towgs84: "-199.87,74.79,246.62", ellipse: "GRS80", datumName: "Greek_Geodetic_Reference_System_1987" }, i.nad83 = { towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983" }, i.nad27 = { nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat", ellipse: "clrk66", datumName: "North_American_Datum_1927" }, i.potsdam = { towgs84: "606.0,23.0,413.0", ellipse: "bessel", datumName: "Potsdam Rauenberg 1950 DHDN" }, i.carthage = { towgs84: "-263.0,6.0,431.0", ellipse: "clark80", datumName: "Carthage 1934 Tunisia" }, i.hermannskogel = { towgs84: "653.0,-212.0,449.0", ellipse: "bessel", datumName: "Hermannskogel" }, i.ire65 = { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "mod_airy", datumName: "Ireland 1965" }, i.rassadiran = { towgs84: "-133.63,-157.5,-158.62", ellipse: "intl", datumName: "Rassadiran" }, i.nzgd49 = { towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993", ellipse: "intl", datumName: "New Zealand Geodetic Datum 1949" }, i.osgb36 = { towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894", ellipse: "airy", datumName: "Airy 1830" }, i.s_jtsk = { towgs84: "589,76,480", ellipse: "bessel", datumName: "S-JTSK (Ferro)" }, i.beduaram = { towgs84: "-106,-87,188", ellipse: "clrk80", datumName: "Beduaram" }, i.gunung_segara = { towgs84: "-403,684,41", ellipse: "bessel", datumName: "Gunung Segara Jakarta" }, i.rnb72 = { towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1", ellipse: "intl", datumName: "Reseau National Belge 1972" } }, {}],
        26: [function(t, e, i) { i.MERIT = { a: 6378137, rf: 298.257, ellipseName: "MERIT 1983" }, i.SGS85 = { a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85" }, i.GRS80 = { a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)" }, i.IAU76 = { a: 6378140, rf: 298.257, ellipseName: "IAU 1976" }, i.airy = { a: 6377563.396, b: 6356256.91, ellipseName: "Airy 1830" }, i.APL4 = { a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965" }, i.NWL9D = { a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965" }, i.mod_airy = { a: 6377340.189, b: 6356034.446, ellipseName: "Modified Airy" }, i.andrae = { a: 6377104.43, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)" }, i.aust_SA = { a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969" }, i.GRS67 = { a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)" }, i.bessel = { a: 6377397.155, rf: 299.1528128, ellipseName: "Bessel 1841" }, i.bess_nam = { a: 6377483.865, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)" }, i.clrk66 = { a: 6378206.4, b: 6356583.8, ellipseName: "Clarke 1866" }, i.clrk80 = { a: 6378249.145, rf: 293.4663, ellipseName: "Clarke 1880 mod." }, i.clrk58 = { a: 6378293.645208759, rf: 294.2606763692654, ellipseName: "Clarke 1858" }, i.CPM = { a: 6375738.7, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799" }, i.delmbr = { a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)" }, i.engelis = { a: 6378136.05, rf: 298.2566, ellipseName: "Engelis 1985" }, i.evrst30 = { a: 6377276.345, rf: 300.8017, ellipseName: "Everest 1830" }, i.evrst48 = { a: 6377304.063, rf: 300.8017, ellipseName: "Everest 1948" }, i.evrst56 = { a: 6377301.243, rf: 300.8017, ellipseName: "Everest 1956" }, i.evrst69 = { a: 6377295.664, rf: 300.8017, ellipseName: "Everest 1969" }, i.evrstSS = { a: 6377298.556, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)" }, i.fschr60 = { a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960" }, i.fschr60m = { a: 6378155, rf: 298.3, ellipseName: "Fischer 1960" }, i.fschr68 = { a: 6378150, rf: 298.3, ellipseName: "Fischer 1968" }, i.helmert = { a: 6378200, rf: 298.3, ellipseName: "Helmert 1906" }, i.hough = { a: 6378270, rf: 297, ellipseName: "Hough" }, i.intl = { a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)" }, i.kaula = { a: 6378163, rf: 298.24, ellipseName: "Kaula 1961" }, i.lerch = { a: 6378139, rf: 298.257, ellipseName: "Lerch 1979" }, i.mprts = { a: 6397300, rf: 191, ellipseName: "Maupertius 1738" }, i.new_intl = { a: 6378157.5, b: 6356772.2, ellipseName: "New International 1967" }, i.plessis = { a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)" }, i.krass = { a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942" }, i.SEasia = { a: 6378155, b: 6356773.3205, ellipseName: "Southeast Asia" }, i.walbeck = { a: 6376896, b: 6355834.8467, ellipseName: "Walbeck" }, i.WGS60 = { a: 6378165, rf: 298.3, ellipseName: "WGS 60" }, i.WGS66 = { a: 6378145, rf: 298.25, ellipseName: "WGS 66" }, i.WGS7 = { a: 6378135, rf: 298.26, ellipseName: "WGS 72" }, i.WGS84 = { a: 6378137, rf: 298.257223563, ellipseName: "WGS 84" }, i.sphere = { a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)" } }, {}],
        27: [function(t, e, i) { i.greenwich = 0, i.lisbon = -9.131906111111, i.paris = 2.337229166667, i.bogota = -74.080916666667, i.madrid = -3.687938888889, i.rome = 12.452333333333, i.bern = 7.439583333333, i.jakarta = 106.807719444444, i.ferro = -17.666666666667, i.brussels = 4.367975, i.stockholm = 18.058277777778, i.athens = 23.7163375, i.oslo = 10.722916666667 }, {}],
        28: [function(t, e, i) { i.ft = { to_meter: .3048 }, i["us-ft"] = { to_meter: 1200 / 3937 } }, {}],
        29: [function(t, e, i) {
            function n(t, e, i) { var n; return Array.isArray(i) ? (n = a(t, e, i), 3 === i.length ? [n.x, n.y, n.z] : [n.x, n.y]) : a(t, e, i) }

            function r(t) { return t instanceof s ? t : t.oProj ? t.oProj : s(t) }

            function o(t, e, i) { t = r(t); var o, s = !1; return "undefined" == typeof e ? (e = t, t = h, s = !0) : ("undefined" != typeof e.x || Array.isArray(e)) && (i = e, e = t, t = h, s = !0), e = r(e), i ? n(t, e, i) : (o = { forward: function(i) { return n(t, e, i) }, inverse: function(i) { return n(e, t, i) } }, s && (o.oProj = e), o) }
            var s = t("./Proj"),
                a = t("./transform"),
                h = s("WGS84");
            e.exports = o
        }, { "./Proj": 2, "./transform": 66 }],
        30: [function(t, e, i) {
            var n = Math.PI / 2,
                r = 1,
                o = 2,
                s = 3,
                a = 4,
                h = 5,
                l = 484813681109536e-20,
                u = 1.0026,
                p = .3826834323650898,
                c = function(t) { return this instanceof c ? (this.datum_type = a, void(t && (t.datumCode && "none" === t.datumCode && (this.datum_type = h), t.datum_params && (this.datum_params = t.datum_params.map(parseFloat), 0 === this.datum_params[0] && 0 === this.datum_params[1] && 0 === this.datum_params[2] || (this.datum_type = r), this.datum_params.length > 3 && (0 === this.datum_params[3] && 0 === this.datum_params[4] && 0 === this.datum_params[5] && 0 === this.datum_params[6] || (this.datum_type = o, this.datum_params[3] *= l, this.datum_params[4] *= l, this.datum_params[5] *= l, this.datum_params[6] = this.datum_params[6] / 1e6 + 1))), this.datum_type = t.grids ? s : this.datum_type, this.a = t.a, this.b = t.b, this.es = t.es, this.ep2 = t.ep2, this.datum_type === s && (this.grids = t.grids)))) : new c(t) };
            c.prototype = {
                compare_datums: function(t) { return this.datum_type === t.datum_type && (!(this.a !== t.a || Math.abs(this.es - t.es) > 5e-11) && (this.datum_type === r ? this.datum_params[0] === t.datum_params[0] && this.datum_params[1] === t.datum_params[1] && this.datum_params[2] === t.datum_params[2] : this.datum_type === o ? this.datum_params[0] === t.datum_params[0] && this.datum_params[1] === t.datum_params[1] && this.datum_params[2] === t.datum_params[2] && this.datum_params[3] === t.datum_params[3] && this.datum_params[4] === t.datum_params[4] && this.datum_params[5] === t.datum_params[5] && this.datum_params[6] === t.datum_params[6] : this.datum_type !== s && t.datum_type !== s || this.nadgrids === t.nadgrids)) },
                geodetic_to_geocentric: function(t) {
                    var e, i, r, o, s, a, h, l = t.x,
                        u = t.y,
                        p = t.z ? t.z : 0,
                        c = 0;
                    if (u < -n && u > -1.001 * n) u = -n;
                    else if (u > n && u < 1.001 * n) u = n;
                    else if (u < -n || u > n) return null;
                    return l > Math.PI && (l -= 2 * Math.PI), s = Math.sin(u), h = Math.cos(u), a = s * s, o = this.a / Math.sqrt(1 - this.es * a), e = (o + p) * h * Math.cos(l), i = (o + p) * h * Math.sin(l), r = (o * (1 - this.es) + p) * s, t.x = e, t.y = i, t.z = r, c
                },
                geocentric_to_geodetic: function(t) {
                    var e, i, r, o, s, a, h, l, u, p, c, f, g, d, y, m, v, b = 1e-12,
                        w = b * b,
                        x = 30,
                        E = t.x,
                        S = t.y,
                        N = t.z ? t.z : 0;
                    if (g = !1, e = Math.sqrt(E * E + S * S), i = Math.sqrt(E * E + S * S + N * N), e / this.a < b) { if (g = !0, y = 0, i / this.a < b) return m = n, void(v = -this.b) } else y = Math.atan2(S, E);
                    r = N / i, o = e / i, s = 1 / Math.sqrt(1 - this.es * (2 - this.es) * o * o), l = o * (1 - this.es) * s, u = r * s, d = 0;
                    do d++, h = this.a / Math.sqrt(1 - this.es * u * u), v = e * l + N * u - h * (1 - this.es * u * u), a = this.es * h / (h + v), s = 1 / Math.sqrt(1 - a * (2 - a) * o * o), p = o * (1 - a) * s, c = r * s, f = c * l - p * u, l = p, u = c; while (f * f > w && d < x);
                    return m = Math.atan(c / Math.abs(p)), t.x = y, t.y = m, t.z = v, t
                },
                geocentric_to_geodetic_noniter: function(t) {
                    var e, i, r, o, s, a, h, l, c, f, g, d, y, m, v, b, w, x = t.x,
                        E = t.y,
                        S = t.z ? t.z : 0;
                    if (x = parseFloat(x), E = parseFloat(E), S = parseFloat(S), w = !1, 0 !== x) e = Math.atan2(E, x);
                    else if (E > 0) e = n;
                    else if (E < 0) e = -n;
                    else if (w = !0, e = 0, S > 0) i = n;
                    else {
                        if (!(S < 0)) return i = n, void(r = -this.b);
                        i = -n
                    }
                    return s = x * x + E * E, o = Math.sqrt(s), a = S * u, l = Math.sqrt(a * a + s), f = a / l, d = o / l, g = f * f * f, h = S + this.b * this.ep2 * g, b = o - this.a * this.es * d * d * d, c = Math.sqrt(h * h + b * b), y = h / c, m = b / c, v = this.a / Math.sqrt(1 - this.es * y * y), r = m >= p ? o / m - v : m <= -p ? o / -m - v : S / y + v * (this.es - 1), w === !1 && (i = Math.atan(y / m)), t.x = e, t.y = i, t.z = r, t
                },
                geocentric_to_wgs84: function(t) {
                    if (this.datum_type === r) t.x += this.datum_params[0], t.y += this.datum_params[1], t.z += this.datum_params[2];
                    else if (this.datum_type === o) {
                        var e = this.datum_params[0],
                            i = this.datum_params[1],
                            n = this.datum_params[2],
                            s = this.datum_params[3],
                            a = this.datum_params[4],
                            h = this.datum_params[5],
                            l = this.datum_params[6],
                            u = l * (t.x - h * t.y + a * t.z) + e,
                            p = l * (h * t.x + t.y - s * t.z) + i,
                            c = l * (-a * t.x + s * t.y + t.z) + n;
                        t.x = u, t.y = p, t.z = c
                    }
                },
                geocentric_from_wgs84: function(t) {
                    if (this.datum_type === r) t.x -= this.datum_params[0], t.y -= this.datum_params[1], t.z -= this.datum_params[2];
                    else if (this.datum_type === o) {
                        var e = this.datum_params[0],
                            i = this.datum_params[1],
                            n = this.datum_params[2],
                            s = this.datum_params[3],
                            a = this.datum_params[4],
                            h = this.datum_params[5],
                            l = this.datum_params[6],
                            u = (t.x - e) / l,
                            p = (t.y - i) / l,
                            c = (t.z - n) / l;
                        t.x = u + h * p - a * c, t.y = -h * u + p + s * c, t.z = a * u - s * p + c
                    }
                }
            }, e.exports = c
        }, {}],
        31: [function(t, e, i) {
            var n = 1,
                r = 2,
                o = 3,
                s = 5,
                a = 6378137,
                h = .006694379990141316;
            e.exports = function(t, e, i) {
                function l(t) { return t === n || t === r }
                var u, p, c;
                if (t.compare_datums(e)) return i;
                if (t.datum_type === s || e.datum_type === s) return i;
                var f = t.a,
                    g = t.es,
                    d = e.a,
                    y = e.es,
                    m = t.datum_type;
                if (m === o)
                    if (0 === this.apply_gridshift(t, 0, i)) t.a = a, t.es = h;
                    else {
                        if (!t.datum_params) return t.a = f, t.es = t.es, i;
                        for (u = 1, p = 0, c = t.datum_params.length; p < c; p++) u *= t.datum_params[p];
                        if (0 === u) return t.a = f, t.es = t.es, i;
                        m = t.datum_params.length > 3 ? r : n
                    }
                return e.datum_type === o && (e.a = a, e.es = h), (t.es !== e.es || t.a !== e.a || l(m) || l(e.datum_type)) && (t.geodetic_to_geocentric(i), l(t.datum_type) && t.geocentric_to_wgs84(i), l(e.datum_type) && e.geocentric_from_wgs84(i), e.geocentric_to_geodetic(i)), e.datum_type === o && this.apply_gridshift(e, 1, i), t.a = f, t.es = g, e.a = d, e.es = y, i
            }
        }, {}],
        32: [function(t, e, i) {
            function n(t) { var e = this; if (2 === arguments.length) { var i = arguments[1]; "string" == typeof i ? "+" === i.charAt(0) ? n[t] = o(arguments[1]) : n[t] = s(arguments[1]) : n[t] = i } else if (1 === arguments.length) { if (Array.isArray(t)) return t.map(function(t) { Array.isArray(t) ? n.apply(e, t) : n(t) }); if ("string" == typeof t) { if (t in n) return n[t] } else "EPSG" in t ? n["EPSG:" + t.EPSG] = t : "ESRI" in t ? n["ESRI:" + t.ESRI] = t : "IAU2000" in t ? n["IAU2000:" + t.IAU2000] = t : console.log(t); return } }
            var r = t("./global"),
                o = t("./projString"),
                s = t("./wkt");
            r(n), e.exports = n
        }, { "./global": 35, "./projString": 38, "./wkt": 67 }],
        33: [function(t, e, i) {
            var n = t("./constants/Datum"),
                r = t("./constants/Ellipsoid"),
                o = t("./extend"),
                s = t("./datum"),
                a = 1e-10,
                h = .16666666666666666,
                l = .04722222222222222,
                u = .022156084656084655;
            e.exports = function(t) {
                if (t.datumCode && "none" !== t.datumCode) {
                    var e = n[t.datumCode];
                    e && (t.datum_params = e.towgs84 ? e.towgs84.split(",") : null, t.ellps = e.ellipse, t.datumName = e.datumName ? e.datumName : t.datumCode)
                }
                if (!t.a) {
                    var i = r[t.ellps] ? r[t.ellps] : r.WGS84;
                    o(t, i)
                }
                return t.rf && !t.b && (t.b = (1 - 1 / t.rf) * t.a), (0 === t.rf || Math.abs(t.a - t.b) < a) && (t.sphere = !0, t.b = t.a), t.a2 = t.a * t.a, t.b2 = t.b * t.b, t.es = (t.a2 - t.b2) / t.a2, t.e = Math.sqrt(t.es), t.R_A && (t.a *= 1 - t.es * (h + t.es * (l + t.es * u)), t.a2 = t.a * t.a, t.b2 = t.b * t.b, t.es = 0), t.ep2 = (t.a2 - t.b2) / t.b2, t.k0 || (t.k0 = 1), t.axis || (t.axis = "enu"), t.datum || (t.datum = s(t)), t
            }
        }, { "./constants/Datum": 25, "./constants/Ellipsoid": 26, "./datum": 30, "./extend": 34 }],
        34: [function(t, e, i) { e.exports = function(t, e) { t = t || {}; var i, n; if (!e) return t; for (n in e) i = e[n], void 0 !== i && (t[n] = i); return t } }, {}],
        35: [function(t, e, i) { e.exports = function(t) { t("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), t("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), t.WGS84 = t["EPSG:4326"], t["EPSG:3785"] = t["EPSG:3857"], t.GOOGLE = t["EPSG:3857"], t["EPSG:900913"] = t["EPSG:3857"], t["EPSG:102113"] = t["EPSG:3857"] } }, {}],
        36: [function(t, e, i) {
            var n = t("./core");
            n.defaultDatum = "WGS84", n.Proj = t("./Proj"), n.WGS84 = new n.Proj("WGS84"), n.Point = t("./Point"), n.toPoint = t("./common/toPoint"), n.defs = t("./defs"), n.transform = t("./transform"), n.mgrs = t("mgrs"), n.version = t("../package.json").version, t("./includedProjections")(n), e.exports = n
        }, { "../package.json": 69, "./Point": 1, "./Proj": 2, "./common/toPoint": 23, "./core": 29, "./defs": 32, "./includedProjections": "./includedProjections", "./transform": 66, mgrs: 68 }],
        37: [function(t, e, i) {
            function n(t) { return "string" == typeof t }

            function r(t) { return t in h }

            function o(t) { var e = ["GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS"]; return e.reduce(function(e, i) { return e + 1 + t.indexOf(i) }, 0) }

            function s(t) { return "+" === t[0] }

            function a(t) { return n(t) ? r(t) ? h[t] : o(t) ? l(t) : s(t) ? u(t) : void 0 : t }
            var h = t("./defs"),
                l = t("./wkt"),
                u = t("./projString");
            e.exports = a
        }, { "./defs": 32, "./projString": 38, "./wkt": 67 }],
        38: [function(t, e, i) {
            var n = .017453292519943295,
                r = t("./constants/PrimeMeridian"),
                o = t("./constants/units");
            e.exports = function(t) {
                var e = {},
                    i = {};
                t.split("+").map(function(t) { return t.trim() }).filter(function(t) { return t }).forEach(function(t) {
                    var e = t.split("=");
                    e.push(!0), i[e[0].toLowerCase()] = e[1]
                });
                var s, a, h, l = {
                    proj: "projName",
                    datum: "datumCode",
                    rf: function(t) { e.rf = parseFloat(t) },
                    lat_0: function(t) { e.lat0 = t * n },
                    lat_1: function(t) { e.lat1 = t * n },
                    lat_2: function(t) { e.lat2 = t * n },
                    lat_ts: function(t) { e.lat_ts = t * n },
                    lon_0: function(t) { e.long0 = t * n },
                    lon_1: function(t) { e.long1 = t * n },
                    lon_2: function(t) { e.long2 = t * n },
                    alpha: function(t) { e.alpha = parseFloat(t) * n },
                    lonc: function(t) { e.longc = t * n },
                    x_0: function(t) { e.x0 = parseFloat(t) },
                    y_0: function(t) { e.y0 = parseFloat(t) },
                    k_0: function(t) { e.k0 = parseFloat(t) },
                    k: function(t) { e.k0 = parseFloat(t) },
                    a: function(t) { e.a = parseFloat(t) },
                    b: function(t) { e.b = parseFloat(t) },
                    r_a: function() { e.R_A = !0 },
                    zone: function(t) { e.zone = parseInt(t, 10) },
                    south: function() { e.utmSouth = !0 },
                    towgs84: function(t) { e.datum_params = t.split(",").map(function(t) { return parseFloat(t) }) },
                    to_meter: function(t) { e.to_meter = parseFloat(t) },
                    units: function(t) { e.units = t, o[t] && (e.to_meter = o[t].to_meter) },
                    from_greenwich: function(t) { e.from_greenwich = t * n },
                    pm: function(t) { e.from_greenwich = (r[t] ? r[t] : parseFloat(t)) * n },
                    nadgrids: function(t) { "@null" === t ? e.datumCode = "none" : e.nadgrids = t },
                    axis: function(t) {
                        var i = "ewnsud";
                        3 === t.length && i.indexOf(t.substr(0, 1)) !== -1 && i.indexOf(t.substr(1, 1)) !== -1 && i.indexOf(t.substr(2, 1)) !== -1 && (e.axis = t)
                    }
                };
                for (s in i) a = i[s], s in l ? (h = l[s], "function" == typeof h ? h(a) : e[h] = a) : e[s] = a;
                return "string" == typeof e.datumCode && "WGS84" !== e.datumCode && (e.datumCode = e.datumCode.toLowerCase()), e
            }
        }, { "./constants/PrimeMeridian": 27, "./constants/units": 28 }],
        39: [function(t, e, i) {
            function n(t, e) { var i = s.length; return t.names ? (s[i] = t, t.names.forEach(function(t) { o[t.toLowerCase()] = i }), this) : (console.log(e), !0) }
            var r = [t("./projections/merc"), t("./projections/longlat")],
                o = {},
                s = [];
            i.add = n, i.get = function(t) { if (!t) return !1; var e = t.toLowerCase(); return "undefined" != typeof o[e] && s[o[e]] ? s[o[e]] : void 0 }, i.start = function() { r.forEach(n) }
        }, { "./projections/longlat": 51, "./projections/merc": 52 }],
        40: [function(t, e, i) {
            var n = 1e-10,
                r = t("../common/msfnz"),
                o = t("../common/qsfnz"),
                s = t("../common/adjust_lon"),
                a = t("../common/asinz");
            i.init = function() { Math.abs(this.lat1 + this.lat2) < n || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = r(this.e3, this.sin_po, this.cos_po), this.qs1 = o(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = r(this.e3, this.sin_po, this.cos_po), this.qs2 = o(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = o(this.e3, this.sin_po, this.cos_po), Math.abs(this.lat1 - this.lat2) > n ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0) }, i.forward = function(t) {
                var e = t.x,
                    i = t.y;
                this.sin_phi = Math.sin(i), this.cos_phi = Math.cos(i);
                var n = o(this.e3, this.sin_phi, this.cos_phi),
                    r = this.a * Math.sqrt(this.c - this.ns0 * n) / this.ns0,
                    a = this.ns0 * s(e - this.long0),
                    h = r * Math.sin(a) + this.x0,
                    l = this.rh - r * Math.cos(a) + this.y0;
                return t.x = h, t.y = l, t
            }, i.inverse = function(t) {
                var e, i, n, r, o, a;
                return t.x -= this.x0, t.y = this.rh - t.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(t.x * t.x + t.y * t.y),
                    n = 1) : (e = -Math.sqrt(t.x * t.x + t.y * t.y), n = -1), r = 0, 0 !== e && (r = Math.atan2(n * t.x, n * t.y)), n = e * this.ns0 / this.a, this.sphere ? a = Math.asin((this.c - n * n) / (2 * this.ns0)) : (i = (this.c - n * n) / this.ns0, a = this.phi1z(this.e3, i)), o = s(r / this.ns0 + this.long0), t.x = o, t.y = a, t
            }, i.phi1z = function(t, e) {
                var i, r, o, s, h, l = a(.5 * e);
                if (t < n) return l;
                for (var u = t * t, p = 1; p <= 25; p++)
                    if (i = Math.sin(l), r = Math.cos(l), o = t * i, s = 1 - o * o, h = .5 * s * s / r * (e / (1 - u) - i / s + .5 / t * Math.log((1 - o) / (1 + o))), l += h, Math.abs(h) <= 1e-7) return l;
                return null
            }, i.names = ["Albers_Conic_Equal_Area", "Albers", "aea"]
        }, { "../common/adjust_lon": 5, "../common/asinz": 6, "../common/msfnz": 15, "../common/qsfnz": 20 }],
        41: [function(t, e, i) {
            var n = t("../common/adjust_lon"),
                r = Math.PI / 2,
                o = 1e-10,
                s = t("../common/mlfn"),
                a = t("../common/e0fn"),
                h = t("../common/e1fn"),
                l = t("../common/e2fn"),
                u = t("../common/e3fn"),
                p = t("../common/gN"),
                c = t("../common/asinz"),
                f = t("../common/imlfn");
            i.init = function() { this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0) }, i.forward = function(t) {
                var e, i, c, f, g, d, y, m, v, b, w, x, E, S, N, L, C, M, I, k, T, A, R, _ = t.x,
                    P = t.y,
                    O = Math.sin(t.y),
                    D = Math.cos(t.y),
                    F = n(_ - this.long0);
                return this.sphere ? Math.abs(this.sin_p12 - 1) <= o ? (t.x = this.x0 + this.a * (r - P) * Math.sin(F), t.y = this.y0 - this.a * (r - P) * Math.cos(F), t) : Math.abs(this.sin_p12 + 1) <= o ? (t.x = this.x0 + this.a * (r + P) * Math.sin(F), t.y = this.y0 + this.a * (r + P) * Math.cos(F), t) : (M = this.sin_p12 * O + this.cos_p12 * D * Math.cos(F), L = Math.acos(M), C = L / Math.sin(L), t.x = this.x0 + this.a * C * D * Math.sin(F), t.y = this.y0 + this.a * C * (this.cos_p12 * O - this.sin_p12 * D * Math.cos(F)), t) : (e = a(this.es), i = h(this.es), c = l(this.es), f = u(this.es), Math.abs(this.sin_p12 - 1) <= o ? (g = this.a * s(e, i, c, f, r), d = this.a * s(e, i, c, f, P), t.x = this.x0 + (g - d) * Math.sin(F), t.y = this.y0 - (g - d) * Math.cos(F), t) : Math.abs(this.sin_p12 + 1) <= o ? (g = this.a * s(e, i, c, f, r), d = this.a * s(e, i, c, f, P), t.x = this.x0 + (g + d) * Math.sin(F), t.y = this.y0 + (g + d) * Math.cos(F), t) : (y = O / D, m = p(this.a, this.e, this.sin_p12), v = p(this.a, this.e, O), b = Math.atan((1 - this.es) * y + this.es * m * this.sin_p12 / (v * D)), w = Math.atan2(Math.sin(F), this.cos_p12 * Math.tan(b) - this.sin_p12 * Math.cos(F)), I = 0 === w ? Math.asin(this.cos_p12 * Math.sin(b) - this.sin_p12 * Math.cos(b)) : Math.abs(Math.abs(w) - Math.PI) <= o ? -Math.asin(this.cos_p12 * Math.sin(b) - this.sin_p12 * Math.cos(b)) : Math.asin(Math.sin(F) * Math.cos(b) / Math.sin(w)), x = this.e * this.sin_p12 / Math.sqrt(1 - this.es), E = this.e * this.cos_p12 * Math.cos(w) / Math.sqrt(1 - this.es), S = x * E, N = E * E, k = I * I, T = k * I, A = T * I, R = A * I, L = m * I * (1 - k * N * (1 - N) / 6 + T / 8 * S * (1 - 2 * N) + A / 120 * (N * (4 - 7 * N) - 3 * x * x * (1 - 7 * N)) - R / 48 * S), t.x = this.x0 + L * Math.sin(w), t.y = this.y0 + L * Math.cos(w), t))
            }, i.inverse = function(t) { t.x -= this.x0, t.y -= this.y0; var e, i, g, d, y, m, v, b, w, x, E, S, N, L, C, M, I, k, T, A, R, _, P; if (this.sphere) { if (e = Math.sqrt(t.x * t.x + t.y * t.y), e > 2 * r * this.a) return; return i = e / this.a, g = Math.sin(i), d = Math.cos(i), y = this.long0, Math.abs(e) <= o ? m = this.lat0 : (m = c(d * this.sin_p12 + t.y * g * this.cos_p12 / e), v = Math.abs(this.lat0) - r, y = n(Math.abs(v) <= o ? this.lat0 >= 0 ? this.long0 + Math.atan2(t.x, -t.y) : this.long0 - Math.atan2(-t.x, t.y) : this.long0 + Math.atan2(t.x * g, e * this.cos_p12 * d - t.y * this.sin_p12 * g))), t.x = y, t.y = m, t } return b = a(this.es), w = h(this.es), x = l(this.es), E = u(this.es), Math.abs(this.sin_p12 - 1) <= o ? (S = this.a * s(b, w, x, E, r), e = Math.sqrt(t.x * t.x + t.y * t.y), N = S - e, m = f(N / this.a, b, w, x, E), y = n(this.long0 + Math.atan2(t.x, -1 * t.y)), t.x = y, t.y = m, t) : Math.abs(this.sin_p12 + 1) <= o ? (S = this.a * s(b, w, x, E, r), e = Math.sqrt(t.x * t.x + t.y * t.y), N = e - S, m = f(N / this.a, b, w, x, E), y = n(this.long0 + Math.atan2(t.x, t.y)), t.x = y, t.y = m, t) : (e = Math.sqrt(t.x * t.x + t.y * t.y), M = Math.atan2(t.x, t.y), L = p(this.a, this.e, this.sin_p12), I = Math.cos(M), k = this.e * this.cos_p12 * I, T = -k * k / (1 - this.es), A = 3 * this.es * (1 - T) * this.sin_p12 * this.cos_p12 * I / (1 - this.es), R = e / L, _ = R - T * (1 + T) * Math.pow(R, 3) / 6 - A * (1 + 3 * T) * Math.pow(R, 4) / 24, P = 1 - T * _ * _ / 2 - R * _ * _ * _ / 6, C = Math.asin(this.sin_p12 * Math.cos(_) + this.cos_p12 * Math.sin(_) * I), y = n(this.long0 + Math.asin(Math.sin(M) * Math.sin(_) / Math.cos(C))), m = Math.atan((1 - this.es * P * this.sin_p12 / Math.sin(C)) * Math.tan(C) / (1 - this.es)), t.x = y, t.y = m, t) }, i.names = ["Azimuthal_Equidistant", "aeqd"]
        }, { "../common/adjust_lon": 5, "../common/asinz": 6, "../common/e0fn": 7, "../common/e1fn": 8, "../common/e2fn": 9, "../common/e3fn": 10, "../common/gN": 11, "../common/imlfn": 12, "../common/mlfn": 14 }],
        42: [function(t, e, i) {
            var n = t("../common/mlfn"),
                r = t("../common/e0fn"),
                o = t("../common/e1fn"),
                s = t("../common/e2fn"),
                a = t("../common/e3fn"),
                h = t("../common/gN"),
                l = t("../common/adjust_lon"),
                u = t("../common/adjust_lat"),
                p = t("../common/imlfn"),
                c = Math.PI / 2,
                f = 1e-10;
            i.init = function() { this.sphere || (this.e0 = r(this.es), this.e1 = o(this.es), this.e2 = s(this.es), this.e3 = a(this.es), this.ml0 = this.a * n(this.e0, this.e1, this.e2, this.e3, this.lat0)) }, i.forward = function(t) {
                var e, i, r = t.x,
                    o = t.y;
                if (r = l(r - this.long0), this.sphere) e = this.a * Math.asin(Math.cos(o) * Math.sin(r)), i = this.a * (Math.atan2(Math.tan(o), Math.cos(r)) - this.lat0);
                else {
                    var s = Math.sin(o),
                        a = Math.cos(o),
                        u = h(this.a, this.e, s),
                        p = Math.tan(o) * Math.tan(o),
                        c = r * Math.cos(o),
                        f = c * c,
                        g = this.es * a * a / (1 - this.es),
                        d = this.a * n(this.e0, this.e1, this.e2, this.e3, o);
                    e = u * c * (1 - f * p * (1 / 6 - (8 - p + 8 * g) * f / 120)), i = d - this.ml0 + u * s / a * f * (.5 + (5 - p + 6 * g) * f / 24)
                }
                return t.x = e + this.x0, t.y = i + this.y0, t
            }, i.inverse = function(t) {
                t.x -= this.x0, t.y -= this.y0;
                var e, i, n = t.x / this.a,
                    r = t.y / this.a;
                if (this.sphere) {
                    var o = r + this.lat0;
                    e = Math.asin(Math.sin(o) * Math.cos(n)), i = Math.atan2(Math.tan(n), Math.cos(o))
                } else {
                    var s = this.ml0 / this.a + r,
                        a = p(s, this.e0, this.e1, this.e2, this.e3);
                    if (Math.abs(Math.abs(a) - c) <= f) return t.x = this.long0, t.y = c, r < 0 && (t.y *= -1), t;
                    var g = h(this.a, this.e, Math.sin(a)),
                        d = g * g * g / this.a / this.a * (1 - this.es),
                        y = Math.pow(Math.tan(a), 2),
                        m = n * this.a / g,
                        v = m * m;
                    e = a - g * Math.tan(a) / d * m * m * (.5 - (1 + 3 * y) * m * m / 24), i = m * (1 - v * (y / 3 + (1 + 3 * y) * y * v / 15)) / Math.cos(a)
                }
                return t.x = l(i + this.long0), t.y = u(e), t
            }, i.names = ["Cassini", "Cassini_Soldner", "cass"]
        }, { "../common/adjust_lat": 4, "../common/adjust_lon": 5, "../common/e0fn": 7, "../common/e1fn": 8, "../common/e2fn": 9, "../common/e3fn": 10, "../common/gN": 11, "../common/imlfn": 12, "../common/mlfn": 14 }],
        43: [function(t, e, i) {
            var n = t("../common/adjust_lon"),
                r = t("../common/qsfnz"),
                o = t("../common/msfnz"),
                s = t("../common/iqsfnz");
            i.init = function() { this.sphere || (this.k0 = o(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts))) }, i.forward = function(t) {
                var e, i, o = t.x,
                    s = t.y,
                    a = n(o - this.long0);
                if (this.sphere) e = this.x0 + this.a * a * Math.cos(this.lat_ts), i = this.y0 + this.a * Math.sin(s) / Math.cos(this.lat_ts);
                else {
                    var h = r(this.e, Math.sin(s));
                    e = this.x0 + this.a * this.k0 * a, i = this.y0 + this.a * h * .5 / this.k0
                }
                return t.x = e, t.y = i, t
            }, i.inverse = function(t) { t.x -= this.x0, t.y -= this.y0; var e, i; return this.sphere ? (e = n(this.long0 + t.x / this.a / Math.cos(this.lat_ts)), i = Math.asin(t.y / this.a * Math.cos(this.lat_ts))) : (i = s(this.e, 2 * t.y * this.k0 / this.a), e = n(this.long0 + t.x / (this.a * this.k0))), t.x = e, t.y = i, t }, i.names = ["cea"]
        }, { "../common/adjust_lon": 5, "../common/iqsfnz": 13, "../common/msfnz": 15, "../common/qsfnz": 20 }],
        44: [function(t, e, i) {
            var n = t("../common/adjust_lon"),
                r = t("../common/adjust_lat");
            i.init = function() { this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts) }, i.forward = function(t) {
                var e = t.x,
                    i = t.y,
                    o = n(e - this.long0),
                    s = r(i - this.lat0);
                return t.x = this.x0 + this.a * o * this.rc, t.y = this.y0 + this.a * s, t
            }, i.inverse = function(t) {
                var e = t.x,
                    i = t.y;
                return t.x = n(this.long0 + (e - this.x0) / (this.a * this.rc)), t.y = r(this.lat0 + (i - this.y0) / this.a), t
            }, i.names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"]
        }, { "../common/adjust_lat": 4, "../common/adjust_lon": 5 }],
        45: [function(t, e, i) {
            var n = t("../common/e0fn"),
                r = t("../common/e1fn"),
                o = t("../common/e2fn"),
                s = t("../common/e3fn"),
                a = t("../common/msfnz"),
                h = t("../common/mlfn"),
                l = t("../common/adjust_lon"),
                u = t("../common/adjust_lat"),
                p = t("../common/imlfn"),
                c = 1e-10;
            i.init = function() { Math.abs(this.lat1 + this.lat2) < c || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = n(this.es), this.e1 = r(this.es), this.e2 = o(this.es), this.e3 = s(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = a(this.e, this.sinphi, this.cosphi), this.ml1 = h(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < c ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = a(this.e, this.sinphi, this.cosphi), this.ml2 = h(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = h(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0)) }, i.forward = function(t) {
                var e, i = t.x,
                    n = t.y;
                if (this.sphere) e = this.a * (this.g - n);
                else {
                    var r = h(this.e0, this.e1, this.e2, this.e3, n);
                    e = this.a * (this.g - r)
                }
                var o = this.ns * l(i - this.long0),
                    s = this.x0 + e * Math.sin(o),
                    a = this.y0 + this.rh - e * Math.cos(o);
                return t.x = s, t.y = a, t
            }, i.inverse = function(t) {
                t.x -= this.x0, t.y = this.rh - t.y + this.y0;
                var e, i, n, r;
                this.ns >= 0 ? (i = Math.sqrt(t.x * t.x + t.y * t.y), e = 1) : (i = -Math.sqrt(t.x * t.x + t.y * t.y), e = -1);
                var o = 0;
                if (0 !== i && (o = Math.atan2(e * t.x, e * t.y)), this.sphere) return r = l(this.long0 + o / this.ns), n = u(this.g - i / this.a), t.x = r, t.y = n, t;
                var s = this.g - i / this.a;
                return n = p(s, this.e0, this.e1, this.e2, this.e3), r = l(this.long0 + o / this.ns), t.x = r, t.y = n, t
            }, i.names = ["Equidistant_Conic", "eqdc"]
        }, { "../common/adjust_lat": 4, "../common/adjust_lon": 5, "../common/e0fn": 7, "../common/e1fn": 8, "../common/e2fn": 9, "../common/e3fn": 10, "../common/imlfn": 12, "../common/mlfn": 14, "../common/msfnz": 15 }],
        46: [function(t, e, i) {
            var n = Math.PI / 4,
                r = t("../common/srat"),
                o = Math.PI / 2,
                s = 20;
            i.init = function() {
                var t = Math.sin(this.lat0),
                    e = Math.cos(this.lat0);
                e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t * t), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(t / this.C), this.ratexp = .5 * this.C * this.e, this.K = Math.tan(.5 * this.phic0 + n) / (Math.pow(Math.tan(.5 * this.lat0 + n), this.C) * r(this.e * t, this.ratexp))
            }, i.forward = function(t) {
                var e = t.x,
                    i = t.y;
                return t.y = 2 * Math.atan(this.K * Math.pow(Math.tan(.5 * i + n), this.C) * r(this.e * Math.sin(i), this.ratexp)) - o, t.x = this.C * e, t
            }, i.inverse = function(t) { for (var e = 1e-14, i = t.x / this.C, a = t.y, h = Math.pow(Math.tan(.5 * a + n) / this.K, 1 / this.C), l = s; l > 0 && (a = 2 * Math.atan(h * r(this.e * Math.sin(t.y), -.5 * this.e)) - o, !(Math.abs(a - t.y) < e)); --l) t.y = a; return l ? (t.x = i, t.y = a, t) : null }, i.names = ["gauss"]
        }, { "../common/srat": 22 }],
        47: [function(t, e, i) {
            var n = t("../common/adjust_lon"),
                r = 1e-10,
                o = t("../common/asinz");
            i.init = function() { this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1 }, i.forward = function(t) {
                var e, i, o, s, a, h, l, u, p = t.x,
                    c = t.y;
                return o = n(p - this.long0), e = Math.sin(c), i = Math.cos(c), s = Math.cos(o), h = this.sin_p14 * e + this.cos_p14 * i * s, a = 1, h > 0 || Math.abs(h) <= r ? (l = this.x0 + this.a * a * i * Math.sin(o) / h, u = this.y0 + this.a * a * (this.cos_p14 * e - this.sin_p14 * i * s) / h) : (l = this.x0 + this.infinity_dist * i * Math.sin(o), u = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * i * s)), t.x = l, t.y = u, t
            }, i.inverse = function(t) { var e, i, r, s, a, h; return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, (e = Math.sqrt(t.x * t.x + t.y * t.y)) ? (s = Math.atan2(e, this.rc), i = Math.sin(s), r = Math.cos(s), h = o(r * this.sin_p14 + t.y * i * this.cos_p14 / e), a = Math.atan2(t.x * i, e * this.cos_p14 * r - t.y * this.sin_p14 * i), a = n(this.long0 + a)) : (h = this.phic0, a = 0), t.x = a, t.y = h, t }, i.names = ["gnom"]
        }, { "../common/adjust_lon": 5, "../common/asinz": 6 }],
        48: [function(t, e, i) {
            var n = t("../common/adjust_lon");
            i.init = function() { this.a = 6377397.155, this.es = .006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = .863937979737193), this.long0 || (this.long0 = .4334234309119251), this.k0 || (this.k0 = .9999), this.s45 = .785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq }, i.forward = function(t) {
                var e, i, r, o, s, a, h, l = t.x,
                    u = t.y,
                    p = n(l - this.long0);
                return e = Math.pow((1 + this.e * Math.sin(u)) / (1 - this.e * Math.sin(u)), this.alfa * this.e / 2), i = 2 * (Math.atan(this.k * Math.pow(Math.tan(u / 2 + this.s45), this.alfa) / e) - this.s45), r = -p * this.alfa, o = Math.asin(Math.cos(this.ad) * Math.sin(i) + Math.sin(this.ad) * Math.cos(i) * Math.cos(r)), s = Math.asin(Math.cos(i) * Math.sin(r) / Math.cos(o)), a = this.n * s, h = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(o / 2 + this.s45), this.n), t.y = h * Math.cos(a) / 1, t.x = h * Math.sin(a) / 1, this.czech || (t.y *= -1, t.x *= -1), t
            }, i.inverse = function(t) {
                var e, i, n, r, o, s, a, h, l = t.x;
                t.x = t.y, t.y = l, this.czech || (t.y *= -1, t.x *= -1), s = Math.sqrt(t.x * t.x + t.y * t.y), o = Math.atan2(t.y, t.x), r = o / Math.sin(this.s0), n = 2 * (Math.atan(Math.pow(this.ro0 / s, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(n) - Math.sin(this.ad) * Math.cos(n) * Math.cos(r)), i = Math.asin(Math.cos(n) * Math.sin(r) / Math.cos(e)), t.x = this.long0 - i / this.alfa, a = e, h = 0;
                var u = 0;
                do t.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(a)) / (1 - this.e * Math.sin(a)), this.e / 2)) - this.s45), Math.abs(a - t.y) < 1e-10 && (h = 1), a = t.y, u += 1; while (0 === h && u < 15);
                return u >= 15 ? null : t
            }, i.names = ["Krovak", "krovak"]
        }, { "../common/adjust_lon": 5 }],
        49: [function(t, e, i) {
            var n = Math.PI / 2,
                r = Math.PI / 4,
                o = 1e-10,
                s = t("../common/qsfnz"),
                a = t("../common/adjust_lon");
            i.S_POLE = 1, i.N_POLE = 2, i.EQUIT = 3, i.OBLIQ = 4, i.init = function() {
                var t = Math.abs(this.lat0);
                if (Math.abs(t - n) < o ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(t) < o ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
                    var e;
                    switch (this.qp = s(this.e, 1), this.mmf = .5 / (1 - this.es), this.apa = this.authset(this.es), this.mode) {
                        case this.N_POLE:
                            this.dd = 1;
                            break;
                        case this.S_POLE:
                            this.dd = 1;
                            break;
                        case this.EQUIT:
                            this.rq = Math.sqrt(.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = .5 * this.qp;
                            break;
                        case this.OBLIQ:
                            this.rq = Math.sqrt(.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = s(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd
                    }
                } else this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0))
            }, i.forward = function(t) {
                var e, i, h, l, u, p, c, f, g, d, y = t.x,
                    m = t.y;
                if (y = a(y - this.long0), this.sphere) {
                    if (u = Math.sin(m), d = Math.cos(m), h = Math.cos(y), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                        if (i = this.mode === this.EQUIT ? 1 + d * h : 1 + this.sinph0 * u + this.cosph0 * d * h, i <= o) return null;
                        i = Math.sqrt(2 / i), e = i * d * Math.sin(y), i *= this.mode === this.EQUIT ? u : this.cosph0 * u - this.sinph0 * d * h
                    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                        if (this.mode === this.N_POLE && (h = -h), Math.abs(m + this.phi0) < o) return null;
                        i = r - .5 * m, i = 2 * (this.mode === this.S_POLE ? Math.cos(i) : Math.sin(i)), e = i * Math.sin(y), i *= h
                    }
                } else {
                    switch (c = 0, f = 0, g = 0, h = Math.cos(y), l = Math.sin(y), u = Math.sin(m), p = s(this.e, u), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (c = p / this.qp, f = Math.sqrt(1 - c * c)), this.mode) {
                        case this.OBLIQ:
                            g = 1 + this.sinb1 * c + this.cosb1 * f * h;
                            break;
                        case this.EQUIT:
                            g = 1 + f * h;
                            break;
                        case this.N_POLE:
                            g = n + m, p = this.qp - p;
                            break;
                        case this.S_POLE:
                            g = m - n, p = this.qp + p
                    }
                    if (Math.abs(g) < o) return null;
                    switch (this.mode) {
                        case this.OBLIQ:
                        case this.EQUIT:
                            g = Math.sqrt(2 / g), i = this.mode === this.OBLIQ ? this.ymf * g * (this.cosb1 * c - this.sinb1 * f * h) : (g = Math.sqrt(2 / (1 + f * h))) * c * this.ymf, e = this.xmf * g * f * l;
                            break;
                        case this.N_POLE:
                        case this.S_POLE:
                            p >= 0 ? (e = (g = Math.sqrt(p)) * l, i = h * (this.mode === this.S_POLE ? g : -g)) : e = i = 0
                    }
                }
                return t.x = this.a * e + this.x0, t.y = this.a * i + this.y0, t
            }, i.inverse = function(t) {
                t.x -= this.x0, t.y -= this.y0;
                var e, i, r, s, h, l, u, p = t.x / this.a,
                    c = t.y / this.a;
                if (this.sphere) {
                    var f, g = 0,
                        d = 0;
                    if (f = Math.sqrt(p * p + c * c), i = .5 * f, i > 1) return null;
                    switch (i = 2 * Math.asin(i), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (d = Math.sin(i), g = Math.cos(i)), this.mode) {
                        case this.EQUIT:
                            i = Math.abs(f) <= o ? 0 : Math.asin(c * d / f), p *= d, c = g * f;
                            break;
                        case this.OBLIQ:
                            i = Math.abs(f) <= o ? this.phi0 : Math.asin(g * this.sinph0 + c * d * this.cosph0 / f), p *= d * this.cosph0, c = (g - Math.sin(i) * this.sinph0) * f;
                            break;
                        case this.N_POLE:
                            c = -c, i = n - i;
                            break;
                        case this.S_POLE:
                            i -= n
                    }
                    e = 0 !== c || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(p, c) : 0
                } else {
                    if (u = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                        if (p /= this.dd, c *= this.dd, l = Math.sqrt(p * p + c * c), l < o) return t.x = 0, t.y = this.phi0, t;
                        s = 2 * Math.asin(.5 * l / this.rq), r = Math.cos(s), p *= s = Math.sin(s), this.mode === this.OBLIQ ? (u = r * this.sinb1 + c * s * this.cosb1 / l, h = this.qp * u, c = l * this.cosb1 * r - c * this.sinb1 * s) : (u = c * s / l, h = this.qp * u, c = l * r)
                    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                        if (this.mode === this.N_POLE && (c = -c), h = p * p + c * c, !h) return t.x = 0, t.y = this.phi0, t;
                        u = 1 - h / this.qp, this.mode === this.S_POLE && (u = -u)
                    }
                    e = Math.atan2(p, c), i = this.authlat(Math.asin(u), this.apa)
                }
                return t.x = a(this.long0 + e), t.y = i, t
            }, i.P00 = .3333333333333333, i.P01 = .17222222222222222, i.P02 = .10257936507936508, i.P10 = .06388888888888888, i.P11 = .0664021164021164, i.P20 = .016415012942191543, i.authset = function(t) { var e, i = []; return i[0] = t * this.P00, e = t * t, i[0] += e * this.P01, i[1] = e * this.P10, e *= t, i[0] += e * this.P02, i[1] += e * this.P11, i[2] = e * this.P20, i }, i.authlat = function(t, e) { var i = t + t; return t + e[0] * Math.sin(i) + e[1] * Math.sin(i + i) + e[2] * Math.sin(i + i + i) }, i.names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"]
        }, { "../common/adjust_lon": 5, "../common/qsfnz": 20 }],
        50: [function(t, e, i) {
            var n = 1e-10,
                r = t("../common/msfnz"),
                o = t("../common/tsfnz"),
                s = Math.PI / 2,
                a = t("../common/sign"),
                h = t("../common/adjust_lon"),
                l = t("../common/phi2z");
            i.init = function() {
                if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < n)) {
                    var t = this.b / this.a;
                    this.e = Math.sqrt(1 - t * t);
                    var e = Math.sin(this.lat1),
                        i = Math.cos(this.lat1),
                        s = r(this.e, e, i),
                        a = o(this.e, this.lat1, e),
                        h = Math.sin(this.lat2),
                        l = Math.cos(this.lat2),
                        u = r(this.e, h, l),
                        p = o(this.e, this.lat2, h),
                        c = o(this.e, this.lat0, Math.sin(this.lat0));
                    Math.abs(this.lat1 - this.lat2) > n ? this.ns = Math.log(s / u) / Math.log(a / p) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = s / (this.ns * Math.pow(a, this.ns)), this.rh = this.a * this.f0 * Math.pow(c, this.ns), this.title || (this.title = "Lambert Conformal Conic")
                }
            }, i.forward = function(t) {
                var e = t.x,
                    i = t.y;
                Math.abs(2 * Math.abs(i) - Math.PI) <= n && (i = a(i) * (s - 2 * n));
                var r, l, u = Math.abs(Math.abs(i) - s);
                if (u > n) r = o(this.e, i, Math.sin(i)), l = this.a * this.f0 * Math.pow(r, this.ns);
                else {
                    if (u = i * this.ns, u <= 0) return null;
                    l = 0
                }
                var p = this.ns * h(e - this.long0);
                return t.x = this.k0 * (l * Math.sin(p)) + this.x0, t.y = this.k0 * (this.rh - l * Math.cos(p)) + this.y0, t
            }, i.inverse = function(t) {
                var e, i, n, r, o, a = (t.x - this.x0) / this.k0,
                    u = this.rh - (t.y - this.y0) / this.k0;
                this.ns > 0 ? (e = Math.sqrt(a * a + u * u), i = 1) : (e = -Math.sqrt(a * a + u * u), i = -1);
                var p = 0;
                if (0 !== e && (p = Math.atan2(i * a, i * u)), 0 !== e || this.ns > 0) { if (i = 1 / this.ns, n = Math.pow(e / (this.a * this.f0), i), r = l(this.e, n), r === -9999) return null } else r = -s;
                return o = h(p / this.ns + this.long0), t.x = o, t.y = r, t
            }, i.names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"]
        }, { "../common/adjust_lon": 5, "../common/msfnz": 15, "../common/phi2z": 16, "../common/sign": 21, "../common/tsfnz": 24 }],
        51: [function(t, e, i) {
            function n(t) { return t }
            i.init = function() {}, i.forward = n, i.inverse = n, i.names = ["longlat", "identity"]
        }, {}],
        52: [function(t, e, i) {
            var n = t("../common/msfnz"),
                r = Math.PI / 2,
                o = 1e-10,
                s = 57.29577951308232,
                a = t("../common/adjust_lon"),
                h = Math.PI / 4,
                l = t("../common/tsfnz"),
                u = t("../common/phi2z");
            i.init = function() {
                var t = this.b / this.a;
                this.es = 1 - t * t, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = n(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1)
            }, i.forward = function(t) {
                var e = t.x,
                    i = t.y;
                if (i * s > 90 && i * s < -90 && e * s > 180 && e * s < -180) return null;
                var n, u;
                if (Math.abs(Math.abs(i) - r) <= o) return null;
                if (this.sphere) n = this.x0 + this.a * this.k0 * a(e - this.long0), u = this.y0 + this.a * this.k0 * Math.log(Math.tan(h + .5 * i));
                else {
                    var p = Math.sin(i),
                        c = l(this.e, i, p);
                    n = this.x0 + this.a * this.k0 * a(e - this.long0), u = this.y0 - this.a * this.k0 * Math.log(c)
                }
                return t.x = n, t.y = u, t
            }, i.inverse = function(t) {
                var e, i, n = t.x - this.x0,
                    o = t.y - this.y0;
                if (this.sphere) i = r - 2 * Math.atan(Math.exp(-o / (this.a * this.k0)));
                else { var s = Math.exp(-o / (this.a * this.k0)); if (i = u(this.e, s), i === -9999) return null }
                return e = a(this.long0 + n / (this.a * this.k0)), t.x = e, t.y = i, t
            }, i.names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"]
        }, { "../common/adjust_lon": 5, "../common/msfnz": 15, "../common/phi2z": 16, "../common/tsfnz": 24 }],
        53: [function(t, e, i) {
            var n = t("../common/adjust_lon");
            i.init = function() {}, i.forward = function(t) {
                var e = t.x,
                    i = t.y,
                    r = n(e - this.long0),
                    o = this.x0 + this.a * r,
                    s = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + i / 2.5)) * 1.25;
                return t.x = o, t.y = s, t
            }, i.inverse = function(t) {
                t.x -= this.x0, t.y -= this.y0;
                var e = n(this.long0 + t.x / this.a),
                    i = 2.5 * (Math.atan(Math.exp(.8 * t.y / this.a)) - Math.PI / 4);
                return t.x = e, t.y = i, t
            }, i.names = ["Miller_Cylindrical", "mill"]
        }, { "../common/adjust_lon": 5 }],
        54: [function(t, e, i) {
            var n = t("../common/adjust_lon"),
                r = 1e-10;
            i.init = function() {}, i.forward = function(t) {
                for (var e = t.x, i = t.y, o = n(e - this.long0), s = i, a = Math.PI * Math.sin(i), h = 0; !0; h++) { var l = -(s + Math.sin(s) - a) / (1 + Math.cos(s)); if (s += l, Math.abs(l) < r) break }
                s /= 2, Math.PI / 2 - Math.abs(i) < r && (o = 0);
                var u = .900316316158 * this.a * o * Math.cos(s) + this.x0,
                    p = 1.4142135623731 * this.a * Math.sin(s) + this.y0;
                return t.x = u, t.y = p, t
            }, i.inverse = function(t) {
                var e, i;
                t.x -= this.x0, t.y -= this.y0, i = t.y / (1.4142135623731 * this.a), Math.abs(i) > .999999999999 && (i = .999999999999), e = Math.asin(i);
                var r = n(this.long0 + t.x / (.900316316158 * this.a * Math.cos(e)));
                r < -Math.PI && (r = -Math.PI), r > Math.PI && (r = Math.PI), i = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(i) > 1 && (i = 1);
                var o = Math.asin(i);
                return t.x = r, t.y = o, t
            }, i.names = ["Mollweide", "moll"]
        }, { "../common/adjust_lon": 5 }],
        55: [function(t, e, i) {
            var n = 484813681109536e-20;
            i.iterations = 1, i.init = function() { this.A = [], this.A[1] = .6399175073, this.A[2] = -.1358797613, this.A[3] = .063294409, this.A[4] = -.02526853, this.A[5] = .0117879, this.A[6] = -.0055161, this.A[7] = .0026906, this.A[8] = -.001333, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = .7557853228, this.B_im[1] = 0, this.B_re[2] = .249204646, this.B_im[2] = .003371507, this.B_re[3] = -.001541739, this.B_im[3] = .04105856, this.B_re[4] = -.10162907, this.B_im[4] = .01727609, this.B_re[5] = -.26623489, this.B_im[5] = -.36249218, this.B_re[6] = -.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -.577245789, this.C_im[2] = -.007809598, this.C_re[3] = .508307513, this.C_im[3] = -.112208952, this.C_re[4] = -.15094762, this.C_im[4] = .18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = .5185406398, this.D[3] = -.03333098, this.D[4] = -.1052906, this.D[5] = -.0368594, this.D[6] = .007317, this.D[7] = .0122, this.D[8] = .00394, this.D[9] = -.0013 }, i.forward = function(t) {
                var e, i = t.x,
                    r = t.y,
                    o = r - this.lat0,
                    s = i - this.long0,
                    a = o / n * 1e-5,
                    h = s,
                    l = 1,
                    u = 0;
                for (e = 1; e <= 10; e++) l *= a, u += this.A[e] * l;
                var p, c, f = u,
                    g = h,
                    d = 1,
                    y = 0,
                    m = 0,
                    v = 0;
                for (e = 1; e <= 6; e++) p = d * f - y * g, c = y * f + d * g, d = p, y = c, m = m + this.B_re[e] * d - this.B_im[e] * y, v = v + this.B_im[e] * d + this.B_re[e] * y;
                return t.x = v * this.a + this.x0, t.y = m * this.a + this.y0, t
            }, i.inverse = function(t) {
                var e, i, r, o = t.x,
                    s = t.y,
                    a = o - this.x0,
                    h = s - this.y0,
                    l = h / this.a,
                    u = a / this.a,
                    p = 1,
                    c = 0,
                    f = 0,
                    g = 0;
                for (e = 1; e <= 6; e++) i = p * l - c * u, r = c * l + p * u, p = i, c = r, f = f + this.C_re[e] * p - this.C_im[e] * c, g = g + this.C_im[e] * p + this.C_re[e] * c;
                for (var d = 0; d < this.iterations; d++) {
                    var y, m, v = f,
                        b = g,
                        w = l,
                        x = u;
                    for (e = 2; e <= 6; e++) y = v * f - b * g, m = b * f + v * g, v = y, b = m, w += (e - 1) * (this.B_re[e] * v - this.B_im[e] * b), x += (e - 1) * (this.B_im[e] * v + this.B_re[e] * b);
                    v = 1, b = 0;
                    var E = this.B_re[1],
                        S = this.B_im[1];
                    for (e = 2; e <= 6; e++) y = v * f - b * g, m = b * f + v * g, v = y, b = m, E += e * (this.B_re[e] * v - this.B_im[e] * b), S += e * (this.B_im[e] * v + this.B_re[e] * b);
                    var N = E * E + S * S;
                    f = (w * E + x * S) / N, g = (x * E - w * S) / N
                }
                var L = f,
                    C = g,
                    M = 1,
                    I = 0;
                for (e = 1; e <= 9; e++) M *= L, I += this.D[e] * M;
                var k = this.lat0 + I * n * 1e5,
                    T = this.long0 + C;
                return t.x = T, t.y = k, t
            }, i.names = ["New_Zealand_Map_Grid", "nzmg"]
        }, {}],
        56: [function(t, e, i) {
            var n = t("../common/tsfnz"),
                r = t("../common/adjust_lon"),
                o = t("../common/phi2z"),
                s = Math.PI / 2,
                a = Math.PI / 4,
                h = 1e-10;
            i.init = function() {
                this.no_off = this.no_off || !1, this.no_rot = this.no_rot || !1, isNaN(this.k0) && (this.k0 = 1);
                var t = Math.sin(this.lat0),
                    e = Math.cos(this.lat0),
                    i = this.e * t;
                this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(e, 4)), this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - i * i);
                var o = n(this.e, this.lat0, t),
                    s = this.bl / e * Math.sqrt((1 - this.es) / (1 - i * i));
                s * s < 1 && (s = 1);
                var a, h;
                if (isNaN(this.longc)) {
                    var l = n(this.e, this.lat1, Math.sin(this.lat1)),
                        u = n(this.e, this.lat2, Math.sin(this.lat2));
                    this.lat0 >= 0 ? this.el = (s + Math.sqrt(s * s - 1)) * Math.pow(o, this.bl) : this.el = (s - Math.sqrt(s * s - 1)) * Math.pow(o, this.bl);
                    var p = Math.pow(l, this.bl),
                        c = Math.pow(u, this.bl);
                    a = this.el / p, h = .5 * (a - 1 / a);
                    var f = (this.el * this.el - c * p) / (this.el * this.el + c * p),
                        g = (c - p) / (c + p),
                        d = r(this.long1 - this.long2);
                    this.long0 = .5 * (this.long1 + this.long2) - Math.atan(f * Math.tan(.5 * this.bl * d) / g) / this.bl, this.long0 = r(this.long0);
                    var y = r(this.long1 - this.long0);
                    this.gamma0 = Math.atan(Math.sin(this.bl * y) / h), this.alpha = Math.asin(s * Math.sin(this.gamma0))
                } else a = this.lat0 >= 0 ? s + Math.sqrt(s * s - 1) : s - Math.sqrt(s * s - 1), this.el = a * Math.pow(o, this.bl), h = .5 * (a - 1 / a), this.gamma0 = Math.asin(Math.sin(this.alpha) / s), this.long0 = this.longc - Math.asin(h * Math.tan(this.gamma0)) / this.bl;
                this.no_off ? this.uc = 0 : this.lat0 >= 0 ? this.uc = this.al / this.bl * Math.atan2(Math.sqrt(s * s - 1), Math.cos(this.alpha)) : this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(s * s - 1), Math.cos(this.alpha))
            }, i.forward = function(t) {
                var e, i, o, l = t.x,
                    u = t.y,
                    p = r(l - this.long0);
                if (Math.abs(Math.abs(u) - s) <= h) o = u > 0 ? -1 : 1, i = this.al / this.bl * Math.log(Math.tan(a + o * this.gamma0 * .5)), e = -1 * o * s * this.al / this.bl;
                else {
                    var c = n(this.e, u, Math.sin(u)),
                        f = this.el / Math.pow(c, this.bl),
                        g = .5 * (f - 1 / f),
                        d = .5 * (f + 1 / f),
                        y = Math.sin(this.bl * p),
                        m = (g * Math.sin(this.gamma0) - y * Math.cos(this.gamma0)) / d;
                    i = Math.abs(Math.abs(m) - 1) <= h ? Number.POSITIVE_INFINITY : .5 * this.al * Math.log((1 - m) / (1 + m)) / this.bl, e = Math.abs(Math.cos(this.bl * p)) <= h ? this.al * this.bl * p : this.al * Math.atan2(g * Math.cos(this.gamma0) + y * Math.sin(this.gamma0), Math.cos(this.bl * p)) / this.bl
                }
                return this.no_rot ? (t.x = this.x0 + e, t.y = this.y0 + i) : (e -= this.uc, t.x = this.x0 + i * Math.cos(this.alpha) + e * Math.sin(this.alpha), t.y = this.y0 + e * Math.cos(this.alpha) - i * Math.sin(this.alpha)), t
            }, i.inverse = function(t) {
                var e, i;
                this.no_rot ? (i = t.y - this.y0, e = t.x - this.x0) : (i = (t.x - this.x0) * Math.cos(this.alpha) - (t.y - this.y0) * Math.sin(this.alpha), e = (t.y - this.y0) * Math.cos(this.alpha) + (t.x - this.x0) * Math.sin(this.alpha), e += this.uc);
                var n = Math.exp(-1 * this.bl * i / this.al),
                    a = .5 * (n - 1 / n),
                    l = .5 * (n + 1 / n),
                    u = Math.sin(this.bl * e / this.al),
                    p = (u * Math.cos(this.gamma0) + a * Math.sin(this.gamma0)) / l,
                    c = Math.pow(this.el / Math.sqrt((1 + p) / (1 - p)), 1 / this.bl);
                return Math.abs(p - 1) < h ? (t.x = this.long0, t.y = s) : Math.abs(p + 1) < h ? (t.x = this.long0, t.y = -1 * s) : (t.y = o(this.e, c), t.x = r(this.long0 - Math.atan2(a * Math.cos(this.gamma0) - u * Math.sin(this.gamma0), Math.cos(this.bl * e / this.al)) / this.bl)), t
            }, i.names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"]
        }, { "../common/adjust_lon": 5, "../common/phi2z": 16, "../common/tsfnz": 24 }],
        57: [function(t, e, i) {
            var n = t("../common/adjust_lon"),
                r = 1e-10,
                o = t("../common/asinz"),
                s = Math.PI / 2;
            i.init = function() { this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0) }, i.forward = function(t) {
                var e, i, o, s, a, h, l, u, p = t.x,
                    c = t.y;
                return o = n(p - this.long0), e = Math.sin(c), i = Math.cos(c), s = Math.cos(o), h = this.sin_p14 * e + this.cos_p14 * i * s, a = 1, (h > 0 || Math.abs(h) <= r) && (l = this.a * a * i * Math.sin(o), u = this.y0 + this.a * a * (this.cos_p14 * e - this.sin_p14 * i * s)), t.x = l, t.y = u, t
            }, i.inverse = function(t) { var e, i, a, h, l, u, p; return t.x -= this.x0, t.y -= this.y0, e = Math.sqrt(t.x * t.x + t.y * t.y), i = o(e / this.a), a = Math.sin(i), h = Math.cos(i), u = this.long0, Math.abs(e) <= r ? (p = this.lat0, t.x = u, t.y = p, t) : (p = o(h * this.sin_p14 + t.y * a * this.cos_p14 / e), l = Math.abs(this.lat0) - s, Math.abs(l) <= r ? (u = n(this.lat0 >= 0 ? this.long0 + Math.atan2(t.x, -t.y) : this.long0 - Math.atan2(-t.x, t.y)), t.x = u, t.y = p, t) : (u = n(this.long0 + Math.atan2(t.x * a, e * this.cos_p14 * h - t.y * this.sin_p14 * a)), t.x = u, t.y = p, t)) }, i.names = ["ortho"]
        }, { "../common/adjust_lon": 5, "../common/asinz": 6 }],
        58: [function(t, e, i) {
            var n = t("../common/e0fn"),
                r = t("../common/e1fn"),
                o = t("../common/e2fn"),
                s = t("../common/e3fn"),
                a = t("../common/adjust_lon"),
                h = t("../common/adjust_lat"),
                l = t("../common/mlfn"),
                u = 1e-10,
                p = t("../common/gN"),
                c = 20;
            i.init = function() { this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = n(this.es), this.e1 = r(this.es), this.e2 = o(this.es), this.e3 = s(this.es), this.ml0 = this.a * l(this.e0, this.e1, this.e2, this.e3, this.lat0) }, i.forward = function(t) {
                var e, i, n, r = t.x,
                    o = t.y,
                    s = a(r - this.long0);
                if (n = s * Math.sin(o), this.sphere) Math.abs(o) <= u ? (e = this.a * s, i = -1 * this.a * this.lat0) : (e = this.a * Math.sin(n) / Math.tan(o), i = this.a * (h(o - this.lat0) + (1 - Math.cos(n)) / Math.tan(o)));
                else if (Math.abs(o) <= u) e = this.a * s, i = -1 * this.ml0;
                else {
                    var c = p(this.a, this.e, Math.sin(o)) / Math.tan(o);
                    e = c * Math.sin(n), i = this.a * l(this.e0, this.e1, this.e2, this.e3, o) - this.ml0 + c * (1 - Math.cos(n))
                }
                return t.x = e + this.x0, t.y = i + this.y0, t
            }, i.inverse = function(t) {
                var e, i, n, r, o, s, h, p, f;
                if (n = t.x - this.x0, r = t.y - this.y0, this.sphere)
                    if (Math.abs(r + this.a * this.lat0) <= u) e = a(n / this.a + this.long0), i = 0;
                    else {
                        s = this.lat0 + r / this.a, h = n * n / this.a / this.a + s * s, p = s;
                        var g;
                        for (o = c; o; --o)
                            if (g = Math.tan(p), f = -1 * (s * (p * g + 1) - p - .5 * (p * p + h) * g) / ((p - s) / g - 1), p += f, Math.abs(f) <= u) { i = p; break }
                        e = a(this.long0 + Math.asin(n * Math.tan(p) / this.a) / Math.sin(i))
                    }
                else if (Math.abs(r + this.ml0) <= u) i = 0, e = a(this.long0 + n / this.a);
                else {
                    s = (this.ml0 + r) / this.a, h = n * n / this.a / this.a + s * s, p = s;
                    var d, y, m, v, b;
                    for (o = c; o; --o)
                        if (b = this.e * Math.sin(p), d = Math.sqrt(1 - b * b) * Math.tan(p), y = this.a * l(this.e0, this.e1, this.e2, this.e3, p), m = this.e0 - 2 * this.e1 * Math.cos(2 * p) + 4 * this.e2 * Math.cos(4 * p) - 6 * this.e3 * Math.cos(6 * p), v = y / this.a, f = (s * (d * v + 1) - v - .5 * d * (v * v + h)) / (this.es * Math.sin(2 * p) * (v * v + h - 2 * s * v) / (4 * d) + (s - v) * (d * m - 2 / Math.sin(2 * p)) - m), p -= f, Math.abs(f) <= u) { i = p; break }
                    d = Math.sqrt(1 - this.es * Math.pow(Math.sin(i), 2)) * Math.tan(i), e = a(this.long0 + Math.asin(n * d / this.a) / Math.sin(i))
                }
                return t.x = e, t.y = i, t
            }, i.names = ["Polyconic", "poly"]
        }, { "../common/adjust_lat": 4, "../common/adjust_lon": 5, "../common/e0fn": 7, "../common/e1fn": 8, "../common/e2fn": 9, "../common/e3fn": 10, "../common/gN": 11, "../common/mlfn": 14 }],
        59: [function(t, e, i) {
            var n = t("../common/adjust_lon"),
                r = t("../common/adjust_lat"),
                o = t("../common/pj_enfn"),
                s = 20,
                a = t("../common/pj_mlfn"),
                h = t("../common/pj_inv_mlfn"),
                l = Math.PI / 2,
                u = 1e-10,
                p = t("../common/asinz");
            i.init = function() { this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = o(this.es) }, i.forward = function(t) {
                var e, i, r = t.x,
                    o = t.y;
                if (r = n(r - this.long0), this.sphere) {
                    if (this.m)
                        for (var h = this.n * Math.sin(o), l = s; l; --l) { var p = (this.m * o + Math.sin(o) - h) / (this.m + Math.cos(o)); if (o -= p, Math.abs(p) < u) break } else o = 1 !== this.n ? Math.asin(this.n * Math.sin(o)) : o;
                    e = this.a * this.C_x * r * (this.m + Math.cos(o)), i = this.a * this.C_y * o
                } else {
                    var c = Math.sin(o),
                        f = Math.cos(o);
                    i = this.a * a(o, c, f, this.en), e = this.a * r * f / Math.sqrt(1 - this.es * c * c)
                }
                return t.x = e, t.y = i, t
            }, i.inverse = function(t) { var e, i, o, s; return t.x -= this.x0, o = t.x / this.a, t.y -= this.y0, e = t.y / this.a, this.sphere ? (e /= this.C_y, o /= this.C_x * (this.m + Math.cos(e)), this.m ? e = p((this.m * e + Math.sin(e)) / this.n) : 1 !== this.n && (e = p(Math.sin(e) / this.n)), o = n(o + this.long0), e = r(e)) : (e = h(t.y / this.a, this.es, this.en), s = Math.abs(e), s < l ? (s = Math.sin(e), i = this.long0 + t.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(e)), o = n(i)) : s - u < l && (o = this.long0)), t.x = o, t.y = e, t }, i.names = ["Sinusoidal", "sinu"]
        }, { "../common/adjust_lat": 4, "../common/adjust_lon": 5, "../common/asinz": 6, "../common/pj_enfn": 17, "../common/pj_inv_mlfn": 18, "../common/pj_mlfn": 19 }],
        60: [function(t, e, i) {
            i.init = function() {
                var t = this.lat0;
                this.lambda0 = this.long0;
                var e = Math.sin(t),
                    i = this.a,
                    n = this.rf,
                    r = 1 / n,
                    o = 2 * r - Math.pow(r, 2),
                    s = this.e = Math.sqrt(o);
                this.R = this.k0 * i * Math.sqrt(1 - o) / (1 - o * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + o / (1 - o) * Math.pow(Math.cos(t), 4)), this.b0 = Math.asin(e / this.alpha);
                var a = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)),
                    h = Math.log(Math.tan(Math.PI / 4 + t / 2)),
                    l = Math.log((1 + s * e) / (1 - s * e));
                this.K = a - this.alpha * h + this.alpha * s / 2 * l;
            }, i.forward = function(t) {
                var e = Math.log(Math.tan(Math.PI / 4 - t.y / 2)),
                    i = this.e / 2 * Math.log((1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y))),
                    n = -this.alpha * (e + i) + this.K,
                    r = 2 * (Math.atan(Math.exp(n)) - Math.PI / 4),
                    o = this.alpha * (t.x - this.lambda0),
                    s = Math.atan(Math.sin(o) / (Math.sin(this.b0) * Math.tan(r) + Math.cos(this.b0) * Math.cos(o))),
                    a = Math.asin(Math.cos(this.b0) * Math.sin(r) - Math.sin(this.b0) * Math.cos(r) * Math.cos(o));
                return t.y = this.R / 2 * Math.log((1 + Math.sin(a)) / (1 - Math.sin(a))) + this.y0, t.x = this.R * s + this.x0, t
            }, i.inverse = function(t) {
                for (var e = t.x - this.x0, i = t.y - this.y0, n = e / this.R, r = 2 * (Math.atan(Math.exp(i / this.R)) - Math.PI / 4), o = Math.asin(Math.cos(this.b0) * Math.sin(r) + Math.sin(this.b0) * Math.cos(r) * Math.cos(n)), s = Math.atan(Math.sin(n) / (Math.cos(this.b0) * Math.cos(n) - Math.sin(this.b0) * Math.tan(r))), a = this.lambda0 + s / this.alpha, h = 0, l = o, u = -1e3, p = 0; Math.abs(l - u) > 1e-7;) {
                    if (++p > 20) return;
                    h = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + o / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(l)) / 2)), u = l, l = 2 * Math.atan(Math.exp(h)) - Math.PI / 2
                }
                return t.x = a, t.y = l, t
            }, i.names = ["somerc"]
        }, {}],
        61: [function(t, e, i) {
            var n = Math.PI / 2,
                r = 1e-10,
                o = t("../common/sign"),
                s = t("../common/msfnz"),
                a = t("../common/tsfnz"),
                h = t("../common/phi2z"),
                l = t("../common/adjust_lon");
            i.ssfn_ = function(t, e, i) { return e *= i, Math.tan(.5 * (n + t)) * Math.pow((1 - e) / (1 + e), .5 * i) }, i.init = function() { this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= r && (this.k0 = .5 * (1 + o(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= r && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= r && (this.k0 = .5 * this.cons * s(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / a(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = s(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - n, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0)) }, i.forward = function(t) {
                var e, i, o, s, h, u, p = t.x,
                    c = t.y,
                    f = Math.sin(c),
                    g = Math.cos(c),
                    d = l(p - this.long0);
                return Math.abs(Math.abs(p - this.long0) - Math.PI) <= r && Math.abs(c + this.lat0) <= r ? (t.x = NaN, t.y = NaN, t) : this.sphere ? (e = 2 * this.k0 / (1 + this.sinlat0 * f + this.coslat0 * g * Math.cos(d)), t.x = this.a * e * g * Math.sin(d) + this.x0, t.y = this.a * e * (this.coslat0 * f - this.sinlat0 * g * Math.cos(d)) + this.y0, t) : (i = 2 * Math.atan(this.ssfn_(c, f, this.e)) - n, s = Math.cos(i), o = Math.sin(i), Math.abs(this.coslat0) <= r ? (h = a(this.e, c * this.con, this.con * f), u = 2 * this.a * this.k0 * h / this.cons, t.x = this.x0 + u * Math.sin(p - this.long0), t.y = this.y0 - this.con * u * Math.cos(p - this.long0), t) : (Math.abs(this.sinlat0) < r ? (e = 2 * this.a * this.k0 / (1 + s * Math.cos(d)), t.y = e * o) : (e = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * o + this.cosX0 * s * Math.cos(d))), t.y = e * (this.cosX0 * o - this.sinX0 * s * Math.cos(d)) + this.y0), t.x = e * s * Math.sin(d) + this.x0, t))
            }, i.inverse = function(t) {
                t.x -= this.x0, t.y -= this.y0;
                var e, i, o, s, a, u = Math.sqrt(t.x * t.x + t.y * t.y);
                if (this.sphere) { var p = 2 * Math.atan(u / (.5 * this.a * this.k0)); return e = this.long0, i = this.lat0, u <= r ? (t.x = e, t.y = i, t) : (i = Math.asin(Math.cos(p) * this.sinlat0 + t.y * Math.sin(p) * this.coslat0 / u), e = l(Math.abs(this.coslat0) < r ? this.lat0 > 0 ? this.long0 + Math.atan2(t.x, -1 * t.y) : this.long0 + Math.atan2(t.x, t.y) : this.long0 + Math.atan2(t.x * Math.sin(p), u * this.coslat0 * Math.cos(p) - t.y * this.sinlat0 * Math.sin(p))), t.x = e, t.y = i, t) }
                if (Math.abs(this.coslat0) <= r) {
                    if (u <= r) return i = this.lat0, e = this.long0, t.x = e, t.y = i, t;
                    t.x *= this.con, t.y *= this.con, o = u * this.cons / (2 * this.a * this.k0), i = this.con * h(this.e, o), e = this.con * l(this.con * this.long0 + Math.atan2(t.x, -1 * t.y))
                } else s = 2 * Math.atan(u * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, u <= r ? a = this.X0 : (a = Math.asin(Math.cos(s) * this.sinX0 + t.y * Math.sin(s) * this.cosX0 / u), e = l(this.long0 + Math.atan2(t.x * Math.sin(s), u * this.cosX0 * Math.cos(s) - t.y * this.sinX0 * Math.sin(s)))), i = -1 * h(this.e, Math.tan(.5 * (n + a)));
                return t.x = e, t.y = i, t
            }, i.names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"]
        }, { "../common/adjust_lon": 5, "../common/msfnz": 15, "../common/phi2z": 16, "../common/sign": 21, "../common/tsfnz": 24 }],
        62: [function(t, e, i) {
            var n = t("./gauss"),
                r = t("../common/adjust_lon");
            i.init = function() { n.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative")) }, i.forward = function(t) { var e, i, o, s; return t.x = r(t.x - this.long0), n.forward.apply(this, [t]), e = Math.sin(t.y), i = Math.cos(t.y), o = Math.cos(t.x), s = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * i * o), t.x = s * i * Math.sin(t.x), t.y = s * (this.cosc0 * e - this.sinc0 * i * o), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t }, i.inverse = function(t) {
                var e, i, o, s, a;
                if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, a = Math.sqrt(t.x * t.x + t.y * t.y)) {
                    var h = 2 * Math.atan2(a, this.R2);
                    e = Math.sin(h), i = Math.cos(h), s = Math.asin(i * this.sinc0 + t.y * e * this.cosc0 / a), o = Math.atan2(t.x * e, a * this.cosc0 * i - t.y * this.sinc0 * e)
                } else s = this.phic0, o = 0;
                return t.x = o, t.y = s, n.inverse.apply(this, [t]), t.x = r(t.x + this.long0), t
            }, i.names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative"]
        }, { "../common/adjust_lon": 5, "./gauss": 46 }],
        63: [function(t, e, i) {
            var n = t("../common/e0fn"),
                r = t("../common/e1fn"),
                o = t("../common/e2fn"),
                s = t("../common/e3fn"),
                a = t("../common/mlfn"),
                h = t("../common/adjust_lon"),
                l = Math.PI / 2,
                u = 1e-10,
                p = t("../common/sign"),
                c = t("../common/asinz");
            i.init = function() { this.e0 = n(this.es), this.e1 = r(this.es), this.e2 = o(this.es), this.e3 = s(this.es), this.ml0 = this.a * a(this.e0, this.e1, this.e2, this.e3, this.lat0) }, i.forward = function(t) {
                var e, i, n, r = t.x,
                    o = t.y,
                    s = h(r - this.long0),
                    l = Math.sin(o),
                    u = Math.cos(o);
                if (this.sphere) {
                    var p = u * Math.sin(s);
                    if (Math.abs(Math.abs(p) - 1) < 1e-10) return 93;
                    i = .5 * this.a * this.k0 * Math.log((1 + p) / (1 - p)), e = Math.acos(u * Math.cos(s) / Math.sqrt(1 - p * p)), o < 0 && (e = -e), n = this.a * this.k0 * (e - this.lat0)
                } else {
                    var c = u * s,
                        f = Math.pow(c, 2),
                        g = this.ep2 * Math.pow(u, 2),
                        d = Math.tan(o),
                        y = Math.pow(d, 2);
                    e = 1 - this.es * Math.pow(l, 2);
                    var m = this.a / Math.sqrt(e),
                        v = this.a * a(this.e0, this.e1, this.e2, this.e3, o);
                    i = this.k0 * m * c * (1 + f / 6 * (1 - y + g + f / 20 * (5 - 18 * y + Math.pow(y, 2) + 72 * g - 58 * this.ep2))) + this.x0, n = this.k0 * (v - this.ml0 + m * d * (f * (.5 + f / 24 * (5 - y + 9 * g + 4 * Math.pow(g, 2) + f / 30 * (61 - 58 * y + Math.pow(y, 2) + 600 * g - 330 * this.ep2))))) + this.y0
                }
                return t.x = i, t.y = n, t
            }, i.inverse = function(t) {
                var e, i, n, r, o, s, a = 6;
                if (this.sphere) {
                    var f = Math.exp(t.x / (this.a * this.k0)),
                        g = .5 * (f - 1 / f),
                        d = this.lat0 + t.y / (this.a * this.k0),
                        y = Math.cos(d);
                    e = Math.sqrt((1 - y * y) / (1 + g * g)), o = c(e), d < 0 && (o = -o), s = 0 === g && 0 === y ? this.long0 : h(Math.atan2(g, y) + this.long0)
                } else {
                    var m = t.x - this.x0,
                        v = t.y - this.y0;
                    for (e = (this.ml0 + v / this.k0) / this.a, i = e, r = 0; !0 && (n = (e + this.e1 * Math.sin(2 * i) - this.e2 * Math.sin(4 * i) + this.e3 * Math.sin(6 * i)) / this.e0 - i, i += n, !(Math.abs(n) <= u)); r++)
                        if (r >= a) return 95;
                    if (Math.abs(i) < l) {
                        var b = Math.sin(i),
                            w = Math.cos(i),
                            x = Math.tan(i),
                            E = this.ep2 * Math.pow(w, 2),
                            S = Math.pow(E, 2),
                            N = Math.pow(x, 2),
                            L = Math.pow(N, 2);
                        e = 1 - this.es * Math.pow(b, 2);
                        var C = this.a / Math.sqrt(e),
                            M = C * (1 - this.es) / e,
                            I = m / (C * this.k0),
                            k = Math.pow(I, 2);
                        o = i - C * x * k / M * (.5 - k / 24 * (5 + 3 * N + 10 * E - 4 * S - 9 * this.ep2 - k / 30 * (61 + 90 * N + 298 * E + 45 * L - 252 * this.ep2 - 3 * S))), s = h(this.long0 + I * (1 - k / 6 * (1 + 2 * N + E - k / 20 * (5 - 2 * E + 28 * N - 3 * S + 8 * this.ep2 + 24 * L))) / w)
                    } else o = l * p(v), s = this.long0
                }
                return t.x = s, t.y = o, t
            }, i.names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"]
        }, { "../common/adjust_lon": 5, "../common/asinz": 6, "../common/e0fn": 7, "../common/e1fn": 8, "../common/e2fn": 9, "../common/e3fn": 10, "../common/mlfn": 14, "../common/sign": 21 }],
        64: [function(t, e, i) {
            var n = .017453292519943295,
                r = t("./tmerc");
            i.dependsOn = "tmerc", i.init = function() { this.zone && (this.lat0 = 0, this.long0 = (6 * Math.abs(this.zone) - 183) * n, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = .9996, r.init.apply(this), this.forward = r.forward, this.inverse = r.inverse) }, i.names = ["Universal Transverse Mercator System", "utm"]
        }, { "./tmerc": 63 }],
        65: [function(t, e, i) {
            var n = t("../common/adjust_lon"),
                r = Math.PI / 2,
                o = 1e-10,
                s = t("../common/asinz");
            i.init = function() { this.R = this.a }, i.forward = function(t) {
                var e, i, a = t.x,
                    h = t.y,
                    l = n(a - this.long0);
                Math.abs(h) <= o && (e = this.x0 + this.R * l, i = this.y0);
                var u = s(2 * Math.abs(h / Math.PI));
                (Math.abs(l) <= o || Math.abs(Math.abs(h) - r) <= o) && (e = this.x0, i = h >= 0 ? this.y0 + Math.PI * this.R * Math.tan(.5 * u) : this.y0 + Math.PI * this.R * -Math.tan(.5 * u));
                var p = .5 * Math.abs(Math.PI / l - l / Math.PI),
                    c = p * p,
                    f = Math.sin(u),
                    g = Math.cos(u),
                    d = g / (f + g - 1),
                    y = d * d,
                    m = d * (2 / f - 1),
                    v = m * m,
                    b = Math.PI * this.R * (p * (d - v) + Math.sqrt(c * (d - v) * (d - v) - (v + c) * (y - v))) / (v + c);
                l < 0 && (b = -b), e = this.x0 + b;
                var w = c + d;
                return b = Math.PI * this.R * (m * w - p * Math.sqrt((v + c) * (c + 1) - w * w)) / (v + c), i = h >= 0 ? this.y0 + b : this.y0 - b, t.x = e, t.y = i, t
            }, i.inverse = function(t) { var e, i, r, s, a, h, l, u, p, c, f, g, d; return t.x -= this.x0, t.y -= this.y0, f = Math.PI * this.R, r = t.x / f, s = t.y / f, a = r * r + s * s, h = -Math.abs(s) * (1 + a), l = h - 2 * s * s + r * r, u = -2 * h + 1 + 2 * s * s + a * a, d = s * s / u + (2 * l * l * l / u / u / u - 9 * h * l / u / u) / 27, p = (h - l * l / 3 / u) / u, c = 2 * Math.sqrt(-p / 3), f = 3 * d / p / c, Math.abs(f) > 1 && (f = f >= 0 ? 1 : -1), g = Math.acos(f) / 3, i = t.y >= 0 ? (-c * Math.cos(g + Math.PI / 3) - l / 3 / u) * Math.PI : -(-c * Math.cos(g + Math.PI / 3) - l / 3 / u) * Math.PI, e = Math.abs(r) < o ? this.long0 : n(this.long0 + Math.PI * (a - 1 + Math.sqrt(1 + 2 * (r * r - s * s) + a * a)) / 2 / r), t.x = e, t.y = i, t }, i.names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"]
        }, { "../common/adjust_lon": 5, "../common/asinz": 6 }],
        66: [function(t, e, i) {
            var n = .017453292519943295,
                r = 57.29577951308232,
                o = 1,
                s = 2,
                a = t("./datum_transform"),
                h = t("./adjust_axis"),
                l = t("./Proj"),
                u = t("./common/toPoint");
            e.exports = function t(e, i, p) {
                function c(t, e) { return (t.datum.datum_type === o || t.datum.datum_type === s) && "WGS84" !== e.datumCode }
                var f;
                return Array.isArray(p) && (p = u(p)), e.datum && i.datum && (c(e, i) || c(i, e)) && (f = new l("WGS84"), t(e, f, p), e = f), "enu" !== e.axis && h(e, !1, p), "longlat" === e.projName ? (p.x *= n, p.y *= n) : (e.to_meter && (p.x *= e.to_meter, p.y *= e.to_meter), e.inverse(p)), e.from_greenwich && (p.x += e.from_greenwich), p = a(e.datum, i.datum, p), i.from_greenwich && (p.x -= i.from_greenwich), "longlat" === i.projName ? (p.x *= r, p.y *= r) : (i.forward(p), i.to_meter && (p.x /= i.to_meter, p.y /= i.to_meter)), "enu" !== i.axis && h(i, !0, p), p
            }
        }, { "./Proj": 2, "./adjust_axis": 3, "./common/toPoint": 23, "./datum_transform": 31 }],
        67: [function(t, e, i) {
            function n(t, e, i) { t[e] = i.map(function(t) { var e = {}; return r(t, e), e }).reduce(function(t, e) { return l(t, e) }, {}) }

            function r(t, e) { var i; return Array.isArray(t) ? (i = t.shift(), "PARAMETER" === i && (i = t.shift()), 1 === t.length ? Array.isArray(t[0]) ? (e[i] = {}, r(t[0], e[i])) : e[i] = t[0] : t.length ? "TOWGS84" === i ? e[i] = t : (e[i] = {}, ["UNIT", "PRIMEM", "VERT_DATUM"].indexOf(i) > -1 ? (e[i] = { name: t[0].toLowerCase(), convert: t[1] }, 3 === t.length && (e[i].auth = t[2])) : "SPHEROID" === i ? (e[i] = { name: t[0], a: t[1], rf: t[2] }, 4 === t.length && (e[i].auth = t[3])) : ["GEOGCS", "GEOCCS", "DATUM", "VERT_CS", "COMPD_CS", "LOCAL_CS", "FITTED_CS", "LOCAL_DATUM"].indexOf(i) > -1 ? (t[0] = ["name", t[0]], n(e, i, t)) : t.every(function(t) { return Array.isArray(t) }) ? n(e, i, t) : r(t, e[i])) : e[i] = !0, void 0) : void(e[t] = !0) }

            function o(t, e) {
                var i = e[0],
                    n = e[1];
                !(i in t) && n in t && (t[i] = t[n], 3 === e.length && (t[i] = e[2](t[i])))
            }

            function s(t) { return t * h }

            function a(t) {
                function e(e) { var i = t.to_meter || 1; return parseFloat(e, 10) * i }
                "GEOGCS" === t.type ? t.projName = "longlat" : "LOCAL_CS" === t.type ? (t.projName = "identity", t.local = !0) : "object" == typeof t.PROJECTION ? t.projName = Object.keys(t.PROJECTION)[0] : t.projName = t.PROJECTION, t.UNIT && (t.units = t.UNIT.name.toLowerCase(), "metre" === t.units && (t.units = "meter"), t.UNIT.convert && ("GEOGCS" === t.type ? t.DATUM && t.DATUM.SPHEROID && (t.to_meter = parseFloat(t.UNIT.convert, 10) * t.DATUM.SPHEROID.a) : t.to_meter = parseFloat(t.UNIT.convert, 10))), t.GEOGCS && (t.GEOGCS.DATUM ? t.datumCode = t.GEOGCS.DATUM.name.toLowerCase() : t.datumCode = t.GEOGCS.name.toLowerCase(), "d_" === t.datumCode.slice(0, 2) && (t.datumCode = t.datumCode.slice(2)), "new_zealand_geodetic_datum_1949" !== t.datumCode && "new_zealand_1949" !== t.datumCode || (t.datumCode = "nzgd49"), "wgs_1984" === t.datumCode && ("Mercator_Auxiliary_Sphere" === t.PROJECTION && (t.sphere = !0), t.datumCode = "wgs84"), "_ferro" === t.datumCode.slice(-6) && (t.datumCode = t.datumCode.slice(0, -6)), "_jakarta" === t.datumCode.slice(-8) && (t.datumCode = t.datumCode.slice(0, -8)), ~t.datumCode.indexOf("belge") && (t.datumCode = "rnb72"), t.GEOGCS.DATUM && t.GEOGCS.DATUM.SPHEROID && (t.ellps = t.GEOGCS.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), "international" === t.ellps.toLowerCase().slice(0, 13) && (t.ellps = "intl"), t.a = t.GEOGCS.DATUM.SPHEROID.a, t.rf = parseFloat(t.GEOGCS.DATUM.SPHEROID.rf, 10)), ~t.datumCode.indexOf("osgb_1936") && (t.datumCode = "osgb36")), t.b && !isFinite(t.b) && (t.b = t.a);
                var i = function(e) { return o(t, e) },
                    n = [
                        ["standard_parallel_1", "Standard_Parallel_1"],
                        ["standard_parallel_2", "Standard_Parallel_2"],
                        ["false_easting", "False_Easting"],
                        ["false_northing", "False_Northing"],
                        ["central_meridian", "Central_Meridian"],
                        ["latitude_of_origin", "Latitude_Of_Origin"],
                        ["latitude_of_origin", "Central_Parallel"],
                        ["scale_factor", "Scale_Factor"],
                        ["k0", "scale_factor"],
                        ["latitude_of_center", "Latitude_of_center"],
                        ["lat0", "latitude_of_center", s],
                        ["longitude_of_center", "Longitude_Of_Center"],
                        ["longc", "longitude_of_center", s],
                        ["x0", "false_easting", e],
                        ["y0", "false_northing", e],
                        ["long0", "central_meridian", s],
                        ["lat0", "latitude_of_origin", s],
                        ["lat0", "standard_parallel_1", s],
                        ["lat1", "standard_parallel_1", s],
                        ["lat2", "standard_parallel_2", s],
                        ["alpha", "azimuth", s],
                        ["srsCode", "name"]
                    ];
                n.forEach(i), t.long0 || !t.longc || "Albers_Conic_Equal_Area" !== t.projName && "Lambert_Azimuthal_Equal_Area" !== t.projName || (t.long0 = t.longc), t.lat_ts || !t.lat1 || "Stereographic_South_Pole" !== t.projName && "Polar Stereographic (variant B)" !== t.projName || (t.lat0 = s(t.lat1 > 0 ? 90 : -90), t.lat_ts = t.lat1)
            }
            var h = .017453292519943295,
                l = t("./extend");
            e.exports = function(t, e) {
                var i = JSON.parse(("," + t).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]').replace(/,\["VERTCS".+/, "")),
                    n = i.shift(),
                    o = i.shift();
                i.unshift(["name", o]), i.unshift(["type", n]), i.unshift("output");
                var s = {};
                return r(i, s), a(s.output), l(e, s.output)
            }
        }, { "./extend": 34 }],
        68: [function(t, e, i) {
            function n(t) { return t * (Math.PI / 180) }

            function r(t) { return 180 * (t / Math.PI) }

            function o(t) {
                var e, i, r, o, s, h, l, u, p, c = t.lat,
                    f = t.lon,
                    g = 6378137,
                    d = .00669438,
                    y = .9996,
                    m = n(c),
                    v = n(f);
                p = Math.floor((f + 180) / 6) + 1, 180 === f && (p = 60), c >= 56 && c < 64 && f >= 3 && f < 12 && (p = 32), c >= 72 && c < 84 && (f >= 0 && f < 9 ? p = 31 : f >= 9 && f < 21 ? p = 33 : f >= 21 && f < 33 ? p = 35 : f >= 33 && f < 42 && (p = 37)), e = 6 * (p - 1) - 180 + 3, u = n(e), i = d / (1 - d), r = g / Math.sqrt(1 - d * Math.sin(m) * Math.sin(m)), o = Math.tan(m) * Math.tan(m), s = i * Math.cos(m) * Math.cos(m), h = Math.cos(m) * (v - u), l = g * ((1 - d / 4 - 3 * d * d / 64 - 5 * d * d * d / 256) * m - (3 * d / 8 + 3 * d * d / 32 + 45 * d * d * d / 1024) * Math.sin(2 * m) + (15 * d * d / 256 + 45 * d * d * d / 1024) * Math.sin(4 * m) - 35 * d * d * d / 3072 * Math.sin(6 * m));
                var b = y * r * (h + (1 - o + s) * h * h * h / 6 + (5 - 18 * o + o * o + 72 * s - 58 * i) * h * h * h * h * h / 120) + 5e5,
                    w = y * (l + r * Math.tan(m) * (h * h / 2 + (5 - o + 9 * s + 4 * s * s) * h * h * h * h / 24 + (61 - 58 * o + o * o + 600 * s - 330 * i) * h * h * h * h * h * h / 720));
                return c < 0 && (w += 1e7), { northing: Math.round(w), easting: Math.round(b), zoneNumber: p, zoneLetter: a(c) }
            }

            function s(t) {
                var e = t.northing,
                    i = t.easting,
                    n = t.zoneLetter,
                    o = t.zoneNumber;
                if (o < 0 || o > 60) return null;
                var a, h, l, u, p, c, f, g, d, y, m = .9996,
                    v = 6378137,
                    b = .00669438,
                    w = (1 - Math.sqrt(1 - b)) / (1 + Math.sqrt(1 - b)),
                    x = i - 5e5,
                    E = e;
                n < "N" && (E -= 1e7), g = 6 * (o - 1) - 180 + 3, a = b / (1 - b), f = E / m, d = f / (v * (1 - b / 4 - 3 * b * b / 64 - 5 * b * b * b / 256)), y = d + (3 * w / 2 - 27 * w * w * w / 32) * Math.sin(2 * d) + (21 * w * w / 16 - 55 * w * w * w * w / 32) * Math.sin(4 * d) + 151 * w * w * w / 96 * Math.sin(6 * d), h = v / Math.sqrt(1 - b * Math.sin(y) * Math.sin(y)), l = Math.tan(y) * Math.tan(y), u = a * Math.cos(y) * Math.cos(y), p = v * (1 - b) / Math.pow(1 - b * Math.sin(y) * Math.sin(y), 1.5), c = x / (h * m);
                var S = y - h * Math.tan(y) / p * (c * c / 2 - (5 + 3 * l + 10 * u - 4 * u * u - 9 * a) * c * c * c * c / 24 + (61 + 90 * l + 298 * u + 45 * l * l - 252 * a - 3 * u * u) * c * c * c * c * c * c / 720);
                S = r(S);
                var N = (c - (1 + 2 * l + u) * c * c * c / 6 + (5 - 2 * u + 28 * l - 3 * u * u + 8 * a + 24 * l * l) * c * c * c * c * c / 120) / Math.cos(y);
                N = g + r(N);
                var L;
                if (t.accuracy) {
                    var C = s({ northing: t.northing + t.accuracy, easting: t.easting + t.accuracy, zoneLetter: t.zoneLetter, zoneNumber: t.zoneNumber });
                    L = { top: C.lat, right: C.lon, bottom: S, left: N }
                } else L = { lat: S, lon: N };
                return L
            }

            function a(t) { var e = "Z"; return 84 >= t && t >= 72 ? e = "X" : 72 > t && t >= 64 ? e = "W" : 64 > t && t >= 56 ? e = "V" : 56 > t && t >= 48 ? e = "U" : 48 > t && t >= 40 ? e = "T" : 40 > t && t >= 32 ? e = "S" : 32 > t && t >= 24 ? e = "R" : 24 > t && t >= 16 ? e = "Q" : 16 > t && t >= 8 ? e = "P" : 8 > t && t >= 0 ? e = "N" : 0 > t && t >= -8 ? e = "M" : -8 > t && t >= -16 ? e = "L" : -16 > t && t >= -24 ? e = "K" : -24 > t && t >= -32 ? e = "J" : -32 > t && t >= -40 ? e = "H" : -40 > t && t >= -48 ? e = "G" : -48 > t && t >= -56 ? e = "F" : -56 > t && t >= -64 ? e = "E" : -64 > t && t >= -72 ? e = "D" : -72 > t && t >= -80 && (e = "C"), e }

            function h(t, e) {
                var i = "00000" + t.easting,
                    n = "00000" + t.northing;
                return t.zoneNumber + t.zoneLetter + l(t.easting, t.northing, t.zoneNumber) + i.substr(i.length - 5, e) + n.substr(n.length - 5, e)
            }

            function l(t, e, i) {
                var n = u(i),
                    r = Math.floor(t / 1e5),
                    o = Math.floor(e / 1e5) % 20;
                return p(r, o, n)
            }

            function u(t) { var e = t % y; return 0 === e && (e = y), e }

            function p(t, e, i) {
                var n = i - 1,
                    r = m.charCodeAt(n),
                    o = v.charCodeAt(n),
                    s = r + t - 1,
                    a = o + e,
                    h = !1;
                s > S && (s = s - S + b - 1, h = !0), (s === w || r < w && s > w || (s > w || r < w) && h) && s++, (s === x || r < x && s > x || (s > x || r < x) && h) && (s++, s === w && s++), s > S && (s = s - S + b - 1), a > E ? (a = a - E + b - 1, h = !0) : h = !1, (a === w || o < w && a > w || (a > w || o < w) && h) && a++, (a === x || o < x && a > x || (a > x || o < x) && h) && (a++, a === w && a++), a > E && (a = a - E + b - 1);
                var l = String.fromCharCode(s) + String.fromCharCode(a);
                return l
            }

            function c(t) {
                if (t && 0 === t.length) throw "MGRSPoint coverting from nothing";
                for (var e, i = t.length, n = null, r = "", o = 0; !/[A-Z]/.test(e = t.charAt(o));) {
                    if (o >= 2) throw "MGRSPoint bad conversion from: " + t;
                    r += e, o++
                }
                var s = parseInt(r, 10);
                if (0 === o || o + 3 > i) throw "MGRSPoint bad conversion from: " + t;
                var a = t.charAt(o++);
                if (a <= "A" || "B" === a || "Y" === a || a >= "Z" || "I" === a || "O" === a) throw "MGRSPoint zone letter " + a + " not handled: " + t;
                n = t.substring(o, o += 2);
                for (var h = u(s), l = f(n.charAt(0), h), p = g(n.charAt(1), h); p < d(a);) p += 2e6;
                var c = i - o;
                if (c % 2 !== 0) throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + t;
                var y, m, v, b, w, x = c / 2,
                    E = 0,
                    S = 0;
                return x > 0 && (y = 1e5 / Math.pow(10, x), m = t.substring(o, o + x), E = parseFloat(m) * y, v = t.substring(o + x), S = parseFloat(v) * y), b = E + l, w = S + p, { easting: b, northing: w, zoneLetter: a, zoneNumber: s, accuracy: y }
            }

            function f(t, e) {
                for (var i = m.charCodeAt(e - 1), n = 1e5, r = !1; i !== t.charCodeAt(0);) {
                    if (i++, i === w && i++, i === x && i++, i > S) {
                        if (r) throw "Bad character: " + t;
                        i = b, r = !0
                    }
                    n += 1e5
                }
                return n
            }

            function g(t, e) {
                if (t > "V") throw "MGRSPoint given invalid Northing " + t;
                for (var i = v.charCodeAt(e - 1), n = 0, r = !1; i !== t.charCodeAt(0);) {
                    if (i++, i === w && i++, i === x && i++, i > E) {
                        if (r) throw "Bad character: " + t;
                        i = b, r = !0
                    }
                    n += 1e5
                }
                return n
            }

            function d(t) {
                var e;
                switch (t) {
                    case "C":
                        e = 11e5;
                        break;
                    case "D":
                        e = 2e6;
                        break;
                    case "E":
                        e = 28e5;
                        break;
                    case "F":
                        e = 37e5;
                        break;
                    case "G":
                        e = 46e5;
                        break;
                    case "H":
                        e = 55e5;
                        break;
                    case "J":
                        e = 64e5;
                        break;
                    case "K":
                        e = 73e5;
                        break;
                    case "L":
                        e = 82e5;
                        break;
                    case "M":
                        e = 91e5;
                        break;
                    case "N":
                        e = 0;
                        break;
                    case "P":
                        e = 8e5;
                        break;
                    case "Q":
                        e = 17e5;
                        break;
                    case "R":
                        e = 26e5;
                        break;
                    case "S":
                        e = 35e5;
                        break;
                    case "T":
                        e = 44e5;
                        break;
                    case "U":
                        e = 53e5;
                        break;
                    case "V":
                        e = 62e5;
                        break;
                    case "W":
                        e = 7e6;
                        break;
                    case "X":
                        e = 79e5;
                        break;
                    default:
                        e = -1
                }
                if (e >= 0) return e;
                throw "Invalid zone letter: " + t
            }
            var y = 6,
                m = "AJSAJS",
                v = "AFAFAF",
                b = 65,
                w = 73,
                x = 79,
                E = 86,
                S = 90;
            i.forward = function(t, e) { return e = e || 5, h(o({ lat: t[1], lon: t[0] }), e) }, i.inverse = function(t) { var e = s(c(t.toUpperCase())); return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top] }, i.toPoint = function(t) { var e = s(c(t.toUpperCase())); return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2] }
        }, {}],
        69: [function(t, e, i) { e.exports = { name: "proj4", version: "2.3.15", description: "Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.", main: "lib/index.js", directories: { test: "test", doc: "docs" }, scripts: { test: "./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js" }, repository: { type: "git", url: "git://github.com/proj4js/proj4js.git" }, author: "", license: "MIT", jam: { main: "dist/proj4.js", include: ["dist/proj4.js", "README.md", "AUTHORS", "LICENSE.md"] }, devDependencies: { "grunt-cli": "~0.1.13", grunt: "~0.4.2", "grunt-contrib-connect": "~0.6.0", "grunt-contrib-jshint": "~0.8.0", chai: "~1.8.1", mocha: "~1.17.1", "grunt-mocha-phantomjs": "~0.4.0", browserify: "~12.0.1", "grunt-browserify": "~4.0.1", "grunt-contrib-uglify": "~0.11.1", curl: "git://github.com/cujojs/curl.git", istanbul: "~0.2.4", tin: "~0.4.0" }, dependencies: { mgrs: "~0.0.2" } } }, {}]
    }, {}, [36])(36)
}),
function(t) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = t();
    else if ("function" == typeof define && define.amd) define([], t);
    else {
        var e;
        e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, e.turf = t()
    }
}(function() {
    var t;
    return function t(e, i, n) {
        function r(s, a) {
            if (!i[s]) {
                if (!e[s]) { var h = "function" == typeof require && require; if (!a && h) return h(s, !0); if (o) return o(s, !0); var l = new Error("Cannot find module '" + s + "'"); throw l.code = "MODULE_NOT_FOUND", l }
                var u = i[s] = { exports: {} };
                e[s][0].call(u.exports, function(t) { var i = e[s][1][t]; return r(i ? i : t) }, u, u.exports, t, e, i, n)
            }
            return i[s].exports
        }
        for (var o = "function" == typeof require && require, s = 0; s < n.length; s++) r(n[s]);
        return r
    }({
        1: [function(t, e, i) {
            var n = t("@turf/distance"),
                r = t("@turf/helpers").point,
                o = t("@turf/bearing"),
                s = t("@turf/destination");
            e.exports = function(t, e, i) {
                var a;
                if ("Feature" === t.type) a = t.geometry.coordinates;
                else {
                    if ("LineString" !== t.type) throw new Error("input must be a LineString Feature or Geometry");
                    a = t.coordinates
                }
                for (var h = 0, l = 0; l < a.length && !(e >= h && l === a.length - 1); l++) {
                    if (h >= e) {
                        var u = e - h;
                        if (u) {
                            var p = o(a[l], a[l - 1]) - 180,
                                c = s(a[l], u, p, i);
                            return c
                        }
                        return r(a[l])
                    }
                    h += n(a[l], a[l + 1], i)
                }
                return r(a[a.length - 1])
            }
        }, { "@turf/bearing": 2, "@turf/destination": 3, "@turf/distance": 4, "@turf/helpers": 5 }],
        2: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-bearing") }, { "/Users/tmcw/src/turf/packages/turf-bearing": 13 }],
        3: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-destination") }, { "/Users/tmcw/src/turf/packages/turf-destination": 64 }],
        4: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-distance") }, { "/Users/tmcw/src/turf/packages/turf-distance": 69 }],
        5: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-helpers") }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80 }],
        6: [function(t, e, i) {
            function n(t) { if ("FeatureCollection" === t.type) { for (var e = 0, i = 0; e < t.features.length; e++) t.features[e].geometry && (i += r(t.features[e].geometry)); return i } return r("Feature" === t.type ? t.geometry : t) }
            var r = t("geojson-area").geometry;
            e.exports = n
        }, { "geojson-area": 7 }],
        7: [function(t, e, n) {
            function r(t) {
                var e, i = 0;
                switch (t.type) {
                    case "Polygon":
                        return o(t.coordinates);
                    case "MultiPolygon":
                        for (e = 0; e < t.coordinates.length; e++) i += o(t.coordinates[e]);
                        return i;
                    case "Point":
                    case "MultiPoint":
                    case "LineString":
                    case "MultiLineString":
                        return 0;
                    case "GeometryCollection":
                        for (e = 0; e < t.geometries.length; e++) i += r(t.geometries[e]);
                        return i
                }
            }

            function o(t) { var e = 0; if (t && t.length > 0) { e += Math.abs(s(t[0])); for (var i = 1; i < t.length; i++) e -= Math.abs(s(t[i])) } return e }

            function s(t) {
                var e, n, r, o, s, l, u = 0,
                    p = t.length;
                if (p > 2) {
                    for (i = 0; i < p; i++) i === p - 2 ? (o = p - 2, s = p - 1, l = 0) : i === p - 1 ? (o = p - 1, s = 0, l = 1) : (o = i, s = i + 1, l = i + 2), e = t[o], n = t[s], r = t[l], u += (a(r[0]) - a(e[0])) * Math.sin(a(n[1]));
                    u = u * h.RADIUS * h.RADIUS / 2
                }
                return u
            }

            function a(t) { return t * Math.PI / 180 }
            var h = t("wgs84");
            e.exports.geometry = r, e.exports.ring = s
        }, { wgs84: 8 }],
        8: [function(t, e, i) { e.exports.RADIUS = 6378137, e.exports.FLATTENING = 1 / 298.257223563, e.exports.POLAR_RADIUS = 6356752.3142 }, {}],
        9: [function(t, e, i) {
            var n = t("@turf/helpers").polygon;
            e.exports = function(t) {
                var e = [t[0], t[1]],
                    i = [t[0], t[3]],
                    r = [t[2], t[3]],
                    o = [t[2], t[1]];
                return n([
                    [e, o, r, i, e]
                ])
            }
        }, { "@turf/helpers": 10 }],
        10: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        11: [function(t, e, i) {
            var n = t("@turf/meta").coordEach;
            e.exports = function(t) { var e = [1 / 0, 1 / 0, -(1 / 0), -(1 / 0)]; return n(t, function(t) { e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]) }), e }
        }, { "@turf/meta": 12 }],
        12: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-meta") }, { "/Users/tmcw/src/turf/packages/turf-meta": 113 }],
        13: [function(t, e, i) {
            var n = t("@turf/invariant").getCoord;
            e.exports = function(t, e) {
                var i = Math.PI / 180,
                    r = 180 / Math.PI,
                    o = n(t),
                    s = n(e),
                    a = i * o[0],
                    h = i * s[0],
                    l = i * o[1],
                    u = i * s[1],
                    p = Math.sin(h - a) * Math.cos(u),
                    c = Math.cos(l) * Math.sin(u) - Math.sin(l) * Math.cos(u) * Math.cos(h - a),
                    f = r * Math.atan2(p, c);
                return f
            }
        }, { "@turf/invariant": 14 }],
        14: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-invariant") }, { "/Users/tmcw/src/turf/packages/turf-invariant": 88 }],
        15: [function(t, e, i) {
            var n = t("@turf/helpers").lineString,
                r = t("./spline.js");
            e.exports = function(t, e, i) {
                var o = n([]);
                o.properties = t.properties;
                for (var s = new r({ points: t.geometry.coordinates.map(function(t) { return { x: t[0], y: t[1] } }), duration: e, sharpness: i }), a = 0; a < s.duration; a += 10) {
                    var h = s.pos(a);
                    Math.floor(a / 100) % 2 === 0 && o.geometry.coordinates.push([h.x, h.y])
                }
                return o
            }
        }, { "./spline.js": 17, "@turf/helpers": 16 }],
        16: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        17: [function(t, e, i) {
            var n = function(t) {
                this.points = t.points || [], this.duration = t.duration || 1e4, this.sharpness = t.sharpness || .85, this.centers = [], this.controls = [], this.stepLength = t.stepLength || 60, this.length = this.points.length, this.delay = 0;
                for (var e = 0; e < this.length; e++) this.points[e].z = this.points[e].z || 0;
                for (var e = 0; e < this.length - 1; e++) {
                    var i = this.points[e],
                        n = this.points[e + 1];
                    this.centers.push({ x: (i.x + n.x) / 2, y: (i.y + n.y) / 2, z: (i.z + n.z) / 2 })
                }
                this.controls.push([this.points[0], this.points[0]]);
                for (var e = 0; e < this.centers.length - 1; e++) {
                    var i = this.centers[e],
                        n = this.centers[e + 1],
                        r = this.points[e + 1].x - (this.centers[e].x + this.centers[e + 1].x) / 2,
                        o = this.points[e + 1].y - (this.centers[e].y + this.centers[e + 1].y) / 2,
                        s = this.points[e + 1].z - (this.centers[e].y + this.centers[e + 1].z) / 2;
                    this.controls.push([{ x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e].x + r), y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e].y + o), z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e].z + s) }, { x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e + 1].x + r), y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e + 1].y + o), z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e + 1].z + s) }])
                }
                return this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]), this.steps = this.cacheSteps(this.stepLength), this
            };
            n.prototype.cacheSteps = function(t) {
                var e = [],
                    i = this.pos(0);
                e.push(0);
                for (var n = 0; n < this.duration; n += 10) {
                    var r = this.pos(n),
                        o = Math.sqrt((r.x - i.x) * (r.x - i.x) + (r.y - i.y) * (r.y - i.y) + (r.z - i.z) * (r.z - i.z));
                    o > t && (e.push(n), i = r)
                }
                return e
            }, n.prototype.vector = function(t) {
                var e = this.pos(t + 10),
                    i = this.pos(t - 10);
                return { angle: 180 * Math.atan2(e.y - i.y, e.x - i.x) / 3.14, speed: Math.sqrt((i.x - e.x) * (i.x - e.x) + (i.y - e.y) * (i.y - e.y) + (i.z - e.z) * (i.z - e.z)) }
            }, n.prototype.pos = function(t) {
                function e(t, e, i, n, r) {
                    var o = function(t) {
                            var e = t * t,
                                i = e * t;
                            return [i, 3 * e * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)]
                        },
                        s = o(t),
                        a = { x: r.x * s[0] + n.x * s[1] + i.x * s[2] + e.x * s[3], y: r.y * s[0] + n.y * s[1] + i.y * s[2] + e.y * s[3], z: r.z * s[0] + n.z * s[1] + i.z * s[2] + e.z * s[3] };
                    return a
                }
                var i = t - this.delay;
                i < 0 && (i = 0), i > this.duration && (i = this.duration - 1);
                var n = i / this.duration;
                if (n >= 1) return this.points[this.length - 1];
                var r = Math.floor((this.points.length - 1) * n),
                    o = (this.length - 1) * n - r;
                return e(o, this.points[r], this.controls[r][1], this.controls[r + 1][0], this.points[r + 1])
            }, e.exports = n
        }, {}],
        18: [function(t, e, i) {
            function n(t, e) {
                var i = new s.io.GeoJSONReader,
                    n = i.read(t.geometry),
                    r = n.buffer(e),
                    o = new s.io.GeoJSONWriter;
                return r = o.write(r), { type: "Feature", geometry: r, properties: {} }
            }
            var r = t("@turf/helpers"),
                o = r.featureCollection,
                s = t("jsts"),
                a = t("geojson-normalize");
            e.exports = function(t, e, i) {
                var s = r.distanceToDegrees(e, i),
                    h = a(t),
                    l = a(o(h.features.map(function(t) { return n(t, s) })));
                return l.features.length > 1 ? l : 1 === l.features.length ? l.features[0] : void 0
            }
        }, { "@turf/helpers": 19, "geojson-normalize": 20, jsts: 21 }],
        19: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        20: [function(t, e, i) {
            function n(t) { if (!t || !t.type) return null; var e = r[t.type]; return e ? "geometry" === e ? { type: "FeatureCollection", features: [{ type: "Feature", properties: {}, geometry: t }] } : "feature" === e ? { type: "FeatureCollection", features: [t] } : "featurecollection" === e ? t : void 0 : null }
            e.exports = n;
            var r = { Point: "geometry", MultiPoint: "geometry", LineString: "geometry", MultiLineString: "geometry", Polygon: "geometry", MultiPolygon: "geometry", GeometryCollection: "geometry", Feature: "feature", FeatureCollection: "featurecollection" }
        }, {}],
        21: [function(e, i, n) {
            ! function(e, r) { "object" == typeof n && "undefined" != typeof i ? r(n) : "function" == typeof t && t.amd ? t(["exports"], r) : r(e.jsts = e.jsts || {}) }(this, function(t) {
                "use strict";

                function e(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }

                function i() {}

                function n() {}

                function r() {}

                function o() {}

                function s() {}

                function a() {}

                function h() {}

                function l(t) { this.name = "RuntimeException", this.message = t, this.stack = (new Error).stack, Error.call(this, t) }

                function u(t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t }

                function p() {
                    if (0 === arguments.length) l.call(this);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        l.call(this, t)
                    }
                }

                function c() {}

                function f() {
                    if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) f.call(this, 0, 0);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        f.call(this, t.x, t.y, t.z)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        f.call(this, e, i, f.NULL_ORDINATE)
                    } else if (3 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1],
                            o = arguments[2];
                        this.x = n, this.y = r, this.z = o
                    }
                }

                function g() {
                    if (this.dimensionsToTest = 2, 0 === arguments.length) g.call(this, 2);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        if (2 !== t && 3 !== t) throw new n("only 2 or 3 dimensions may be specified");
                        this.dimensionsToTest = t
                    }
                }

                function d() {}

                function y() {}

                function m(t) { this.message = t || "" }

                function v() {}

                function b(t) { this.message = t || "" }

                function w(t) { this.message = t || "" }

                function x() { this.array_ = [], arguments[0] instanceof y && this.addAll(arguments[0]) }

                function E() {
                    if (x.apply(this), 0 === arguments.length);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.ensureCapacity(t.length), this.add(t, !0)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.ensureCapacity(e.length), this.add(e, i)
                    }
                }

                function S() {
                    if (this.minx = null, this.maxx = null, this.miny = null, this.maxy = null, 0 === arguments.length) this.init();
                    else if (1 === arguments.length) {
                        if (arguments[0] instanceof f) {
                            var t = arguments[0];
                            this.init(t.x, t.x, t.y, t.y)
                        } else if (arguments[0] instanceof S) {
                            var e = arguments[0];
                            this.init(e)
                        }
                    } else if (2 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1];
                        this.init(i.x, n.x, i.y, n.y)
                    } else if (4 === arguments.length) {
                        var r = arguments[0],
                            o = arguments[1],
                            s = arguments[2],
                            a = arguments[3];
                        this.init(r, o, s, a)
                    }
                }

                function N() {}

                function L() { N.call(this, "Projective point not representable on the Cartesian plane.") }

                function C() {}

                function M(t, e) { return t.interfaces_ && t.interfaces_().indexOf(e) > -1 }

                function I() {}

                function k(t) { this.str = t }

                function T(t) { this.value = t }

                function A() {}

                function R() {
                    if (this.hi = 0, this.lo = 0, 0 === arguments.length) this.init(0);
                    else if (1 === arguments.length) {
                        if ("number" == typeof arguments[0]) {
                            var t = arguments[0];
                            this.init(t)
                        } else if (arguments[0] instanceof R) {
                            var e = arguments[0];
                            this.init(e)
                        } else if ("string" == typeof arguments[0]) {
                            var i = arguments[0];
                            R.call(this, R.parse(i))
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1];
                        this.init(n, r)
                    }
                }

                function _() {}

                function P() {}

                function O() {}

                function D() {
                    if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.x = t.x, this.y = t.y, this.w = 1
                    } else if (2 === arguments.length) {
                        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                            var e = arguments[0],
                                i = arguments[1];
                            this.x = e, this.y = i, this.w = 1
                        } else if (arguments[0] instanceof D && arguments[1] instanceof D) {
                            var n = arguments[0],
                                r = arguments[1];
                            this.x = n.y * r.w - r.y * n.w, this.y = r.x * n.w - n.x * r.w, this.w = n.x * r.y - r.x * n.y
                        } else if (arguments[0] instanceof f && arguments[1] instanceof f) {
                            var o = arguments[0],
                                s = arguments[1];
                            this.x = o.y - s.y, this.y = s.x - o.x, this.w = o.x * s.y - s.x * o.y
                        }
                    } else if (3 === arguments.length) {
                        var a = arguments[0],
                            h = arguments[1],
                            l = arguments[2];
                        this.x = a, this.y = h, this.w = l
                    } else if (4 === arguments.length) {
                        var u = arguments[0],
                            p = arguments[1],
                            c = arguments[2],
                            g = arguments[3],
                            d = u.y - p.y,
                            y = p.x - u.x,
                            m = u.x * p.y - p.x * u.y,
                            v = c.y - g.y,
                            b = g.x - c.x,
                            w = c.x * g.y - g.x * c.y;
                        this.x = y * w - b * m, this.y = v * m - d * w, this.w = d * b - v * y;
                    }
                }

                function F() {}

                function U() {}

                function B() {
                    this.envelope = null, this.factory = null, this.SRID = null, this.userData = null;
                    var t = arguments[0];
                    this.factory = t, this.SRID = t.getSRID()
                }

                function j() {}

                function z() {}

                function G() {}

                function q() {}

                function V() {}

                function W() {}

                function X() {}

                function H() {}

                function Y() {}

                function K() {}

                function $() {}

                function Z() {}

                function J() { this.array_ = [], arguments[0] instanceof y && this.addAll(arguments[0]) }

                function Q(t) { return null == t ? ts : t.color }

                function tt(t) { return null == t ? null : t.parent }

                function et(t, e) { null !== t && (t.color = e) }

                function it(t) { return null == t ? null : t.left }

                function nt(t) { return null == t ? null : t.right }

                function rt() { this.root_ = null, this.size_ = 0 }

                function ot() {}

                function st() {}

                function at() { this.array_ = [], arguments[0] instanceof y && this.addAll(arguments[0]) }

                function ht() {}

                function lt() {}

                function ut() {}

                function pt() {}

                function ct() {
                    this.geometries = null;
                    var t = arguments[0],
                        e = arguments[1];
                    if (B.call(this, e), null === t && (t = []), B.hasNullElements(t)) throw new n("geometries must not contain null elements");
                    this.geometries = t
                }

                function ft() {
                    var t = arguments[0],
                        e = arguments[1];
                    ct.call(this, t, e)
                }

                function gt() {
                    if (this.geom = null, this.geomFact = null, this.bnRule = null, this.endpointMap = null, 1 === arguments.length) {
                        var t = arguments[0];
                        gt.call(this, t, z.MOD2_BOUNDARY_RULE)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.geom = e, this.geomFact = e.getFactory(), this.bnRule = i
                    }
                }

                function dt() { this.count = null }

                function yt() {}

                function mt() {}

                function vt() {}

                function bt() {}

                function wt() {}

                function xt() {}

                function Et() {}

                function St() {}

                function Nt() {
                    this.points = null;
                    var t = arguments[0],
                        e = arguments[1];
                    B.call(this, e), this.init(t)
                }

                function Lt() {}

                function Ct() {
                    this.coordinates = null;
                    var t = arguments[0],
                        e = arguments[1];
                    B.call(this, e), this.init(t)
                }

                function Mt() {}

                function It() {
                    this.shell = null, this.holes = null;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2];
                    if (B.call(this, i), null === t && (t = this.getFactory().createLinearRing()), null === e && (e = []), B.hasNullElements(e)) throw new n("holes must not contain null elements");
                    if (t.isEmpty() && B.hasNonEmptyElements(e)) throw new n("shell is empty but holes are not");
                    this.shell = t, this.holes = e
                }

                function kt() {
                    var t = arguments[0],
                        e = arguments[1];
                    ct.call(this, t, e)
                }

                function Tt() {
                    if (arguments[0] instanceof f && arguments[1] instanceof ne) {
                        var t = arguments[0],
                            e = arguments[1];
                        Tt.call(this, e.getCoordinateSequenceFactory().create(t), e)
                    } else if (M(arguments[0], P) && arguments[1] instanceof ne) {
                        var i = arguments[0],
                            n = arguments[1];
                        Nt.call(this, i, n), this.validateConstruction()
                    }
                }

                function At() {
                    var t = arguments[0],
                        e = arguments[1];
                    ct.call(this, t, e)
                }

                function Rt() {
                    if (this.factory = null, this.isUserDataCopied = !1, 0 === arguments.length);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.factory = t
                    }
                }

                function _t() {}

                function Pt() {}

                function Ot() {}

                function Dt() {}

                function Ft() {
                    if (this.dimension = 3, this.coordinates = null, 1 === arguments.length) {
                        if (arguments[0] instanceof Array) {
                            var t = arguments[0];
                            Ft.call(this, t, 3)
                        } else if (Number.isInteger(arguments[0])) {
                            var e = arguments[0];
                            this.coordinates = new Array(e).fill(null);
                            for (var i = 0; e > i; i++) this.coordinates[i] = new f
                        } else if (M(arguments[0], P)) {
                            var n = arguments[0];
                            if (null === n) return this.coordinates = new Array(0).fill(null), null;
                            this.dimension = n.getDimension(), this.coordinates = new Array(n.size()).fill(null);
                            for (var i = 0; i < this.coordinates.length; i++) this.coordinates[i] = n.getCoordinateCopy(i)
                        }
                    } else if (2 === arguments.length)
                        if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
                            var r = arguments[0],
                                o = arguments[1];
                            this.coordinates = r, this.dimension = o, null === r && (this.coordinates = new Array(0).fill(null))
                        } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                        var s = arguments[0],
                            a = arguments[1];
                        this.coordinates = new Array(s).fill(null), this.dimension = a;
                        for (var i = 0; s > i; i++) this.coordinates[i] = new f
                    }
                }

                function Ut() {}

                function Bt(t, e) { return t === e || t !== t && e !== e }

                function jt(t, e) {
                    function i(t) { return this && this.constructor === i ? (this._keys = [], this._values = [], this._itp = [], this.objectOnly = e, void(t && zt.call(this, t))) : new i(t) }
                    return e || rs(t, "size", { get: Jt }), t.constructor = i, i.prototype = t, i
                }

                function zt(t) { this.add ? t.forEach(this.add, this) : t.forEach(function(t) { this.set(t[0], t[1]) }, this) }

                function Gt(t) { return this.has(t) && (this._keys.splice(ns, 1), this._values.splice(ns, 1), this._itp.forEach(function(t) { ns < t[0] && t[0]-- })), ns > -1 }

                function qt(t) { return this.has(t) ? this._values[ns] : void 0 }

                function Vt(t, e) {
                    if (this.objectOnly && e !== Object(e)) throw new TypeError("Invalid value used as weak collection key");
                    if (e !== e || 0 === e)
                        for (ns = t.length; ns-- && !Bt(t[ns], e););
                    else ns = t.indexOf(e);
                    return ns > -1
                }

                function Wt(t) { return Vt.call(this, this._keys, t) }

                function Xt(t, e) { return this.has(t) ? this._values[ns] = e : this._values[this._keys.push(t) - 1] = e, this }

                function Ht() {
                    (this._keys || 0).length = this._values.length = 0
                }

                function Yt() { return Zt(this._itp, this._keys) }

                function Kt() { return Zt(this._itp, this._values) }

                function $t() { return Zt(this._itp, this._keys, this._values) }

                function Zt(t, e, i) {
                    var n = [0],
                        r = !1;
                    return t.push(n), { next: function() { var o, s = n[0]; return !r && s < e.length ? (o = i ? [e[s], i[s]] : e[s], n[0]++) : (r = !0, t.splice(t.indexOf(n), 1)), { done: r, value: o } } }
                }

                function Jt() { return this._values.length }

                function Qt(t, e) {
                    for (var i = this.entries();;) {
                        var n = i.next();
                        if (n.done) break;
                        t.call(e, n.value[1], n.value[0], this)
                    }
                }

                function te() { this.map_ = new ss }

                function ee() {
                    if (this.modelType = null, this.scale = null, 0 === arguments.length) this.modelType = ee.FLOATING;
                    else if (1 === arguments.length)
                        if (arguments[0] instanceof ie) {
                            var t = arguments[0];
                            this.modelType = t, t === ee.FIXED && this.setScale(1)
                        } else if ("number" == typeof arguments[0]) {
                        var e = arguments[0];
                        this.modelType = ee.FIXED, this.setScale(e)
                    } else if (arguments[0] instanceof ee) {
                        var i = arguments[0];
                        this.modelType = i.modelType, this.scale = i.scale
                    }
                }

                function ie() {
                    this.name = null;
                    var t = arguments[0];
                    this.name = t, ie.nameToTypeMap.put(t, this)
                }

                function ne() {
                    if (this.precisionModel = null, this.coordinateSequenceFactory = null, this.SRID = null, 0 === arguments.length) ne.call(this, new ee, 0);
                    else if (1 === arguments.length) {
                        if (M(arguments[0], F)) {
                            var t = arguments[0];
                            ne.call(this, new ee, 0, t)
                        } else if (arguments[0] instanceof ee) {
                            var e = arguments[0];
                            ne.call(this, e, 0, ne.getDefaultCoordinateSequenceFactory())
                        }
                    } else if (2 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1];
                        ne.call(this, i, n, ne.getDefaultCoordinateSequenceFactory())
                    } else if (3 === arguments.length) {
                        var r = arguments[0],
                            o = arguments[1],
                            s = arguments[2];
                        this.precisionModel = r, this.coordinateSequenceFactory = s, this.SRID = o
                    }
                }

                function re(t) { this.geometryFactory = t || new ne }

                function oe(t) { this.parser = new re(t) }

                function se() { this.result = null, this.inputLines = Array(2).fill().map(function() { return Array(2) }), this.intPt = new Array(2).fill(null), this.intLineIndex = null, this._isProper = null, this.pa = null, this.pb = null, this.precisionModel = null, this.intPt[0] = new f, this.intPt[1] = new f, this.pa = this.intPt[0], this.pb = this.intPt[1], this.result = 0 }

                function ae() { se.apply(this) }

                function he() {}

                function le() {
                    this.p = null, this.crossingCount = 0, this.isPointOnSegment = !1;
                    var t = arguments[0];
                    this.p = t
                }

                function ue() {}

                function pe() {
                    if (this.p0 = null, this.p1 = null, 0 === arguments.length) pe.call(this, new f, new f);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        pe.call(this, t.p0, t.p1)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.p0 = e, this.p1 = i
                    } else if (4 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1],
                            o = arguments[2],
                            s = arguments[3];
                        pe.call(this, new f(n, r), new f(o, s))
                    }
                }

                function ce() {
                    if (this.matrix = null, 0 === arguments.length) this.matrix = Array(3).fill().map(function() { return Array(3) }), this.setAll(lt.FALSE);
                    else if (1 === arguments.length)
                        if ("string" == typeof arguments[0]) {
                            var t = arguments[0];
                            ce.call(this), this.set(t)
                        } else if (arguments[0] instanceof ce) {
                        var e = arguments[0];
                        ce.call(this), this.matrix[C.INTERIOR][C.INTERIOR] = e.matrix[C.INTERIOR][C.INTERIOR], this.matrix[C.INTERIOR][C.BOUNDARY] = e.matrix[C.INTERIOR][C.BOUNDARY], this.matrix[C.INTERIOR][C.EXTERIOR] = e.matrix[C.INTERIOR][C.EXTERIOR], this.matrix[C.BOUNDARY][C.INTERIOR] = e.matrix[C.BOUNDARY][C.INTERIOR], this.matrix[C.BOUNDARY][C.BOUNDARY] = e.matrix[C.BOUNDARY][C.BOUNDARY], this.matrix[C.BOUNDARY][C.EXTERIOR] = e.matrix[C.BOUNDARY][C.EXTERIOR], this.matrix[C.EXTERIOR][C.INTERIOR] = e.matrix[C.EXTERIOR][C.INTERIOR], this.matrix[C.EXTERIOR][C.BOUNDARY] = e.matrix[C.EXTERIOR][C.BOUNDARY], this.matrix[C.EXTERIOR][C.EXTERIOR] = e.matrix[C.EXTERIOR][C.EXTERIOR]
                    }
                }

                function fe() {
                    this.areaBasePt = null, this.triangleCent3 = new f, this.areasum2 = 0, this.cg3 = new f, this.lineCentSum = new f, this.totalLength = 0, this.ptCount = 0, this.ptCentSum = new f;
                    var t = arguments[0];
                    this.areaBasePt = null, this.add(t)
                }

                function ge(t) { this.message = t || "" }

                function de() { this.array_ = [] }

                function ye() { this.treeSet = new at, this.list = new x }

                function me() {
                    if (this.geomFactory = null, this.inputPts = null, 1 === arguments.length) {
                        var t = arguments[0];
                        me.call(this, me.extractCoordinates(t), t.getFactory())
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.inputPts = ye.filterCoordinates(e), this.geomFactory = i
                    }
                }

                function ve() {
                    this.origin = null;
                    var t = arguments[0];
                    this.origin = t
                }

                function be() { this.inputGeom = null, this.factory = null, this.pruneEmptyGeometry = !0, this.preserveGeometryCollectionType = !0, this.preserveCollections = !1, this.preserveType = !1 }

                function we() {
                    if (this.snapTolerance = 0, this.srcPts = null, this.seg = new pe, this.allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof Nt && "number" == typeof arguments[1]) {
                        var t = arguments[0],
                            e = arguments[1];
                        we.call(this, t.getCoordinates(), e)
                    } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
                        var i = arguments[0],
                            n = arguments[1];
                        this.srcPts = i, this._isClosed = we.isClosed(i), this.snapTolerance = n
                    }
                }

                function xe() {
                    this.srcGeom = null;
                    var t = arguments[0];
                    this.srcGeom = t
                }

                function Ee() {
                    if (be.apply(this), this.snapTolerance = null, this.snapPts = null, this.isSelfSnap = !1, 2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        this.snapTolerance = t, this.snapPts = e
                    } else if (3 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            r = arguments[2];
                        this.snapTolerance = i, this.snapPts = n, this.isSelfSnap = r
                    }
                }

                function Se() { this.isFirst = !0, this.commonMantissaBitsCount = 53, this.commonBits = 0, this.commonSignExp = null }

                function Ne() { this.commonCoord = null, this.ccFilter = new Le }

                function Le() { this.commonBitsX = new Se, this.commonBitsY = new Se }

                function Ce() {
                    this.trans = null;
                    var t = arguments[0];
                    this.trans = t
                }

                function Me() {
                    this.parent = null, this.atStart = null, this.max = null, this.index = null, this.subcollectionIterator = null;
                    var t = arguments[0];
                    this.parent = t, this.atStart = !0, this.index = 0, this.max = t.getNumGeometries()
                }

                function Ie() {
                    if (this.boundaryRule = z.OGC_SFS_BOUNDARY_RULE, this.isIn = null, this.numBoundaries = null, 0 === arguments.length);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        if (null === t) throw new n("Rule must be non-null");
                        this.boundaryRule = t
                    }
                }

                function ke() {}

                function Te() {}

                function Ae() {
                    this.pts = null, this.data = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.pts = t, this.data = e
                }

                function Re() {}

                function _e() {
                    this.bounds = null, this.item = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.bounds = t, this.item = e
                }

                function Pe() { this._size = null, this.items = null, this._size = 0, this.items = new x, this.items.add(null) }

                function Oe() {}

                function De() {}

                function Fe() {
                    if (this.childBoundables = new x, this.bounds = null, this.level = null, 0 === arguments.length);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.level = t
                    }
                }

                function Ue() {
                    this.boundable1 = null, this.boundable2 = null, this._distance = null, this.itemDistance = null;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2];
                    this.boundable1 = t, this.boundable2 = e, this.itemDistance = i, this._distance = this.distance()
                }

                function Be() {
                    if (this.root = null, this.built = !1, this.itemBoundables = new x, this.nodeCapacity = null, 0 === arguments.length) Be.call(this, Be.DEFAULT_NODE_CAPACITY);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        c.isTrue(t > 1, "Node capacity must be greater than 1"), this.nodeCapacity = t
                    }
                }

                function je() {}

                function ze() {}

                function Ge() {
                    if (0 === arguments.length) Ge.call(this, Ge.DEFAULT_NODE_CAPACITY);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        Be.call(this, t)
                    }
                }

                function qe() {
                    var t = arguments[0];
                    Fe.call(this, t)
                }

                function Ve() {}

                function We() {
                    this.segString = null, this.coord = null, this.segmentIndex = null, this.segmentOctant = null, this._isInterior = null;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2],
                        n = arguments[3];
                    this.segString = t, this.coord = new f(e), this.segmentIndex = i, this.segmentOctant = n, this._isInterior = !e.equals2D(t.getCoordinate(i))
                }

                function Xe() {
                    this.nodeMap = new rt, this.edge = null;
                    var t = arguments[0];
                    this.edge = t
                }

                function He() {
                    this.nodeList = null, this.edge = null, this.nodeIt = null, this.currNode = null, this.nextNode = null, this.currSegIndex = 0;
                    var t = arguments[0];
                    this.nodeList = t, this.edge = t.getEdge(), this.nodeIt = t.iterator(), this.readNextNode()
                }

                function Ye() {}

                function Ke() {
                    this.nodeList = new Xe(this), this.pts = null, this.data = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.pts = t, this.data = e
                }

                function $e() { this.tempEnv1 = new S, this.tempEnv2 = new S, this.overlapSeg1 = new pe, this.overlapSeg2 = new pe }

                function Ze() {
                    this.pts = null, this.start = null, this.end = null, this.env = null, this.context = null, this.id = null;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2],
                        n = arguments[3];
                    this.pts = t, this.start = e, this.end = i, this.context = n
                }

                function Je() {}

                function Qe() {}

                function ti() {}

                function ei() {
                    if (this.segInt = null, 0 === arguments.length);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.setSegmentIntersector(t)
                    }
                }

                function ii() {
                    if (this.monoChains = new x, this.index = new Ge, this.idCounter = 0, this.nodedSegStrings = null, this.nOverlaps = 0, 0 === arguments.length);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        ei.call(this, t)
                    }
                }

                function ni() {
                    $e.apply(this), this.si = null;
                    var t = arguments[0];
                    this.si = t
                }

                function ri() {
                    if (this.pt = null, 1 === arguments.length) {
                        var t = arguments[0];
                        l.call(this, t)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        l.call(this, ri.msgWithCoord(e, i)), this.name = "TopologyException", this.pt = new f(i)
                    }
                }

                function oi() {}

                function si() {
                    this.findAllIntersections = !1, this.isCheckEndSegmentsOnly = !1, this.li = null, this.interiorIntersection = null, this.intSegments = null, this.intersections = new x, this.intersectionCount = 0, this.keepIntersections = !0;
                    var t = arguments[0];
                    this.li = t, this.interiorIntersection = null
                }

                function ai() {
                    this.li = new ae, this.segStrings = null, this.findAllIntersections = !1, this.segInt = null, this._isValid = !0;
                    var t = arguments[0];
                    this.segStrings = t
                }

                function hi() {
                    this.nv = null;
                    var t = arguments[0];
                    this.nv = new ai(hi.toSegmentStrings(t))
                }

                function li() {
                    this.mapOp = null;
                    var t = arguments[0];
                    this.mapOp = t
                }

                function ui() {}

                function pi() {
                    if (this.location = null, 1 === arguments.length) {
                        if (arguments[0] instanceof Array) {
                            var t = arguments[0];
                            this.init(t.length)
                        } else if (Number.isInteger(arguments[0])) {
                            var e = arguments[0];
                            this.init(1), this.location[ui.ON] = e
                        } else if (arguments[0] instanceof pi) {
                            var i = arguments[0];
                            if (this.init(i.location.length), null !== i)
                                for (var n = 0; n < this.location.length; n++) this.location[n] = i.location[n]
                        }
                    } else if (3 === arguments.length) {
                        var r = arguments[0],
                            o = arguments[1],
                            s = arguments[2];
                        this.init(3), this.location[ui.ON] = r, this.location[ui.LEFT] = o, this.location[ui.RIGHT] = s
                    }
                }

                function ci() {
                    if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
                        if (Number.isInteger(arguments[0])) {
                            var t = arguments[0];
                            this.elt[0] = new pi(t), this.elt[1] = new pi(t)
                        } else if (arguments[0] instanceof ci) {
                            var e = arguments[0];
                            this.elt[0] = new pi(e.elt[0]), this.elt[1] = new pi(e.elt[1])
                        }
                    } else if (2 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1];
                        this.elt[0] = new pi(C.NONE), this.elt[1] = new pi(C.NONE), this.elt[i].setLocation(n)
                    } else if (3 === arguments.length) {
                        var r = arguments[0],
                            o = arguments[1],
                            s = arguments[2];
                        this.elt[0] = new pi(r, o, s), this.elt[1] = new pi(r, o, s)
                    } else if (4 === arguments.length) {
                        var a = arguments[0],
                            h = arguments[1],
                            l = arguments[2],
                            u = arguments[3];
                        this.elt[0] = new pi(C.NONE, C.NONE, C.NONE), this.elt[1] = new pi(C.NONE, C.NONE, C.NONE), this.elt[a].setLocations(h, l, u)
                    }
                }

                function fi() {
                    this.startDe = null, this.maxNodeDegree = -1, this.edges = new x, this.pts = new x, this.label = new ci(C.NONE), this.ring = null, this._isHole = null, this.shell = null, this.holes = new x, this.geometryFactory = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.geometryFactory = e, this.computePoints(t), this.computeRing()
                }

                function gi() {
                    var t = arguments[0],
                        e = arguments[1];
                    fi.call(this, t, e)
                }

                function di() {
                    var t = arguments[0],
                        e = arguments[1];
                    fi.call(this, t, e)
                }

                function yi() {
                    if (this.label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.label = t
                    }
                }

                function mi() {
                    yi.apply(this), this.coord = null, this.edges = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.coord = t, this.edges = e, this.label = new ci(0, C.NONE)
                }

                function vi() {
                    this.nodeMap = new rt, this.nodeFact = null;
                    var t = arguments[0];
                    this.nodeFact = t
                }

                function bi() {
                    if (this.edge = null, this.label = null, this.node = null, this.p0 = null, this.p1 = null, this.dx = null, this.dy = null, this.quadrant = null, 1 === arguments.length) {
                        var t = arguments[0];
                        this.edge = t
                    } else if (3 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1],
                            n = arguments[2];
                        bi.call(this, e, i, n, null)
                    } else if (4 === arguments.length) {
                        var r = arguments[0],
                            o = arguments[1],
                            s = arguments[2],
                            a = arguments[3];
                        bi.call(this, r), this.init(o, s), this.label = a
                    }
                }

                function wi() {
                    this._isForward = null, this._isInResult = !1, this._isVisited = !1, this.sym = null, this.next = null, this.nextMin = null, this.edgeRing = null, this.minEdgeRing = null, this.depth = [0, -999, -999];
                    var t = arguments[0],
                        e = arguments[1];
                    if (bi.call(this, t), this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1));
                    else {
                        var i = t.getNumPoints() - 1;
                        this.init(t.getCoordinate(i), t.getCoordinate(i - 1))
                    }
                    this.computeDirectedLabel()
                }

                function xi() {}

                function Ei() {
                    if (this.edges = new x, this.nodes = null, this.edgeEndList = new x, 0 === arguments.length) this.nodes = new vi(new xi);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.nodes = new vi(t)
                    }
                }

                function Si() {
                    this.geometryFactory = null, this.shellList = new x;
                    var t = arguments[0];
                    this.geometryFactory = t
                }

                function Ni() {
                    this.op = null, this.geometryFactory = null, this.ptLocator = null, this.lineEdgesList = new x, this.resultLineList = new x;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2];
                    this.op = t, this.geometryFactory = e, this.ptLocator = i
                }

                function Li() {
                    this.op = null, this.geometryFactory = null, this.resultPointList = new x;
                    var t = arguments[0],
                        e = arguments[1];
                    arguments[2], this.op = t, this.geometryFactory = e
                }

                function Ci() {}

                function Mi() {
                    this.geom = null;
                    var t = arguments[0];
                    this.geom = t
                }

                function Ii() { this.edgeMap = new rt, this.edgeList = null, this.ptInAreaLocation = [C.NONE, C.NONE] }

                function ki() { Ii.apply(this), this.resultAreaEdgeList = null, this.label = null, this.SCANNING_FOR_INCOMING = 1, this.LINKING_TO_OUTGOING = 2 }

                function Ti() { xi.apply(this) }

                function Ai() {
                    this.mce = null, this.chainIndex = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.mce = t, this.chainIndex = e
                }

                function Ri() {
                    if (this.label = null, this.xValue = null, this.eventType = null, this.insertEvent = null, this.deleteEventIndex = null, this.obj = null, 2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        this.eventType = Ri.DELETE, this.xValue = t, this.insertEvent = e
                    } else if (3 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            r = arguments[2];
                        this.eventType = Ri.INSERT, this.label = i, this.xValue = n, this.obj = r
                    }
                }

                function _i() {}

                function Pi() {
                    this._hasIntersection = !1, this.hasProper = !1, this.hasProperInterior = !1, this.properIntersectionPoint = null, this.li = null, this.includeProper = null, this.recordIsolated = null, this.isSelfIntersection = null, this.numIntersections = 0, this.numTests = 0, this.bdyNodes = null, this._isDone = !1, this.isDoneWhenProperInt = !1;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2];
                    this.li = t, this.includeProper = e, this.recordIsolated = i
                }

                function Oi() { _i.apply(this), this.events = new x, this.nOverlaps = null }

                function Di() { this.min = r.POSITIVE_INFINITY, this.max = r.NEGATIVE_INFINITY }

                function Fi() {}

                function Ui() {
                    Di.apply(this), this.item = null;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2];
                    this.min = t, this.max = e, this.item = i
                }

                function Bi() {
                    Di.apply(this), this.node1 = null, this.node2 = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.node1 = t, this.node2 = e, this.buildExtent(this.node1, this.node2)
                }

                function ji() { this.leaves = new x, this.root = null, this.level = 0 }

                function zi() {
                    if (this.lines = null, this.isForcedToLineString = !1, 1 === arguments.length) {
                        var t = arguments[0];
                        this.lines = t
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.lines = e, this.isForcedToLineString = i
                    }
                }

                function Gi() { this.items = new x }

                function qi() {
                    this.index = null;
                    var t = arguments[0];
                    if (!M(t, Mt)) throw new n("Argument must be Polygonal");
                    this.index = new Wi(t)
                }

                function Vi() {
                    this.counter = null;
                    var t = arguments[0];
                    this.counter = t
                }

                function Wi() {
                    this.index = new ji;
                    var t = arguments[0];
                    this.init(t)
                }

                function Xi() {
                    this.coord = null, this.segmentIndex = null, this.dist = null;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2];
                    this.coord = new f(t), this.segmentIndex = e, this.dist = i
                }

                function Hi() {
                    this.nodeMap = new rt, this.edge = null;
                    var t = arguments[0];
                    this.edge = t
                }

                function Yi() {}

                function Ki() {
                    this.e = null, this.pts = null, this.startIndex = null, this.env1 = new S, this.env2 = new S;
                    var t = arguments[0];
                    this.e = t, this.pts = t.getCoordinates();
                    var e = new Yi;
                    this.startIndex = e.getChainStartIndices(this.pts)
                }

                function $i() {
                    this.depth = Array(2).fill().map(function() { return Array(3) });
                    for (var t = 0; 2 > t; t++)
                        for (var e = 0; 3 > e; e++) this.depth[t][e] = $i.NULL_VALUE
                }

                function Zi() {
                    if (yi.apply(this), this.pts = null, this.env = null, this.eiList = new Hi(this), this.name = null, this.mce = null, this._isIsolated = !0, this.depth = new $i, this.depthDelta = 0, 1 === arguments.length) {
                        var t = arguments[0];
                        Zi.call(this, t, null)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.pts = e, this.label = i
                    }
                }

                function Ji() {
                    if (Ei.apply(this), this.parentGeom = null, this.lineEdgeMap = new te, this.boundaryNodeRule = null, this.useBoundaryDeterminationRule = !0, this.argIndex = null, this.boundaryNodes = null, this._hasTooFewPoints = !1, this.invalidPoint = null, this.areaPtLocator = null, this.ptLocator = new Ie, 2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        Ji.call(this, t, e, z.OGC_SFS_BOUNDARY_RULE)
                    } else if (3 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            r = arguments[2];
                        this.argIndex = i, this.parentGeom = n, this.boundaryNodeRule = r, null !== n && this.add(n)
                    }
                }

                function Qi() {
                    if (this.li = new ae, this.resultPrecisionModel = null, this.arg = null, 1 === arguments.length) {
                        var t = arguments[0];
                        this.setComputationPrecision(t.getPrecisionModel()), this.arg = new Array(1).fill(null), this.arg[0] = new Ji(0, t)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        Qi.call(this, e, i, z.OGC_SFS_BOUNDARY_RULE)
                    } else if (3 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1],
                            o = arguments[2];
                        n.getPrecisionModel().compareTo(r.getPrecisionModel()) >= 0 ? this.setComputationPrecision(n.getPrecisionModel()) : this.setComputationPrecision(r.getPrecisionModel()), this.arg = new Array(2).fill(null), this.arg[0] = new Ji(0, n, o), this.arg[1] = new Ji(1, r, o)
                    }
                }

                function tn() {
                    this.pts = null, this._orientation = null;
                    var t = arguments[0];
                    this.pts = t, this._orientation = tn.orientation(t)
                }

                function en() { this.edges = new x, this.ocaMap = new rt }

                function nn() {
                    this.ptLocator = new Ie, this.geomFact = null, this.resultGeom = null, this.graph = null, this.edgeList = new en, this.resultPolyList = new x, this.resultLineList = new x, this.resultPointList = new x;
                    var t = arguments[0],
                        e = arguments[1];
                    Qi.call(this, t, e), this.graph = new Ei(new Ti), this.geomFact = t.getFactory()
                }

                function rn() {
                    this.geom = new Array(2).fill(null), this.snapTolerance = null, this.cbr = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.geom[0] = t, this.geom[1] = e, this.computeSnapTolerance()
                }

                function on() {
                    this.geom = new Array(2).fill(null);
                    var t = arguments[0],
                        e = arguments[1];
                    this.geom[0] = t, this.geom[1] = e
                }

                function sn() {
                    this.factory = null, this.interiorPoint = null, this.maxWidth = 0;
                    var t = arguments[0];
                    this.factory = t.getFactory(), this.add(t)
                }

                function an() {
                    this.poly = null, this.centreY = null, this.hiY = r.MAX_VALUE, this.loY = -r.MAX_VALUE;
                    var t = arguments[0];
                    this.poly = t, this.hiY = t.getEnvelopeInternal().getMaxY(), this.loY = t.getEnvelopeInternal().getMinY(), this.centreY = sn.avg(this.loY, this.hiY)
                }

                function hn() {
                    this.centroid = null, this.minDistance = r.MAX_VALUE, this.interiorPoint = null;
                    var t = arguments[0];
                    this.centroid = t.getCentroid().getCoordinate(), this.addInterior(t), null === this.interiorPoint && this.addEndpoints(t)
                }

                function ln() {
                    this.centroid = null, this.minDistance = r.MAX_VALUE, this.interiorPoint = null;
                    var t = arguments[0];
                    this.centroid = t.getCentroid().getCoordinate(), this.add(t)
                }

                function un() { this.tempEnv1 = new S, this.selectedSegment = new pe }

                function pn() { this.items = new x, this.subnode = [null, null] }

                function cn() {
                    if (this.min = null, this.max = null, 0 === arguments.length) this.min = 0, this.max = 0;
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.init(t.min, t.max)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.init(e, i)
                    }
                }

                function fn() {}

                function gn(t, e) {
                    var i, n, r, o, s = { 32: { d: 127, c: 128, b: 0, a: 0 }, 64: { d: 32752, c: 0, b: 0, a: 0 } },
                        a = { 32: 8, 64: 11 }[t];
                    if (o || (i = 0 > e || 0 > 1 / e, isFinite(e) || (o = s[t], i && (o.d += 1 << t / 4 - 1), n = Math.pow(2, a) - 1, r = 0)), !o) {
                        for (n = { 32: 127, 64: 1023 }[t], r = Math.abs(e); r >= 2;) n++, r /= 2;
                        for (; 1 > r && n > 0;) n--, r *= 2;
                        0 >= n && (r /= 2), 32 === t && n > 254 && (o = { d: i ? 255 : 127, c: 128, b: 0, a: 0 }, n = Math.pow(2, a) - 1, r = 0)
                    }
                    return n
                }

                function dn() {
                    this.pt = 0, this.level = 0, this.interval = null;
                    var t = arguments[0];
                    this.computeKey(t)
                }

                function yn() {
                    pn.apply(this), this.interval = null, this.centre = null, this.level = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.interval = t, this.level = e, this.centre = (t.getMin() + t.getMax()) / 2
                }

                function mn() {}

                function vn() { pn.apply(this) }

                function bn() { this.root = null, this.minExtent = 1, this.root = new vn }

                function wn() {}

                function xn() {
                    this.ring = null, this.tree = null, this.crossings = 0, this.interval = new cn;
                    var t = arguments[0];
                    this.ring = t, this.buildIndex()
                }

                function En() {
                    un.apply(this), this.mcp = null, this.p = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.mcp = t, this.p = e
                }

                function Sn() {}

                function Nn() {
                    this.p0 = null, this.p1 = null, this.p2 = null;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2];
                    this.p0 = t, this.p1 = e, this.p2 = i
                }

                function Ln() {
                    this.input = null, this.extremalPts = null, this.centre = null, this.radius = 0;
                    var t = arguments[0];
                    this.input = t
                }

                function Cn() {
                    if (this.inputGeom = null, this.isConvex = null, this.convexHullPts = null, this.minBaseSeg = new pe, this.minWidthPt = null, this.minPtIndex = null, this.minWidth = 0, 1 === arguments.length) {
                        var t = arguments[0];
                        Cn.call(this, t, !1)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.inputGeom = e, this.isConvex = i
                    }
                }

                function Mn() {
                    this.inputGeom = null, this.distanceTolerance = null;
                    var t = arguments[0];
                    this.inputGeom = t
                }

                function In() {
                    be.apply(this), this.distanceTolerance = null;
                    var t = arguments[0];
                    this.distanceTolerance = t
                }

                function kn() {
                    this._orig = null, this._sym = null, this._next = null;
                    var t = arguments[0];
                    this._orig = t
                }

                function Tn() {
                    this._isMarked = !1;
                    var t = arguments[0];
                    kn.call(this, t)
                }

                function An() { this.vertexMap = new te }

                function Rn() {
                    this._isStart = !1;
                    var t = arguments[0];
                    Tn.call(this, t)
                }

                function _n() { An.apply(this) }

                function Pn() { this.result = null, this.factory = null, this.graph = null, this.lines = new x, this.nodeEdgeStack = new de, this.ringStartEdge = null, this.graph = new _n }

                function On() { this.items = new x, this.subnode = new Array(4).fill(null) }

                function Dn() {
                    this.pt = new f, this.level = 0, this.env = null;
                    var t = arguments[0];
                    this.computeKey(t)
                }

                function Fn() {
                    On.apply(this), this.env = null, this.centrex = null, this.centrey = null, this.level = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.env = t, this.level = e, this.centrex = (t.getMinX() + t.getMaxX()) / 2, this.centrey = (t.getMinY() + t.getMaxY()) / 2
                }

                function Un() { On.apply(this) }

                function Bn() { this.root = null, this.minExtent = 1, this.root = new Un }

                function jn(t) { this.geometryFactory = t || new ne }

                function zn(t) { this.geometryFactory = t || new ne, this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new jn(this.geometryFactory) }

                function Gn() { this.parser = new jn(this.geometryFactory) }

                function qn(t) { this.geometryFactory = t || new ne, this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new re(this.geometryFactory) }

                function Vn(t) { return [t.x, t.y] }

                function Wn(t) { this.geometryFactory = t || new ne }

                function Xn() {
                    if (this.noder = null, this.scaleFactor = null, this.offsetX = null, this.offsetY = null, this.isScaled = !1, 2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        Xn.call(this, t, e, 0, 0)
                    } else if (4 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1];
                        arguments[2], arguments[3], this.noder = i, this.scaleFactor = n, this.isScaled = !this.isIntegerPrecision()
                    }
                }

                function Hn() {
                    if (this.inputGeom = null, this.isClosedEndpointsInInterior = !0, this.nonSimpleLocation = null, 1 === arguments.length) {
                        var t = arguments[0];
                        this.inputGeom = t
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.inputGeom = e, this.isClosedEndpointsInInterior = !i.isInBoundary(2)
                    }
                }

                function Yn() {
                    this.pt = null, this.isClosed = null, this.degree = null;
                    var t = arguments[0];
                    this.pt = t, this.isClosed = !1, this.degree = 0
                }

                function Kn() {
                    if (this.quadrantSegments = Kn.DEFAULT_QUADRANT_SEGMENTS, this.endCapStyle = Kn.CAP_ROUND, this.joinStyle = Kn.JOIN_ROUND, this.mitreLimit = Kn.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this.simplifyFactor = Kn.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.setQuadrantSegments(t)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.setQuadrantSegments(e), this.setEndCapStyle(i)
                    } else if (4 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1],
                            o = arguments[2],
                            s = arguments[3];
                        this.setQuadrantSegments(n), this.setEndCapStyle(r), this.setJoinStyle(o), this.setMitreLimit(s)
                    }
                }

                function $n() { this.minIndex = -1, this.minCoord = null, this.minDe = null, this.orientedDe = null }

                function Zn() { this.array_ = [] }

                function Jn() { this.finder = null, this.dirEdgeList = new x, this.nodes = new x, this.rightMostCoord = null, this.env = null, this.finder = new $n }

                function Qn() {
                    this.inputLine = null, this.distanceTol = null, this.isDeleted = null, this.angleOrientation = ue.COUNTERCLOCKWISE;
                    var t = arguments[0];
                    this.inputLine = t
                }

                function tr() { this.ptList = null, this.precisionModel = null, this.minimimVertexDistance = 0, this.ptList = new x }

                function er() {
                    this.maxCurveSegmentError = 0, this.filletAngleQuantum = null, this.closingSegLengthFactor = 1, this.segList = null, this.distance = 0, this.precisionModel = null, this.bufParams = null, this.li = null, this.s0 = null, this.s1 = null, this.s2 = null, this.seg0 = new pe, this.seg1 = new pe, this.offset0 = new pe, this.offset1 = new pe, this.side = 0, this._hasNarrowConcaveAngle = !1;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2];
                    this.precisionModel = t, this.bufParams = e, this.li = new ae, this.filletAngleQuantum = Math.PI / 2 / e.getQuadrantSegments(), e.getQuadrantSegments() >= 8 && e.getJoinStyle() === Kn.JOIN_ROUND && (this.closingSegLengthFactor = er.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i)
                }

                function ir() {
                    this.distance = 0, this.precisionModel = null, this.bufParams = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.precisionModel = t, this.bufParams = e
                }

                function nr() {
                    this.subgraphs = null, this.seg = new pe, this.cga = new ue;
                    var t = arguments[0];
                    this.subgraphs = t
                }

                function rr() {
                    this.upwardSeg = null, this.leftDepth = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.upwardSeg = new pe(t), this.leftDepth = e
                }

                function or() {
                    this.inputGeom = null, this.distance = null, this.curveBuilder = null, this.curveList = new x;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2];
                    this.inputGeom = t, this.distance = e, this.curveBuilder = i
                }

                function sr() {
                    this._hasIntersection = !1, this.hasProper = !1, this.hasProperInterior = !1, this.hasInterior = !1, this.properIntersectionPoint = null, this.li = null, this.isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
                    var t = arguments[0];
                    this.li = t
                }

                function ar() {
                    this.bufParams = null, this.workingPrecisionModel = null, this.workingNoder = null, this.geomFact = null, this.graph = null, this.edgeList = new en;
                    var t = arguments[0];
                    this.bufParams = t
                }

                function hr() {
                    this.li = new ae, this.segStrings = null;
                    var t = arguments[0];
                    this.segStrings = t
                }

                function lr() {
                    this.li = null, this.pt = null, this.originalPt = null, this.ptScaled = null, this.p0Scaled = null, this.p1Scaled = null, this.scaleFactor = null, this.minx = null, this.maxx = null, this.miny = null, this.maxy = null, this.corner = new Array(4).fill(null), this.safeEnv = null;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2];
                    if (this.originalPt = t, this.pt = t, this.scaleFactor = e, this.li = i, 0 >= e) throw new n("Scale factor must be non-zero");
                    1 !== e && (this.pt = new f(this.scale(t.x), this.scale(t.y)), this.p0Scaled = new f, this.p1Scaled = new f), this.initCorners(this.pt)
                }

                function ur() {
                    this.index = null;
                    var t = arguments[0];
                    this.index = t
                }

                function pr() {
                    un.apply(this), this.hotPixel = null, this.parentEdge = null, this.hotPixelVertexIndex = null, this._isNodeAdded = !1;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2];
                    this.hotPixel = t, this.parentEdge = e, this.hotPixelVertexIndex = i
                }

                function cr() {
                    this.li = null, this.interiorIntersections = null;
                    var t = arguments[0];
                    this.li = t, this.interiorIntersections = new x
                }

                function fr() {
                    this.pm = null, this.li = null, this.scaleFactor = null, this.noder = null, this.pointSnapper = null, this.nodedSegStrings = null;
                    var t = arguments[0];
                    this.pm = t, this.li = new ae, this.li.setPrecisionModel(t), this.scaleFactor = t.getScale()
                }

                function gr() {
                    if (this.argGeom = null, this.distance = null, this.bufParams = new Kn, this.resultGeometry = null, this.saveException = null, 1 === arguments.length) {
                        var t = arguments[0];
                        this.argGeom = t
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.argGeom = e, this.bufParams = i
                    }
                }

                function dr() {
                    this.comps = null;
                    var t = arguments[0];
                    this.comps = t
                }

                function yr() {
                    if (this.component = null, this.segIndex = null, this.pt = null, 2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        yr.call(this, t, yr.INSIDE_AREA, e)
                    } else if (3 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            r = arguments[2];
                        this.component = i, this.segIndex = n, this.pt = r
                    }
                }

                function mr() {
                    this.pts = null;
                    var t = arguments[0];
                    this.pts = t
                }

                function vr() {
                    this.locations = null;
                    var t = arguments[0];
                    this.locations = t
                }

                function br() {
                    if (this.geom = null, this.terminateDistance = 0, this.ptLocator = new Ie, this.minDistanceLocation = null, this.minDistance = r.MAX_VALUE, 2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        br.call(this, t, e, 0)
                    } else if (3 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            o = arguments[2];
                        this.geom = new Array(2).fill(null), this.geom[0] = i, this.geom[1] = n, this.terminateDistance = o
                    }
                }

                function wr() {
                    this.factory = null, this.directedEdges = new x, this.coordinates = null;
                    var t = arguments[0];
                    this.factory = t
                }

                function xr() { this._isMarked = !1, this._isVisited = !1, this.data = null }

                function Er() {
                    xr.apply(this), this.parentEdge = null, this.from = null, this.to = null, this.p0 = null, this.p1 = null, this.sym = null, this.edgeDirection = null, this.quadrant = null, this.angle = null;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2],
                        n = arguments[3];
                    this.from = t, this.to = e, this.edgeDirection = n, this.p0 = t.getCoordinate(), this.p1 = i;
                    var r = this.p1.x - this.p0.x,
                        o = this.p1.y - this.p0.y;
                    this.quadrant = Je.quadrant(r, o), this.angle = Math.atan2(o, r)
                }

                function Sr() {
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2],
                        n = arguments[3];
                    Er.call(this, t, e, i, n)
                }

                function Nr() {
                    if (xr.apply(this), this.dirEdge = null, 0 === arguments.length);
                    else if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        this.setDirectedEdges(t, e)
                    }
                }

                function Lr() { this.outEdges = new x, this.sorted = !1 }

                function Cr() {
                    if (xr.apply(this), this.pt = null, this.deStar = null, 1 === arguments.length) {
                        var t = arguments[0];
                        Cr.call(this, t, new Lr)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.pt = e, this.deStar = i
                    }
                }

                function Mr() {
                    Nr.apply(this), this.line = null;
                    var t = arguments[0];
                    this.line = t
                }

                function Ir() { this.nodeMap = new rt }

                function kr() { this.edges = new J, this.dirEdges = new J, this.nodeMap = new Ir }

                function Tr() { kr.apply(this) }

                function Ar() { this.graph = new Tr, this.mergedLineStrings = null, this.factory = null, this.edgeStrings = null }

                function Rr() {
                    this.edgeRing = null, this.next = null, this.label = -1;
                    var t = arguments[0],
                        e = arguments[1],
                        i = arguments[2],
                        n = arguments[3];
                    Er.call(this, t, e, i, n)
                }

                function _r() {
                    Nr.apply(this), this.line = null;
                    var t = arguments[0];
                    this.line = t
                }

                function Pr() {
                    this.factory = null, this.deList = new x, this.lowestEdge = null, this.ring = null, this.ringPts = null, this.holes = null, this.shell = null, this._isHole = null, this._isProcessed = !1, this._isIncludedSet = !1, this._isIncluded = !1;
                    var t = arguments[0];
                    this.factory = t
                }

                function Or() {}

                function Dr() {
                    kr.apply(this), this.factory = null;
                    var t = arguments[0];
                    this.factory = t
                }

                function Fr() {
                    if (this.lineStringAdder = new Ur(this), this.graph = null, this.dangles = new x, this.cutEdges = new x, this.invalidRingLines = new x, this.holeList = null, this.shellList = null, this.polyList = null, this.isCheckingRingsValid = !0, this.extractOnlyPolygonal = null, this.geomFactory = null, 0 === arguments.length) Fr.call(this, !1);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.extractOnlyPolygonal = t
                    }
                }

                function Ur() {
                    this.p = null;
                    var t = arguments[0];
                    this.p = t
                }

                function Br() {}

                function jr() {
                    if (this.edgeEnds = new x, 1 === arguments.length) {
                        var t = arguments[0];
                        jr.call(this, null, t)
                    } else if (2 === arguments.length) {
                        var e = (arguments[0], arguments[1]);
                        bi.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new ci(e.getLabel())), this.insert(e)
                    }
                }

                function zr() { Ii.apply(this) }

                function Gr() {
                    var t = arguments[0],
                        e = arguments[1];
                    mi.call(this, t, e)
                }

                function qr() { xi.apply(this) }

                function Vr() {
                    this.li = new ae, this.ptLocator = new Ie, this.arg = null, this.nodes = new vi(new qr), this.im = null, this.isolatedEdges = new x, this.invalidPoint = null;
                    var t = arguments[0];
                    this.arg = t
                }

                function Wr() {
                    this.rectEnv = null;
                    var t = arguments[0];
                    this.rectEnv = t.getEnvelopeInternal()
                }

                function Xr() {
                    this.li = new ae, this.rectEnv = null, this.diagUp0 = null, this.diagUp1 = null, this.diagDown0 = null, this.diagDown1 = null;
                    var t = arguments[0];
                    this.rectEnv = t, this.diagUp0 = new f(t.getMinX(), t.getMinY()), this.diagUp1 = new f(t.getMaxX(), t.getMaxY()), this.diagDown0 = new f(t.getMinX(), t.getMaxY()), this.diagDown1 = new f(t.getMaxX(), t.getMinY())
                }

                function Hr() { this._isDone = !1 }

                function Yr() {
                    this.rectangle = null, this.rectEnv = null;
                    var t = arguments[0];
                    this.rectangle = t, this.rectEnv = t.getEnvelopeInternal()
                }

                function Kr() {
                    Hr.apply(this), this.rectEnv = null, this._intersects = !1;
                    var t = arguments[0];
                    this.rectEnv = t
                }

                function $r() {
                    Hr.apply(this), this.rectSeq = null, this.rectEnv = null, this._containsPoint = !1;
                    var t = arguments[0];
                    this.rectSeq = t.getExteriorRing().getCoordinateSequence(), this.rectEnv = t.getEnvelopeInternal()
                }

                function Zr() {
                    Hr.apply(this), this.rectEnv = null, this.rectIntersector = null, this.hasIntersection = !1, this.p0 = new f, this.p1 = new f;
                    var t = arguments[0];
                    this.rectEnv = t.getEnvelopeInternal(), this.rectIntersector = new Xr(this.rectEnv)
                }

                function Jr() {
                    if (this._relate = null, 2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        Qi.call(this, t, e), this._relate = new Vr(this.arg)
                    } else if (3 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            r = arguments[2];
                        Qi.call(this, i, n, r), this._relate = new Vr(this.arg)
                    }
                }

                function Qr() {
                    this.geomFactory = null, this.skipEmpty = !1, this.inputGeoms = null;
                    var t = arguments[0];
                    this.geomFactory = Qr.extractFactory(t), this.inputGeoms = t
                }

                function to() {
                    this.pointGeom = null, this.otherGeom = null, this.geomFact = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.pointGeom = t, this.otherGeom = e, this.geomFact = e.getFactory()
                }

                function eo() {
                    this.sortIndex = -1, this.comps = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.sortIndex = t, this.comps = e
                }

                function io() {
                    this.inputPolys = null, this.geomFactory = null;
                    var t = arguments[0];
                    this.inputPolys = t, null === this.inputPolys && (this.inputPolys = new x)
                }

                function no() {
                    if (this.polygons = new x, this.lines = new x, this.points = new x, this.geomFact = null, 1 === arguments.length) {
                        if (M(arguments[0], y)) {
                            var t = arguments[0];
                            this.extract(t)
                        } else if (arguments[0] instanceof B) {
                            var e = arguments[0];
                            this.extract(e)
                        }
                    } else if (2 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1];
                        this.geomFact = n, this.extract(i)
                    }
                }

                function ro() {
                    this.geometryFactory = new ne, this.geomGraph = null, this.disconnectedRingcoord = null;
                    var t = arguments[0];
                    this.geomGraph = t
                }

                function oo() { this.nodes = new vi(new qr) }

                function so() {
                    this.li = new ae, this.geomGraph = null, this.nodeGraph = new oo, this.invalidPoint = null;
                    var t = arguments[0];
                    this.geomGraph = t
                }

                function ao() {
                    this.graph = null, this.rings = new x, this.totalEnv = new S, this.index = null, this.nestedPt = null;
                    var t = arguments[0];
                    this.graph = t
                }

                function ho() {
                    if (this.errorType = null, this.pt = null, 1 === arguments.length) {
                        var t = arguments[0];
                        ho.call(this, t, null)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.errorType = e, null !== i && (this.pt = i.copy())
                    }
                }

                function lo() {
                    this.parentGeometry = null, this.isSelfTouchingRingFormingHoleValid = !1, this.validErr = null;
                    var t = arguments[0];
                    this.parentGeometry = t
                }

                function uo() {
                    Rt.CoordinateOperation.apply(this), this.targetPM = null, this.removeCollapsed = !0;
                    var t = arguments[0],
                        e = arguments[1];
                    this.targetPM = t, this.removeCollapsed = e
                }

                function po() {
                    this.targetPM = null, this.removeCollapsed = !0, this.changePrecisionModel = !1, this.isPointwise = !1;
                    var t = arguments[0];
                    this.targetPM = t
                }

                function co() {
                    this.pts = null, this.usePt = null, this.distanceTolerance = null, this.seg = new pe;
                    var t = arguments[0];
                    this.pts = t
                }

                function fo() {
                    this.inputGeom = null, this.distanceTolerance = null, this.isEnsureValidTopology = !0;
                    var t = arguments[0];
                    this.inputGeom = t
                }

                function go() {
                    be.apply(this), this.isEnsureValidTopology = !0, this.distanceTolerance = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.isEnsureValidTopology = t, this.distanceTolerance = e
                }

                function yo() {
                    if (this.parent = null, this.index = null, 2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        yo.call(this, t, e, null, -1)
                    } else if (4 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            r = arguments[2],
                            o = arguments[3];
                        pe.call(this, i, n), this.parent = r, this.index = o
                    }
                }

                function mo() {
                    if (this.parentLine = null, this.segs = null, this.resultSegs = new x, this.minimumSize = null, 1 === arguments.length) {
                        var t = arguments[0];
                        mo.call(this, t, 2)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.parentLine = e, this.minimumSize = i, this.init()
                    }
                }

                function vo() { this.index = new Bn }

                function bo() {
                    this.querySeg = null, this.items = new x;
                    var t = arguments[0];
                    this.querySeg = t
                }

                function wo() {
                    this.li = new ae, this.inputIndex = new vo, this.outputIndex = new vo, this.line = null, this.linePts = null, this.distanceTolerance = 0;
                    var t = arguments[0],
                        e = arguments[1];
                    this.inputIndex = t, this.outputIndex = e
                }

                function xo() { this.inputIndex = new vo, this.outputIndex = new vo, this.distanceTolerance = 0 }

                function Eo() {
                    this.inputGeom = null, this.lineSimplifier = new xo, this.linestringMap = null;
                    var t = arguments[0];
                    this.inputGeom = t
                }

                function So() {
                    be.apply(this), this.linestringMap = null;
                    var t = arguments[0];
                    this.linestringMap = t
                }

                function No() {
                    this.tps = null;
                    var t = arguments[0];
                    this.tps = t
                }

                function Lo() {
                    this.seg = null, this.segLen = null, this.splitPt = null, this.minimumLen = 0;
                    var t = arguments[0];
                    this.seg = t, this.segLen = t.getLength()
                }

                function Co() {}

                function Mo() {}

                function Io() {}

                function ko() {
                    if (this.p = null, 1 === arguments.length) {
                        var t = arguments[0];
                        this.p = new f(t)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        this.p = new f(e, i)
                    } else if (3 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1],
                            o = arguments[2];
                        this.p = new f(n, r, o)
                    }
                }

                function To() {
                    this._isOnConstraint = null, this.constraint = null;
                    var t = arguments[0];
                    ko.call(this, t)
                }

                function Ao() { this._rot = null, this.vertex = null, this.next = null, this.data = null }

                function Ro() {
                    this.subdiv = null, this.isUsingTolerance = !1;
                    var t = arguments[0];
                    this.subdiv = t, this.isUsingTolerance = t.getTolerance() > 0
                }

                function _o() {}

                function Po() {
                    this.subdiv = null, this.lastEdge = null;
                    var t = arguments[0];
                    this.subdiv = t, this.init()
                }

                function Oo() {
                    if (this.seg = null, 1 === arguments.length) {
                        if ("string" == typeof arguments[0]) {
                            var t = arguments[0];
                            l.call(this, t)
                        } else if (arguments[0] instanceof pe) {
                            var e = arguments[0];
                            l.call(this, "Locate failed to converge (at edge: " + e + ").  Possible causes include invalid Subdivision topology or very close sites"), this.seg = new pe(e)
                        }
                    } else if (2 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1];
                        l.call(this, Oo.msgWithSpatial(i, n)), this.seg = new pe(n)
                    }
                }

                function Do() {}

                function Fo() {
                    this.visitedKey = 0, this.quadEdges = new x, this.startingEdge = null, this.tolerance = null, this.edgeCoincidenceTolerance = null, this.frameVertex = new Array(3).fill(null), this.frameEnv = null, this.locator = null, this.seg = new pe, this.triEdges = new Array(3).fill(null);
                    var t = arguments[0],
                        e = arguments[1];
                    this.tolerance = e, this.edgeCoincidenceTolerance = e / Fo.EDGE_COINCIDENCE_TOL_FACTOR, this.createFrame(t), this.startingEdge = this.initSubdiv(), this.locator = new Po(this)
                }

                function Uo() {}

                function Bo() { this.triList = new x }

                function jo() { this.triList = new x }

                function zo() { this.coordList = new E, this.triCoords = new x }

                function Go() {
                    if (this.ls = null, this.data = null, 2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        this.ls = new pe(t, e)
                    } else if (3 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            r = arguments[2];
                        this.ls = new pe(i, n), this.data = r
                    } else if (6 === arguments.length) {
                        var o = arguments[0],
                            s = arguments[1],
                            a = arguments[2],
                            h = arguments[3],
                            l = arguments[4],
                            u = arguments[5];
                        Go.call(this, new f(o, s, a), new f(h, l, u))
                    } else if (7 === arguments.length) {
                        var p = arguments[0],
                            c = arguments[1],
                            g = arguments[2],
                            d = arguments[3],
                            y = arguments[4],
                            m = arguments[5],
                            v = arguments[6];
                        Go.call(this, new f(p, c, g), new f(d, y, m), v)
                    }
                }

                function qo() {}

                function Vo() {
                    if (this.p = null, this.data = null, this.left = null, this.right = null, this.count = null, 2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        this.p = new f(t), this.left = null, this.right = null, this.count = 1, this.data = e
                    } else if (3 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            r = arguments[2];
                        this.p = new f(i, n), this.left = null, this.right = null, this.count = 1, this.data = r
                    }
                }

                function Wo() {
                    if (this.root = null, this.numberOfNodes = null, this.tolerance = null, 0 === arguments.length) Wo.call(this, 0);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.tolerance = t
                    }
                }

                function Xo() {
                    this.tolerance = null, this.matchNode = null, this.matchDist = 0, this.p = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.p = t, this.tolerance = e
                }

                function Ho() {
                    this.initialVertices = null, this.segVertices = null, this.segments = new x, this.subdiv = null, this.incDel = null, this.convexHull = null, this.splitFinder = new Mo, this.kdt = null, this.vertexFactory = null, this.computeAreaEnv = null, this.splitPt = null, this.tolerance = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.initialVertices = new x(t), this.tolerance = e, this.kdt = new Wo(e)
                }

                function Yo() { this.siteCoords = null, this.tolerance = 0, this.subdiv = null }

                function Ko() { this.siteCoords = null, this.constraintLines = null, this.tolerance = 0, this.subdiv = null, this.constraintVertexMap = new rt }

                function $o() { this.siteCoords = null, this.tolerance = 0, this.subdiv = null, this.clipEnv = null, this.diagramEnv = null }

                function Zo() {}
                Array.prototype.fill || (Array.prototype.fill = function(t) { for (var e = Object(this), i = parseInt(e.length, 10), n = arguments[1], r = parseInt(n, 10) || 0, o = 0 > r ? Math.max(i + r, 0) : Math.min(r, i), s = arguments[2], a = void 0 === s ? i : parseInt(s, 10) || 0, h = 0 > a ? Math.max(i + a, 0) : Math.min(a, i); h > o; o++) e[o] = t; return e }), Number.isFinite = Number.isFinite || function(t) { return "number" == typeof t && isFinite(t) }, Number.isInteger = Number.isInteger || function(t) { return "number" == typeof t && isFinite(t) && Math.floor(t) === t }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function(t) { return t !== t }, Math.trunc = Math.trunc || function(t) { return 0 > t ? Math.ceil(t) : Math.floor(t) }, e(i.prototype, { interfaces_: function() { return [] }, getClass: function() { return i } }), i.equalsWithTolerance = function(t, e, i) { return Math.abs(t - e) <= i }, r.isNaN = function(t) { return Number.isNaN(t) }, r.doubleToLongBits = function(t) { return t }, r.longBitsToDouble = function(t) { return t }, r.isInfinite = function(t) { return !Number.isFinite(t) }, r.MAX_VALUE = Number.MAX_VALUE, l.prototype = Object.create(Error.prototype), l.prototype.constructor = Error, u(p, l), e(p.prototype, { interfaces_: function() { return [] }, getClass: function() { return p } }), e(c.prototype, { interfaces_: function() { return [] }, getClass: function() { return c } }), c.shouldNeverReachHere = function() {
                    if (0 === arguments.length) c.shouldNeverReachHere(null);
                    else if (1 === arguments.length) { var t = arguments[0]; throw new p("Should never reach here" + (null !== t ? ": " + t : "")) }
                }, c.isTrue = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        c.isTrue(t, null)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        if (!e) throw null === i ? new p : new p(i)
                    }
                }, c.equals = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        c.equals(t, e, null)
                    } else if (3 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            r = arguments[2];
                        if (!n.equals(i)) throw new p("Expected " + i + " but encountered " + n + (null !== r ? ": " + r : ""))
                    }
                }, e(f.prototype, {
                    setOrdinate: function(t, e) {
                        switch (t) {
                            case f.X:
                                this.x = e;
                                break;
                            case f.Y:
                                this.y = e;
                                break;
                            case f.Z:
                                this.z = e;
                                break;
                            default:
                                throw new n("Invalid ordinate index: " + t)
                        }
                    },
                    equals2D: function() {
                        if (1 === arguments.length) { var t = arguments[0]; return this.x === t.x && this.y === t.y }
                        if (2 === arguments.length) {
                            var e = arguments[0],
                                n = arguments[1];
                            return !!i.equalsWithTolerance(this.x, e.x, n) && !!i.equalsWithTolerance(this.y, e.y, n)
                        }
                    },
                    getOrdinate: function(t) {
                        switch (t) {
                            case f.X:
                                return this.x;
                            case f.Y:
                                return this.y;
                            case f.Z:
                                return this.z
                        }
                        throw new n("Invalid ordinate index: " + t)
                    },
                    equals3D: function(t) { return this.x === t.x && this.y === t.y && (this.z === t.z || r.isNaN(this.z) && r.isNaN(t.z)) },
                    equals: function(t) { return t instanceof f && this.equals2D(t) },
                    equalInZ: function(t, e) { return i.equalsWithTolerance(this.z, t.z, e) },
                    compareTo: function(t) { var e = t; return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0 },
                    clone: function() { try { var t = null; return t } catch (t) { if (t instanceof CloneNotSupportedException) return c.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null; throw t } finally {} },
                    copy: function() { return new f(this) },
                    toString: function() { return "(" + this.x + ", " + this.y + ", " + this.z + ")" },
                    distance3D: function(t) {
                        var e = this.x - t.x,
                            i = this.y - t.y,
                            n = this.z - t.z;
                        return Math.sqrt(e * e + i * i + n * n)
                    },
                    distance: function(t) {
                        var e = this.x - t.x,
                            i = this.y - t.y;
                        return Math.sqrt(e * e + i * i)
                    },
                    hashCode: function() { var t = 17; return t = 37 * t + f.hashCode(this.x), t = 37 * t + f.hashCode(this.y) },
                    setCoordinate: function(t) { this.x = t.x, this.y = t.y, this.z = t.z },
                    interfaces_: function() { return [o, s, h] },
                    getClass: function() { return f }
                }), f.hashCode = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = r.doubleToLongBits(t);
                        return Math.trunc(e ^ e >>> 32)
                    }
                }, e(g.prototype, {
                    compare: function(t, e) {
                        var i = t,
                            n = e,
                            r = g.compare(i.x, n.x);
                        if (0 !== r) return r;
                        var o = g.compare(i.y, n.y);
                        if (0 !== o) return o;
                        if (this.dimensionsToTest <= 2) return 0;
                        var s = g.compare(i.z, n.z);
                        return s
                    },
                    interfaces_: function() { return [a] },
                    getClass: function() { return g }
                }), g.compare = function(t, e) { return e > t ? -1 : t > e ? 1 : r.isNaN(t) ? r.isNaN(e) ? 0 : -1 : r.isNaN(e) ? 1 : 0 }, f.DimensionalComparator = g, f.serialVersionUID = 0x5cbf2c235c7e5800, f.NULL_ORDINATE = r.NaN, f.X = 0, f.Y = 1, f.Z = 2, d.prototype.hasNext = function() {}, d.prototype.next = function() {}, d.prototype.remove = function() {}, y.prototype.add = function() {}, y.prototype.addAll = function() {}, y.prototype.isEmpty = function() {}, y.prototype.iterator = function() {}, y.prototype.size = function() {}, y.prototype.toArray = function() {}, y.prototype.remove = function() {}, m.prototype = new Error, m.prototype.name = "IndexOutOfBoundsException", v.prototype = Object.create(y.prototype), v.prototype.constructor = v, v.prototype.get = function() {}, v.prototype.set = function() {}, v.prototype.isEmpty = function() {}, b.prototype = new Error, b.prototype.name = "NoSuchElementException", w.prototype = new Error, w.prototype.name = "OperationNotSupported", x.prototype = Object.create(v.prototype), x.prototype.constructor = x, x.prototype.ensureCapacity = function() {}, x.prototype.interfaces_ = function() { return [v, y] }, x.prototype.add = function(t) { return 1 === arguments.length ? this.array_.push(t) : this.array_.splice(arguments[0], arguments[1]), !0 }, x.prototype.clear = function() { this.array_ = [] }, x.prototype.addAll = function(t) { for (var e = t.iterator(); e.hasNext();) this.add(e.next()); return !0 }, x.prototype.set = function(t, e) { var i = this.array_[t]; return this.array_[t] = e, i }, x.prototype.iterator = function() { return new Jo(this) }, x.prototype.get = function(t) { if (0 > t || t >= this.size()) throw new m; return this.array_[t] }, x.prototype.isEmpty = function() { return 0 === this.array_.length }, x.prototype.size = function() { return this.array_.length }, x.prototype.toArray = function() { for (var t = [], e = 0, i = this.array_.length; i > e; e++) t.push(this.array_[e]); return t }, x.prototype.remove = function(t) {
                    for (var e = !1, i = 0, n = this.array_.length; n > i; i++)
                        if (this.array_[i] === t) { this.array_.splice(i, 1), e = !0; break }
                    return e
                };
                var Jo = function(t) { this.arrayList_ = t, this.position_ = 0 };
                Jo.prototype.next = function() { if (this.position_ === this.arrayList_.size()) throw new b; return this.arrayList_.get(this.position_++) }, Jo.prototype.hasNext = function() { return this.position_ < this.arrayList_.size() }, Jo.prototype.set = function(t) { return this.arrayList_.set(this.position_ - 1, t) }, Jo.prototype.remove = function() { throw new w }, u(E, x), e(E.prototype, {
                    getCoordinate: function(t) { return this.get(t) },
                    addAll: function() { if (2 === arguments.length) { for (var t = arguments[0], e = arguments[1], i = !1, n = t.iterator(); n.hasNext();) this.add(n.next(), e), i = !0; return i } return x.prototype.addAll.apply(this, arguments) },
                    clone: function t() { for (var t = x.prototype.clone.call(this), e = 0; e < this.size(); e++) t.add(e, this.get(e).copy()); return t },
                    toCoordinateArray: function() { return this.toArray(E.coordArrayType) },
                    add: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            x.prototype.add.call(this, t)
                        } else if (2 === arguments.length) {
                            if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                                var e = arguments[0],
                                    i = arguments[1];
                                return this.add(e, i, !0), !0
                            }
                            if (arguments[0] instanceof f && "boolean" == typeof arguments[1]) {
                                var n = arguments[0],
                                    r = arguments[1];
                                if (!r && this.size() >= 1) { var o = this.get(this.size() - 1); if (o.equals2D(n)) return null }
                                x.prototype.add.call(this, n)
                            } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
                                var s = arguments[0],
                                    a = arguments[1];
                                return this.add(s, a), !0
                            }
                        } else if (3 === arguments.length) {
                            if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                                var h = arguments[0],
                                    l = arguments[1],
                                    u = arguments[2];
                                if (u)
                                    for (var p = 0; p < h.length; p++) this.add(h[p], l);
                                else
                                    for (var p = h.length - 1; p >= 0; p--) this.add(h[p], l);
                                return !0
                            }
                            if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof f) {
                                var c = arguments[0],
                                    g = arguments[1],
                                    d = arguments[2];
                                if (!d) { var y = this.size(); if (y > 0) { if (c > 0) { var m = this.get(c - 1); if (m.equals2D(g)) return null } if (y > c) { var v = this.get(c); if (v.equals2D(g)) return null } } }
                                x.prototype.add.call(this, c, g)
                            }
                        } else if (4 === arguments.length) {
                            var b = arguments[0],
                                w = arguments[1],
                                E = arguments[2],
                                S = arguments[3],
                                N = 1;
                            E > S && (N = -1);
                            for (var p = E; p !== S; p += N) this.add(b[p], w);
                            return !0
                        }
                    },
                    closeRing: function() { this.size() > 0 && this.add(new f(this.get(0)), !1) },
                    interfaces_: function() { return [] },
                    getClass: function() { return E }
                }), E.coordArrayType = new Array(0).fill(null), e(S.prototype, {
                    getArea: function() { return this.getWidth() * this.getHeight() },
                    equals: function(t) { if (!(t instanceof S)) return !1; var e = t; return this.isNull() ? e.isNull() : this.maxx === e.getMaxX() && this.maxy === e.getMaxY() && this.minx === e.getMinX() && this.miny === e.getMinY() },
                    intersection: function(t) {
                        if (this.isNull() || t.isNull() || !this.intersects(t)) return new S;
                        var e = this.minx > t.minx ? this.minx : t.minx,
                            i = this.miny > t.miny ? this.miny : t.miny,
                            n = this.maxx < t.maxx ? this.maxx : t.maxx,
                            r = this.maxy < t.maxy ? this.maxy : t.maxy;
                        return new S(e, n, i, r)
                    },
                    isNull: function() { return this.maxx < this.minx },
                    getMaxX: function() { return this.maxx },
                    covers: function() {
                        if (1 === arguments.length) { if (arguments[0] instanceof f) { var t = arguments[0]; return this.covers(t.x, t.y) } if (arguments[0] instanceof S) { var e = arguments[0]; return !this.isNull() && !e.isNull() && (e.getMinX() >= this.minx && e.getMaxX() <= this.maxx && e.getMinY() >= this.miny && e.getMaxY() <= this.maxy) } } else if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1];
                            return !this.isNull() && (i >= this.minx && i <= this.maxx && n >= this.miny && n <= this.maxy)
                        }
                    },
                    intersects: function() {
                        if (1 === arguments.length) { if (arguments[0] instanceof S) { var t = arguments[0]; return !this.isNull() && !t.isNull() && !(t.minx > this.maxx || t.maxx < this.minx || t.miny > this.maxy || t.maxy < this.miny) } if (arguments[0] instanceof f) { var e = arguments[0]; return this.intersects(e.x, e.y) } } else if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1];
                            return !this.isNull() && !(i > this.maxx || i < this.minx || n > this.maxy || n < this.miny)
                        }
                    },
                    getMinY: function() { return this.miny },
                    getMinX: function() { return this.minx },
                    expandToInclude: function() {
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof f) {
                                var t = arguments[0];
                                this.expandToInclude(t.x, t.y)
                            } else if (arguments[0] instanceof S) {
                                var e = arguments[0];
                                if (e.isNull()) return null;
                                this.isNull() ? (this.minx = e.getMinX(), this.maxx = e.getMaxX(), this.miny = e.getMinY(), this.maxy = e.getMaxY()) : (e.minx < this.minx && (this.minx = e.minx), e.maxx > this.maxx && (this.maxx = e.maxx), e.miny < this.miny && (this.miny = e.miny), e.maxy > this.maxy && (this.maxy = e.maxy))
                            }
                        } else if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1];
                            this.isNull() ? (this.minx = i, this.maxx = i, this.miny = n, this.maxy = n) : (i < this.minx && (this.minx = i), i > this.maxx && (this.maxx = i), n < this.miny && (this.miny = n), n > this.maxy && (this.maxy = n))
                        }
                    },
                    minExtent: function() {
                        if (this.isNull()) return 0;
                        var t = this.getWidth(),
                            e = this.getHeight();
                        return e > t ? t : e
                    },
                    getWidth: function() { return this.isNull() ? 0 : this.maxx - this.minx },
                    compareTo: function(t) { var e = t; return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this.minx < e.minx ? -1 : this.minx > e.minx ? 1 : this.miny < e.miny ? -1 : this.miny > e.miny ? 1 : this.maxx < e.maxx ? -1 : this.maxx > e.maxx ? 1 : this.maxy < e.maxy ? -1 : this.maxy > e.maxy ? 1 : 0 },
                    translate: function(t, e) { return this.isNull() ? null : void this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e) },
                    toString: function() { return "Env[" + this.minx + " : " + this.maxx + ", " + this.miny + " : " + this.maxy + "]" },
                    setToNull: function() { this.minx = 0, this.maxx = -1, this.miny = 0, this.maxy = -1 },
                    getHeight: function() { return this.isNull() ? 0 : this.maxy - this.miny },
                    maxExtent: function() {
                        if (this.isNull()) return 0;
                        var t = this.getWidth(),
                            e = this.getHeight();
                        return t > e ? t : e
                    },
                    expandBy: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.expandBy(t, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1];
                            if (this.isNull()) return null;
                            this.minx -= e, this.maxx += e, this.miny -= i, this.maxy += i, (this.minx > this.maxx || this.miny > this.maxy) && this.setToNull()
                        }
                    },
                    contains: function() {
                        if (1 === arguments.length) { if (arguments[0] instanceof S) { var t = arguments[0]; return this.covers(t) } if (arguments[0] instanceof f) { var e = arguments[0]; return this.covers(e) } } else if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1];
                            return this.covers(i, n)
                        }
                    },
                    centre: function() { return this.isNull() ? null : new f((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2) },
                    init: function() {
                        if (0 === arguments.length) this.setToNull();
                        else if (1 === arguments.length) {
                            if (arguments[0] instanceof f) {
                                var t = arguments[0];
                                this.init(t.x, t.x, t.y, t.y)
                            } else if (arguments[0] instanceof S) {
                                var e = arguments[0];
                                this.minx = e.minx, this.maxx = e.maxx, this.miny = e.miny, this.maxy = e.maxy
                            }
                        } else if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1];
                            this.init(i.x, n.x, i.y, n.y)
                        } else if (4 === arguments.length) {
                            var r = arguments[0],
                                o = arguments[1],
                                s = arguments[2],
                                a = arguments[3];
                            o > r ? (this.minx = r, this.maxx = o) : (this.minx = o, this.maxx = r), a > s ? (this.miny = s, this.maxy = a) : (this.miny = a, this.maxy = s)
                        }
                    },
                    getMaxY: function() { return this.maxy },
                    distance: function(t) {
                        if (this.intersects(t)) return 0;
                        var e = 0;
                        this.maxx < t.minx ? e = t.minx - this.maxx : this.minx > t.maxx && (e = this.minx - t.maxx);
                        var i = 0;
                        return this.maxy < t.miny ? i = t.miny - this.maxy : this.miny > t.maxy && (i = this.miny - t.maxy), 0 === e ? i : 0 === i ? e : Math.sqrt(e * e + i * i)
                    },
                    hashCode: function() { var t = 17; return t = 37 * t + f.hashCode(this.minx), t = 37 * t + f.hashCode(this.maxx), t = 37 * t + f.hashCode(this.miny), t = 37 * t + f.hashCode(this.maxy) },
                    interfaces_: function() { return [o, h] },
                    getClass: function() { return S }
                }), S.intersects = function() {
                    if (3 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            i = arguments[2];
                        return i.x >= (t.x < e.x ? t.x : e.x) && i.x <= (t.x > e.x ? t.x : e.x) && i.y >= (t.y < e.y ? t.y : e.y) && i.y <= (t.y > e.y ? t.y : e.y)
                    }
                    if (4 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1],
                            o = arguments[2],
                            s = arguments[3],
                            a = Math.min(o.x, s.x),
                            h = Math.max(o.x, s.x),
                            l = Math.min(n.x, r.x),
                            u = Math.max(n.x, r.x);
                        return !(l > h) && (!(a > u) && (a = Math.min(o.y, s.y), h = Math.max(o.y, s.y), l = Math.min(n.y, r.y), u = Math.max(n.y, r.y), !(l > h) && !(a > u)))
                    }
                }, S.serialVersionUID = 0x51845cd552189800, u(L, N), e(L.prototype, { interfaces_: function() { return [] }, getClass: function() { return L } }), e(C.prototype, { interfaces_: function() { return [] }, getClass: function() { return C } }), C.toLocationSymbol = function(t) {
                    switch (t) {
                        case C.EXTERIOR:
                            return "e";
                        case C.BOUNDARY:
                            return "b";
                        case C.INTERIOR:
                            return "i";
                        case C.NONE:
                            return "-"
                    }
                    throw new n("Unknown location value: " + t)
                }, C.INTERIOR = 0, C.BOUNDARY = 1, C.EXTERIOR = 2, C.NONE = -1, e(I.prototype, { interfaces_: function() { return [] }, getClass: function() { return I } }), I.log10 = function(t) { var e = Math.log(t); return r.isInfinite(e) ? e : r.isNaN(e) ? e : e / I.LOG_10 }, I.min = function(t, e, i, n) { var r = t; return r > e && (r = e), r > i && (r = i), r > n && (r = n), r }, I.clamp = function() {
                    if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                        var t = arguments[0],
                            e = arguments[1],
                            i = arguments[2];
                        return e > t ? e : t > i ? i : t
                    }
                    if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                        var n = arguments[0],
                            r = arguments[1],
                            o = arguments[2];
                        return r > n ? r : n > o ? o : n
                    }
                }, I.wrap = function(t, e) { return 0 > t ? e - -t % e : t % e }, I.max = function() {
                    if (3 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            i = arguments[2],
                            n = t;
                        return e > n && (n = e), i > n && (n = i), n
                    }
                    if (4 === arguments.length) {
                        var r = arguments[0],
                            o = arguments[1],
                            s = arguments[2],
                            a = arguments[3],
                            n = r;
                        return o > n && (n = o), s > n && (n = s), a > n && (n = a), n
                    }
                }, I.average = function(t, e) { return (t + e) / 2 }, I.LOG_10 = Math.log(10), k.prototype.append = function(t) { this.str += t }, k.prototype.setCharAt = function(t, e) { return this.str.substr(0, t) + e + this.str.substr(t + 1) }, k.prototype.toString = function(t) { return this.str }, T.prototype.intValue = function() { return this.value }, T.prototype.compareTo = function(t) { return this.value < t ? -1 : this.value > t ? 1 : 0 }, T.isNaN = function(t) { return Number.isNaN(t) }, A.isWhitespace = function(t) { return 32 >= t && t >= 0 || 127 == t }, A.toUpperCase = function(t) { return t.toUpperCase() }, e(R.prototype, {
                    le: function(t) { return this.hi < t.hi || this.hi === t.hi && this.lo <= t.lo },
                    extractSignificantDigits: function(t, e) {
                        var i = this.abs(),
                            n = R.magnitude(i.hi),
                            r = R.TEN.pow(n);
                        i = i.divide(r), i.gt(R.TEN) ? (i = i.divide(R.TEN), n += 1) : i.lt(R.ONE) && (i = i.multiply(R.TEN), n -= 1);
                        for (var o = n + 1, s = new k, a = R.MAX_PRINT_DIGITS - 1, h = 0; a >= h; h++) {
                            t && h === o && s.append(".");
                            var l = Math.trunc(i.hi);
                            if (0 > l) break;
                            var u = !1,
                                p = 0;
                            l > 9 ? (u = !0, p = "9") : p = "0" + l, s.append(p), i = i.subtract(R.valueOf(l)).multiply(R.TEN), u && i.selfAdd(R.TEN);
                            var c = !0,
                                f = R.magnitude(i.hi);
                            if (0 > f && Math.abs(f) >= a - h && (c = !1), !c) break
                        }
                        return e[0] = n, s.toString()
                    },
                    sqr: function() { return this.multiply(this) },
                    doubleValue: function() { return this.hi + this.lo },
                    subtract: function() { if (arguments[0] instanceof R) { var t = arguments[0]; return this.add(t.negate()) } if ("number" == typeof arguments[0]) { var e = arguments[0]; return this.add(-e) } },
                    equals: function() { if (1 === arguments.length) { var t = arguments[0]; return this.hi === t.hi && this.lo === t.lo } },
                    isZero: function() { return 0 === this.hi && 0 === this.lo },
                    selfSubtract: function() { if (arguments[0] instanceof R) { var t = arguments[0]; return this.isNaN() ? this : this.selfAdd(-t.hi, -t.lo) } if ("number" == typeof arguments[0]) { var e = arguments[0]; return this.isNaN() ? this : this.selfAdd(-e, 0) } },
                    getSpecialNumberString: function() { return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null },
                    min: function(t) { return this.le(t) ? this : t },
                    selfDivide: function() {
                        if (1 === arguments.length) { if (arguments[0] instanceof R) { var t = arguments[0]; return this.selfDivide(t.hi, t.lo) } if ("number" == typeof arguments[0]) { var e = arguments[0]; return this.selfDivide(e, 0) } } else if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1],
                                r = null,
                                o = null,
                                s = null,
                                a = null,
                                h = null,
                                l = null,
                                u = null,
                                p = null;
                            return h = this.hi / i, l = R.SPLIT * h, r = l - h, p = R.SPLIT * i, r = l - r, o = h - r, s = p - i, u = h * i, s = p - s, a = i - s, p = r * s - u + r * a + o * s + o * a, l = (this.hi - u - p + this.lo - h * n) / i, p = h + l, this.hi = p, this.lo = h - p + l, this
                        }
                    },
                    dump: function() { return "DD<" + this.hi + ", " + this.lo + ">" },
                    divide: function() {
                        if (arguments[0] instanceof R) {
                            var t = arguments[0],
                                e = null,
                                i = null,
                                n = null,
                                o = null,
                                s = null,
                                a = null,
                                h = null,
                                l = null;
                            s = this.hi / t.hi, a = R.SPLIT * s, e = a - s, l = R.SPLIT * t.hi, e = a - e, i = s - e, n = l - t.hi, h = s * t.hi, n = l - n, o = t.hi - n, l = e * n - h + e * o + i * n + i * o, a = (this.hi - h - l + this.lo - s * t.lo) / t.hi, l = s + a;
                            var u = l,
                                p = s - l + a;
                            return new R(u, p)
                        }
                        if ("number" == typeof arguments[0]) { var c = arguments[0]; return r.isNaN(c) ? R.createNaN() : R.copy(this).selfDivide(c, 0) }
                    },
                    ge: function(t) { return this.hi > t.hi || this.hi === t.hi && this.lo >= t.lo },
                    pow: function(t) {
                        if (0 === t) return R.valueOf(1);
                        var e = new R(this),
                            i = R.valueOf(1),
                            n = Math.abs(t);
                        if (n > 1)
                            for (; n > 0;) n % 2 === 1 && i.selfMultiply(e), n /= 2, n > 0 && (e = e.sqr());
                        else i = e;
                        return 0 > t ? i.reciprocal() : i
                    },
                    ceil: function() {
                        if (this.isNaN()) return R.NaN;
                        var t = Math.ceil(this.hi),
                            e = 0;
                        return t === this.hi && (e = Math.ceil(this.lo)), new R(t, e)
                    },
                    compareTo: function(t) { var e = t; return this.hi < e.hi ? -1 : this.hi > e.hi ? 1 : this.lo < e.lo ? -1 : this.lo > e.lo ? 1 : 0 },
                    rint: function() { if (this.isNaN()) return this; var t = this.add(.5); return t.floor() },
                    setValue: function() { if (arguments[0] instanceof R) { var t = arguments[0]; return this.init(t), this } if ("number" == typeof arguments[0]) { var e = arguments[0]; return this.init(e), this } },
                    max: function(t) {
                        return this.ge(t) ? this : t;
                    },
                    sqrt: function() {
                        if (this.isZero()) return R.valueOf(0);
                        if (this.isNegative()) return R.NaN;
                        var t = 1 / Math.sqrt(this.hi),
                            e = this.hi * t,
                            i = R.valueOf(e),
                            n = this.subtract(i.sqr()),
                            r = n.hi * (.5 * t);
                        return i.add(r)
                    },
                    selfAdd: function() {
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof R) { var t = arguments[0]; return this.selfAdd(t.hi, t.lo) }
                            if ("number" == typeof arguments[0]) {
                                var e = arguments[0],
                                    i = null,
                                    n = null,
                                    r = null,
                                    o = null,
                                    s = null,
                                    a = null;
                                return r = this.hi + e, s = r - this.hi, o = r - s, o = e - s + (this.hi - o), a = o + this.lo, i = r + a, n = a + (r - i), this.hi = i + n, this.lo = n + (i - this.hi), this
                            }
                        } else if (2 === arguments.length) {
                            var h = arguments[0],
                                l = arguments[1],
                                i = null,
                                n = null,
                                u = null,
                                p = null,
                                r = null,
                                o = null,
                                s = null,
                                a = null;
                            r = this.hi + h, u = this.lo + l, s = r - this.hi, a = u - this.lo, o = r - s, p = u - a, o = h - s + (this.hi - o), p = l - a + (this.lo - p), s = o + u, i = r + s, n = s + (r - i), s = p + n;
                            var c = i + s,
                                f = s + (i - c);
                            return this.hi = c, this.lo = f, this
                        }
                    },
                    selfMultiply: function() {
                        if (1 === arguments.length) { if (arguments[0] instanceof R) { var t = arguments[0]; return this.selfMultiply(t.hi, t.lo) } if ("number" == typeof arguments[0]) { var e = arguments[0]; return this.selfMultiply(e, 0) } } else if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1],
                                r = null,
                                o = null,
                                s = null,
                                a = null,
                                h = null,
                                l = null;
                            h = R.SPLIT * this.hi, r = h - this.hi, l = R.SPLIT * i, r = h - r, o = this.hi - r, s = l - i, h = this.hi * i, s = l - s, a = i - s, l = r * s - h + r * a + o * s + o * a + (this.hi * n + this.lo * i);
                            var u = h + l;
                            r = h - u;
                            var p = l + r;
                            return this.hi = u, this.lo = p, this
                        }
                    },
                    selfSqr: function() { return this.selfMultiply(this) },
                    floor: function() {
                        if (this.isNaN()) return R.NaN;
                        var t = Math.floor(this.hi),
                            e = 0;
                        return t === this.hi && (e = Math.floor(this.lo)), new R(t, e)
                    },
                    negate: function() { return this.isNaN() ? this : new R(-this.hi, -this.lo) },
                    clone: function() { try { return null } catch (t) { if (t instanceof CloneNotSupportedException) return null; throw t } finally {} },
                    multiply: function() { if (arguments[0] instanceof R) { var t = arguments[0]; return t.isNaN() ? R.createNaN() : R.copy(this).selfMultiply(t) } if ("number" == typeof arguments[0]) { var e = arguments[0]; return r.isNaN(e) ? R.createNaN() : R.copy(this).selfMultiply(e, 0) } },
                    isNaN: function() { return r.isNaN(this.hi) },
                    intValue: function() { return Math.trunc(this.hi) },
                    toString: function() { var t = R.magnitude(this.hi); return t >= -3 && 20 >= t ? this.toStandardNotation() : this.toSciNotation() },
                    toStandardNotation: function() {
                        var t = this.getSpecialNumberString();
                        if (null !== t) return t;
                        var e = new Array(1).fill(null),
                            i = this.extractSignificantDigits(!0, e),
                            n = e[0] + 1,
                            r = i;
                        if ("." === i.charAt(0)) r = "0" + i;
                        else if (0 > n) r = "0." + R.stringOfChar("0", -n) + i;
                        else if (-1 === i.indexOf(".")) {
                            var o = n - i.length,
                                s = R.stringOfChar("0", o);
                            r = i + s + ".0"
                        }
                        return this.isNegative() ? "-" + r : r
                    },
                    reciprocal: function() {
                        var t = null,
                            e = null,
                            i = null,
                            n = null,
                            r = null,
                            o = null,
                            s = null,
                            a = null;
                        r = 1 / this.hi, o = R.SPLIT * r, t = o - r, a = R.SPLIT * this.hi, t = o - t, e = r - t, i = a - this.hi, s = r * this.hi, i = a - i, n = this.hi - i, a = t * i - s + t * n + e * i + e * n, o = (1 - s - a - r * this.lo) / this.hi;
                        var h = r + o,
                            l = r - h + o;
                        return new R(h, l)
                    },
                    toSciNotation: function() {
                        if (this.isZero()) return R.SCI_NOT_ZERO;
                        var t = this.getSpecialNumberString();
                        if (null !== t) return t;
                        var e = new Array(1).fill(null),
                            i = this.extractSignificantDigits(!1, e),
                            n = R.SCI_NOT_EXPONENT_CHAR + e[0];
                        if ("0" === i.charAt(0)) throw new IllegalStateException("Found leading zero: " + i);
                        var r = "";
                        i.length > 1 && (r = i.substring(1));
                        var o = i.charAt(0) + "." + r;
                        return this.isNegative() ? "-" + o + n : o + n
                    },
                    abs: function() { return this.isNaN() ? R.NaN : this.isNegative() ? this.negate() : new R(this) },
                    isPositive: function() { return this.hi > 0 || 0 === this.hi && this.lo > 0 },
                    lt: function(t) { return this.hi < t.hi || this.hi === t.hi && this.lo < t.lo },
                    add: function() { if (arguments[0] instanceof R) { var t = arguments[0]; return R.copy(this).selfAdd(t) } if ("number" == typeof arguments[0]) { var e = arguments[0]; return R.copy(this).selfAdd(e) } },
                    init: function() {
                        if (1 === arguments.length) {
                            if ("number" == typeof arguments[0]) {
                                var t = arguments[0];
                                this.hi = t, this.lo = 0
                            } else if (arguments[0] instanceof R) {
                                var e = arguments[0];
                                this.hi = e.hi, this.lo = e.lo
                            }
                        } else if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1];
                            this.hi = i, this.lo = n
                        }
                    },
                    gt: function(t) { return this.hi > t.hi || this.hi === t.hi && this.lo > t.lo },
                    isNegative: function() { return this.hi < 0 || 0 === this.hi && this.lo < 0 },
                    trunc: function() { return this.isNaN() ? R.NaN : this.isPositive() ? this.floor() : this.ceil() },
                    signum: function() { return this.hi > 0 ? 1 : this.hi < 0 ? -1 : this.lo > 0 ? 1 : this.lo < 0 ? -1 : 0 },
                    interfaces_: function() { return [h, o, s] },
                    getClass: function() { return R }
                }), R.sqr = function(t) { return R.valueOf(t).selfMultiply(t) }, R.valueOf = function() { if ("string" == typeof arguments[0]) { var t = arguments[0]; return R.parse(t) } if ("number" == typeof arguments[0]) { var e = arguments[0]; return new R(e) } }, R.sqrt = function(t) { return R.valueOf(t).sqrt() }, R.parse = function(t) {
                    for (var e = 0, i = t.length; A.isWhitespace(t.charAt(e));) e++;
                    var n = !1;
                    if (i > e) { var r = t.charAt(e); "-" !== r && "+" !== r || (e++, "-" === r && (n = !0)) }
                    for (var o = new R, s = 0, a = 0, h = 0; !(e >= i);) {
                        var l = t.charAt(e);
                        if (e++, A.isDigit(l)) {
                            var u = l - "0";
                            o.selfMultiply(R.TEN), o.selfAdd(u), s++
                        } else {
                            if ("." !== l) { if ("e" === l || "E" === l) { var p = t.substring(e); try { h = T.parseInt(p) } catch (e) { throw e instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + p + " in string " + t) : e } finally {} break } throw new NumberFormatException("Unexpected character '" + l + "' at position " + e + " in string " + t) }
                            a = s
                        }
                    }
                    var c = o,
                        f = s - a - h;
                    if (0 === f) c = o;
                    else if (f > 0) {
                        var g = R.TEN.pow(f);
                        c = o.divide(g)
                    } else if (0 > f) {
                        var g = R.TEN.pow(-f);
                        c = o.multiply(g)
                    }
                    return n ? c.negate() : c
                }, R.createNaN = function() { return new R(r.NaN, r.NaN) }, R.copy = function(t) { return new R(t) }, R.magnitude = function(t) {
                    var e = Math.abs(t),
                        i = Math.log(e) / Math.log(10),
                        n = Math.trunc(Math.floor(i)),
                        r = Math.pow(10, n);
                    return e >= 10 * r && (n += 1), n
                }, R.stringOfChar = function(t, e) { for (var i = new k, n = 0; e > n; n++) i.append(t); return i.toString() }, R.PI = new R(3.141592653589793, 1.2246467991473532e-16), R.TWO_PI = new R(6.283185307179586, 2.4492935982947064e-16), R.PI_2 = new R(1.5707963267948966, 6.123233995736766e-17), R.E = new R(2.718281828459045, 1.4456468917292502e-16), R.NaN = new R(r.NaN, r.NaN), R.EPS = 1.23259516440783e-32, R.SPLIT = 134217729, R.MAX_PRINT_DIGITS = 32, R.TEN = R.valueOf(10), R.ONE = R.valueOf(1), R.SCI_NOT_EXPONENT_CHAR = "E", R.SCI_NOT_ZERO = "0.0E0", e(_.prototype, { interfaces_: function() { return [] }, getClass: function() { return _ } }), _.orientationIndex = function(t, e, i) {
                    var n = _.orientationIndexFilter(t, e, i);
                    if (1 >= n) return n;
                    var r = R.valueOf(e.x).selfAdd(-t.x),
                        o = R.valueOf(e.y).selfAdd(-t.y),
                        s = R.valueOf(i.x).selfAdd(-e.x),
                        a = R.valueOf(i.y).selfAdd(-e.y);
                    return r.selfMultiply(a).selfSubtract(o.selfMultiply(s)).signum()
                }, _.signOfDet2x2 = function(t, e, i, n) { var r = t.multiply(n).selfSubtract(e.multiply(i)); return r.signum() }, _.intersection = function(t, e, i, n) {
                    var r = R.valueOf(n.y).selfSubtract(i.y).selfMultiply(R.valueOf(e.x).selfSubtract(t.x)),
                        o = R.valueOf(n.x).selfSubtract(i.x).selfMultiply(R.valueOf(e.y).selfSubtract(t.y)),
                        s = r.subtract(o),
                        a = R.valueOf(n.x).selfSubtract(i.x).selfMultiply(R.valueOf(t.y).selfSubtract(i.y)),
                        h = R.valueOf(n.y).selfSubtract(i.y).selfMultiply(R.valueOf(t.x).selfSubtract(i.x)),
                        l = a.subtract(h),
                        u = l.selfDivide(s).doubleValue(),
                        p = R.valueOf(t.x).selfAdd(R.valueOf(e.x).selfSubtract(t.x).selfMultiply(u)).doubleValue(),
                        c = R.valueOf(e.x).selfSubtract(t.x).selfMultiply(R.valueOf(t.y).selfSubtract(i.y)),
                        g = R.valueOf(e.y).selfSubtract(t.y).selfMultiply(R.valueOf(t.x).selfSubtract(i.x)),
                        d = c.subtract(g),
                        y = d.selfDivide(s).doubleValue(),
                        m = R.valueOf(i.y).selfAdd(R.valueOf(n.y).selfSubtract(i.y).selfMultiply(y)).doubleValue();
                    return new f(p, m)
                }, _.orientationIndexFilter = function(t, e, i) {
                    var n = null,
                        r = (t.x - i.x) * (e.y - i.y),
                        o = (t.y - i.y) * (e.x - i.x),
                        s = r - o;
                    if (r > 0) {
                        if (0 >= o) return _.signum(s);
                        n = r + o
                    } else {
                        if (!(0 > r)) return _.signum(s);
                        if (o >= 0) return _.signum(s);
                        n = -r - o
                    }
                    var a = _.DP_SAFE_EPSILON * n;
                    return s >= a || -s >= a ? _.signum(s) : 2
                }, _.signum = function(t) { return t > 0 ? 1 : 0 > t ? -1 : 0 }, _.DP_SAFE_EPSILON = 1e-15, e(P.prototype, { setOrdinate: function(t, e, i) {}, size: function() {}, getOrdinate: function(t, e) {}, getCoordinate: function() { 1 === arguments.length ? arguments[0] : 2 === arguments.length && (arguments[0], arguments[1]) }, getCoordinateCopy: function(t) {}, getDimension: function() {}, getX: function(t) {}, clone: function() {}, expandEnvelope: function(t) {}, copy: function() {}, getY: function(t) {}, toCoordinateArray: function() {}, interfaces_: function() { return [s] }, getClass: function() { return P } }), P.X = 0, P.Y = 1, P.Z = 2, P.M = 3, O.arraycopy = function(t, e, i, n, r) { for (var o = 0, s = e; e + r > s; s++) i[n + o] = t[s], o++ }, O.getProperty = function(t) { return { "line.separator": "\n" }[t] }, e(D.prototype, { getY: function() { var t = this.y / this.w; if (r.isNaN(t) || r.isInfinite(t)) throw new L; return t }, getX: function() { var t = this.x / this.w; if (r.isNaN(t) || r.isInfinite(t)) throw new L; return t }, getCoordinate: function() { var t = new f; return t.x = this.getX(), t.y = this.getY(), t }, interfaces_: function() { return [] }, getClass: function() { return D } }), D.intersection = function(t, e, i, n) {
                    var o = t.y - e.y,
                        s = e.x - t.x,
                        a = t.x * e.y - e.x * t.y,
                        h = i.y - n.y,
                        l = n.x - i.x,
                        u = i.x * n.y - n.x * i.y,
                        p = s * u - l * a,
                        c = h * a - o * u,
                        g = o * l - h * s,
                        d = p / g,
                        y = c / g;
                    if (r.isNaN(d) || r.isInfinite(d) || r.isNaN(y) || r.isInfinite(y)) throw new L;
                    return new f(d, y)
                }, e(F.prototype, { create: function() { 1 === arguments.length ? arguments[0] instanceof Array ? arguments[0] : M(arguments[0], P) && arguments[0] : 2 === arguments.length && (arguments[0], arguments[1]) }, interfaces_: function() { return [] }, getClass: function() { return F } }), e(U.prototype, { filter: function(t) {}, interfaces_: function() { return [] }, getClass: function() { return U } }), e(B.prototype, {
                    isGeometryCollection: function() { return this.getSortIndex() === B.SORTINDEX_GEOMETRYCOLLECTION },
                    getFactory: function() { return this.factory },
                    getGeometryN: function(t) { return this },
                    getArea: function() { return 0 },
                    isRectangle: function() { return !1 },
                    equals: function() { if (1 === arguments.length) { if (arguments[0] instanceof B) { var t = arguments[0]; return null !== t && this.equalsTopo(t) } if (arguments[0] instanceof Object) { var e = arguments[0]; if (!(e instanceof B)) return !1; var i = e; return this.equalsExact(i) } } },
                    equalsExact: function(t) { return this === t || this.equalsExact(t, 0) },
                    geometryChanged: function() { this.apply(B.geometryChangedFilter) },
                    geometryChangedAction: function() { this.envelope = null },
                    equalsNorm: function(t) { return null !== t && this.norm().equalsExact(t.norm()) },
                    getLength: function() { return 0 },
                    getNumGeometries: function() { return 1 },
                    compareTo: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0],
                                e = t;
                            return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t)
                        }
                        if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1],
                                e = i;
                            return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(i, n)
                        }
                    },
                    getUserData: function() { return this.userData },
                    getSRID: function() { return this.SRID },
                    getEnvelope: function() { return this.getFactory().toGeometry(this.getEnvelopeInternal()) },
                    checkNotGeometryCollection: function(t) { if (t.getSortIndex() === B.SORTINDEX_GEOMETRYCOLLECTION) throw new n("This method does not support GeometryCollection arguments") },
                    equal: function(t, e, i) { return 0 === i ? t.equals(e) : t.distance(e) <= i },
                    norm: function() { var t = this.copy(); return t.normalize(), t },
                    getPrecisionModel: function() { return this.factory.getPrecisionModel() },
                    getEnvelopeInternal: function() { return null === this.envelope && (this.envelope = this.computeEnvelopeInternal()), new S(this.envelope) },
                    setSRID: function(t) { this.SRID = t },
                    setUserData: function(t) { this.userData = t },
                    compare: function(t, e) {
                        for (var i = t.iterator(), n = e.iterator(); i.hasNext() && n.hasNext();) {
                            var r = i.next(),
                                o = n.next(),
                                s = r.compareTo(o);
                            if (0 !== s) return s
                        }
                        return i.hasNext() ? 1 : n.hasNext() ? -1 : 0
                    },
                    hashCode: function() { return this.getEnvelopeInternal().hashCode() },
                    isGeometryCollectionOrDerived: function() { return this.getSortIndex() === B.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === B.SORTINDEX_MULTIPOINT || this.getSortIndex() === B.SORTINDEX_MULTILINESTRING || this.getSortIndex() === B.SORTINDEX_MULTIPOLYGON },
                    interfaces_: function() { return [s, o, h] },
                    getClass: function() { return B }
                }), B.hasNonEmptyElements = function(t) {
                    for (var e = 0; e < t.length; e++)
                        if (!t[e].isEmpty()) return !0;
                    return !1
                }, B.hasNullElements = function(t) {
                    for (var e = 0; e < t.length; e++)
                        if (null === t[e]) return !0;
                    return !1
                }, B.serialVersionUID = 0x799ea46522854c00, B.SORTINDEX_POINT = 0, B.SORTINDEX_MULTIPOINT = 1, B.SORTINDEX_LINESTRING = 2, B.SORTINDEX_LINEARRING = 3, B.SORTINDEX_MULTILINESTRING = 4, B.SORTINDEX_POLYGON = 5, B.SORTINDEX_MULTIPOLYGON = 6, B.SORTINDEX_GEOMETRYCOLLECTION = 7, B.geometryChangedFilter = { interfaces_: function() { return [U] }, filter: function(t) { t.geometryChangedAction() } }, e(j.prototype, { filter: function(t) {}, interfaces_: function() { return [] }, getClass: function() { return j } }), e(z.prototype, { isInBoundary: function(t) {}, interfaces_: function() { return [] }, getClass: function() { return z } }), e(G.prototype, { isInBoundary: function(t) { return t % 2 === 1 }, interfaces_: function() { return [z] }, getClass: function() { return G } }), e(q.prototype, { isInBoundary: function(t) { return t > 0 }, interfaces_: function() { return [z] }, getClass: function() { return q } }), e(V.prototype, { isInBoundary: function(t) { return t > 1 }, interfaces_: function() { return [z] }, getClass: function() { return V } }), e(W.prototype, { isInBoundary: function(t) { return 1 === t }, interfaces_: function() { return [z] }, getClass: function() { return W } }), z.Mod2BoundaryNodeRule = G, z.EndPointBoundaryNodeRule = q, z.MultiValentEndPointBoundaryNodeRule = V, z.MonoValentEndPointBoundaryNodeRule = W, z.MOD2_BOUNDARY_RULE = new G, z.ENDPOINT_BOUNDARY_RULE = new q, z.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new V, z.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new W, z.OGC_SFS_BOUNDARY_RULE = z.MOD2_BOUNDARY_RULE, e(X.prototype, { interfaces_: function() { return [] }, getClass: function() { return X } }), X.isRing = function(t) { return !(t.length < 4) && !!t[0].equals2D(t[t.length - 1]) }, X.ptNotInList = function(t, e) { for (var i = 0; i < t.length; i++) { var n = t[i]; if (X.indexOf(n, e) < 0) return n } return null }, X.scroll = function(t, e) {
                    var i = X.indexOf(e, t);
                    if (0 > i) return null;
                    var n = new Array(t.length).fill(null);
                    O.arraycopy(t, i, n, 0, t.length - i), O.arraycopy(t, 0, n, t.length - i, i), O.arraycopy(n, 0, t, 0, t.length)
                }, X.equals = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        if (t === e) return !0;
                        if (null === t || null === e) return !1;
                        if (t.length !== e.length) return !1;
                        for (var i = 0; i < t.length; i++)
                            if (!t[i].equals(e[i])) return !1;
                        return !0
                    }
                    if (3 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1],
                            o = arguments[2];
                        if (n === r) return !0;
                        if (null === n || null === r) return !1;
                        if (n.length !== r.length) return !1;
                        for (var i = 0; i < n.length; i++)
                            if (0 !== o.compare(n[i], r[i])) return !1;
                        return !0
                    }
                }, X.intersection = function(t, e) { for (var i = new E, n = 0; n < t.length; n++) e.intersects(t[n]) && i.add(t[n], !0); return i.toCoordinateArray() }, X.hasRepeatedPoints = function(t) {
                    for (var e = 1; e < t.length; e++)
                        if (t[e - 1].equals(t[e])) return !0;
                    return !1
                }, X.removeRepeatedPoints = function(t) { if (!X.hasRepeatedPoints(t)) return t; var e = new E(t, !1); return e.toCoordinateArray() }, X.reverse = function(t) {
                    for (var e = t.length - 1, i = Math.trunc(e / 2), n = 0; i >= n; n++) {
                        var r = t[n];
                        t[n] = t[e - n], t[e - n] = r
                    }
                }, X.removeNull = function(t) { for (var e = 0, i = 0; i < t.length; i++) null !== t[i] && e++; var n = new Array(e).fill(null); if (0 === e) return n; for (var r = 0, i = 0; i < t.length; i++) null !== t[i] && (n[r++] = t[i]); return n }, X.copyDeep = function() {
                    if (1 === arguments.length) { for (var t = arguments[0], e = new Array(t.length).fill(null), i = 0; i < t.length; i++) e[i] = new f(t[i]); return e }
                    if (5 === arguments.length)
                        for (var n = arguments[0], r = arguments[1], o = arguments[2], s = arguments[3], a = arguments[4], i = 0; a > i; i++) o[s + i] = new f(n[r + i])
                }, X.isEqualReversed = function(t, e) {
                    for (var i = 0; i < t.length; i++) {
                        var n = t[i],
                            r = e[t.length - i - 1];
                        if (0 !== n.compareTo(r)) return !1
                    }
                    return !0
                }, X.envelope = function(t) { for (var e = new S, i = 0; i < t.length; i++) e.expandToInclude(t[i]); return e }, X.toCoordinateArray = function(t) { return t.toArray(X.coordArrayType) }, X.atLeastNCoordinatesOrNothing = function(t, e) { return e.length >= t ? e : [] }, X.indexOf = function(t, e) {
                    for (var i = 0; i < e.length; i++)
                        if (t.equals(e[i])) return i;
                    return -1
                }, X.increasingDirection = function(t) {
                    for (var e = 0; e < Math.trunc(t.length / 2); e++) {
                        var i = t.length - 1 - e,
                            n = t[e].compareTo(t[i]);
                        if (0 !== n) return n
                    }
                    return 1
                }, X.compare = function(t, e) {
                    for (var i = 0; i < t.length && i < e.length;) {
                        var n = t[i].compareTo(e[i]);
                        if (0 !== n) return n;
                        i++
                    }
                    return i < e.length ? -1 : i < t.length ? 1 : 0
                }, X.minCoordinate = function(t) { for (var e = null, i = 0; i < t.length; i++)(null === e || e.compareTo(t[i]) > 0) && (e = t[i]); return e }, X.extract = function(t, e, i) {
                    e = I.clamp(e, 0, t.length), i = I.clamp(i, -1, t.length);
                    var n = i - e + 1;
                    0 > i && (n = 0), e >= t.length && (n = 0), e > i && (n = 0);
                    var r = new Array(n).fill(null);
                    if (0 === n) return r;
                    for (var o = 0, s = e; i >= s; s++) r[o++] = t[s];
                    return r
                }, e(H.prototype, {
                    compare: function(t, e) {
                        var i = t,
                            n = e;
                        return X.compare(i, n)
                    },
                    interfaces_: function() { return [a] },
                    getClass: function() { return H }
                }), e(Y.prototype, {
                    compare: function(t, e) {
                        var i = t,
                            n = e;
                        if (i.length < n.length) return -1;
                        if (i.length > n.length) return 1;
                        if (0 === i.length) return 0;
                        var r = X.compare(i, n),
                            o = X.isEqualReversed(i, n);
                        return o ? 0 : r
                    },
                    OLDcompare: function(t, e) {
                        var i = t,
                            n = e;
                        if (i.length < n.length) return -1;
                        if (i.length > n.length) return 1;
                        if (0 === i.length) return 0;
                        for (var r = X.increasingDirection(i), o = X.increasingDirection(n), s = r > 0 ? 0 : i.length - 1, a = o > 0 ? 0 : i.length - 1, h = 0; h < i.length; h++) {
                            var l = i[s].compareTo(n[a]);
                            if (0 !== l) return l;
                            s += r, a += o
                        }
                        return 0
                    },
                    interfaces_: function() { return [a] },
                    getClass: function() { return Y }
                }), X.ForwardComparator = H, X.BidirectionalComparator = Y, X.coordArrayType = new Array(0).fill(null), K.prototype.get = function() {}, K.prototype.put = function() {}, K.prototype.size = function() {}, K.prototype.values = function() {}, K.prototype.entrySet = function() {}, $.prototype = new K, Z.prototype = new y, Z.prototype.contains = function() {}, J.prototype = new Z, J.prototype.contains = function(t) { for (var e = 0, i = this.array_.length; i > e; e++) { var n = this.array_[e]; if (n === t) return !0 } return !1 }, J.prototype.add = function(t) { return !this.contains(t) && (this.array_.push(t), !0) }, J.prototype.addAll = function(t) { for (var e = t.iterator(); e.hasNext();) this.add(e.next()); return !0 }, J.prototype.remove = function(t) { throw new javascript.util.OperationNotSupported }, J.prototype.size = function() { return this.array_.length }, J.prototype.isEmpty = function() { return 0 === this.array_.length }, J.prototype.toArray = function() { for (var t = [], e = 0, i = this.array_.length; i > e; e++) t.push(this.array_[e]); return t }, J.prototype.iterator = function() { return new Qo(this) };
                var Qo = function(t) { this.hashSet_ = t, this.position_ = 0 };
                Qo.prototype.next = function() { if (this.position_ === this.hashSet_.size()) throw new b; return this.hashSet_.array_[this.position_++] }, Qo.prototype.hasNext = function() { return this.position_ < this.hashSet_.size() }, Qo.prototype.remove = function() { throw new w };
                var ts = 0,
                    es = 1;
                rt.prototype = new $, rt.prototype.get = function(t) {
                    for (var e = this.root_; null !== e;) {
                        var i = t.compareTo(e.key);
                        if (0 > i) e = e.left;
                        else {
                            if (!(i > 0)) return e.value;
                            e = e.right
                        }
                    }
                    return null
                }, rt.prototype.put = function(t, e) {
                    if (null === this.root_) return this.root_ = { key: t, value: e, left: null, right: null, parent: null, color: ts, getValue: function() { return this.value }, getKey: function() { return this.key } }, this.size_ = 1, null;
                    var i, n, r = this.root_;
                    do
                        if (i = r, n = t.compareTo(r.key), 0 > n) r = r.left;
                        else {
                            if (!(n > 0)) { var o = r.value; return r.value = e, o }
                            r = r.right
                        }
                    while (null !== r);
                    var s = { key: t, left: null, right: null, value: e, parent: i, color: ts, getValue: function() { return this.value }, getKey: function() { return this.key } };
                    return 0 > n ? i.left = s : i.right = s, this.fixAfterInsertion(s), this.size_++, null
                }, rt.prototype.fixAfterInsertion = function(t) {
                    for (t.color = es; null != t && t != this.root_ && t.parent.color == es;)
                        if (tt(t) == it(tt(tt(t)))) {
                            var e = nt(tt(tt(t)));
                            Q(e) == es ? (et(tt(t), ts), et(e, ts), et(tt(tt(t)), es), t = tt(tt(t))) : (t == nt(tt(t)) && (t = tt(t), this.rotateLeft(t)), et(tt(t), ts), et(tt(tt(t)), es), this.rotateRight(tt(tt(t))))
                        } else {
                            var e = it(tt(tt(t)));
                            Q(e) == es ? (et(tt(t), ts), et(e, ts), et(tt(tt(t)), es), t = tt(tt(t))) : (t == it(tt(t)) && (t = tt(t), this.rotateRight(t)), et(tt(t), ts), et(tt(tt(t)), es), this.rotateLeft(tt(tt(t))))
                        }
                    this.root_.color = ts
                }, rt.prototype.values = function() {
                    var t = new x,
                        e = this.getFirstEntry();
                    if (null !== e)
                        for (t.add(e.value); null !== (e = rt.successor(e));) t.add(e.value);
                    return t
                }, rt.prototype.entrySet = function() {
                    var t = new J,
                        e = this.getFirstEntry();
                    if (null !== e)
                        for (t.add(e); null !== (e = rt.successor(e));) t.add(e);
                    return t
                }, rt.prototype.rotateLeft = function(t) {
                    if (null != t) {
                        var e = t.right;
                        t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.left == t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e
                    }
                }, rt.prototype.rotateRight = function(t) {
                    if (null != t) {
                        var e = t.left;
                        t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.right == t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e
                    }
                }, rt.prototype.getFirstEntry = function() {
                    var t = this.root_;
                    if (null != t)
                        for (; null != t.left;) t = t.left;
                    return t
                }, rt.successor = function(t) { if (null === t) return null; if (null !== t.right) { for (var e = t.right; null !== e.left;) e = e.left; return e } for (var e = t.parent, i = t; null !== e && i === e.right;) i = e, e = e.parent; return e }, rt.prototype.size = function() { return this.size_ }, e(ot.prototype, { interfaces_: function() { return [] }, getClass: function() { return ot } }), st.prototype = new Z, at.prototype = new st, at.prototype.contains = function(t) { for (var e = 0, i = this.array_.length; i > e; e++) { var n = this.array_[e]; if (0 === n.compareTo(t)) return !0 } return !1 }, at.prototype.add = function(t) { if (this.contains(t)) return !1; for (var e = 0, i = this.array_.length; i > e; e++) { var n = this.array_[e]; if (1 === n.compareTo(t)) return this.array_.splice(e, 0, t), !0 } return this.array_.push(t), !0 }, at.prototype.addAll = function(t) { for (var e = t.iterator(); e.hasNext();) this.add(e.next()); return !0 }, at.prototype.remove = function(t) { throw new w }, at.prototype.size = function() { return this.array_.length }, at.prototype.isEmpty = function() { return 0 === this.array_.length }, at.prototype.toArray = function() { for (var t = [], e = 0, i = this.array_.length; i > e; e++) t.push(this.array_[e]); return t }, at.prototype.iterator = function() { return new is(this) };
                var is = function(t) { this.treeSet_ = t, this.position_ = 0 };
                is.prototype.next = function() { if (this.position_ === this.treeSet_.size()) throw new b; return this.treeSet_.array_[this.position_++] }, is.prototype.hasNext = function() { return this.position_ < this.treeSet_.size() }, is.prototype.remove = function() { throw new w }, ht.sort = function() {
                    var t, e, i, n, r = arguments[0];
                    if (1 === arguments.length) return n = function(t, e) { return t.compareTo(e) }, void r.sort(n);
                    if (2 === arguments.length) i = arguments[1], n = function(t, e) { return i.compare(t, e) }, r.sort(n);
                    else { if (3 === arguments.length) { e = r.slice(arguments[1], arguments[2]), e.sort(); var o = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length)); for (r.splice(0, r.length), t = 0; t < o.length; t++) r.push(o[t]); return } if (4 === arguments.length) { for (e = r.slice(arguments[1], arguments[2]), i = arguments[3], n = function(t, e) { return i.compare(t, e) }, e.sort(n), o = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length)), r.splice(0, r.length), t = 0; t < o.length; t++) r.push(o[t]); return } }
                }, ht.asList = function(t) { for (var e = new x, i = 0, n = t.length; n > i; i++) e.add(t[i]); return e }, e(lt.prototype, { interfaces_: function() { return [] }, getClass: function() { return lt } }), lt.toDimensionSymbol = function(t) {
                    switch (t) {
                        case lt.FALSE:
                            return lt.SYM_FALSE;
                        case lt.TRUE:
                            return lt.SYM_TRUE;
                        case lt.DONTCARE:
                            return lt.SYM_DONTCARE;
                        case lt.P:
                            return lt.SYM_P;
                        case lt.L:
                            return lt.SYM_L;
                        case lt.A:
                            return lt.SYM_A
                    }
                    throw new n("Unknown dimension value: " + t)
                }, lt.toDimensionValue = function(t) {
                    switch (A.toUpperCase(t)) {
                        case lt.SYM_FALSE:
                            return lt.FALSE;
                        case lt.SYM_TRUE:
                            return lt.TRUE;
                        case lt.SYM_DONTCARE:
                            return lt.DONTCARE;
                        case lt.SYM_P:
                            return lt.P;
                        case lt.SYM_L:
                            return lt.L;
                        case lt.SYM_A:
                            return lt.A
                    }
                    throw new n("Unknown dimension symbol: " + t)
                }, lt.P = 0, lt.L = 1, lt.A = 2, lt.FALSE = -1, lt.TRUE = -2, lt.DONTCARE = -3, lt.SYM_FALSE = "F", lt.SYM_TRUE = "T", lt.SYM_DONTCARE = "*", lt.SYM_P = "0", lt.SYM_L = "1", lt.SYM_A = "2", e(ut.prototype, { filter: function(t) {}, interfaces_: function() { return [] }, getClass: function() { return ut } }), e(pt.prototype, { filter: function(t, e) {}, isDone: function() {}, isGeometryChanged: function() {}, interfaces_: function() { return [] }, getClass: function() { return pt } }), u(ct, B), e(ct.prototype, {
                    computeEnvelopeInternal: function() { for (var t = new S, e = 0; e < this.geometries.length; e++) t.expandToInclude(this.geometries[e].getEnvelopeInternal()); return t },
                    getGeometryN: function(t) { return this.geometries[t] },
                    getSortIndex: function() { return B.SORTINDEX_GEOMETRYCOLLECTION },
                    getCoordinates: function() {
                        for (var t = new Array(this.getNumPoints()).fill(null), e = -1, i = 0; i < this.geometries.length; i++)
                            for (var n = this.geometries[i].getCoordinates(), r = 0; r < n.length; r++) e++, t[e] = n[r];
                        return t
                    },
                    getArea: function() { for (var t = 0, e = 0; e < this.geometries.length; e++) t += this.geometries[e].getArea(); return t },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            if (!this.isEquivalentClass(t)) return !1;
                            var i = t;
                            if (this.geometries.length !== i.geometries.length) return !1;
                            for (var n = 0; n < this.geometries.length; n++)
                                if (!this.geometries[n].equalsExact(i.geometries[n], e)) return !1;
                            return !0
                        }
                        return B.prototype.equalsExact.apply(this, arguments)
                    },
                    normalize: function() {
                        for (var t = 0; t < this.geometries.length; t++) this.geometries[t].normalize();
                        ht.sort(this.geometries)
                    },
                    getCoordinate: function() { return this.isEmpty() ? null : this.geometries[0].getCoordinate() },
                    getBoundaryDimension: function() { for (var t = lt.FALSE, e = 0; e < this.geometries.length; e++) t = Math.max(t, this.geometries[e].getBoundaryDimension()); return t },
                    getDimension: function() { for (var t = lt.FALSE, e = 0; e < this.geometries.length; e++) t = Math.max(t, this.geometries[e].getDimension()); return t },
                    getLength: function() { for (var t = 0, e = 0; e < this.geometries.length; e++) t += this.geometries[e].getLength(); return t },
                    getNumPoints: function() { for (var t = 0, e = 0; e < this.geometries.length; e++) t += this.geometries[e].getNumPoints(); return t },
                    getNumGeometries: function() { return this.geometries.length },
                    reverse: function() { for (var t = this.geometries.length, e = new Array(t).fill(null), i = 0; i < this.geometries.length; i++) e[i] = this.geometries[i].reverse(); return this.getFactory().createGeometryCollection(e) },
                    compareToSameClass: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0],
                                e = new at(ht.asList(this.geometries)),
                                i = new at(ht.asList(t.geometries));
                            return this.compare(e, i)
                        }
                        if (2 === arguments.length) {
                            for (var n = arguments[0], r = arguments[1], o = n, s = this.getNumGeometries(), a = o.getNumGeometries(), h = 0; s > h && a > h;) {
                                var l = this.getGeometryN(h),
                                    u = o.getGeometryN(h),
                                    p = l.compareToSameClass(u, r);
                                if (0 !== p) return p;
                                h++
                            }
                            return s > h ? 1 : a > h ? -1 : 0
                        }
                    },
                    apply: function() {
                        if (M(arguments[0], j))
                            for (var t = arguments[0], e = 0; e < this.geometries.length; e++) this.geometries[e].apply(t);
                        else if (M(arguments[0], pt)) {
                            var i = arguments[0];
                            if (0 === this.geometries.length) return null;
                            for (var e = 0; e < this.geometries.length && (this.geometries[e].apply(i), !i.isDone()); e++);
                            i.isGeometryChanged() && this.geometryChanged()
                        } else if (M(arguments[0], ut)) {
                            var n = arguments[0];
                            n.filter(this);
                            for (var e = 0; e < this.geometries.length; e++) this.geometries[e].apply(n)
                        } else if (M(arguments[0], U)) {
                            var r = arguments[0];
                            r.filter(this);
                            for (var e = 0; e < this.geometries.length; e++) this.geometries[e].apply(r)
                        }
                    },
                    getBoundary: function() { return this.checkNotGeometryCollection(this), c.shouldNeverReachHere(), null },
                    clone: function() {
                        var t = B.prototype.clone.call(this);
                        t.geometries = new Array(this.geometries.length).fill(null);
                        for (var e = 0; e < this.geometries.length; e++) t.geometries[e] = this.geometries[e].clone();
                        return t
                    },
                    getGeometryType: function() { return "GeometryCollection" },
                    copy: function() { for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this.geometries[e].copy(); return new ct(t, this.factory) },
                    isEmpty: function() {
                        for (var t = 0; t < this.geometries.length; t++)
                            if (!this.geometries[t].isEmpty()) return !1;
                        return !0
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return ct }
                }), ct.serialVersionUID = -0x4f07bcb1f857d800, u(ft, ct), e(ft.prototype, {
                    getSortIndex: function() { return B.SORTINDEX_MULTILINESTRING },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            return !!this.isEquivalentClass(t) && ct.prototype.equalsExact.call(this, t, e)
                        }
                        return ct.prototype.equalsExact.apply(this, arguments)
                    },
                    getBoundaryDimension: function() { return this.isClosed() ? lt.FALSE : 0 },
                    isClosed: function() {
                        if (this.isEmpty()) return !1;
                        for (var t = 0; t < this.geometries.length; t++)
                            if (!this.geometries[t].isClosed()) return !1;
                        return !0
                    },
                    getDimension: function() { return 1 },
                    reverse: function() { for (var t = this.geometries.length, e = new Array(t).fill(null), i = 0; i < this.geometries.length; i++) e[t - 1 - i] = this.geometries[i].reverse(); return this.getFactory().createMultiLineString(e) },
                    getBoundary: function() { return new gt(this).getBoundary() },
                    getGeometryType: function() { return "MultiLineString" },
                    copy: function() { for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this.geometries[e].copy(); return new ft(t, this.factory) },
                    interfaces_: function() { return [ot] },
                    getClass: function() { return ft }
                }), ft.serialVersionUID = 0x7155d2ab4afa8000, e(gt.prototype, {
                    boundaryMultiLineString: function(t) { if (this.geom.isEmpty()) return this.getEmptyMultiPoint(); var e = this.computeBoundaryCoordinates(t); return 1 === e.length ? this.geomFact.createPoint(e[0]) : this.geomFact.createMultiPointFromCoords(e) },
                    getBoundary: function() { return this.geom instanceof Nt ? this.boundaryLineString(this.geom) : this.geom instanceof ft ? this.boundaryMultiLineString(this.geom) : this.geom.getBoundary() },
                    boundaryLineString: function(t) { if (this.geom.isEmpty()) return this.getEmptyMultiPoint(); if (t.isClosed()) { var e = this.bnRule.isInBoundary(2); return e ? t.getStartPoint() : this.geomFact.createMultiPoint() } return this.geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()]) },
                    getEmptyMultiPoint: function() { return this.geomFact.createMultiPoint() },
                    computeBoundaryCoordinates: function(t) {
                        var e = new x;
                        this.endpointMap = new rt;
                        for (var i = 0; i < t.getNumGeometries(); i++) {
                            var n = t.getGeometryN(i);
                            0 !== n.getNumPoints() && (this.addEndpoint(n.getCoordinateN(0)), this.addEndpoint(n.getCoordinateN(n.getNumPoints() - 1)))
                        }
                        for (var r = this.endpointMap.entrySet().iterator(); r.hasNext();) {
                            var o = r.next(),
                                s = o.getValue(),
                                a = s.count;
                            this.bnRule.isInBoundary(a) && e.add(o.getKey())
                        }
                        return X.toCoordinateArray(e)
                    },
                    addEndpoint: function(t) {
                        var e = this.endpointMap.get(t);
                        null === e && (e = new dt, this.endpointMap.put(t, e)), e.count++
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return gt }
                }), gt.getBoundary = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = new gt(t);
                        return e.getBoundary()
                    }
                    if (2 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            e = new gt(i, n);
                        return e.getBoundary()
                    }
                }, e(dt.prototype, { interfaces_: function() { return [] }, getClass: function() { return dt } }), e(Et.prototype, { interfaces_: function() { return [] }, getClass: function() { return Et } }), Et.chars = function(t, e) { for (var i = new Array(e).fill(null), n = 0; e > n; n++) i[n] = t; return new String(i) }, Et.getStackTrace = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = new bt,
                            i = new yt(e);
                        return t.printStackTrace(i), e.toString()
                    }
                    if (2 === arguments.length) {
                        for (var n = arguments[0], r = arguments[1], o = "", s = new mt(Et.getStackTrace(n)), a = new xt(s), h = 0; r > h; h++) try { o += a.readLine() + Et.NEWLINE } catch (t) {
                            if (!(t instanceof wt)) throw t;
                            c.shouldNeverReachHere()
                        } finally {}
                        return o
                    }
                }, Et.split = function(t, e) {
                    for (var i = e.length, n = new x, r = "" + t, o = r.indexOf(e); o >= 0;) {
                        var s = r.substring(0, o);
                        n.add(s), r = r.substring(o + i), o = r.indexOf(e)
                    }
                    r.length > 0 && n.add(r);
                    for (var a = new Array(n.size()).fill(null), h = 0; h < a.length; h++) a[h] = n.get(h);
                    return a
                }, Et.toString = function() { if (1 === arguments.length) { var t = arguments[0]; return Et.SIMPLE_ORDINATE_FORMAT.format(t) } }, Et.spaces = function(t) { return Et.chars(" ", t) }, Et.NEWLINE = O.getProperty("line.separator"), Et.SIMPLE_ORDINATE_FORMAT = new vt("0.#"), e(St.prototype, { interfaces_: function() { return [] }, getClass: function() { return St } }), St.copyCoord = function(t, e, i, n) { for (var r = Math.min(t.getDimension(), i.getDimension()), o = 0; r > o; o++) i.setOrdinate(n, o, t.getOrdinate(e, o)) }, St.isRing = function(t) { var e = t.size(); return 0 === e || !(3 >= e) && (t.getOrdinate(0, P.X) === t.getOrdinate(e - 1, P.X) && t.getOrdinate(0, P.Y) === t.getOrdinate(e - 1, P.Y)) }, St.isEqual = function(t, e) {
                    var i = t.size(),
                        n = e.size();
                    if (i !== n) return !1;
                    for (var o = Math.min(t.getDimension(), e.getDimension()), s = 0; i > s; s++)
                        for (var a = 0; o > a; a++) {
                            var h = t.getOrdinate(s, a),
                                l = e.getOrdinate(s, a);
                            if (!(t.getOrdinate(s, a) === e.getOrdinate(s, a) || r.isNaN(h) && r.isNaN(l))) return !1
                        }
                    return !0
                }, St.extend = function(t, e, i) {
                    var n = t.create(i, e.getDimension()),
                        r = e.size();
                    if (St.copy(e, 0, n, 0, r), r > 0)
                        for (var o = r; i > o; o++) St.copy(e, r - 1, n, o, 1);
                    return n
                }, St.reverse = function(t) {
                    for (var e = t.size() - 1, i = Math.trunc(e / 2), n = 0; i >= n; n++) St.swap(t, n, e - n);
                }, St.swap = function(t, e, i) {
                    if (e === i) return null;
                    for (var n = 0; n < t.getDimension(); n++) {
                        var r = t.getOrdinate(e, n);
                        t.setOrdinate(e, n, t.getOrdinate(i, n)), t.setOrdinate(i, n, r)
                    }
                }, St.copy = function(t, e, i, n, r) { for (var o = 0; r > o; o++) St.copyCoord(t, e + o, i, n + o) }, St.toString = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = t.size();
                        if (0 === e) return "()";
                        var i = t.getDimension(),
                            n = new k;
                        n.append("(");
                        for (var r = 0; e > r; r++) { r > 0 && n.append(" "); for (var o = 0; i > o; o++) o > 0 && n.append(","), n.append(Et.toString(t.getOrdinate(r, o))) }
                        return n.append(")"), n.toString()
                    }
                }, St.ensureValidRing = function(t, e) { var i = e.size(); if (0 === i) return e; if (3 >= i) return St.createClosedRing(t, e, 4); var n = e.getOrdinate(0, P.X) === e.getOrdinate(i - 1, P.X) && e.getOrdinate(0, P.Y) === e.getOrdinate(i - 1, P.Y); return n ? e : St.createClosedRing(t, e, i + 1) }, St.createClosedRing = function(t, e, i) {
                    var n = t.create(i, e.getDimension()),
                        r = e.size();
                    St.copy(e, 0, n, 0, r);
                    for (var o = r; i > o; o++) St.copy(e, 0, n, o, 1);
                    return n
                }, u(Nt, B), e(Nt.prototype, {
                    computeEnvelopeInternal: function() { return this.isEmpty() ? new S : this.points.expandEnvelope(new S) },
                    isRing: function() { return this.isClosed() && this.isSimple() },
                    getSortIndex: function() { return B.SORTINDEX_LINESTRING },
                    getCoordinates: function() { return this.points.toCoordinateArray() },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            if (!this.isEquivalentClass(t)) return !1;
                            var i = t;
                            if (this.points.size() !== i.points.size()) return !1;
                            for (var n = 0; n < this.points.size(); n++)
                                if (!this.equal(this.points.getCoordinate(n), i.points.getCoordinate(n), e)) return !1;
                            return !0
                        }
                        return B.prototype.equalsExact.apply(this, arguments)
                    },
                    normalize: function() { for (var t = 0; t < Math.trunc(this.points.size() / 2); t++) { var e = this.points.size() - 1 - t; if (!this.points.getCoordinate(t).equals(this.points.getCoordinate(e))) return this.points.getCoordinate(t).compareTo(this.points.getCoordinate(e)) > 0 && St.reverse(this.points), null } },
                    getCoordinate: function() { return this.isEmpty() ? null : this.points.getCoordinate(0) },
                    getBoundaryDimension: function() { return this.isClosed() ? lt.FALSE : 0 },
                    isClosed: function() { return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1)) },
                    getEndPoint: function() { return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1) },
                    getDimension: function() { return 1 },
                    getLength: function() { return ue.computeLength(this.points) },
                    getNumPoints: function() { return this.points.size() },
                    reverse: function() {
                        var t = this.points.copy();
                        St.reverse(t);
                        var e = this.getFactory().createLineString(t);
                        return e
                    },
                    compareToSameClass: function() {
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = t, i = 0, n = 0; i < this.points.size() && n < e.points.size();) {
                                var r = this.points.getCoordinate(i).compareTo(e.points.getCoordinate(n));
                                if (0 !== r) return r;
                                i++, n++
                            }
                            return i < this.points.size() ? 1 : n < e.points.size() ? -1 : 0
                        }
                        if (2 === arguments.length) {
                            var o = arguments[0],
                                s = arguments[1],
                                e = o;
                            return s.compare(this.points, e.points)
                        }
                    },
                    apply: function() {
                        if (M(arguments[0], j))
                            for (var t = arguments[0], e = 0; e < this.points.size(); e++) t.filter(this.points.getCoordinate(e));
                        else if (M(arguments[0], pt)) {
                            var i = arguments[0];
                            if (0 === this.points.size()) return null;
                            for (var e = 0; e < this.points.size() && (i.filter(this.points, e), !i.isDone()); e++);
                            i.isGeometryChanged() && this.geometryChanged()
                        } else if (M(arguments[0], ut)) {
                            var n = arguments[0];
                            n.filter(this)
                        } else if (M(arguments[0], U)) {
                            var r = arguments[0];
                            r.filter(this)
                        }
                    },
                    getBoundary: function() { return new gt(this).getBoundary() },
                    isEquivalentClass: function(t) { return t instanceof Nt },
                    clone: function() { var t = B.prototype.clone.call(this); return t.points = this.points.clone(), t },
                    getCoordinateN: function(t) { return this.points.getCoordinate(t) },
                    getGeometryType: function() { return "LineString" },
                    copy: function() { return new Nt(this.points.copy(), this.factory) },
                    getCoordinateSequence: function() { return this.points },
                    isEmpty: function() { return 0 === this.points.size() },
                    init: function(t) {
                        if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new n("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)");
                        this.points = t
                    },
                    isCoordinate: function(t) {
                        for (var e = 0; e < this.points.size(); e++)
                            if (this.points.getCoordinate(e).equals(t)) return !0;
                        return !1
                    },
                    getStartPoint: function() { return this.isEmpty() ? null : this.getPointN(0) },
                    getPointN: function(t) { return this.getFactory().createPoint(this.points.getCoordinate(t)) },
                    interfaces_: function() { return [ot] },
                    getClass: function() { return Nt }
                }), Nt.serialVersionUID = 0x2b2b51ba435c8e00, e(Lt.prototype, { interfaces_: function() { return [] }, getClass: function() { return Lt } }), u(Ct, B), e(Ct.prototype, {
                    computeEnvelopeInternal: function() { if (this.isEmpty()) return new S; var t = new S; return t.expandToInclude(this.coordinates.getX(0), this.coordinates.getY(0)), t },
                    getSortIndex: function() { return B.SORTINDEX_POINT },
                    getCoordinates: function() { return this.isEmpty() ? [] : [this.getCoordinate()] },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            return !!this.isEquivalentClass(t) && (!(!this.isEmpty() || !t.isEmpty()) || this.isEmpty() === t.isEmpty() && this.equal(t.getCoordinate(), this.getCoordinate(), e))
                        }
                        return B.prototype.equalsExact.apply(this, arguments)
                    },
                    normalize: function() {},
                    getCoordinate: function() { return 0 !== this.coordinates.size() ? this.coordinates.getCoordinate(0) : null },
                    getBoundaryDimension: function() { return lt.FALSE },
                    getDimension: function() { return 0 },
                    getNumPoints: function() { return this.isEmpty() ? 0 : 1 },
                    reverse: function() { return this.copy() },
                    getX: function() { if (null === this.getCoordinate()) throw new IllegalStateException("getX called on empty Point"); return this.getCoordinate().x },
                    compareToSameClass: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0],
                                e = t;
                            return this.getCoordinate().compareTo(e.getCoordinate())
                        }
                        if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1],
                                e = i;
                            return n.compare(this.coordinates, e.coordinates)
                        }
                    },
                    apply: function() {
                        if (M(arguments[0], j)) {
                            var t = arguments[0];
                            if (this.isEmpty()) return null;
                            t.filter(this.getCoordinate())
                        } else if (M(arguments[0], pt)) {
                            var e = arguments[0];
                            if (this.isEmpty()) return null;
                            e.filter(this.coordinates, 0), e.isGeometryChanged() && this.geometryChanged()
                        } else if (M(arguments[0], ut)) {
                            var i = arguments[0];
                            i.filter(this)
                        } else if (M(arguments[0], U)) {
                            var n = arguments[0];
                            n.filter(this)
                        }
                    },
                    getBoundary: function() { return this.getFactory().createGeometryCollection(null) },
                    clone: function() { var t = B.prototype.clone.call(this); return t.coordinates = this.coordinates.clone(), t },
                    getGeometryType: function() { return "Point" },
                    copy: function() { return new Ct(this.coordinates.copy(), this.factory) },
                    getCoordinateSequence: function() { return this.coordinates },
                    getY: function() { if (null === this.getCoordinate()) throw new IllegalStateException("getY called on empty Point"); return this.getCoordinate().y },
                    isEmpty: function() { return 0 === this.coordinates.size() },
                    init: function(t) { null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), c.isTrue(t.size() <= 1), this.coordinates = t },
                    isSimple: function() { return !0 },
                    interfaces_: function() { return [Lt] },
                    getClass: function() { return Ct }
                }), Ct.serialVersionUID = 0x44077bad161cbc00, e(Mt.prototype, { interfaces_: function() { return [] }, getClass: function() { return Mt } }), u(It, B), e(It.prototype, {
                    computeEnvelopeInternal: function() { return this.shell.getEnvelopeInternal() },
                    getSortIndex: function() { return B.SORTINDEX_POLYGON },
                    getCoordinates: function() {
                        if (this.isEmpty()) return [];
                        for (var t = new Array(this.getNumPoints()).fill(null), e = -1, i = this.shell.getCoordinates(), n = 0; n < i.length; n++) e++, t[e] = i[n];
                        for (var r = 0; r < this.holes.length; r++)
                            for (var o = this.holes[r].getCoordinates(), s = 0; s < o.length; s++) e++, t[e] = o[s];
                        return t
                    },
                    getArea: function() {
                        var t = 0;
                        t += Math.abs(ue.signedArea(this.shell.getCoordinateSequence()));
                        for (var e = 0; e < this.holes.length; e++) t -= Math.abs(ue.signedArea(this.holes[e].getCoordinateSequence()));
                        return t
                    },
                    isRectangle: function() {
                        if (0 !== this.getNumInteriorRing()) return !1;
                        if (null === this.shell) return !1;
                        if (5 !== this.shell.getNumPoints()) return !1;
                        for (var t = this.shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), i = 0; 5 > i; i++) { var n = t.getX(i); if (n !== e.getMinX() && n !== e.getMaxX()) return !1; var r = t.getY(i); if (r !== e.getMinY() && r !== e.getMaxY()) return !1 }
                        for (var o = t.getX(0), s = t.getY(0), i = 1; 4 >= i; i++) {
                            var n = t.getX(i),
                                r = t.getY(i),
                                a = n !== o,
                                h = r !== s;
                            if (a === h) return !1;
                            o = n, s = r
                        }
                        return !0
                    },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            if (!this.isEquivalentClass(t)) return !1;
                            var i = t,
                                n = this.shell,
                                r = i.shell;
                            if (!n.equalsExact(r, e)) return !1;
                            if (this.holes.length !== i.holes.length) return !1;
                            for (var o = 0; o < this.holes.length; o++)
                                if (!this.holes[o].equalsExact(i.holes[o], e)) return !1;
                            return !0
                        }
                        return B.prototype.equalsExact.apply(this, arguments)
                    },
                    normalize: function() {
                        if (0 === arguments.length) {
                            this.normalize(this.shell, !0);
                            for (var t = 0; t < this.holes.length; t++) this.normalize(this.holes[t], !1);
                            ht.sort(this.holes)
                        } else if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1];
                            if (e.isEmpty()) return null;
                            var n = new Array(e.getCoordinates().length - 1).fill(null);
                            O.arraycopy(e.getCoordinates(), 0, n, 0, n.length);
                            var r = X.minCoordinate(e.getCoordinates());
                            X.scroll(n, r), O.arraycopy(n, 0, e.getCoordinates(), 0, n.length), e.getCoordinates()[n.length] = n[0], ue.isCCW(e.getCoordinates()) === i && X.reverse(e.getCoordinates())
                        }
                    },
                    getCoordinate: function() { return this.shell.getCoordinate() },
                    getNumInteriorRing: function() { return this.holes.length },
                    getBoundaryDimension: function() { return 1 },
                    getDimension: function() { return 2 },
                    getLength: function() {
                        var t = 0;
                        t += this.shell.getLength();
                        for (var e = 0; e < this.holes.length; e++) t += this.holes[e].getLength();
                        return t
                    },
                    getNumPoints: function() { for (var t = this.shell.getNumPoints(), e = 0; e < this.holes.length; e++) t += this.holes[e].getNumPoints(); return t },
                    reverse: function() {
                        var t = this.copy();
                        t.shell = this.shell.copy().reverse(), t.holes = new Array(this.holes.length).fill(null);
                        for (var e = 0; e < this.holes.length; e++) t.holes[e] = this.holes[e].copy().reverse();
                        return t
                    },
                    convexHull: function() { return this.getExteriorRing().convexHull() },
                    compareToSameClass: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0],
                                e = this.shell,
                                i = t.shell;
                            return e.compareToSameClass(i)
                        }
                        if (2 === arguments.length) {
                            var n = arguments[0],
                                r = arguments[1],
                                o = n,
                                e = this.shell,
                                i = o.shell,
                                s = e.compareToSameClass(i, r);
                            if (0 !== s) return s;
                            for (var a = this.getNumInteriorRing(), h = o.getNumInteriorRing(), l = 0; a > l && h > l;) {
                                var u = this.getInteriorRingN(l),
                                    p = o.getInteriorRingN(l),
                                    c = u.compareToSameClass(p, r);
                                if (0 !== c) return c;
                                l++
                            }
                            return a > l ? 1 : h > l ? -1 : 0
                        }
                    },
                    apply: function() {
                        if (M(arguments[0], j)) {
                            var t = arguments[0];
                            this.shell.apply(t);
                            for (var e = 0; e < this.holes.length; e++) this.holes[e].apply(t)
                        } else if (M(arguments[0], pt)) {
                            var i = arguments[0];
                            if (this.shell.apply(i), !i.isDone())
                                for (var e = 0; e < this.holes.length && (this.holes[e].apply(i), !i.isDone()); e++);
                            i.isGeometryChanged() && this.geometryChanged()
                        } else if (M(arguments[0], ut)) {
                            var n = arguments[0];
                            n.filter(this)
                        } else if (M(arguments[0], U)) {
                            var r = arguments[0];
                            r.filter(this), this.shell.apply(r);
                            for (var e = 0; e < this.holes.length; e++) this.holes[e].apply(r)
                        }
                    },
                    getBoundary: function() {
                        if (this.isEmpty()) return this.getFactory().createMultiLineString();
                        var t = new Array(this.holes.length + 1).fill(null);
                        t[0] = this.shell;
                        for (var e = 0; e < this.holes.length; e++) t[e + 1] = this.holes[e];
                        return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t)
                    },
                    clone: function() {
                        var t = B.prototype.clone.call(this);
                        t.shell = this.shell.clone(), t.holes = new Array(this.holes.length).fill(null);
                        for (var e = 0; e < this.holes.length; e++) t.holes[e] = this.holes[e].clone();
                        return t
                    },
                    getGeometryType: function() { return "Polygon" },
                    copy: function() { for (var t = this.shell.copy(), e = new Array(this.holes.length).fill(null), i = 0; i < e.length; i++) e[i] = this.holes[i].copy(); return new It(t, e, this.factory) },
                    getExteriorRing: function() { return this.shell },
                    isEmpty: function() { return this.shell.isEmpty() },
                    getInteriorRingN: function(t) { return this.holes[t] },
                    interfaces_: function() { return [Mt] },
                    getClass: function() { return It }
                }), It.serialVersionUID = -0x307ffefd8dc97200, u(kt, ct), e(kt.prototype, {
                    getSortIndex: function() { return B.SORTINDEX_MULTIPOINT },
                    isValid: function() { return !0 },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            return !!this.isEquivalentClass(t) && ct.prototype.equalsExact.call(this, t, e)
                        }
                        return ct.prototype.equalsExact.apply(this, arguments)
                    },
                    getCoordinate: function() { if (1 === arguments.length) { var t = arguments[0]; return this.geometries[t].getCoordinate() } return ct.prototype.getCoordinate.apply(this, arguments) },
                    getBoundaryDimension: function() { return lt.FALSE },
                    getDimension: function() { return 0 },
                    getBoundary: function() { return this.getFactory().createGeometryCollection(null) },
                    getGeometryType: function() { return "MultiPoint" },
                    copy: function() { for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this.geometries[e].copy(); return new kt(t, this.factory) },
                    interfaces_: function() { return [Lt] },
                    getClass: function() { return kt }
                }), kt.serialVersionUID = -0x6fb1ed4162e0fc00, u(Tt, Nt), e(Tt.prototype, {
                    getSortIndex: function() { return B.SORTINDEX_LINEARRING },
                    getBoundaryDimension: function() { return lt.FALSE },
                    isClosed: function() { return !!this.isEmpty() || Nt.prototype.isClosed.call(this) },
                    reverse: function() {
                        var t = this.points.copy();
                        St.reverse(t);
                        var e = this.getFactory().createLinearRing(t);
                        return e
                    },
                    validateConstruction: function() { if (!this.isEmpty() && !Nt.prototype.isClosed.call(this)) throw new n("Points of LinearRing do not form a closed linestring"); if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < Tt.MINIMUM_VALID_SIZE) throw new n("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)") },
                    getGeometryType: function() { return "LinearRing" },
                    copy: function() { return new Tt(this.points.copy(), this.factory) },
                    interfaces_: function() { return [] },
                    getClass: function() { return Tt }
                }), Tt.MINIMUM_VALID_SIZE = 4, Tt.serialVersionUID = -0x3b229e262367a600, u(At, ct), e(At.prototype, {
                    getSortIndex: function() { return B.SORTINDEX_MULTIPOLYGON },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            return !!this.isEquivalentClass(t) && ct.prototype.equalsExact.call(this, t, e)
                        }
                        return ct.prototype.equalsExact.apply(this, arguments)
                    },
                    getBoundaryDimension: function() { return 1 },
                    getDimension: function() { return 2 },
                    reverse: function() { for (var t = this.geometries.length, e = new Array(t).fill(null), i = 0; i < this.geometries.length; i++) e[i] = this.geometries[i].reverse(); return this.getFactory().createMultiPolygon(e) },
                    getBoundary: function() {
                        if (this.isEmpty()) return this.getFactory().createMultiLineString();
                        for (var t = new x, e = 0; e < this.geometries.length; e++)
                            for (var i = this.geometries[e], n = i.getBoundary(), r = 0; r < n.getNumGeometries(); r++) t.add(n.getGeometryN(r));
                        var o = new Array(t.size()).fill(null);
                        return this.getFactory().createMultiLineString(t.toArray(o))
                    },
                    getGeometryType: function() { return "MultiPolygon" },
                    copy: function() { for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this.geometries[e].copy(); return new At(t, this.factory) },
                    interfaces_: function() { return [Mt] },
                    getClass: function() { return At }
                }), At.serialVersionUID = -0x7a5aa1369171980, e(Rt.prototype, {
                    setCopyUserData: function(t) { this.isUserDataCopied = t },
                    edit: function(t, e) { if (null === t) return null; var i = this.editInternal(t, e); return this.isUserDataCopied && i.setUserData(t.getUserData()), i },
                    editInternal: function(t, e) { return null === this.factory && (this.factory = t.getFactory()), t instanceof ct ? this.editGeometryCollection(t, e) : t instanceof It ? this.editPolygon(t, e) : t instanceof Ct ? e.edit(t, this.factory) : t instanceof Nt ? e.edit(t, this.factory) : (c.shouldNeverReachHere("Unsupported Geometry class: " + t.getClass().getName()), null) },
                    editGeometryCollection: function(t, e) {
                        for (var i = e.edit(t, this.factory), n = new x, r = 0; r < i.getNumGeometries(); r++) {
                            var o = this.edit(i.getGeometryN(r), e);
                            null === o || o.isEmpty() || n.add(o)
                        }
                        return i.getClass() === kt ? this.factory.createMultiPoint(n.toArray([])) : i.getClass() === ft ? this.factory.createMultiLineString(n.toArray([])) : i.getClass() === At ? this.factory.createMultiPolygon(n.toArray([])) : this.factory.createGeometryCollection(n.toArray([]))
                    },
                    editPolygon: function(t, e) {
                        var i = e.edit(t, this.factory);
                        if (null === i && (i = this.factory.createPolygon(null)), i.isEmpty()) return i;
                        var n = this.edit(i.getExteriorRing(), e);
                        if (null === n || n.isEmpty()) return this.factory.createPolygon();
                        for (var r = new x, o = 0; o < i.getNumInteriorRing(); o++) {
                            var s = this.edit(i.getInteriorRingN(o), e);
                            null === s || s.isEmpty() || r.add(s)
                        }
                        return this.factory.createPolygon(n, r.toArray([]))
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Rt }
                }), Rt.GeometryEditorOperation = _t, e(Pt.prototype, { edit: function(t, e) { return t }, interfaces_: function() { return [_t] }, getClass: function() { return Pt } }), e(Ot.prototype, { edit: function(t, e) { if (t instanceof Tt) return e.createLinearRing(this.editCoordinates(t.getCoordinates(), t)); if (t instanceof Nt) return e.createLineString(this.editCoordinates(t.getCoordinates(), t)); if (t instanceof Ct) { var i = this.editCoordinates(t.getCoordinates(), t); return i.length > 0 ? e.createPoint(i[0]) : e.createPoint() } return t }, interfaces_: function() { return [_t] }, getClass: function() { return Ot } }), e(Dt.prototype, { edit: function(t, e) { return t instanceof Tt ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof Nt ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof Ct ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t }, interfaces_: function() { return [_t] }, getClass: function() { return Dt } }), Rt.NoOpGeometryOperation = Pt, Rt.CoordinateOperation = Ot, Rt.CoordinateSequenceOperation = Dt, e(Ft.prototype, {
                    setOrdinate: function(t, e, i) {
                        switch (e) {
                            case P.X:
                                this.coordinates[t].x = i;
                                break;
                            case P.Y:
                                this.coordinates[t].y = i;
                                break;
                            case P.Z:
                                this.coordinates[t].z = i;
                                break;
                            default:
                                throw new n("invalid ordinateIndex")
                        }
                    },
                    size: function() { return this.coordinates.length },
                    getOrdinate: function(t, e) {
                        switch (e) {
                            case P.X:
                                return this.coordinates[t].x;
                            case P.Y:
                                return this.coordinates[t].y;
                            case P.Z:
                                return this.coordinates[t].z
                        }
                        return r.NaN
                    },
                    getCoordinate: function() {
                        if (1 === arguments.length) { var t = arguments[0]; return this.coordinates[t] }
                        if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1];
                            i.x = this.coordinates[e].x, i.y = this.coordinates[e].y, i.z = this.coordinates[e].z
                        }
                    },
                    getCoordinateCopy: function(t) { return new f(this.coordinates[t]) },
                    getDimension: function() { return this.dimension },
                    getX: function(t) { return this.coordinates[t].x },
                    clone: function() { for (var t = new Array(this.size()).fill(null), e = 0; e < this.coordinates.length; e++) t[e] = this.coordinates[e].clone(); return new Ft(t, this.dimension) },
                    expandEnvelope: function(t) { for (var e = 0; e < this.coordinates.length; e++) t.expandToInclude(this.coordinates[e]); return t },
                    copy: function() { for (var t = new Array(this.size()).fill(null), e = 0; e < this.coordinates.length; e++) t[e] = this.coordinates[e].copy(); return new Ft(t, this.dimension) },
                    toString: function() {
                        if (this.coordinates.length > 0) {
                            var t = new k(17 * this.coordinates.length);
                            t.append("("), t.append(this.coordinates[0]);
                            for (var e = 1; e < this.coordinates.length; e++) t.append(", "), t.append(this.coordinates[e]);
                            return t.append(")"), t.toString()
                        }
                        return "()"
                    },
                    getY: function(t) { return this.coordinates[t].y },
                    toCoordinateArray: function() { return this.coordinates },
                    interfaces_: function() { return [P, h] },
                    getClass: function() { return Ft }
                }), Ft.serialVersionUID = -0xcb44a778db18e00, e(Ut.prototype, {
                    readResolve: function() { return Ut.instance() },
                    create: function() {
                        if (1 === arguments.length) { if (arguments[0] instanceof Array) { var t = arguments[0]; return new Ft(t) } if (M(arguments[0], P)) { var e = arguments[0]; return new Ft(e) } } else if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1];
                            return n > 3 && (n = 3), 2 > n ? new Ft(i) : new Ft(i, n)
                        }
                    },
                    interfaces_: function() { return [F, h] },
                    getClass: function() { return Ut }
                }), Ut.instance = function() { return Ut.instanceObject }, Ut.serialVersionUID = -0x38e49fa6cf6f2e00, Ut.instanceObject = new Ut;
                var ns, rs = Object.defineProperty,
                    os = jt({ delete: Gt, has: Wt, get: qt, set: Xt, keys: Yt, values: Kt, entries: $t, forEach: Qt, clear: Ht }),
                    ss = "undefined" != typeof Map && Map.prototype.values ? Map : os;
                te.prototype = new K, te.prototype.get = function(t) { return this.map_.get(t) || null }, te.prototype.put = function(t, e) { return this.map_.set(t, e), e }, te.prototype.values = function() { for (var t = new x, e = this.map_.values(), i = e.next(); !i.done;) t.add(i.value), i = e.next(); return t }, te.prototype.entrySet = function() { var t = new J; return this.map_.entries().forEach(function(e) { return t.add(e) }), t }, te.prototype.size = function() { return this.map_.size() }, e(ee.prototype, {
                    equals: function(t) { if (!(t instanceof ee)) return !1; var e = t; return this.modelType === e.modelType && this.scale === e.scale },
                    compareTo: function(t) {
                        var e = t,
                            i = this.getMaximumSignificantDigits(),
                            n = e.getMaximumSignificantDigits();
                        return new T(i).compareTo(new T(n))
                    },
                    getScale: function() { return this.scale },
                    isFloating: function() { return this.modelType === ee.FLOATING || this.modelType === ee.FLOATING_SINGLE },
                    getType: function() { return this.modelType },
                    toString: function() { var t = "UNKNOWN"; return this.modelType === ee.FLOATING ? t = "Floating" : this.modelType === ee.FLOATING_SINGLE ? t = "Floating-Single" : this.modelType === ee.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t },
                    makePrecise: function() {
                        if ("number" == typeof arguments[0]) { var t = arguments[0]; if (r.isNaN(t)) return t; if (this.modelType === ee.FLOATING_SINGLE) { var e = t; return e } return this.modelType === ee.FIXED ? Math.round(t * this.scale) / this.scale : t }
                        if (arguments[0] instanceof f) {
                            var i = arguments[0];
                            if (this.modelType === ee.FLOATING) return null;
                            i.x = this.makePrecise(i.x), i.y = this.makePrecise(i.y)
                        }
                    },
                    getMaximumSignificantDigits: function() { var t = 16; return this.modelType === ee.FLOATING ? t = 16 : this.modelType === ee.FLOATING_SINGLE ? t = 6 : this.modelType === ee.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t },
                    setScale: function(t) { this.scale = Math.abs(t) },
                    interfaces_: function() { return [h, o] },
                    getClass: function() { return ee }
                }), ee.mostPrecise = function(t, e) { return t.compareTo(e) >= 0 ? t : e }, e(ie.prototype, { readResolve: function() { return ie.nameToTypeMap.get(this.name) }, toString: function() { return this.name }, interfaces_: function() { return [h] }, getClass: function() { return ie } }), ie.serialVersionUID = -552860263173159e4, ie.nameToTypeMap = new te, ee.Type = ie, ee.serialVersionUID = 0x6bee6404e9a25c00, ee.FIXED = new ie("FIXED"), ee.FLOATING = new ie("FLOATING"), ee.FLOATING_SINGLE = new ie("FLOATING SINGLE"), ee.maximumPreciseValue = 9007199254740992, e(ne.prototype, {
                    toGeometry: function(t) { return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new f(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new f(t.getMinX(), t.getMinY()), new f(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new f(t.getMinX(), t.getMinY()), new f(t.getMinX(), t.getMaxY()), new f(t.getMaxX(), t.getMaxY()), new f(t.getMaxX(), t.getMinY()), new f(t.getMinX(), t.getMinY())]), null) },
                    createLineString: function() { if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([])); if (1 === arguments.length) { if (arguments[0] instanceof Array) { var t = arguments[0]; return this.createLineString(null !== t ? this.getCoordinateSequenceFactory().create(t) : null) } if (M(arguments[0], P)) { var e = arguments[0]; return new Nt(e, this) } } },
                    createMultiLineString: function() { if (0 === arguments.length) return new ft(null, this); if (1 === arguments.length) { var t = arguments[0]; return new ft(t, this) } },
                    buildGeometry: function(t) {
                        for (var e = null, i = !1, n = !1, r = t.iterator(); r.hasNext();) {
                            var o = r.next(),
                                s = o.getClass();
                            null === e && (e = s), s !== e && (i = !0), o.isGeometryCollectionOrDerived() && (n = !0)
                        }
                        if (null === e) return this.createGeometryCollection();
                        if (i || n) return this.createGeometryCollection(ne.toGeometryArray(t));
                        var a = t.iterator().next(),
                            h = t.size() > 1;
                        if (h) {
                            if (a instanceof It) return this.createMultiPolygon(ne.toPolygonArray(t));
                            if (a instanceof Nt) return this.createMultiLineString(ne.toLineStringArray(t));
                            if (a instanceof Ct) return this.createMultiPoint(ne.toPointArray(t));
                            c.shouldNeverReachHere("Unhandled class: " + a.getClass().getName())
                        }
                        return a
                    },
                    createMultiPointFromCoords: function(t) { return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null) },
                    createPoint: function() { if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([])); if (1 === arguments.length) { if (arguments[0] instanceof f) { var t = arguments[0]; return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null) } if (M(arguments[0], P)) { var e = arguments[0]; return new Ct(e, this) } } },
                    getCoordinateSequenceFactory: function() { return this.coordinateSequenceFactory },
                    createPolygon: function() {
                        if (0 === arguments.length) return new It(null, null, this);
                        if (1 === arguments.length) { if (M(arguments[0], P)) { var t = arguments[0]; return this.createPolygon(this.createLinearRing(t)) } if (arguments[0] instanceof Array) { var e = arguments[0]; return this.createPolygon(this.createLinearRing(e)) } if (arguments[0] instanceof Tt) { var i = arguments[0]; return this.createPolygon(i, null) } } else if (2 === arguments.length) {
                            var n = arguments[0],
                                r = arguments[1];
                            return new It(n, r, this)
                        }
                    },
                    getSRID: function() { return this.SRID },
                    createGeometryCollection: function() { if (0 === arguments.length) return new ct(null, this); if (1 === arguments.length) { var t = arguments[0]; return new ct(t, this) } },
                    createGeometry: function(t) { var e = new Rt(this); return e.edit(t, { edit: function() { if (2 === arguments.length) { var t = arguments[0]; return arguments[1], this.coordinateSequenceFactory.create(t) } } }) },
                    getPrecisionModel: function() { return this.precisionModel },
                    createLinearRing: function() { if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([])); if (1 === arguments.length) { if (arguments[0] instanceof Array) { var t = arguments[0]; return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null) } if (M(arguments[0], P)) { var e = arguments[0]; return new Tt(e, this) } } },
                    createMultiPolygon: function() { if (0 === arguments.length) return new At(null, this); if (1 === arguments.length) { var t = arguments[0]; return new At(t, this) } },
                    createMultiPoint: function() {
                        if (0 === arguments.length) return new kt(null, this);
                        if (1 === arguments.length) {
                            if (arguments[0] instanceof Array) { var t = arguments[0]; return new kt(t, this) }
                            if (arguments[0] instanceof Array) { var e = arguments[0]; return this.createMultiPoint(null !== e ? this.getCoordinateSequenceFactory().create(e) : null) }
                            if (M(arguments[0], P)) {
                                var i = arguments[0];
                                if (null === i) return this.createMultiPoint(new Array(0).fill(null));
                                for (var n = new Array(i.size()).fill(null), r = 0; r < i.size(); r++) {
                                    var o = this.getCoordinateSequenceFactory().create(1, i.getDimension());
                                    St.copy(i, r, o, 0, 1), n[r] = this.createPoint(o)
                                }
                                return this.createMultiPoint(n)
                            }
                        }
                    },
                    interfaces_: function() { return [h] },
                    getClass: function() { return ne }
                }), ne.toMultiPolygonArray = function(t) { var e = new Array(t.size()).fill(null); return t.toArray(e) }, ne.toGeometryArray = function(t) { if (null === t) return null; var e = new Array(t.size()).fill(null); return t.toArray(e) }, ne.getDefaultCoordinateSequenceFactory = function() { return Ut.instance() }, ne.toMultiLineStringArray = function(t) { var e = new Array(t.size()).fill(null); return t.toArray(e) }, ne.toLineStringArray = function(t) { var e = new Array(t.size()).fill(null); return t.toArray(e) }, ne.toMultiPointArray = function(t) { var e = new Array(t.size()).fill(null); return t.toArray(e) }, ne.toLinearRingArray = function(t) { var e = new Array(t.size()).fill(null); return t.toArray(e) }, ne.toPointArray = function(t) { var e = new Array(t.size()).fill(null); return t.toArray(e) }, ne.toPolygonArray = function(t) { var e = new Array(t.size()).fill(null); return t.toArray(e) }, ne.createPointFromInternalCoord = function(t, e) { return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t) }, ne.serialVersionUID = -0x5ea75f2051eeb400;
                var as = { typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/, emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/, spaces: /\s+/, parenComma: /\)\s*,\s*\(/, doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, trimParens: /^\s*\(?(.*?)\)?\s*$/ };
                e(re.prototype, {
                    read: function(t) {
                        var e, i, n;
                        t = t.replace(/[\n\r]/g, " ");
                        var r = as.typeStr.exec(t);
                        if (-1 !== t.search("EMPTY") && (r = as.emptyTypeStr.exec(t), r[2] = void 0), r && (i = r[1].toLowerCase(), n = r[2], ls[i] && (e = ls[i].apply(this, [n]))), void 0 === e) throw new Error("Could not parse WKT " + t);
                        return e
                    },
                    write: function(t) { return this.extractGeometry(t) },
                    extractGeometry: function(t) { var e = t.getGeometryType().toLowerCase(); if (!hs[e]) return null; var i, n = e.toUpperCase(); return i = t.isEmpty() ? n + " EMPTY" : n + "(" + hs[e].apply(this, [t]) + ")" }
                });
                var hs = {
                        coordinate: function(t) { return t.x + " " + t.y },
                        point: function(t) { return hs.coordinate.call(this, t.coordinates.coordinates[0]) },
                        multipoint: function(t) { for (var e = [], i = 0, n = t.geometries.length; n > i; ++i) e.push("(" + hs.point.apply(this, [t.geometries[i]]) + ")"); return e.join(",") },
                        linestring: function(t) { for (var e = [], i = 0, n = t.points.coordinates.length; n > i; ++i) e.push(hs.coordinate.apply(this, [t.points.coordinates[i]])); return e.join(",") },
                        linearring: function(t) { for (var e = [], i = 0, n = t.points.coordinates.length; n > i; ++i) e.push(hs.coordinate.apply(this, [t.points.coordinates[i]])); return e.join(",") },
                        multilinestring: function(t) { for (var e = [], i = 0, n = t.geometries.length; n > i; ++i) e.push("(" + hs.linestring.apply(this, [t.geometries[i]]) + ")"); return e.join(",") },
                        polygon: function(t) {
                            var e = [];
                            e.push("(" + hs.linestring.apply(this, [t.shell]) + ")");
                            for (var i = 0, n = t.holes.length; n > i; ++i) e.push("(" + hs.linestring.apply(this, [t.holes[i]]) + ")");
                            return e.join(",")
                        },
                        multipolygon: function(t) { for (var e = [], i = 0, n = t.geometries.length; n > i; ++i) e.push("(" + hs.polygon.apply(this, [t.geometries[i]]) + ")"); return e.join(",") },
                        geometrycollection: function(t) { for (var e = [], i = 0, n = t.geometries.length; n > i; ++i) e.push(this.extractGeometry(t.geometries[i])); return e.join(",") }
                    },
                    ls = {
                        point: function(t) { if (void 0 === t) return this.geometryFactory.createPoint(); var e = t.trim().split(as.spaces); return this.geometryFactory.createPoint(new f(Number.parseFloat(e[0]), Number.parseFloat(e[1]))) },
                        multipoint: function(t) { if (void 0 === t) return this.geometryFactory.createMultiPoint(); for (var e, i = t.trim().split(","), n = [], r = 0, o = i.length; o > r; ++r) e = i[r].replace(as.trimParens, "$1"), n.push(ls.point.apply(this, [e])); return this.geometryFactory.createMultiPoint(n) },
                        linestring: function(t) { if (void 0 === t) return this.geometryFactory.createLineString(); for (var e, i = t.trim().split(","), n = [], r = 0, o = i.length; o > r; ++r) e = i[r].trim().split(as.spaces), n.push(new f(Number.parseFloat(e[0]), Number.parseFloat(e[1]))); return this.geometryFactory.createLineString(n) },
                        linearring: function(t) { if (void 0 === t) return this.geometryFactory.createLinearRing(); for (var e, i = t.trim().split(","), n = [], r = 0, o = i.length; o > r; ++r) e = i[r].trim().split(as.spaces), n.push(new f(Number.parseFloat(e[0]), Number.parseFloat(e[1]))); return this.geometryFactory.createLinearRing(n) },
                        multilinestring: function(t) { if (void 0 === t) return this.geometryFactory.createMultiLineString(); for (var e, i = t.trim().split(as.parenComma), n = [], r = 0, o = i.length; o > r; ++r) e = i[r].replace(as.trimParens, "$1"), n.push(ls.linestring.apply(this, [e])); return this.geometryFactory.createMultiLineString(n) },
                        polygon: function(t) { if (void 0 === t) return this.geometryFactory.createPolygon(); for (var e, i, n, r, o = t.trim().split(as.parenComma), s = [], a = 0, h = o.length; h > a; ++a) e = o[a].replace(as.trimParens, "$1"), i = ls.linestring.apply(this, [e]), n = this.geometryFactory.createLinearRing(i.points), 0 === a ? r = n : s.push(n); return this.geometryFactory.createPolygon(r, s) },
                        multipolygon: function(t) { if (void 0 === t) return this.geometryFactory.createMultiPolygon(); for (var e, i = t.trim().split(as.doubleParenComma), n = [], r = 0, o = i.length; o > r; ++r) e = i[r].replace(as.trimParens, "$1"), n.push(ls.polygon.apply(this, [e])); return this.geometryFactory.createMultiPolygon(n) },
                        geometrycollection: function(t) {
                            if (void 0 === t) return this.geometryFactory.createGeometryCollection();
                            t = t.replace(/,\s*([A-Za-z])/g, "|$1");
                            for (var e = t.trim().split("|"), i = [], n = 0, r = e.length; r > n; ++n) i.push(this.read(e[n]));
                            return this.geometryFactory.createGeometryCollection(i)
                        }
                    };
                e(oe.prototype, { write: function(t) { return this.parser.write(t) } }), e(oe, { toLineString: function(t, e) { if (2 !== arguments.length) throw new Error("Not implemented"); return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )" } }), e(se.prototype, {
                    getIndexAlongSegment: function(t, e) {
                        return this.computeIntLineIndex(), this.intLineIndex[t][e];
                    },
                    getTopologySummary: function() { var t = new k; return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString() },
                    computeIntersection: function(t, e, i, n) { this.inputLines[0][0] = t, this.inputLines[0][1] = e, this.inputLines[1][0] = i, this.inputLines[1][1] = n, this.result = this.computeIntersect(t, e, i, n) },
                    getIntersectionNum: function() { return this.result },
                    computeIntLineIndex: function() {
                        if (0 === arguments.length) null === this.intLineIndex && (this.intLineIndex = Array(2).fill().map(function() { return Array(2) }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
                        else if (1 === arguments.length) {
                            var t = arguments[0],
                                e = this.getEdgeDistance(t, 0),
                                i = this.getEdgeDistance(t, 1);
                            e > i ? (this.intLineIndex[t][0] = 0, this.intLineIndex[t][1] = 1) : (this.intLineIndex[t][0] = 1, this.intLineIndex[t][1] = 0)
                        }
                    },
                    isProper: function() { return this.hasIntersection() && this._isProper },
                    setPrecisionModel: function(t) { this.precisionModel = t },
                    isInteriorIntersection: function() {
                        if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = 0; e < this.result; e++)
                                if (!this.intPt[e].equals2D(this.inputLines[t][0]) && !this.intPt[e].equals2D(this.inputLines[t][1])) return !0;
                            return !1
                        }
                    },
                    getIntersection: function(t) { return this.intPt[t] },
                    isEndPoint: function() { return this.hasIntersection() && !this._isProper },
                    hasIntersection: function() { return this.result !== se.NO_INTERSECTION },
                    getEdgeDistance: function(t, e) { var i = se.computeEdgeDistance(this.intPt[e], this.inputLines[t][0], this.inputLines[t][1]); return i },
                    isCollinear: function() { return this.result === se.COLLINEAR_INTERSECTION },
                    toString: function() { return oe.toLineString(this.inputLines[0][0], this.inputLines[0][1]) + " - " + oe.toLineString(this.inputLines[1][0], this.inputLines[1][1]) + this.getTopologySummary() },
                    getEndpoint: function(t, e) { return this.inputLines[t][e] },
                    isIntersection: function(t) {
                        for (var e = 0; e < this.result; e++)
                            if (this.intPt[e].equals2D(t)) return !0;
                        return !1
                    },
                    getIntersectionAlongSegment: function(t, e) { return this.computeIntLineIndex(), this.intPt[this.intLineIndex[t][e]] },
                    interfaces_: function() { return [] },
                    getClass: function() { return se }
                }), se.computeEdgeDistance = function(t, e, i) {
                    var n = Math.abs(i.x - e.x),
                        r = Math.abs(i.y - e.y),
                        o = -1;
                    if (t.equals(e)) o = 0;
                    else if (t.equals(i)) o = n > r ? n : r;
                    else {
                        var s = Math.abs(t.x - e.x),
                            a = Math.abs(t.y - e.y);
                        o = n > r ? s : a, 0 !== o || t.equals(e) || (o = Math.max(s, a))
                    }
                    return c.isTrue(!(0 === o && !t.equals(e)), "Bad distance calculation"), o
                }, se.nonRobustComputeEdgeDistance = function(t, e, i) {
                    var n = t.x - e.x,
                        r = t.y - e.y,
                        o = Math.sqrt(n * n + r * r);
                    return c.isTrue(!(0 === o && !t.equals(e)), "Invalid distance calculation"), o
                }, se.DONT_INTERSECT = 0, se.DO_INTERSECT = 1, se.COLLINEAR = 2, se.NO_INTERSECTION = 0, se.POINT_INTERSECTION = 1, se.COLLINEAR_INTERSECTION = 2, u(ae, se), e(ae.prototype, {
                    isInSegmentEnvelopes: function(t) {
                        var e = new S(this.inputLines[0][0], this.inputLines[0][1]),
                            i = new S(this.inputLines[1][0], this.inputLines[1][1]);
                        return e.contains(t) && i.contains(t)
                    },
                    computeIntersection: function() {
                        if (3 !== arguments.length) return se.prototype.computeIntersection.apply(this, arguments);
                        var t = arguments[0],
                            e = arguments[1],
                            i = arguments[2];
                        return this._isProper = !1, S.intersects(e, i, t) && 0 === ue.orientationIndex(e, i, t) && 0 === ue.orientationIndex(i, e, t) ? (this._isProper = !0, (t.equals(e) || t.equals(i)) && (this._isProper = !1), this.result = se.POINT_INTERSECTION, null) : void(this.result = se.NO_INTERSECTION)
                    },
                    normalizeToMinimum: function(t, e, i, n, r) { r.x = this.smallestInAbsValue(t.x, e.x, i.x, n.x), r.y = this.smallestInAbsValue(t.y, e.y, i.y, n.y), t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, i.x -= r.x, i.y -= r.y, n.x -= r.x, n.y -= r.y },
                    safeHCoordinateIntersection: function(t, e, i, n) {
                        var r = null;
                        try { r = D.intersection(t, e, i, n) } catch (o) {
                            if (!(o instanceof L)) throw o;
                            r = ae.nearestEndpoint(t, e, i, n)
                        } finally {}
                        return r
                    },
                    intersection: function(t, e, i, n) { var r = this.intersectionWithNormalization(t, e, i, n); return this.isInSegmentEnvelopes(r) || (r = new f(ae.nearestEndpoint(t, e, i, n))), null !== this.precisionModel && this.precisionModel.makePrecise(r), r },
                    smallestInAbsValue: function(t, e, i, n) {
                        var r = t,
                            o = Math.abs(r);
                        return Math.abs(e) < o && (r = e, o = Math.abs(e)), Math.abs(i) < o && (r = i, o = Math.abs(i)), Math.abs(n) < o && (r = n), r
                    },
                    checkDD: function(t, e, i, n, r) {
                        var o = _.intersection(t, e, i, n),
                            s = this.isInSegmentEnvelopes(o);
                        O.out.println("DD in env = " + s + "  --------------------- " + o), r.distance(o) > 1e-4 && O.out.println("Distance = " + r.distance(o))
                    },
                    intersectionWithNormalization: function(t, e, i, n) {
                        var r = new f(t),
                            o = new f(e),
                            s = new f(i),
                            a = new f(n),
                            h = new f;
                        this.normalizeToEnvCentre(r, o, s, a, h);
                        var l = this.safeHCoordinateIntersection(r, o, s, a);
                        return l.x += h.x, l.y += h.y, l
                    },
                    computeCollinearIntersection: function(t, e, i, n) {
                        var r = S.intersects(t, e, i),
                            o = S.intersects(t, e, n),
                            s = S.intersects(i, n, t),
                            a = S.intersects(i, n, e);
                        return r && o ? (this.intPt[0] = i, this.intPt[1] = n, se.COLLINEAR_INTERSECTION) : s && a ? (this.intPt[0] = t, this.intPt[1] = e, se.COLLINEAR_INTERSECTION) : r && s ? (this.intPt[0] = i, this.intPt[1] = t, !i.equals(t) || o || a ? se.COLLINEAR_INTERSECTION : se.POINT_INTERSECTION) : r && a ? (this.intPt[0] = i, this.intPt[1] = e, !i.equals(e) || o || s ? se.COLLINEAR_INTERSECTION : se.POINT_INTERSECTION) : o && s ? (this.intPt[0] = n, this.intPt[1] = t, !n.equals(t) || r || a ? se.COLLINEAR_INTERSECTION : se.POINT_INTERSECTION) : o && a ? (this.intPt[0] = n, this.intPt[1] = e, !n.equals(e) || r || s ? se.COLLINEAR_INTERSECTION : se.POINT_INTERSECTION) : se.NO_INTERSECTION
                    },
                    normalizeToEnvCentre: function(t, e, i, n, r) {
                        var o = t.x < e.x ? t.x : e.x,
                            s = t.y < e.y ? t.y : e.y,
                            a = t.x > e.x ? t.x : e.x,
                            h = t.y > e.y ? t.y : e.y,
                            l = i.x < n.x ? i.x : n.x,
                            u = i.y < n.y ? i.y : n.y,
                            p = i.x > n.x ? i.x : n.x,
                            c = i.y > n.y ? i.y : n.y,
                            f = o > l ? o : l,
                            g = p > a ? a : p,
                            d = s > u ? s : u,
                            y = c > h ? h : c,
                            m = (f + g) / 2,
                            v = (d + y) / 2;
                        r.x = m, r.y = v, t.x -= r.x, t.y -= r.y, e.x -= r.x, e.y -= r.y, i.x -= r.x, i.y -= r.y, n.x -= r.x, n.y -= r.y
                    },
                    computeIntersect: function(t, e, i, n) {
                        if (this._isProper = !1, !S.intersects(t, e, i, n)) return se.NO_INTERSECTION;
                        var r = ue.orientationIndex(t, e, i),
                            o = ue.orientationIndex(t, e, n);
                        if (r > 0 && o > 0 || 0 > r && 0 > o) return se.NO_INTERSECTION;
                        var s = ue.orientationIndex(i, n, t),
                            a = ue.orientationIndex(i, n, e);
                        if (s > 0 && a > 0 || 0 > s && 0 > a) return se.NO_INTERSECTION;
                        var h = 0 === r && 0 === o && 0 === s && 0 === a;
                        return h ? this.computeCollinearIntersection(t, e, i, n) : (0 === r || 0 === o || 0 === s || 0 === a ? (this._isProper = !1, t.equals2D(i) || t.equals2D(n) ? this.intPt[0] = t : e.equals2D(i) || e.equals2D(n) ? this.intPt[0] = e : 0 === r ? this.intPt[0] = new f(i) : 0 === o ? this.intPt[0] = new f(n) : 0 === s ? this.intPt[0] = new f(t) : 0 === a && (this.intPt[0] = new f(e))) : (this._isProper = !0, this.intPt[0] = this.intersection(t, e, i, n)), se.POINT_INTERSECTION)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return ae }
                }), ae.nearestEndpoint = function(t, e, i, n) {
                    var r = t,
                        o = ue.distancePointLine(t, i, n),
                        s = ue.distancePointLine(e, i, n);
                    return o > s && (o = s, r = e), s = ue.distancePointLine(i, t, e), o > s && (o = s, r = i), s = ue.distancePointLine(n, t, e), o > s && (o = s, r = n), r
                }, e(he.prototype, { interfaces_: function() { return [] }, getClass: function() { return he } }), he.orientationIndex = function(t, e, i) {
                    var n = e.x - t.x,
                        r = e.y - t.y,
                        o = i.x - e.x,
                        s = i.y - e.y;
                    return he.signOfDet2x2(n, r, o, s)
                }, he.signOfDet2x2 = function(t, e, i, n) {
                    var r = null,
                        o = null,
                        s = null,
                        a = 0;
                    if (r = 1, 0 === t || 0 === n) return 0 === e || 0 === i ? 0 : e > 0 ? i > 0 ? -r : r : i > 0 ? r : -r;
                    if (0 === e || 0 === i) return n > 0 ? t > 0 ? r : -r : t > 0 ? -r : r;
                    if (e > 0 ? n > 0 ? n >= e || (r = -r, o = t, t = i, i = o, o = e, e = n, n = o) : -n >= e ? (r = -r, i = -i, n = -n) : (o = t, t = -i, i = o, o = e, e = -n, n = o) : n > 0 ? n >= -e ? (r = -r, t = -t, e = -e) : (o = -t, t = i, i = o, o = -e, e = n, n = o) : e >= n ? (t = -t, e = -e, i = -i, n = -n) : (r = -r, o = -t, t = -i, i = o, o = -e, e = -n, n = o), t > 0) { if (!(i > 0)) return r; if (!(i >= t)) return r } else {
                        if (i > 0) return -r;
                        if (!(t >= i)) return -r;
                        r = -r, t = -t, i = -i
                    }
                    for (;;) {
                        if (a += 1, s = Math.floor(i / t), i -= s * t, n -= s * e, 0 > n) return -r;
                        if (n > e) return r;
                        if (t > i + i) { if (n + n > e) return r } else {
                            if (e > n + n) return -r;
                            i = t - i, n = e - n, r = -r
                        }
                        if (0 === n) return 0 === i ? 0 : -r;
                        if (0 === i) return r;
                        if (s = Math.floor(t / i), t -= s * i, e -= s * n, 0 > e) return r;
                        if (e > n) return -r;
                        if (i > t + t) { if (e + e > n) return -r } else {
                            if (n > e + e) return r;
                            t = i - t, e = n - e, r = -r
                        }
                        if (0 === e) return 0 === t ? 0 : r;
                        if (0 === t) return -r
                    }
                }, e(le.prototype, {
                    countSegment: function(t, e) {
                        if (t.x < this.p.x && e.x < this.p.x) return null;
                        if (this.p.x === e.x && this.p.y === e.y) return this.isPointOnSegment = !0, null;
                        if (t.y === this.p.y && e.y === this.p.y) {
                            var i = t.x,
                                n = e.x;
                            return i > n && (i = e.x, n = t.x), this.p.x >= i && this.p.x <= n && (this.isPointOnSegment = !0), null
                        }
                        if (t.y > this.p.y && e.y <= this.p.y || e.y > this.p.y && t.y <= this.p.y) {
                            var r = t.x - this.p.x,
                                o = t.y - this.p.y,
                                s = e.x - this.p.x,
                                a = e.y - this.p.y,
                                h = he.signOfDet2x2(r, o, s, a);
                            if (0 === h) return this.isPointOnSegment = !0, null;
                            o > a && (h = -h), h > 0 && this.crossingCount++
                        }
                    },
                    isPointInPolygon: function() { return this.getLocation() !== C.EXTERIOR },
                    getLocation: function() { return this.isPointOnSegment ? C.BOUNDARY : this.crossingCount % 2 === 1 ? C.INTERIOR : C.EXTERIOR },
                    isOnSegment: function() { return this.isPointOnSegment },
                    interfaces_: function() { return [] },
                    getClass: function() { return le }
                }), le.locatePointInRing = function() {
                    if (arguments[0] instanceof f && M(arguments[1], P)) {
                        for (var t = arguments[0], e = arguments[1], i = new le(t), n = new f, r = new f, o = 1; o < e.size(); o++)
                            if (e.getCoordinate(o, n), e.getCoordinate(o - 1, r), i.countSegment(n, r), i.isOnSegment()) return i.getLocation();
                        return i.getLocation()
                    }
                    if (arguments[0] instanceof f && arguments[1] instanceof Array) {
                        for (var s = arguments[0], a = arguments[1], i = new le(s), o = 1; o < a.length; o++) {
                            var n = a[o],
                                r = a[o - 1];
                            if (i.countSegment(n, r), i.isOnSegment()) return i.getLocation()
                        }
                        return i.getLocation()
                    }
                }, e(ue.prototype, { interfaces_: function() { return [] }, getClass: function() { return ue } }), ue.orientationIndex = function(t, e, i) { return _.orientationIndex(t, e, i) }, ue.signedArea = function() {
                    if (arguments[0] instanceof Array) {
                        var t = arguments[0];
                        if (t.length < 3) return 0;
                        for (var e = 0, i = t[0].x, n = 1; n < t.length - 1; n++) {
                            var r = t[n].x - i,
                                o = t[n + 1].y,
                                s = t[n - 1].y;
                            e += r * (s - o)
                        }
                        return e / 2
                    }
                    if (M(arguments[0], P)) {
                        var a = arguments[0],
                            h = a.size();
                        if (3 > h) return 0;
                        var l = new f,
                            u = new f,
                            p = new f;
                        a.getCoordinate(0, u), a.getCoordinate(1, p);
                        var i = u.x;
                        p.x -= i;
                        for (var e = 0, n = 1; h - 1 > n; n++) l.y = u.y, u.x = p.x, u.y = p.y, a.getCoordinate(n + 1, p), p.x -= i, e += u.x * (l.y - p.y);
                        return e / 2
                    }
                }, ue.distanceLineLine = function(t, e, i, n) {
                    if (t.equals(e)) return ue.distancePointLine(t, i, n);
                    if (i.equals(n)) return ue.distancePointLine(n, t, e);
                    var r = !1;
                    if (S.intersects(t, e, i, n)) {
                        var o = (e.x - t.x) * (n.y - i.y) - (e.y - t.y) * (n.x - i.x);
                        if (0 === o) r = !0;
                        else {
                            var s = (t.y - i.y) * (n.x - i.x) - (t.x - i.x) * (n.y - i.y),
                                a = (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y),
                                h = a / o,
                                l = s / o;
                            (0 > l || l > 1 || 0 > h || h > 1) && (r = !0)
                        }
                    } else r = !0;
                    return r ? I.min(ue.distancePointLine(t, i, n), ue.distancePointLine(e, i, n), ue.distancePointLine(i, t, e), ue.distancePointLine(n, t, e)) : 0
                }, ue.isPointInRing = function(t, e) { return ue.locatePointInRing(t, e) !== C.EXTERIOR }, ue.computeLength = function(t) {
                    var e = t.size();
                    if (1 >= e) return 0;
                    var i = 0,
                        n = new f;
                    t.getCoordinate(0, n);
                    for (var r = n.x, o = n.y, s = 1; e > s; s++) {
                        t.getCoordinate(s, n);
                        var a = n.x,
                            h = n.y,
                            l = a - r,
                            u = h - o;
                        i += Math.sqrt(l * l + u * u), r = a, o = h
                    }
                    return i
                }, ue.isCCW = function(t) {
                    var e = t.length - 1;
                    if (3 > e) throw new n("Ring has fewer than 4 points, so orientation cannot be determined");
                    for (var i = t[0], r = 0, o = 1; e >= o; o++) {
                        var s = t[o];
                        s.y > i.y && (i = s, r = o)
                    }
                    var a = r;
                    do a -= 1, 0 > a && (a = e); while (t[a].equals2D(i) && a !== r);
                    var h = r;
                    do h = (h + 1) % e; while (t[h].equals2D(i) && h !== r);
                    var l = t[a],
                        u = t[h];
                    if (l.equals2D(i) || u.equals2D(i) || l.equals2D(u)) return !1;
                    var p = ue.computeOrientation(l, i, u),
                        c = !1;
                    return c = 0 === p ? l.x > u.x : p > 0
                }, ue.locatePointInRing = function(t, e) { return le.locatePointInRing(t, e) }, ue.distancePointLinePerpendicular = function(t, e, i) {
                    var n = (i.x - e.x) * (i.x - e.x) + (i.y - e.y) * (i.y - e.y),
                        r = ((e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)) / n;
                    return Math.abs(r) * Math.sqrt(n)
                }, ue.computeOrientation = function(t, e, i) { return ue.orientationIndex(t, e, i) }, ue.distancePointLine = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        if (0 === e.length) throw new n("Line array must contain at least one vertex");
                        for (var i = t.distance(e[0]), r = 0; r < e.length - 1; r++) {
                            var o = ue.distancePointLine(t, e[r], e[r + 1]);
                            i > o && (i = o)
                        }
                        return i
                    }
                    if (3 === arguments.length) {
                        var s = arguments[0],
                            a = arguments[1],
                            h = arguments[2];
                        if (a.x === h.x && a.y === h.y) return s.distance(a);
                        var l = (h.x - a.x) * (h.x - a.x) + (h.y - a.y) * (h.y - a.y),
                            u = ((s.x - a.x) * (h.x - a.x) + (s.y - a.y) * (h.y - a.y)) / l;
                        if (0 >= u) return s.distance(a);
                        if (u >= 1) return s.distance(h);
                        var p = ((a.y - s.y) * (h.x - a.x) - (a.x - s.x) * (h.y - a.y)) / l;
                        return Math.abs(p) * Math.sqrt(l)
                    }
                }, ue.isOnLine = function(t, e) {
                    for (var i = new ae, n = 1; n < e.length; n++) {
                        var r = e[n - 1],
                            o = e[n];
                        if (i.computeIntersection(t, r, o), i.hasIntersection()) return !0
                    }
                    return !1
                }, ue.CLOCKWISE = -1, ue.RIGHT = ue.CLOCKWISE, ue.COUNTERCLOCKWISE = 1, ue.LEFT = ue.COUNTERCLOCKWISE, ue.COLLINEAR = 0, ue.STRAIGHT = ue.COLLINEAR, e(pe.prototype, {
                    minX: function() { return Math.min(this.p0.x, this.p1.x) },
                    orientationIndex: function() {
                        if (arguments[0] instanceof pe) {
                            var t = arguments[0],
                                e = ue.orientationIndex(this.p0, this.p1, t.p0),
                                i = ue.orientationIndex(this.p0, this.p1, t.p1);
                            return e >= 0 && i >= 0 ? Math.max(e, i) : 0 >= e && 0 >= i ? Math.max(e, i) : 0
                        }
                        if (arguments[0] instanceof f) { var n = arguments[0]; return ue.orientationIndex(this.p0, this.p1, n) }
                    },
                    toGeometry: function(t) { return t.createLineString([this.p0, this.p1]) },
                    isVertical: function() { return this.p0.x === this.p1.x },
                    equals: function(t) { if (!(t instanceof pe)) return !1; var e = t; return this.p0.equals(e.p0) && this.p1.equals(e.p1) },
                    intersection: function(t) { var e = new ae; return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null },
                    project: function() {
                        if (arguments[0] instanceof f) {
                            var t = arguments[0];
                            if (t.equals(this.p0) || t.equals(this.p1)) return new f(t);
                            var e = this.projectionFactor(t),
                                i = new f;
                            return i.x = this.p0.x + e * (this.p1.x - this.p0.x), i.y = this.p0.y + e * (this.p1.y - this.p0.y), i
                        }
                        if (arguments[0] instanceof pe) {
                            var n = arguments[0],
                                r = this.projectionFactor(n.p0),
                                o = this.projectionFactor(n.p1);
                            if (r >= 1 && o >= 1) return null;
                            if (0 >= r && 0 >= o) return null;
                            var s = this.project(n.p0);
                            0 > r && (s = this.p0), r > 1 && (s = this.p1);
                            var a = this.project(n.p1);
                            return 0 > o && (a = this.p0), o > 1 && (a = this.p1), new pe(s, a)
                        }
                    },
                    normalize: function() { this.p1.compareTo(this.p0) < 0 && this.reverse() },
                    angle: function() { return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x) },
                    getCoordinate: function(t) { return 0 === t ? this.p0 : this.p1 },
                    distancePerpendicular: function(t) { return ue.distancePointLinePerpendicular(t, this.p0, this.p1) },
                    minY: function() { return Math.min(this.p0.y, this.p1.y) },
                    midPoint: function() { return pe.midPoint(this.p0, this.p1) },
                    projectionFactor: function(t) {
                        if (t.equals(this.p0)) return 0;
                        if (t.equals(this.p1)) return 1;
                        var e = this.p1.x - this.p0.x,
                            i = this.p1.y - this.p0.y,
                            n = e * e + i * i;
                        if (0 >= n) return r.NaN;
                        var o = ((t.x - this.p0.x) * e + (t.y - this.p0.y) * i) / n;
                        return o
                    },
                    closestPoints: function(t) {
                        var e = this.intersection(t);
                        if (null !== e) return [e, e];
                        var i = new Array(2).fill(null),
                            n = r.MAX_VALUE,
                            o = null,
                            s = this.closestPoint(t.p0);
                        n = s.distance(t.p0), i[0] = s, i[1] = t.p0;
                        var a = this.closestPoint(t.p1);
                        o = a.distance(t.p1), n > o && (n = o, i[0] = a, i[1] = t.p1);
                        var h = t.closestPoint(this.p0);
                        o = h.distance(this.p0), n > o && (n = o, i[0] = this.p0, i[1] = h);
                        var l = t.closestPoint(this.p1);
                        return o = l.distance(this.p1), n > o && (n = o, i[0] = this.p1, i[1] = l), i
                    },
                    closestPoint: function(t) {
                        var e = this.projectionFactor(t);
                        if (e > 0 && 1 > e) return this.project(t);
                        var i = this.p0.distance(t),
                            n = this.p1.distance(t);
                        return n > i ? this.p0 : this.p1
                    },
                    maxX: function() { return Math.max(this.p0.x, this.p1.x) },
                    getLength: function() { return this.p0.distance(this.p1) },
                    compareTo: function(t) {
                        var e = t,
                            i = this.p0.compareTo(e.p0);
                        return 0 !== i ? i : this.p1.compareTo(e.p1)
                    },
                    reverse: function() {
                        var t = this.p0;
                        this.p0 = this.p1, this.p1 = t
                    },
                    equalsTopo: function(t) { return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0) },
                    lineIntersection: function(t) { try { var e = D.intersection(this.p0, this.p1, t.p0, t.p1); return e } catch (t) { if (!(t instanceof L)) throw t } finally {} return null },
                    maxY: function() { return Math.max(this.p0.y, this.p1.y) },
                    pointAlongOffset: function(t, e) {
                        var i = this.p0.x + t * (this.p1.x - this.p0.x),
                            n = this.p0.y + t * (this.p1.y - this.p0.y),
                            r = this.p1.x - this.p0.x,
                            o = this.p1.y - this.p0.y,
                            s = Math.sqrt(r * r + o * o),
                            a = 0,
                            h = 0;
                        if (0 !== e) {
                            if (0 >= s) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
                            a = e * r / s, h = e * o / s
                        }
                        var l = i - h,
                            u = n + a,
                            p = new f(l, u);
                        return p
                    },
                    setCoordinates: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.setCoordinates(t.p0, t.p1)
                        } else if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1];
                            this.p0.x = e.x, this.p0.y = e.y, this.p1.x = i.x, this.p1.y = i.y
                        }
                    },
                    segmentFraction: function(t) { var e = this.projectionFactor(t); return 0 > e ? e = 0 : (e > 1 || r.isNaN(e)) && (e = 1), e },
                    toString: function() { return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")" },
                    isHorizontal: function() { return this.p0.y === this.p1.y },
                    distance: function() { if (arguments[0] instanceof pe) { var t = arguments[0]; return ue.distanceLineLine(this.p0, this.p1, t.p0, t.p1) } if (arguments[0] instanceof f) { var e = arguments[0]; return ue.distancePointLine(e, this.p0, this.p1) } },
                    pointAlong: function(t) { var e = new f; return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e },
                    hashCode: function() {
                        var t = java.lang.Double.doubleToLongBits(this.p0.x);
                        t ^= 31 * java.lang.Double.doubleToLongBits(this.p0.y);
                        var e = Math.trunc(t) ^ Math.trunc(t >> 32),
                            i = java.lang.Double.doubleToLongBits(this.p1.x);
                        i ^= 31 * java.lang.Double.doubleToLongBits(this.p1.y);
                        var n = Math.trunc(i) ^ Math.trunc(i >> 32);
                        return e ^ n
                    },
                    interfaces_: function() { return [o, h] },
                    getClass: function() { return pe }
                }), pe.midPoint = function(t, e) { return new f((t.x + e.x) / 2, (t.y + e.y) / 2) }, pe.serialVersionUID = 0x2d2172135f411c00, e(ce.prototype, {
                    isIntersects: function() { return !this.isDisjoint() },
                    isCovers: function() { var t = ce.isTrue(this.matrix[C.INTERIOR][C.INTERIOR]) || ce.isTrue(this.matrix[C.INTERIOR][C.BOUNDARY]) || ce.isTrue(this.matrix[C.BOUNDARY][C.INTERIOR]) || ce.isTrue(this.matrix[C.BOUNDARY][C.BOUNDARY]); return t && this.matrix[C.EXTERIOR][C.INTERIOR] === lt.FALSE && this.matrix[C.EXTERIOR][C.BOUNDARY] === lt.FALSE },
                    isCoveredBy: function() { var t = ce.isTrue(this.matrix[C.INTERIOR][C.INTERIOR]) || ce.isTrue(this.matrix[C.INTERIOR][C.BOUNDARY]) || ce.isTrue(this.matrix[C.BOUNDARY][C.INTERIOR]) || ce.isTrue(this.matrix[C.BOUNDARY][C.BOUNDARY]); return t && this.matrix[C.INTERIOR][C.EXTERIOR] === lt.FALSE && this.matrix[C.BOUNDARY][C.EXTERIOR] === lt.FALSE },
                    set: function() {
                        if (1 === arguments.length)
                            for (var t = arguments[0], e = 0; e < t.length; e++) {
                                var i = Math.trunc(e / 3),
                                    n = e % 3;
                                this.matrix[i][n] = lt.toDimensionValue(t.charAt(e))
                            } else if (3 === arguments.length) {
                                var r = arguments[0],
                                    o = arguments[1],
                                    s = arguments[2];
                                this.matrix[r][o] = s
                            }
                    },
                    isContains: function() { return ce.isTrue(this.matrix[C.INTERIOR][C.INTERIOR]) && this.matrix[C.EXTERIOR][C.INTERIOR] === lt.FALSE && this.matrix[C.EXTERIOR][C.BOUNDARY] === lt.FALSE },
                    setAtLeast: function() {
                        if (1 === arguments.length)
                            for (var t = arguments[0], e = 0; e < t.length; e++) {
                                var i = Math.trunc(e / 3),
                                    n = e % 3;
                                this.setAtLeast(i, n, lt.toDimensionValue(t.charAt(e)))
                            } else if (3 === arguments.length) {
                                var r = arguments[0],
                                    o = arguments[1],
                                    s = arguments[2];
                                this.matrix[r][o] < s && (this.matrix[r][o] = s)
                            }
                    },
                    setAtLeastIfValid: function(t, e, i) { t >= 0 && e >= 0 && this.setAtLeast(t, e, i) },
                    isWithin: function() { return ce.isTrue(this.matrix[C.INTERIOR][C.INTERIOR]) && this.matrix[C.INTERIOR][C.EXTERIOR] === lt.FALSE && this.matrix[C.BOUNDARY][C.EXTERIOR] === lt.FALSE },
                    isTouches: function(t, e) { return t > e ? this.isTouches(e, t) : (t === lt.A && e === lt.A || t === lt.L && e === lt.L || t === lt.L && e === lt.A || t === lt.P && e === lt.A || t === lt.P && e === lt.L) && (this.matrix[C.INTERIOR][C.INTERIOR] === lt.FALSE && (ce.isTrue(this.matrix[C.INTERIOR][C.BOUNDARY]) || ce.isTrue(this.matrix[C.BOUNDARY][C.INTERIOR]) || ce.isTrue(this.matrix[C.BOUNDARY][C.BOUNDARY]))) },
                    isOverlaps: function(t, e) { return t === lt.P && e === lt.P || t === lt.A && e === lt.A ? ce.isTrue(this.matrix[C.INTERIOR][C.INTERIOR]) && ce.isTrue(this.matrix[C.INTERIOR][C.EXTERIOR]) && ce.isTrue(this.matrix[C.EXTERIOR][C.INTERIOR]) : t === lt.L && e === lt.L && (1 === this.matrix[C.INTERIOR][C.INTERIOR] && ce.isTrue(this.matrix[C.INTERIOR][C.EXTERIOR]) && ce.isTrue(this.matrix[C.EXTERIOR][C.INTERIOR])) },
                    isEquals: function(t, e) { return t === e && (ce.isTrue(this.matrix[C.INTERIOR][C.INTERIOR]) && this.matrix[C.INTERIOR][C.EXTERIOR] === lt.FALSE && this.matrix[C.BOUNDARY][C.EXTERIOR] === lt.FALSE && this.matrix[C.EXTERIOR][C.INTERIOR] === lt.FALSE && this.matrix[C.EXTERIOR][C.BOUNDARY] === lt.FALSE) },
                    toString: function() {
                        for (var t = new k("123456789"), e = 0; 3 > e; e++)
                            for (var i = 0; 3 > i; i++) t.setCharAt(3 * e + i, lt.toDimensionSymbol(this.matrix[e][i]));
                        return t.toString()
                    },
                    setAll: function(t) {
                        for (var e = 0; 3 > e; e++)
                            for (var i = 0; 3 > i; i++) this.matrix[e][i] = t
                    },
                    get: function(t, e) { return this.matrix[t][e] },
                    transpose: function() { var t = this.matrix[1][0]; return this.matrix[1][0] = this.matrix[0][1], this.matrix[0][1] = t, t = this.matrix[2][0], this.matrix[2][0] = this.matrix[0][2], this.matrix[0][2] = t, t = this.matrix[2][1], this.matrix[2][1] = this.matrix[1][2], this.matrix[1][2] = t, this },
                    matches: function(t) {
                        if (9 !== t.length) throw new n("Should be length 9: " + t);
                        for (var e = 0; 3 > e; e++)
                            for (var i = 0; 3 > i; i++)
                                if (!ce.matches(this.matrix[e][i], t.charAt(3 * e + i))) return !1;
                        return !0
                    },
                    add: function(t) {
                        for (var e = 0; 3 > e; e++)
                            for (var i = 0; 3 > i; i++) this.setAtLeast(e, i, t.get(e, i))
                    },
                    isDisjoint: function() { return this.matrix[C.INTERIOR][C.INTERIOR] === lt.FALSE && this.matrix[C.INTERIOR][C.BOUNDARY] === lt.FALSE && this.matrix[C.BOUNDARY][C.INTERIOR] === lt.FALSE && this.matrix[C.BOUNDARY][C.BOUNDARY] === lt.FALSE },
                    isCrosses: function(t, e) { return t === lt.P && e === lt.L || t === lt.P && e === lt.A || t === lt.L && e === lt.A ? ce.isTrue(this.matrix[C.INTERIOR][C.INTERIOR]) && ce.isTrue(this.matrix[C.INTERIOR][C.EXTERIOR]) : t === lt.L && e === lt.P || t === lt.A && e === lt.P || t === lt.A && e === lt.L ? ce.isTrue(this.matrix[C.INTERIOR][C.INTERIOR]) && ce.isTrue(this.matrix[C.EXTERIOR][C.INTERIOR]) : t === lt.L && e === lt.L && 0 === this.matrix[C.INTERIOR][C.INTERIOR] },
                    interfaces_: function() { return [s] },
                    getClass: function() { return ce }
                }), ce.matches = function() {
                    if (Number.isInteger(arguments[0]) && "string" == typeof arguments[1]) {
                        var t = arguments[0],
                            e = arguments[1];
                        return e === lt.SYM_DONTCARE || (e === lt.SYM_TRUE && (t >= 0 || t === lt.TRUE) || (e === lt.SYM_FALSE && t === lt.FALSE || (e === lt.SYM_P && t === lt.P || (e === lt.SYM_L && t === lt.L || e === lt.SYM_A && t === lt.A))))
                    }
                    if ("string" == typeof arguments[0] && "string" == typeof arguments[1]) {
                        var i = arguments[0],
                            n = arguments[1],
                            r = new ce(i);
                        return r.matches(n)
                    }
                }, ce.isTrue = function(t) { return t >= 0 || t === lt.TRUE };
                var us = Object.freeze({ Coordinate: f, CoordinateList: E, Envelope: S, LineSegment: pe, GeometryFactory: ne, Geometry: B, Point: Ct, LineString: Nt, LinearRing: Tt, Polygon: It, GeometryCollection: ct, MultiPoint: kt, MultiLineString: ft, MultiPolygon: At, Dimension: lt, IntersectionMatrix: ce });
                e(fe.prototype, {
                    addPoint: function(t) { this.ptCount += 1, this.ptCentSum.x += t.x, this.ptCentSum.y += t.y },
                    setBasePoint: function(t) { null === this.areaBasePt && (this.areaBasePt = t) },
                    addLineSegments: function(t) {
                        for (var e = 0, i = 0; i < t.length - 1; i++) {
                            var n = t[i].distance(t[i + 1]);
                            if (0 !== n) {
                                e += n;
                                var r = (t[i].x + t[i + 1].x) / 2;
                                this.lineCentSum.x += n * r;
                                var o = (t[i].y + t[i + 1].y) / 2;
                                this.lineCentSum.y += n * o
                            }
                        }
                        this.totalLength += e, 0 === e && t.length > 0 && this.addPoint(t[0])
                    },
                    addHole: function(t) {
                        for (var e = ue.isCCW(t), i = 0; i < t.length - 1; i++) this.addTriangle(this.areaBasePt, t[i], t[i + 1], e);
                        this.addLineSegments(t)
                    },
                    getCentroid: function() {
                        var t = new f;
                        if (Math.abs(this.areasum2) > 0) t.x = this.cg3.x / 3 / this.areasum2, t.y = this.cg3.y / 3 / this.areasum2;
                        else if (this.totalLength > 0) t.x = this.lineCentSum.x / this.totalLength, t.y = this.lineCentSum.y / this.totalLength;
                        else {
                            if (!(this.ptCount > 0)) return null;
                            t.x = this.ptCentSum.x / this.ptCount, t.y = this.ptCentSum.y / this.ptCount
                        }
                        return t
                    },
                    addShell: function(t) {
                        t.length > 0 && this.setBasePoint(t[0]);
                        for (var e = !ue.isCCW(t), i = 0; i < t.length - 1; i++) this.addTriangle(this.areaBasePt, t[i], t[i + 1], e);
                        this.addLineSegments(t)
                    },
                    addTriangle: function(t, e, i, n) {
                        var r = n ? 1 : -1;
                        fe.centroid3(t, e, i, this.triangleCent3);
                        var o = fe.area2(t, e, i);
                        this.cg3.x += r * o * this.triangleCent3.x, this.cg3.y += r * o * this.triangleCent3.y, this.areasum2 += r * o
                    },
                    add: function() {
                        if (arguments[0] instanceof It) {
                            var t = arguments[0];
                            this.addShell(t.getExteriorRing().getCoordinates());
                            for (var e = 0; e < t.getNumInteriorRing(); e++) this.addHole(t.getInteriorRingN(e).getCoordinates())
                        } else if (arguments[0] instanceof B) {
                            var i = arguments[0];
                            if (i.isEmpty()) return null;
                            if (i instanceof Ct) this.addPoint(i.getCoordinate());
                            else if (i instanceof Nt) this.addLineSegments(i.getCoordinates());
                            else if (i instanceof It) {
                                var n = i;
                                this.add(n)
                            } else if (i instanceof ct)
                                for (var r = i, e = 0; e < r.getNumGeometries(); e++) this.add(r.getGeometryN(e))
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return fe }
                }), fe.area2 = function(t, e, i) { return (e.x - t.x) * (i.y - t.y) - (i.x - t.x) * (e.y - t.y) }, fe.centroid3 = function(t, e, i, n) { return n.x = t.x + e.x + i.x, n.y = t.y + e.y + i.y, null }, fe.getCentroid = function(t) { var e = new fe(t); return e.getCentroid() }, ge.prototype = new Error, ge.prototype.name = "EmptyStackException", de.prototype = new v, de.prototype.add = function(t) { return this.array_.push(t), !0 }, de.prototype.get = function(t) { if (0 > t || t >= this.size()) throw new IndexOutOfBoundsException; return this.array_[t] }, de.prototype.push = function(t) { return this.array_.push(t), t }, de.prototype.pop = function(t) { if (0 === this.array_.length) throw new ge; return this.array_.pop() }, de.prototype.peek = function() { if (0 === this.array_.length) throw new ge; return this.array_[this.array_.length - 1] }, de.prototype.empty = function() { return 0 === this.array_.length }, de.prototype.isEmpty = function() { return this.empty() }, de.prototype.search = function(t) { return this.array_.indexOf(t) }, de.prototype.size = function() { return this.array_.length }, de.prototype.toArray = function() { for (var t = [], e = 0, i = this.array_.length; i > e; e++) t.push(this.array_[e]); return t }, e(ye.prototype, { filter: function(t) { this.treeSet.contains(t) || (this.list.add(t), this.treeSet.add(t)) }, getCoordinates: function() { var t = new Array(this.list.size()).fill(null); return this.list.toArray(t) }, interfaces_: function() { return [j] }, getClass: function() { return ye } }), ye.filterCoordinates = function(t) { for (var e = new ye, i = 0; i < t.length; i++) e.filter(t[i]); return e.getCoordinates() }, e(me.prototype, {
                    preSort: function(t) { for (var e = null, i = 1; i < t.length; i++)(t[i].y < t[0].y || t[i].y === t[0].y && t[i].x < t[0].x) && (e = t[0], t[0] = t[i], t[i] = e); return ht.sort(t, 1, t.length, new ve(t[0])), t },
                    computeOctRing: function(t) {
                        var e = this.computeOctPts(t),
                            i = new E;
                        return i.add(e, !1), i.size() < 3 ? null : (i.closeRing(), i.toCoordinateArray())
                    },
                    lineOrPolygon: function(t) { if (t = this.cleanRing(t), 3 === t.length) return this.geomFactory.createLineString([t[0], t[1]]); var e = this.geomFactory.createLinearRing(t); return this.geomFactory.createPolygon(e, null) },
                    cleanRing: function(t) {
                        c.equals(t[0], t[t.length - 1]);
                        for (var e = new x, i = null, n = 0; n <= t.length - 2; n++) {
                            var r = t[n],
                                o = t[n + 1];
                            r.equals(o) || null !== i && this.isBetween(i, r, o) || (e.add(r), i = r)
                        }
                        e.add(t[t.length - 1]);
                        var s = new Array(e.size()).fill(null);
                        return e.toArray(s)
                    },
                    isBetween: function(t, e, i) { if (0 !== ue.computeOrientation(t, e, i)) return !1; if (t.x !== i.x) { if (t.x <= e.x && e.x <= i.x) return !0; if (i.x <= e.x && e.x <= t.x) return !0 } if (t.y !== i.y) { if (t.y <= e.y && e.y <= i.y) return !0; if (i.y <= e.y && e.y <= t.y) return !0 } return !1 },
                    reduce: function(t) { var e = this.computeOctRing(t); if (null === e) return t; for (var i = new at, n = 0; n < e.length; n++) i.add(e[n]); for (var n = 0; n < t.length; n++) ue.isPointInRing(t[n], e) || i.add(t[n]); var r = X.toCoordinateArray(i); return r.length < 3 ? this.padArray3(r) : r },
                    getConvexHull: function() {
                        if (0 === this.inputPts.length) return this.geomFactory.createGeometryCollection(null);
                        if (1 === this.inputPts.length) return this.geomFactory.createPoint(this.inputPts[0]);
                        if (2 === this.inputPts.length) return this.geomFactory.createLineString(this.inputPts);
                        var t = this.inputPts;
                        this.inputPts.length > 50 && (t = this.reduce(this.inputPts));
                        var e = this.preSort(t),
                            i = this.grahamScan(e),
                            n = this.toCoordinateArray(i);
                        return this.lineOrPolygon(n)
                    },
                    padArray3: function(t) { for (var e = new Array(3).fill(null), i = 0; i < e.length; i++) i < t.length ? e[i] = t[i] : e[i] = t[0]; return e },
                    computeOctPts: function(t) { for (var e = new Array(8).fill(null), i = 0; i < e.length; i++) e[i] = t[0]; for (var n = 1; n < t.length; n++) t[n].x < e[0].x && (e[0] = t[n]), t[n].x - t[n].y < e[1].x - e[1].y && (e[1] = t[n]), t[n].y > e[2].y && (e[2] = t[n]), t[n].x + t[n].y > e[3].x + e[3].y && (e[3] = t[n]), t[n].x > e[4].x && (e[4] = t[n]), t[n].x - t[n].y > e[5].x - e[5].y && (e[5] = t[n]), t[n].y < e[6].y && (e[6] = t[n]), t[n].x + t[n].y < e[7].x + e[7].y && (e[7] = t[n]); return e },
                    toCoordinateArray: function(t) {
                        for (var e = new Array(t.size()).fill(null), i = 0; i < t.size(); i++) {
                            var n = t.get(i);
                            e[i] = n
                        }
                        return e
                    },
                    grahamScan: function(t) {
                        var e = null,
                            i = new de;
                        e = i.push(t[0]), e = i.push(t[1]), e = i.push(t[2]);
                        for (var n = 3; n < t.length; n++) {
                            for (e = i.pop(); !i.empty() && ue.computeOrientation(i.peek(), e, t[n]) > 0;) e = i.pop();
                            e = i.push(e), e = i.push(t[n])
                        }
                        return e = i.push(t[0]), i
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return me }
                }), me.extractCoordinates = function(t) { var e = new ye; return t.apply(e), e.getCoordinates() }, e(ve.prototype, {
                    compare: function(t, e) {
                        var i = t,
                            n = e;
                        return ve.polarCompare(this.origin, i, n)
                    },
                    interfaces_: function() { return [a] },
                    getClass: function() { return ve }
                }), ve.polarCompare = function(t, e, i) {
                    var n = e.x - t.x,
                        r = e.y - t.y,
                        o = i.x - t.x,
                        s = i.y - t.y,
                        a = ue.computeOrientation(t, e, i);
                    if (a === ue.COUNTERCLOCKWISE) return 1;
                    if (a === ue.CLOCKWISE) return -1;
                    var h = n * n + r * r,
                        l = o * o + s * s;
                    return l > h ? -1 : h > l ? 1 : 0
                }, me.RadialComparator = ve, e(be.prototype, {
                    transformPoint: function(t, e) { return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t)) },
                    transformPolygon: function(t, e) {
                        var i = !0,
                            n = this.transformLinearRing(t.getExteriorRing(), t);
                        null !== n && n instanceof Tt && !n.isEmpty() || (i = !1);
                        for (var r = new x, o = 0; o < t.getNumInteriorRing(); o++) {
                            var s = this.transformLinearRing(t.getInteriorRingN(o), t);
                            null === s || s.isEmpty() || (s instanceof Tt || (i = !1), r.add(s))
                        }
                        if (i) return this.factory.createPolygon(n, r.toArray([]));
                        var a = new x;
                        return null !== n && a.add(n), a.addAll(r), this.factory.buildGeometry(a)
                    },
                    createCoordinateSequence: function(t) { return this.factory.getCoordinateSequenceFactory().create(t) },
                    getInputGeometry: function() { return this.inputGeom },
                    transformMultiLineString: function(t, e) {
                        for (var i = new x, n = 0; n < t.getNumGeometries(); n++) {
                            var r = this.transformLineString(t.getGeometryN(n), t);
                            null !== r && (r.isEmpty() || i.add(r))
                        }
                        return this.factory.buildGeometry(i)
                    },
                    transformCoordinates: function(t, e) { return this.copy(t) },
                    transformLineString: function(t, e) { return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t)) },
                    transformMultiPoint: function(t, e) {
                        for (var i = new x, n = 0; n < t.getNumGeometries(); n++) {
                            var r = this.transformPoint(t.getGeometryN(n), t);
                            null !== r && (r.isEmpty() || i.add(r))
                        }
                        return this.factory.buildGeometry(i)
                    },
                    transformMultiPolygon: function(t, e) {
                        for (var i = new x, n = 0; n < t.getNumGeometries(); n++) {
                            var r = this.transformPolygon(t.getGeometryN(n), t);
                            null !== r && (r.isEmpty() || i.add(r))
                        }
                        return this.factory.buildGeometry(i)
                    },
                    copy: function(t) { return t.copy() },
                    transformGeometryCollection: function(t, e) {
                        for (var i = new x, n = 0; n < t.getNumGeometries(); n++) {
                            var r = this.transform(t.getGeometryN(n));
                            null !== r && (this.pruneEmptyGeometry && r.isEmpty() || i.add(r))
                        }
                        return this.preserveGeometryCollectionType ? this.factory.createGeometryCollection(ne.toGeometryArray(i)) : this.factory.buildGeometry(i)
                    },
                    transform: function(t) { if (this.inputGeom = t, this.factory = t.getFactory(), t instanceof Ct) return this.transformPoint(t, null); if (t instanceof kt) return this.transformMultiPoint(t, null); if (t instanceof Tt) return this.transformLinearRing(t, null); if (t instanceof Nt) return this.transformLineString(t, null); if (t instanceof ft) return this.transformMultiLineString(t, null); if (t instanceof It) return this.transformPolygon(t, null); if (t instanceof At) return this.transformMultiPolygon(t, null); if (t instanceof ct) return this.transformGeometryCollection(t, null); throw new n("Unknown Geometry subtype: " + t.getClass().getName()) },
                    transformLinearRing: function(t, e) { var i = this.transformCoordinates(t.getCoordinateSequence(), t); if (null === i) return this.factory.createLinearRing(null); var n = i.size(); return n > 0 && 4 > n && !this.preserveType ? this.factory.createLineString(i) : this.factory.createLinearRing(i) },
                    interfaces_: function() { return [] },
                    getClass: function() { return be }
                }), e(we.prototype, {
                    snapVertices: function(t, e) {
                        for (var i = this._isClosed ? t.size() - 1 : t.size(), n = 0; i > n; n++) {
                            var r = t.get(n),
                                o = this.findSnapForVertex(r, e);
                            null !== o && (t.set(n, new f(o)), 0 === n && this._isClosed && t.set(t.size() - 1, new f(o)))
                        }
                    },
                    findSnapForVertex: function(t, e) { for (var i = 0; i < e.length; i++) { if (t.equals2D(e[i])) return null; if (t.distance(e[i]) < this.snapTolerance) return e[i] } return null },
                    snapTo: function(t) {
                        var e = new E(this.srcPts);
                        this.snapVertices(e, t), this.snapSegments(e, t);
                        var i = e.toCoordinateArray();
                        return i
                    },
                    snapSegments: function(t, e) {
                        if (0 === e.length) return null;
                        var i = e.length;
                        e[0].equals2D(e[e.length - 1]) && (i = e.length - 1);
                        for (var n = 0; i > n; n++) {
                            var r = e[n],
                                o = this.findSegmentIndexToSnap(r, t);
                            o >= 0 && t.add(o + 1, new f(r), !1)
                        }
                    },
                    findSegmentIndexToSnap: function(t, e) {
                        for (var i = r.MAX_VALUE, n = -1, o = 0; o < e.size() - 1; o++) {
                            if (this.seg.p0 = e.get(o), this.seg.p1 = e.get(o + 1), this.seg.p0.equals2D(t) || this.seg.p1.equals2D(t)) { if (this.allowSnappingToSourceVertices) continue; return -1 }
                            var s = this.seg.distance(t);
                            s < this.snapTolerance && i > s && (i = s, n = o)
                        }
                        return n
                    },
                    setAllowSnappingToSourceVertices: function(t) { this.allowSnappingToSourceVertices = t },
                    interfaces_: function() { return [] },
                    getClass: function() { return we }
                }), we.isClosed = function(t) { return !(t.length <= 1) && t[0].equals2D(t[t.length - 1]) }, e(xe.prototype, {
                    snapTo: function(t, e) {
                        var i = this.extractTargetCoordinates(t),
                            n = new Ee(e, i);
                        return n.transform(this.srcGeom)
                    },
                    snapToSelf: function(t, e) {
                        var i = this.extractTargetCoordinates(this.srcGeom),
                            n = new Ee(t, i, !0),
                            r = n.transform(this.srcGeom),
                            o = r;
                        return e && M(o, Mt) && (o = r.buffer(0)), o
                    },
                    computeSnapTolerance: function(t) {
                        var e = this.computeMinimumSegmentLength(t),
                            i = e / 10;
                        return i
                    },
                    extractTargetCoordinates: function(t) { for (var e = new at, i = t.getCoordinates(), n = 0; n < i.length; n++) e.add(i[n]); return e.toArray(new Array(0).fill(null)) },
                    computeMinimumSegmentLength: function(t) {
                        for (var e = r.MAX_VALUE, i = 0; i < t.length - 1; i++) {
                            var n = t[i].distance(t[i + 1]);
                            e > n && (e = n)
                        }
                        return e
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return xe }
                }), xe.snap = function(t, e, i) {
                    var n = new Array(2).fill(null),
                        r = new xe(t);
                    n[0] = r.snapTo(e, i);
                    var o = new xe(e);
                    return n[1] = o.snapTo(n[0], i), n
                }, xe.computeOverlaySnapTolerance = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = xe.computeSizeBasedSnapTolerance(t),
                            i = t.getPrecisionModel();
                        if (i.getType() === ee.FIXED) {
                            var n = 1 / i.getScale() * 2 / 1.415;
                            n > e && (e = n)
                        }
                        return e
                    }
                    if (2 === arguments.length) {
                        var r = arguments[0],
                            o = arguments[1];
                        return Math.min(xe.computeOverlaySnapTolerance(r), xe.computeOverlaySnapTolerance(o))
                    }
                }, xe.computeSizeBasedSnapTolerance = function(t) {
                    var e = t.getEnvelopeInternal(),
                        i = Math.min(e.getHeight(), e.getWidth()),
                        n = i * xe.SNAP_PRECISION_FACTOR;
                    return n
                }, xe.snapToSelf = function(t, e, i) { var n = new xe(t); return n.snapToSelf(e, i) }, xe.SNAP_PRECISION_FACTOR = 1e-9, u(Ee, be), e(Ee.prototype, {
                    snapLine: function(t, e) { var i = new we(t, this.snapTolerance); return i.setAllowSnappingToSourceVertices(this.isSelfSnap), i.snapTo(e) },
                    transformCoordinates: function(t, e) {
                        var i = t.toCoordinateArray(),
                            n = this.snapLine(i, this.snapPts);
                        return this.factory.getCoordinateSequenceFactory().create(n)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Ee }
                }), e(Se.prototype, {
                    getCommon: function() { return r.longBitsToDouble(this.commonBits) },
                    add: function(t) { var e = r.doubleToLongBits(t); if (this.isFirst) return this.commonBits = e, this.commonSignExp = Se.signExpBits(this.commonBits), this.isFirst = !1, null; var i = Se.signExpBits(e); return i !== this.commonSignExp ? (this.commonBits = 0, null) : (this.commonMantissaBitsCount = Se.numCommonMostSigMantissaBits(this.commonBits, e), void(this.commonBits = Se.zeroLowerBits(this.commonBits, 64 - (12 + this.commonMantissaBitsCount)))) },
                    toString: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0],
                                e = r.longBitsToDouble(t),
                                i = Long.toBinaryString(t),
                                n = "0000000000000000000000000000000000000000000000000000000000000000" + i,
                                o = n.substring(n.length - 64),
                                s = o.substring(0, 1) + "  " + o.substring(1, 12) + "(exp) " + o.substring(12) + " [ " + e + " ]";
                            return s
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Se }
                }), Se.getBit = function(t, e) { var i = 1 << e; return 0 !== (t & i) ? 1 : 0 }, Se.signExpBits = function(t) { return t >> 52 }, Se.zeroLowerBits = function(t, e) {
                    var i = (1 << e) - 1,
                        n = ~i,
                        r = t & n;
                    return r
                }, Se.numCommonMostSigMantissaBits = function(t, e) {
                    for (var i = 0, n = 52; n >= 0; n--) {
                        if (Se.getBit(t, n) !== Se.getBit(e, n)) return i;
                        i++
                    }
                    return 52
                }, e(Ne.prototype, {
                    addCommonBits: function(t) {
                        var e = new Ce(this.commonCoord);
                        t.apply(e), t.geometryChanged()
                    },
                    removeCommonBits: function(t) {
                        if (0 === this.commonCoord.x && 0 === this.commonCoord.y) return t;
                        var e = new f(this.commonCoord);
                        e.x = -e.x, e.y = -e.y;
                        var i = new Ce(e);
                        return t.apply(i), t.geometryChanged(), t
                    },
                    getCommonCoordinate: function() { return this.commonCoord },
                    add: function(t) { t.apply(this.ccFilter), this.commonCoord = this.ccFilter.getCommonCoordinate() },
                    interfaces_: function() { return [] },
                    getClass: function() { return Ne }
                }), e(Le.prototype, { filter: function(t) { this.commonBitsX.add(t.x), this.commonBitsY.add(t.y) }, getCommonCoordinate: function() { return new f(this.commonBitsX.getCommon(), this.commonBitsY.getCommon()) }, interfaces_: function() { return [j] }, getClass: function() { return Le } }), e(Ce.prototype, {
                    filter: function(t, e) {
                        var i = t.getOrdinate(e, 0) + this.trans.x,
                            n = t.getOrdinate(e, 1) + this.trans.y;
                        t.setOrdinate(e, 0, i), t.setOrdinate(e, 1, n)
                    },
                    isDone: function() { return !1 },
                    isGeometryChanged: function() { return !0 },
                    interfaces_: function() { return [pt] },
                    getClass: function() { return Ce }
                }), Ne.CommonCoordinateFilter = Le, Ne.Translater = Ce, e(Me.prototype, {
                    next: function() {
                        if (this.atStart) return this.atStart = !1, Me.isAtomic(this.parent) && this.index++, this.parent;
                        if (null !== this.subcollectionIterator) {
                            if (this.subcollectionIterator.hasNext()) return this.subcollectionIterator.next();
                            this.subcollectionIterator = null
                        }
                        if (this.index >= this.max) throw new b;
                        var t = this.parent.getGeometryN(this.index++);
                        return t instanceof ct ? (this.subcollectionIterator = new Me(t), this.subcollectionIterator.next()) : t
                    },
                    remove: function() { throw new UnsupportedOperationException(this.getClass().getName()) },
                    hasNext: function() {
                        if (this.atStart) return !0;
                        if (null !== this.subcollectionIterator) {
                            if (this.subcollectionIterator.hasNext()) return !0;
                            this.subcollectionIterator = null
                        }
                        return !(this.index >= this.max)
                    },
                    interfaces_: function() { return [d] },
                    getClass: function() { return Me }
                }), Me.isAtomic = function(t) { return !(t instanceof ct) }, e(Ie.prototype, {
                    locateInternal: function() {
                        if (arguments[0] instanceof f && arguments[1] instanceof It) {
                            var t = arguments[0],
                                e = arguments[1];
                            if (e.isEmpty()) return C.EXTERIOR;
                            var i = e.getExteriorRing(),
                                n = this.locateInPolygonRing(t, i);
                            if (n === C.EXTERIOR) return C.EXTERIOR;
                            if (n === C.BOUNDARY) return C.BOUNDARY;
                            for (var r = 0; r < e.getNumInteriorRing(); r++) {
                                var o = e.getInteriorRingN(r),
                                    s = this.locateInPolygonRing(t, o);
                                if (s === C.INTERIOR) return C.EXTERIOR;
                                if (s === C.BOUNDARY) return C.BOUNDARY
                            }
                            return C.INTERIOR
                        }
                        if (arguments[0] instanceof f && arguments[1] instanceof Nt) {
                            var a = arguments[0],
                                h = arguments[1];
                            if (!h.getEnvelopeInternal().intersects(a)) return C.EXTERIOR;
                            var l = h.getCoordinates();
                            return h.isClosed() || !a.equals(l[0]) && !a.equals(l[l.length - 1]) ? ue.isOnLine(a, l) ? C.INTERIOR : C.EXTERIOR : C.BOUNDARY
                        }
                        if (arguments[0] instanceof f && arguments[1] instanceof Ct) {
                            var u = arguments[0],
                                p = arguments[1],
                                c = p.getCoordinate();
                            return c.equals2D(u) ? C.INTERIOR : C.EXTERIOR
                        }
                    },
                    locateInPolygonRing: function(t, e) { return e.getEnvelopeInternal().intersects(t) ? ue.locatePointInRing(t, e.getCoordinates()) : C.EXTERIOR },
                    intersects: function(t, e) { return this.locate(t, e) !== C.EXTERIOR },
                    updateLocationInfo: function(t) { t === C.INTERIOR && (this.isIn = !0), t === C.BOUNDARY && this.numBoundaries++ },
                    computeLocation: function(t, e) {
                        if (e instanceof Ct && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof Nt) this.updateLocationInfo(this.locateInternal(t, e));
                        else if (e instanceof It) this.updateLocationInfo(this.locateInternal(t, e));
                        else if (e instanceof ft)
                            for (var i = e, n = 0; n < i.getNumGeometries(); n++) {
                                var r = i.getGeometryN(n);
                                this.updateLocationInfo(this.locateInternal(t, r))
                            } else if (e instanceof At)
                                for (var o = e, n = 0; n < o.getNumGeometries(); n++) {
                                    var s = o.getGeometryN(n);
                                    this.updateLocationInfo(this.locateInternal(t, s))
                                } else if (e instanceof ct)
                                    for (var a = new Me(e); a.hasNext();) {
                                        var h = a.next();
                                        h !== e && this.computeLocation(t, h)
                                    }
                    },
                    locate: function(t, e) { return e.isEmpty() ? C.EXTERIOR : e instanceof Nt ? this.locateInternal(t, e) : e instanceof It ? this.locateInternal(t, e) : (this.isIn = !1, this.numBoundaries = 0, this.computeLocation(t, e), this.boundaryRule.isInBoundary(this.numBoundaries) ? C.BOUNDARY : this.numBoundaries > 0 || this.isIn ? C.INTERIOR : C.EXTERIOR) },
                    interfaces_: function() { return [] },
                    getClass: function() { return Ie }
                }), e(ke.prototype, { interfaces_: function() { return [] }, getClass: function() { return ke } }), ke.octant = function() {
                    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                        var t = arguments[0],
                            e = arguments[1];
                        if (0 === t && 0 === e) throw new n("Cannot compute the octant for point ( " + t + ", " + e + " )");
                        var i = Math.abs(t),
                            r = Math.abs(e);
                        return t >= 0 ? e >= 0 ? i >= r ? 0 : 1 : i >= r ? 7 : 6 : e >= 0 ? i >= r ? 3 : 2 : i >= r ? 4 : 5
                    }
                    if (arguments[0] instanceof f && arguments[1] instanceof f) {
                        var o = arguments[0],
                            s = arguments[1],
                            a = s.x - o.x,
                            h = s.y - o.y;
                        if (0 === a && 0 === h) throw new n("Cannot compute the octant for two identical points " + o);
                        return ke.octant(a, h)
                    }
                }, e(Te.prototype, { getCoordinates: function() {}, size: function() {}, getCoordinate: function(t) {}, isClosed: function() {}, setData: function(t) {}, getData: function() {}, interfaces_: function() { return [] }, getClass: function() { return Te } }), e(Ae.prototype, { getCoordinates: function() { return this.pts }, size: function() { return this.pts.length }, getCoordinate: function(t) { return this.pts[t] }, isClosed: function() { return this.pts[0].equals(this.pts[this.pts.length - 1]) }, getSegmentOctant: function(t) { return t === this.pts.length - 1 ? -1 : ke.octant(this.getCoordinate(t), this.getCoordinate(t + 1)) }, setData: function(t) { this.data = t }, getData: function() { return this.data }, toString: function() { return oe.toLineString(new Ft(this.pts)) }, interfaces_: function() { return [Te] }, getClass: function() { return Ae } }), e(Re.prototype, { getBounds: function() {}, interfaces_: function() { return [] }, getClass: function() { return Re } }), e(_e.prototype, { getItem: function() { return this.item }, getBounds: function() { return this.bounds }, interfaces_: function() { return [Re, h] }, getClass: function() { return _e } }), e(Pe.prototype, {
                    poll: function() { if (this.isEmpty()) return null; var t = this.items.get(1); return this.items.set(1, this.items.get(this._size)), this._size -= 1, this.reorder(1), t },
                    size: function() { return this._size },
                    reorder: function(t) {
                        for (var e = null, i = this.items.get(t); 2 * t <= this._size && (e = 2 * t, e !== this._size && this.items.get(e + 1).compareTo(this.items.get(e)) < 0 && e++, this.items.get(e).compareTo(i) < 0); t = e) this.items.set(t, this.items.get(e));
                        this.items.set(t, i)
                    },
                    clear: function() { this._size = 0, this.items.clear() },
                    isEmpty: function() { return 0 === this._size },
                    add: function(t) {
                        this.items.add(null), this._size += 1;
                        var e = this._size;
                        for (this.items.set(0, t); t.compareTo(this.items.get(Math.trunc(e / 2))) < 0; e /= 2) this.items.set(e, this.items.get(Math.trunc(e / 2)));
                        this.items.set(e, t)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Pe }
                }), e(Oe.prototype, { visitItem: function(t) {}, interfaces_: function() { return [] }, getClass: function() { return Oe } }), e(De.prototype, { insert: function(t, e) {}, remove: function(t, e) {}, query: function() { 1 === arguments.length ? arguments[0] : 2 === arguments.length && (arguments[0], arguments[1]) }, interfaces_: function() { return [] }, getClass: function() { return De } }), e(Fe.prototype, { getLevel: function() { return this.level }, size: function() { return this.childBoundables.size() }, getChildBoundables: function() { return this.childBoundables }, addChildBoundable: function(t) { c.isTrue(null === this.bounds), this.childBoundables.add(t) }, isEmpty: function() { return this.childBoundables.isEmpty() }, getBounds: function() { return null === this.bounds && (this.bounds = this.computeBounds()), this.bounds }, interfaces_: function() { return [Re, h] }, getClass: function() { return Fe } }), Fe.serialVersionUID = 0x5a1e55ec41369800;
                var ps = {
                    reverseOrder: function() { return { compare: function(t, e) { return e.compareTo(t) } } },
                    min: function(t) { return ps.sort(t), t.get(0) },
                    sort: function(t, e) {
                        var i = t.toArray();
                        e ? ht.sort(i, e) : ht.sort(i);
                        for (var n = t.iterator(), r = 0, o = i.length; o > r; r++) n.next(), n.set(i[r])
                    },
                    singletonList: function(t) { var e = new x; return e.add(t), e }
                };
                e(Ue.prototype, {
                    expandToQueue: function(t, e) {
                        var i = Ue.isComposite(this.boundable1),
                            r = Ue.isComposite(this.boundable2);
                        if (i && r) return Ue.area(this.boundable1) > Ue.area(this.boundable2) ? (this.expand(this.boundable1, this.boundable2, t, e), null) : (this.expand(this.boundable2, this.boundable1, t, e), null);
                        if (i) return this.expand(this.boundable1, this.boundable2, t, e), null;
                        if (r) return this.expand(this.boundable2, this.boundable1, t, e), null;
                        throw new n("neither boundable is composite")
                    },
                    isLeaves: function() { return !(Ue.isComposite(this.boundable1) || Ue.isComposite(this.boundable2)) },
                    compareTo: function(t) { var e = t; return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0 },
                    expand: function(t, e, i, n) {
                        for (var r = t.getChildBoundables(), o = r.iterator(); o.hasNext();) {
                            var s = o.next(),
                                a = new Ue(s, e, this.itemDistance);
                            a.getDistance() < n && i.add(a)
                        }
                    },
                    getBoundable: function(t) { return 0 === t ? this.boundable1 : this.boundable2 },
                    getDistance: function() { return this._distance },
                    distance: function() { return this.isLeaves() ? this.itemDistance.distance(this.boundable1, this.boundable2) : this.boundable1.getBounds().distance(this.boundable2.getBounds()) },
                    interfaces_: function() { return [o] },
                    getClass: function() { return Ue }
                }), Ue.area = function(t) { return t.getBounds().getArea() }, Ue.isComposite = function(t) { return t instanceof Fe }, e(Be.prototype, {
                    getNodeCapacity: function() { return this.nodeCapacity },
                    lastNode: function(t) { return t.get(t.size() - 1) },
                    size: function t() {
                        if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this.root));
                        if (1 === arguments.length) {
                            for (var e = arguments[0], t = 0, i = e.getChildBoundables().iterator(); i.hasNext();) {
                                var n = i.next();
                                n instanceof Fe ? t += this.size(n) : n instanceof _e && (t += 1)
                            }
                            return t
                        }
                    },
                    removeItem: function(t, e) {
                        for (var i = null, n = t.getChildBoundables().iterator(); n.hasNext();) {
                            var r = n.next();
                            r instanceof _e && r.getItem() === e && (i = r)
                        }
                        return null !== i && (t.getChildBoundables().remove(i), !0)
                    },
                    itemsTree: function() {
                        if (0 === arguments.length) { this.build(); var t = this.itemsTree(this.root); return null === t ? new x : t }
                        if (1 === arguments.length) {
                            for (var e = arguments[0], i = new x, n = e.getChildBoundables().iterator(); n.hasNext();) {
                                var r = n.next();
                                if (r instanceof Fe) {
                                    var o = this.itemsTree(r);
                                    null !== o && i.add(o)
                                } else r instanceof _e ? i.add(r.getItem()) : c.shouldNeverReachHere()
                            }
                            return i.size() <= 0 ? null : i
                        }
                    },
                    insert: function(t, e) { c.isTrue(!this.built, "Cannot insert items into an STR packed R-tree after it has been built."), this.itemBoundables.add(new _e(t, e)) },
                    boundablesAtLevel: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0],
                                e = new x;
                            return this.boundablesAtLevel(t, this.root, e), e
                        }
                        if (3 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1],
                                r = arguments[2];
                            if (c.isTrue(i > -2), n.getLevel() === i) return r.add(n), null;
                            for (var o = n.getChildBoundables().iterator(); o.hasNext();) {
                                var s = o.next();
                                s instanceof Fe ? this.boundablesAtLevel(i, s, r) : (c.isTrue(s instanceof _e), -1 === i && r.add(s))
                            }
                            return null
                        }
                    },
                    query: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.build();
                            var e = new x;
                            return this.isEmpty() ? e : (this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.query(t, this.root, e), e)
                        }
                        if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1];
                            if (this.build(), this.isEmpty()) return null;
                            this.getIntersectsOp().intersects(this.root.getBounds(), i) && this.query(i, this.root, n)
                        } else if (3 === arguments.length)
                            if (M(arguments[2], Oe) && arguments[0] instanceof Object && arguments[1] instanceof Fe)
                                for (var r = arguments[0], o = arguments[1], s = arguments[2], a = o.getChildBoundables(), h = 0; h < a.size(); h++) {
                                    var l = a.get(h);
                                    this.getIntersectsOp().intersects(l.getBounds(), r) && (l instanceof Fe ? this.query(r, l, s) : l instanceof _e ? s.visitItem(l.getItem()) : c.shouldNeverReachHere())
                                } else if (M(arguments[2], v) && arguments[0] instanceof Object && arguments[1] instanceof Fe)
                                    for (var u = arguments[0], p = arguments[1], f = arguments[2], a = p.getChildBoundables(), h = 0; h < a.size(); h++) {
                                        var l = a.get(h);
                                        this.getIntersectsOp().intersects(l.getBounds(), u) && (l instanceof Fe ? this.query(u, l, f) : l instanceof _e ? f.add(l.getItem()) : c.shouldNeverReachHere())
                                    }
                    },
                    build: function() { return this.built ? null : (this.root = this.itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this.itemBoundables, -1), this.itemBoundables = null, void(this.built = !0)) },
                    getRoot: function() { return this.build(), this.root },
                    remove: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            return this.build(), !!this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.remove(t, this.root, e)
                        }
                        if (3 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1],
                                r = arguments[2],
                                o = this.removeItem(n, r);
                            if (o) return !0;
                            for (var s = null, a = n.getChildBoundables().iterator(); a.hasNext();) { var h = a.next(); if (this.getIntersectsOp().intersects(h.getBounds(), i) && h instanceof Fe && (o = this.remove(i, h, r))) { s = h; break } }
                            return null !== s && s.getChildBoundables().isEmpty() && n.getChildBoundables().remove(s), o
                        }
                    },
                    createHigherLevels: function(t, e) { c.isTrue(!t.isEmpty()); var i = this.createParentBoundables(t, e + 1); return 1 === i.size() ? i.get(0) : this.createHigherLevels(i, e + 1) },
                    depth: function() {
                        if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this.root));
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = 0, i = t.getChildBoundables().iterator(); i.hasNext();) {
                                var n = i.next();
                                if (n instanceof Fe) {
                                    var r = this.depth(n);
                                    r > e && (e = r)
                                }
                            }
                            return e + 1
                        }
                    },
                    createParentBoundables: function(t, e) {
                        c.isTrue(!t.isEmpty());
                        var i = new x;
                        i.add(this.createNode(e));
                        var n = new x(t);
                        ps.sort(n, this.getComparator());
                        for (var r = n.iterator(); r.hasNext();) {
                            var o = r.next();
                            this.lastNode(i).getChildBoundables().size() === this.getNodeCapacity() && i.add(this.createNode(e)), this.lastNode(i).addChildBoundable(o)
                        }
                        return i
                    },
                    isEmpty: function() { return this.built ? this.root.isEmpty() : this.itemBoundables.isEmpty() },
                    interfaces_: function() { return [h] },
                    getClass: function() { return Be }
                }), Be.compareDoubles = function(t, e) { return t > e ? 1 : e > t ? -1 : 0 }, Be.IntersectsOp = je, Be.serialVersionUID = -0x35ef64c82d4c5400, Be.DEFAULT_NODE_CAPACITY = 10, e(ze.prototype, { distance: function(t, e) {}, interfaces_: function() { return [] }, getClass: function() { return ze } }), u(Ge, Be), e(Ge.prototype, {
                    createParentBoundablesFromVerticalSlices: function(t, e) { c.isTrue(t.length > 0); for (var i = new x, n = 0; n < t.length; n++) i.addAll(this.createParentBoundablesFromVerticalSlice(t[n], e)); return i },
                    createNode: function(t) { return new qe(t) },
                    size: function() { return 0 === arguments.length ? Be.prototype.size.call(this) : Be.prototype.size.apply(this, arguments) },
                    insert: function() {
                        if (2 !== arguments.length) return Be.prototype.insert.apply(this, arguments);
                        var t = arguments[0],
                            e = arguments[1];
                        return t.isNull() ? null : void Be.prototype.insert.call(this, t, e)
                    },
                    getIntersectsOp: function() { return Ge.intersectsOp },
                    verticalSlices: function(t, e) {
                        for (var i = Math.trunc(Math.ceil(t.size() / e)), n = new Array(e).fill(null), r = t.iterator(), o = 0; e > o; o++) {
                            n[o] = new x;
                            for (var s = 0; r.hasNext() && i > s;) {
                                var a = r.next();
                                n[o].add(a), s++
                            }
                        }
                        return n
                    },
                    query: function() {
                        if (1 === arguments.length) { var t = arguments[0]; return Be.prototype.query.call(this, t) }
                        if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1];
                            Be.prototype.query.call(this, e, i)
                        } else if (3 === arguments.length)
                            if (M(arguments[2], Oe) && arguments[0] instanceof Object && arguments[1] instanceof Fe) {
                                var n = arguments[0],
                                    r = arguments[1],
                                    o = arguments[2];
                                Be.prototype.query.call(this, n, r, o)
                            } else if (M(arguments[2], v) && arguments[0] instanceof Object && arguments[1] instanceof Fe) {
                            var s = arguments[0],
                                a = arguments[1],
                                h = arguments[2];
                            Be.prototype.query.call(this, s, a, h)
                        }
                    },
                    getComparator: function() { return Ge.yComparator },
                    createParentBoundablesFromVerticalSlice: function(t, e) { return Be.prototype.createParentBoundables.call(this, t, e) },
                    remove: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            return Be.prototype.remove.call(this, t, e)
                        }
                        return Be.prototype.remove.apply(this, arguments)
                    },
                    depth: function() { return 0 === arguments.length ? Be.prototype.depth.call(this) : Be.prototype.depth.apply(this, arguments) },
                    createParentBoundables: function(t, e) {
                        c.isTrue(!t.isEmpty());
                        var i = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),
                            n = new x(t);
                        ps.sort(n, Ge.xComparator);
                        var r = this.verticalSlices(n, Math.trunc(Math.ceil(Math.sqrt(i))));
                        return this.createParentBoundablesFromVerticalSlices(r, e)
                    },
                    nearestNeighbour: function() {
                        if (1 === arguments.length) {
                            if (M(arguments[0], ze)) {
                                var t = arguments[0],
                                    e = new Ue(this.getRoot(), this.getRoot(), t);
                                return this.nearestNeighbour(e)
                            }
                            if (arguments[0] instanceof Ue) { var i = arguments[0]; return this.nearestNeighbour(i, r.POSITIVE_INFINITY) }
                        } else if (2 === arguments.length) {
                            if (arguments[0] instanceof Ge && M(arguments[1], ze)) {
                                var n = arguments[0],
                                    o = arguments[1],
                                    e = new Ue(this.getRoot(), n.getRoot(), o);
                                return this.nearestNeighbour(e)
                            }
                            if (arguments[0] instanceof Ue && "number" == typeof arguments[1]) {
                                var s = arguments[0],
                                    a = arguments[1],
                                    h = a,
                                    l = null,
                                    u = new Pe;
                                for (u.add(s); !u.isEmpty() && h > 0;) {
                                    var p = u.poll(),
                                        c = p.getDistance();
                                    if (c >= h) break;
                                    p.isLeaves() ? (h = c, l = p) : p.expandToQueue(u, h)
                                }
                                return [l.getBoundable(0).getItem(), l.getBoundable(1).getItem()]
                            }
                        } else if (3 === arguments.length) {
                            var f = arguments[0],
                                g = arguments[1],
                                d = arguments[2],
                                y = new _e(f, g),
                                e = new Ue(this.getRoot(), y, d);
                            return this.nearestNeighbour(e)[0]
                        }
                    },
                    interfaces_: function() { return [De, h] },
                    getClass: function() { return Ge }
                }), Ge.centreX = function(t) { return Ge.avg(t.getMinX(), t.getMaxX()) }, Ge.avg = function(t, e) { return (t + e) / 2 }, Ge.centreY = function(t) { return Ge.avg(t.getMinY(), t.getMaxY()) }, u(qe, Fe), e(qe.prototype, {
                    computeBounds: function() {
                        for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {
                            var i = e.next();
                            null === t ? t = new S(i.getBounds()) : t.expandToInclude(i.getBounds())
                        }
                        return t
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return qe }
                }), Ge.STRtreeNode = qe, Ge.serialVersionUID = 0x39920f7d5f261e0, Ge.xComparator = { interfaces_: function() { return [a] }, compare: function(t, e) { return Be.compareDoubles(Ge.centreX(t.getBounds()), Ge.centreX(e.getBounds())) } }, Ge.yComparator = { interfaces_: function() { return [a] }, compare: function(t, e) { return Be.compareDoubles(Ge.centreY(t.getBounds()), Ge.centreY(e.getBounds())) } }, Ge.intersectsOp = { interfaces_: function() { return [IntersectsOp] }, intersects: function(t, e) { return t.intersects(e) } }, Ge.DEFAULT_NODE_CAPACITY = 10, e(Ve.prototype, { interfaces_: function() { return [] }, getClass: function() { return Ve } }), Ve.relativeSign = function(t, e) { return e > t ? -1 : t > e ? 1 : 0 }, Ve.compare = function(t, e, i) {
                    if (e.equals2D(i)) return 0;
                    var n = Ve.relativeSign(e.x, i.x),
                        r = Ve.relativeSign(e.y, i.y);
                    switch (t) {
                        case 0:
                            return Ve.compareValue(n, r);
                        case 1:
                            return Ve.compareValue(r, n);
                        case 2:
                            return Ve.compareValue(r, -n);
                        case 3:
                            return Ve.compareValue(-n, r);
                        case 4:
                            return Ve.compareValue(-n, -r);
                        case 5:
                            return Ve.compareValue(-r, -n);
                        case 6:
                            return Ve.compareValue(-r, n);
                        case 7:
                            return Ve.compareValue(n, -r)
                    }
                    return c.shouldNeverReachHere("invalid octant value"), 0
                }, Ve.compareValue = function(t, e) { return 0 > t ? -1 : t > 0 ? 1 : 0 > e ? -1 : e > 0 ? 1 : 0 }, e(We.prototype, { getCoordinate: function() { return this.coord }, print: function(t) { t.print(this.coord), t.print(" seg # = " + this.segmentIndex) }, compareTo: function(t) { var e = t; return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : Ve.compare(this.segmentOctant, this.coord, e.coord) }, isEndPoint: function(t) { return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t }, isInterior: function() { return this._isInterior }, interfaces_: function() { return [o] }, getClass: function() { return We } }), e(Xe.prototype, {
                    getSplitCoordinates: function() {
                        var t = new E;
                        this.addEndpoints();
                        for (var e = this.iterator(), i = e.next(); e.hasNext();) {
                            var n = e.next();
                            this.addEdgeCoordinates(i, n, t), i = n
                        }
                        return t.toCoordinateArray()
                    },
                    addCollapsedNodes: function() {
                        var t = new x;
                        this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);
                        for (var e = t.iterator(); e.hasNext();) {
                            var i = e.next().intValue();
                            this.add(this.edge.getCoordinate(i), i)
                        }
                    },
                    print: function(t) {
                        t.println("Intersections:");
                        for (var e = this.iterator(); e.hasNext();) {
                            var i = e.next();
                            i.print(t)
                        }
                    },
                    findCollapsesFromExistingVertices: function(t) {
                        for (var e = 0; e < this.edge.size() - 2; e++) {
                            var i = this.edge.getCoordinate(e),
                                n = (this.edge.getCoordinate(e + 1), this.edge.getCoordinate(e + 2));
                            i.equals2D(n) && t.add(new T(e + 1))
                        }
                    },
                    addEdgeCoordinates: function(t, e, i) {
                        var n = e.segmentIndex - t.segmentIndex + 2,
                            r = this.edge.getCoordinate(e.segmentIndex),
                            o = e.isInterior() || !e.coord.equals2D(r);
                        o || n--, i.add(new f(t.coord), !1);
                        for (var s = t.segmentIndex + 1; s <= e.segmentIndex; s++) i.add(this.edge.getCoordinate(s));
                        o && i.add(new f(e.coord))
                    },
                    iterator: function() { return this.nodeMap.values().iterator() },
                    addSplitEdges: function(t) {
                        this.addEndpoints(), this.addCollapsedNodes();
                        for (var e = this.iterator(), i = e.next(); e.hasNext();) {
                            var n = e.next(),
                                r = this.createSplitEdge(i, n);
                            t.add(r), i = n
                        }
                    },
                    findCollapseIndex: function(t, e, i) { if (!t.coord.equals2D(e.coord)) return !1; var n = e.segmentIndex - t.segmentIndex; return e.isInterior() || n--, 1 === n && (i[0] = t.segmentIndex + 1, !0) },
                    findCollapsesFromInsertedNodes: function(t) {
                        for (var e = new Array(1).fill(null), i = this.iterator(), n = i.next(); i.hasNext();) {
                            var r = i.next(),
                                o = this.findCollapseIndex(n, r, e);
                            o && t.add(new T(e[0])), n = r
                        }
                    },
                    getEdge: function() { return this.edge },
                    addEndpoints: function() {
                        var t = this.edge.size() - 1;
                        this.add(this.edge.getCoordinate(0), 0), this.add(this.edge.getCoordinate(t), t)
                    },
                    createSplitEdge: function(t, e) {
                        var i = e.segmentIndex - t.segmentIndex + 2,
                            n = this.edge.getCoordinate(e.segmentIndex),
                            r = e.isInterior() || !e.coord.equals2D(n);
                        r || i--;
                        var o = new Array(i).fill(null),
                            s = 0;
                        o[s++] = new f(t.coord);
                        for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this.edge.getCoordinate(a);
                        return r && (o[s] = new f(e.coord)), new Ke(o, this.edge.getData())
                    },
                    add: function(t, e) {
                        var i = new We(this.edge, t, e, this.edge.getSegmentOctant(e)),
                            n = this.nodeMap.get(i);
                        return null !== n ? (c.isTrue(n.coord.equals2D(t), "Found equal nodes with different coordinates"), n) : (this.nodeMap.put(i, i), i)
                    },
                    checkSplitEdgesCorrectness: function(t) {
                        var e = this.edge.getCoordinates(),
                            i = t.get(0),
                            n = i.getCoordinate(0);
                        if (!n.equals2D(e[0])) throw new l("bad split edge start point at " + n);
                        var r = t.get(t.size() - 1),
                            o = r.getCoordinates(),
                            s = o[o.length - 1];
                        if (!s.equals2D(e[e.length - 1])) throw new l("bad split edge end point at " + s)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Xe }
                }), e(He.prototype, { next: function() { return null === this.currNode ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : null === this.nextNode ? null : this.nextNode.segmentIndex === this.currNode.segmentIndex ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : (this.nextNode.segmentIndex > this.currNode.segmentIndex, null) }, remove: function() { throw new UnsupportedOperationException(this.getClass().getName()) }, hasNext: function() { return null !== this.nextNode }, readNextNode: function() { this.nodeIt.hasNext() ? this.nextNode = this.nodeIt.next() : this.nextNode = null }, interfaces_: function() { return [d] }, getClass: function() { return He } }), e(Ye.prototype, { addIntersection: function(t, e) {}, interfaces_: function() { return [Te] }, getClass: function() { return Ye } }), e(Ke.prototype, {
                    getCoordinates: function() { return this.pts },
                    size: function() { return this.pts.length },
                    getCoordinate: function(t) { return this.pts[t] },
                    isClosed: function() { return this.pts[0].equals(this.pts[this.pts.length - 1]) },
                    getSegmentOctant: function(t) { return t === this.pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1)) },
                    setData: function(t) { this.data = t },
                    safeOctant: function(t, e) { return t.equals2D(e) ? 0 : ke.octant(t, e) },
                    getData: function() { return this.data },
                    addIntersection: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            this.addIntersectionNode(t, e)
                        } else if (4 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1],
                                r = (arguments[2], arguments[3]),
                                o = new f(i.getIntersection(r));
                            this.addIntersection(o, n)
                        }
                    },
                    toString: function() { return oe.toLineString(new Ft(this.pts)) },
                    getNodeList: function() { return this.nodeList },
                    addIntersectionNode: function(t, e) {
                        var i = e,
                            n = i + 1;
                        if (n < this.pts.length) {
                            var r = this.pts[n];
                            t.equals2D(r) && (i = n)
                        }
                        var o = this.nodeList.add(t, i);
                        return o
                    },
                    addIntersections: function(t, e, i) { for (var n = 0; n < t.getIntersectionNum(); n++) this.addIntersection(t, e, i, n) },
                    interfaces_: function() { return [Ye] },
                    getClass: function() { return Ke }
                }), Ke.getNodedSubstrings = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = new x;
                        return Ke.getNodedSubstrings(t, e), e
                    }
                    if (2 === arguments.length)
                        for (var i = arguments[0], n = arguments[1], r = i.iterator(); r.hasNext();) {
                            var o = r.next();
                            o.getNodeList().addSplitEdges(n)
                        }
                }, e($e.prototype, {
                    overlap: function() {
                        if (2 === arguments.length) arguments[0], arguments[1];
                        else if (4 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1],
                                i = arguments[2],
                                n = arguments[3];
                            t.getLineSegment(e, this.overlapSeg1), i.getLineSegment(n, this.overlapSeg2), this.overlap(this.overlapSeg1, this.overlapSeg2)
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return $e }
                }), e(Ze.prototype, {
                    getLineSegment: function(t, e) { e.p0 = this.pts[t], e.p1 = this.pts[t + 1] },
                    computeSelect: function(t, e, i, n) {
                        var r = this.pts[e],
                            o = this.pts[i];
                        if (n.tempEnv1.init(r, o), i - e === 1) return n.select(this, e), null;
                        if (!t.intersects(n.tempEnv1)) return null;
                        var s = Math.trunc((e + i) / 2);
                        s > e && this.computeSelect(t, e, s, n), i > s && this.computeSelect(t, s, i, n)
                    },
                    getCoordinates: function() { for (var t = new Array(this.end - this.start + 1).fill(null), e = 0, i = this.start; i <= this.end; i++) t[e++] = this.pts[i]; return t },
                    computeOverlaps: function(t, e) { this.computeOverlapsInternal(this.start, this.end, t, t.start, t.end, e) },
                    setId: function(t) { this.id = t },
                    select: function(t, e) { this.computeSelect(t, this.start, this.end, e) },
                    getEnvelope: function() {
                        if (null === this.env) {
                            var t = this.pts[this.start],
                                e = this.pts[this.end];
                            this.env = new S(t, e)
                        }
                        return this.env
                    },
                    getEndIndex: function() { return this.end },
                    getStartIndex: function() { return this.start },
                    getContext: function() { return this.context },
                    getId: function() { return this.id },
                    computeOverlapsInternal: function(t, e, i, n, r, o) {
                        var s = this.pts[t],
                            a = this.pts[e],
                            h = i.pts[n],
                            l = i.pts[r];
                        if (e - t === 1 && r - n === 1) return o.overlap(this, t, i, n), null;
                        if (o.tempEnv1.init(s, a), o.tempEnv2.init(h, l), !o.tempEnv1.intersects(o.tempEnv2)) return null;
                        var u = Math.trunc((t + e) / 2),
                            p = Math.trunc((n + r) / 2);
                        u > t && (p > n && this.computeOverlapsInternal(t, u, i, n, p, o), r > p && this.computeOverlapsInternal(t, u, i, p, r, o)), e > u && (p > n && this.computeOverlapsInternal(u, e, i, n, p, o), r > p && this.computeOverlapsInternal(u, e, i, p, r, o))
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Ze }
                }), e(Je.prototype, { interfaces_: function() { return [] }, getClass: function() { return Je } }), Je.isNorthern = function(t) { return t === Je.NE || t === Je.NW }, Je.isOpposite = function(t, e) { if (t === e) return !1; var i = (t - e + 4) % 4; return 2 === i }, Je.commonHalfPlane = function(t, e) {
                    if (t === e) return t;
                    var i = (t - e + 4) % 4;
                    if (2 === i) return -1;
                    var n = e > t ? t : e,
                        r = t > e ? t : e;
                    return 0 === n && 3 === r ? 3 : n
                }, Je.isInHalfPlane = function(t, e) { return e === Je.SE ? t === Je.SE || t === Je.SW : t === e || t === e + 1 }, Je.quadrant = function() {
                    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                        var t = arguments[0],
                            e = arguments[1];
                        if (0 === t && 0 === e) throw new n("Cannot compute the quadrant for point ( " + t + ", " + e + " )");
                        return t >= 0 ? e >= 0 ? Je.NE : Je.SE : e >= 0 ? Je.NW : Je.SW
                    }
                    if (arguments[0] instanceof f && arguments[1] instanceof f) {
                        var i = arguments[0],
                            r = arguments[1];
                        if (r.x === i.x && r.y === i.y) throw new n("Cannot compute the quadrant for two identical points " + i);
                        return r.x >= i.x ? r.y >= i.y ? Je.NE : Je.SE : r.y >= i.y ? Je.NW : Je.SW
                    }
                }, Je.NE = 0, Je.NW = 1, Je.SW = 2, Je.SE = 3, e(Qe.prototype, { interfaces_: function() { return [] }, getClass: function() { return Qe } }), Qe.getChainStartIndices = function(t) {
                    var e = 0,
                        i = new x;
                    i.add(new T(e));
                    do {
                        var n = Qe.findChainEnd(t, e);
                        i.add(new T(n)), e = n
                    } while (e < t.length - 1);
                    var r = Qe.toIntArray(i);
                    return r
                }, Qe.findChainEnd = function(t, e) {
                    for (var i = e; i < t.length - 1 && t[i].equals2D(t[i + 1]);) i++;
                    if (i >= t.length - 1) return t.length - 1;
                    for (var n = Je.quadrant(t[i], t[i + 1]), r = e + 1; r < t.length;) {
                        if (!t[r - 1].equals2D(t[r])) { var o = Je.quadrant(t[r - 1], t[r]); if (o !== n) break }
                        r++
                    }
                    return r - 1
                }, Qe.getChains = function() {
                    if (1 === arguments.length) { var t = arguments[0]; return Qe.getChains(t, null) }
                    if (2 === arguments.length) {
                        for (var e = arguments[0], i = arguments[1], n = new x, r = Qe.getChainStartIndices(e), o = 0; o < r.length - 1; o++) {
                            var s = new Ze(e, r[o], r[o + 1], i);
                            n.add(s)
                        }
                        return n
                    }
                }, Qe.toIntArray = function(t) { for (var e = new Array(t.size()).fill(null), i = 0; i < e.length; i++) e[i] = t.get(i).intValue(); return e }, e(ti.prototype, { computeNodes: function(t) {}, getNodedSubstrings: function() {}, interfaces_: function() { return [] }, getClass: function() { return ti } }), e(ei.prototype, { setSegmentIntersector: function(t) { this.segInt = t }, interfaces_: function() { return [ti] }, getClass: function() { return ei } }), u(ii, ei), e(ii.prototype, {
                    getMonotoneChains: function() { return this.monoChains },
                    getNodedSubstrings: function() { return Ke.getNodedSubstrings(this.nodedSegStrings) },
                    getIndex: function() { return this.index },
                    add: function(t) {
                        for (var e = Qe.getChains(t.getCoordinates(), t), i = e.iterator(); i.hasNext();) {
                            var n = i.next();
                            n.setId(this.idCounter++), this.index.insert(n.getEnvelope(), n),
                                this.monoChains.add(n)
                        }
                    },
                    computeNodes: function(t) {
                        this.nodedSegStrings = t;
                        for (var e = t.iterator(); e.hasNext();) this.add(e.next());
                        this.intersectChains()
                    },
                    intersectChains: function() {
                        for (var t = new ni(this.segInt), e = this.monoChains.iterator(); e.hasNext();)
                            for (var i = e.next(), n = this.index.query(i.getEnvelope()), r = n.iterator(); r.hasNext();) { var o = r.next(); if (o.getId() > i.getId() && (i.computeOverlaps(o, t), this.nOverlaps++), this.segInt.isDone()) return null }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return ii }
                }), u(ni, $e), e(ni.prototype, {
                    overlap: function() {
                        if (4 !== arguments.length) return $e.prototype.overlap.apply(this, arguments);
                        var t = arguments[0],
                            e = arguments[1],
                            i = arguments[2],
                            n = arguments[3],
                            r = t.getContext(),
                            o = i.getContext();
                        this.si.processIntersections(r, e, o, n)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return ni }
                }), ii.SegmentOverlapAction = ni, u(ri, l), e(ri.prototype, { getCoordinate: function() { return this.pt }, interfaces_: function() { return [] }, getClass: function() { return ri } }), ri.msgWithCoord = function(t, e) { return null !== e ? t + " [ " + e + " ]" : t }, e(oi.prototype, { processIntersections: function(t, e, i, n) {}, isDone: function() {}, interfaces_: function() { return [] }, getClass: function() { return oi } }), e(si.prototype, {
                    getInteriorIntersection: function() { return this.interiorIntersection },
                    setCheckEndSegmentsOnly: function(t) { this.isCheckEndSegmentsOnly = t },
                    getIntersectionSegments: function() { return this.intSegments },
                    count: function() { return this.intersectionCount },
                    getIntersections: function() { return this.intersections },
                    setFindAllIntersections: function(t) { this.findAllIntersections = t },
                    setKeepIntersections: function(t) { this.keepIntersections = t },
                    processIntersections: function(t, e, i, n) {
                        if (!this.findAllIntersections && this.hasIntersection()) return null;
                        if (t === i && e === n) return null;
                        if (this.isCheckEndSegmentsOnly) { var r = this.isEndSegment(t, e) || this.isEndSegment(i, n); if (!r) return null }
                        var o = t.getCoordinates()[e],
                            s = t.getCoordinates()[e + 1],
                            a = i.getCoordinates()[n],
                            h = i.getCoordinates()[n + 1];
                        this.li.computeIntersection(o, s, a, h), this.li.hasIntersection() && this.li.isInteriorIntersection() && (this.intSegments = new Array(4).fill(null), this.intSegments[0] = o, this.intSegments[1] = s, this.intSegments[2] = a, this.intSegments[3] = h, this.interiorIntersection = this.li.getIntersection(0), this.keepIntersections && this.intersections.add(this.interiorIntersection), this.intersectionCount++)
                    },
                    isEndSegment: function(t, e) { return 0 === e || e >= t.size() - 2 },
                    hasIntersection: function() { return null !== this.interiorIntersection },
                    isDone: function() { return !this.findAllIntersections && null !== this.interiorIntersection },
                    interfaces_: function() { return [oi] },
                    getClass: function() { return si }
                }), si.createAllIntersectionsFinder = function(t) { var e = new si(t); return e.setFindAllIntersections(!0), e }, si.createAnyIntersectionFinder = function(t) { return new si(t) }, si.createIntersectionCounter = function(t) { var e = new si(t); return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e }, e(ai.prototype, { execute: function() { return null !== this.segInt ? null : void this.checkInteriorIntersections() }, getIntersections: function() { return this.segInt.getIntersections() }, isValid: function() { return this.execute(), this._isValid }, setFindAllIntersections: function(t) { this.findAllIntersections = t }, checkInteriorIntersections: function() { this._isValid = !0, this.segInt = new si(this.li), this.segInt.setFindAllIntersections(this.findAllIntersections); var t = new ii; return t.setSegmentIntersector(this.segInt), t.computeNodes(this.segStrings), this.segInt.hasIntersection() ? (this._isValid = !1, null) : void 0 }, checkValid: function() { if (this.execute(), !this._isValid) throw new ri(this.getErrorMessage(), this.segInt.getInteriorIntersection()) }, getErrorMessage: function() { if (this._isValid) return "no intersections found"; var t = this.segInt.getIntersectionSegments(); return "found non-noded intersection between " + oe.toLineString(t[0], t[1]) + " and " + oe.toLineString(t[2], t[3]) }, interfaces_: function() { return [] }, getClass: function() { return ai } }), ai.computeIntersections = function(t) { var e = new ai(t); return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections() }, e(hi.prototype, { checkValid: function() { this.nv.checkValid() }, interfaces_: function() { return [] }, getClass: function() { return hi } }), hi.toSegmentStrings = function(t) {
                    for (var e = new x, i = t.iterator(); i.hasNext();) {
                        var n = i.next();
                        e.add(new Ae(n.getCoordinates(), n))
                    }
                    return e
                }, hi.checkValid = function(t) {
                    var e = new hi(t);
                    e.checkValid()
                }, e(li.prototype, {
                    map: function(t) {
                        for (var e = new x, i = 0; i < t.getNumGeometries(); i++) {
                            var n = this.mapOp.map(t.getGeometryN(i));
                            n.isEmpty() || e.add(n)
                        }
                        return t.getFactory().createGeometryCollection(ne.toGeometryArray(e))
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return li }
                }), li.map = function(t, e) { var i = new li(e); return i.map(t) }, e(ui.prototype, { interfaces_: function() { return [] }, getClass: function() { return ui } }), ui.opposite = function(t) { return t === ui.LEFT ? ui.RIGHT : t === ui.RIGHT ? ui.LEFT : t }, ui.ON = 0, ui.LEFT = 1, ui.RIGHT = 2, e(pi.prototype, {
                    setAllLocations: function(t) { for (var e = 0; e < this.location.length; e++) this.location[e] = t },
                    isNull: function() {
                        for (var t = 0; t < this.location.length; t++)
                            if (this.location[t] !== C.NONE) return !1;
                        return !0
                    },
                    setAllLocationsIfNull: function(t) { for (var e = 0; e < this.location.length; e++) this.location[e] === C.NONE && (this.location[e] = t) },
                    isLine: function() { return 1 === this.location.length },
                    merge: function(t) {
                        if (t.location.length > this.location.length) {
                            var e = new Array(3).fill(null);
                            e[ui.ON] = this.location[ui.ON], e[ui.LEFT] = C.NONE, e[ui.RIGHT] = C.NONE, this.location = e
                        }
                        for (var i = 0; i < this.location.length; i++) this.location[i] === C.NONE && i < t.location.length && (this.location[i] = t.location[i])
                    },
                    getLocations: function() { return this.location },
                    flip: function() {
                        if (this.location.length <= 1) return null;
                        var t = this.location[ui.LEFT];
                        this.location[ui.LEFT] = this.location[ui.RIGHT], this.location[ui.RIGHT] = t
                    },
                    toString: function() { var t = new k; return this.location.length > 1 && t.append(C.toLocationSymbol(this.location[ui.LEFT])), t.append(C.toLocationSymbol(this.location[ui.ON])), this.location.length > 1 && t.append(C.toLocationSymbol(this.location[ui.RIGHT])), t.toString() },
                    setLocations: function(t, e, i) { this.location[ui.ON] = t, this.location[ui.LEFT] = e, this.location[ui.RIGHT] = i },
                    get: function(t) { return t < this.location.length ? this.location[t] : C.NONE },
                    isArea: function() { return this.location.length > 1 },
                    isAnyNull: function() {
                        for (var t = 0; t < this.location.length; t++)
                            if (this.location[t] === C.NONE) return !0;
                        return !1
                    },
                    setLocation: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.setLocation(ui.ON, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1];
                            this.location[e] = i
                        }
                    },
                    init: function(t) { this.location = new Array(t).fill(null), this.setAllLocations(C.NONE) },
                    isEqualOnSide: function(t, e) { return this.location[e] === t.location[e] },
                    allPositionsEqual: function(t) {
                        for (var e = 0; e < this.location.length; e++)
                            if (this.location[e] !== t) return !1;
                        return !0
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return pi }
                }), e(ci.prototype, {
                    getGeometryCount: function() { var t = 0; return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t },
                    setAllLocations: function(t, e) { this.elt[t].setAllLocations(e) },
                    isNull: function(t) { return this.elt[t].isNull() },
                    setAllLocationsIfNull: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1];
                            this.elt[e].setAllLocationsIfNull(i)
                        }
                    },
                    isLine: function(t) { return this.elt[t].isLine() },
                    merge: function(t) { for (var e = 0; 2 > e; e++) null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new pi(t.elt[e]) : this.elt[e].merge(t.elt[e]) },
                    flip: function() { this.elt[0].flip(), this.elt[1].flip() },
                    getLocation: function() {
                        if (1 === arguments.length) { var t = arguments[0]; return this.elt[t].get(ui.ON) }
                        if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1];
                            return this.elt[e].get(i)
                        }
                    },
                    toString: function() { var t = new k; return null !== this.elt[0] && (t.append("A:"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString() },
                    isArea: function() { if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea(); if (1 === arguments.length) { var t = arguments[0]; return this.elt[t].isArea() } },
                    isAnyNull: function(t) { return this.elt[t].isAnyNull() },
                    setLocation: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            this.elt[t].setLocation(ui.ON, e)
                        } else if (3 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1],
                                r = arguments[2];
                            this.elt[i].setLocation(n, r)
                        }
                    },
                    isEqualOnSide: function(t, e) { return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e) },
                    allPositionsEqual: function(t, e) { return this.elt[t].allPositionsEqual(e) },
                    toLine: function(t) { this.elt[t].isArea() && (this.elt[t] = new pi(this.elt[t].location[0])) },
                    interfaces_: function() { return [] },
                    getClass: function() { return ci }
                }), ci.toLineLabel = function(t) { for (var e = new ci(C.NONE), i = 0; 2 > i; i++) e.setLocation(i, t.getLocation(i)); return e }, e(fi.prototype, {
                    computeRing: function() {
                        if (null !== this.ring) return null;
                        for (var t = new Array(this.pts.size()).fill(null), e = 0; e < this.pts.size(); e++) t[e] = this.pts.get(e);
                        this.ring = this.geometryFactory.createLinearRing(t), this._isHole = ue.isCCW(this.ring.getCoordinates())
                    },
                    isIsolated: function() { return 1 === this.label.getGeometryCount() },
                    computePoints: function(t) {
                        this.startDe = t;
                        var e = t,
                            i = !0;
                        do {
                            if (null === e) throw new ri("Found null DirectedEdge");
                            if (e.getEdgeRing() === this) throw new ri("Directed Edge visited twice during ring-building at " + e.getCoordinate());
                            this.edges.add(e);
                            var n = e.getLabel();
                            c.isTrue(n.isArea()), this.mergeLabel(n), this.addPoints(e.getEdge(), e.isForward(), i), i = !1, this.setEdgeRing(e, this), e = this.getNext(e)
                        } while (e !== this.startDe)
                    },
                    getLinearRing: function() { return this.ring },
                    getCoordinate: function(t) { return this.pts.get(t) },
                    computeMaxNodeDegree: function() {
                        this.maxNodeDegree = 0;
                        var t = this.startDe;
                        do {
                            var e = t.getNode(),
                                i = e.getEdges().getOutgoingDegree(this);
                            i > this.maxNodeDegree && (this.maxNodeDegree = i), t = this.getNext(t)
                        } while (t !== this.startDe);
                        this.maxNodeDegree *= 2
                    },
                    addPoints: function(t, e, i) {
                        var n = t.getCoordinates();
                        if (e) {
                            var r = 1;
                            i && (r = 0);
                            for (var o = r; o < n.length; o++) this.pts.add(n[o])
                        } else {
                            var r = n.length - 2;
                            i && (r = n.length - 1);
                            for (var o = r; o >= 0; o--) this.pts.add(n[o])
                        }
                    },
                    isHole: function() { return this._isHole },
                    setInResult: function() {
                        var t = this.startDe;
                        do t.getEdge().setInResult(!0), t = t.getNext(); while (t !== this.startDe)
                    },
                    containsPoint: function(t) {
                        var e = this.getLinearRing(),
                            i = e.getEnvelopeInternal();
                        if (!i.contains(t)) return !1;
                        if (!ue.isPointInRing(t, e.getCoordinates())) return !1;
                        for (var n = this.holes.iterator(); n.hasNext();) { var r = n.next(); if (r.containsPoint(t)) return !1 }
                        return !0
                    },
                    addHole: function(t) { this.holes.add(t) },
                    isShell: function() { return null === this.shell },
                    getLabel: function() { return this.label },
                    getEdges: function() { return this.edges },
                    getMaxNodeDegree: function() { return this.maxNodeDegree < 0 && this.computeMaxNodeDegree(), this.maxNodeDegree },
                    getShell: function() { return this.shell },
                    mergeLabel: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.mergeLabel(t, 0), this.mergeLabel(t, 1)
                        } else if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1],
                                n = e.getLocation(i, ui.RIGHT);
                            if (n === C.NONE) return null;
                            if (this.label.getLocation(i) === C.NONE) return this.label.setLocation(i, n), null
                        }
                    },
                    setShell: function(t) { this.shell = t, null !== t && t.addHole(this) },
                    toPolygon: function(t) { for (var e = new Array(this.holes.size()).fill(null), i = 0; i < this.holes.size(); i++) e[i] = this.holes.get(i).getLinearRing(); var n = t.createPolygon(this.getLinearRing(), e); return n },
                    interfaces_: function() { return [] },
                    getClass: function() { return fi }
                }), u(gi, fi), e(gi.prototype, { setEdgeRing: function(t, e) { t.setMinEdgeRing(e) }, getNext: function(t) { return t.getNextMin() }, interfaces_: function() { return [] }, getClass: function() { return gi } }), u(di, fi), e(di.prototype, {
                    buildMinimalRings: function() {
                        var t = new x,
                            e = this.startDe;
                        do {
                            if (null === e.getMinEdgeRing()) {
                                var i = new gi(e, this.geometryFactory);
                                t.add(i)
                            }
                            e = e.getNext()
                        } while (e !== this.startDe);
                        return t
                    },
                    setEdgeRing: function(t, e) { t.setEdgeRing(e) },
                    linkDirectedEdgesForMinimalEdgeRings: function() {
                        var t = this.startDe;
                        do {
                            var e = t.getNode();
                            e.getEdges().linkMinimalDirectedEdges(this), t = t.getNext()
                        } while (t !== this.startDe)
                    },
                    getNext: function(t) { return t.getNext() },
                    interfaces_: function() { return [] },
                    getClass: function() { return di }
                }), e(yi.prototype, { setVisited: function(t) { this._isVisited = t }, setInResult: function(t) { this._isInResult = t }, isCovered: function() { return this._isCovered }, isCoveredSet: function() { return this._isCoveredSet }, setLabel: function(t) { this.label = t }, getLabel: function() { return this.label }, setCovered: function(t) { this._isCovered = t, this._isCoveredSet = !0 }, updateIM: function(t) { c.isTrue(this.label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t) }, isInResult: function() { return this._isInResult }, isVisited: function() { return this._isVisited }, interfaces_: function() { return [] }, getClass: function() { return yi } }), u(mi, yi), e(mi.prototype, {
                    isIncidentEdgeInResult: function() { for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) { var e = t.next(); if (e.getEdge().isInResult()) return !0 } return !1 },
                    isIsolated: function() { return 1 === this.label.getGeometryCount() },
                    getCoordinate: function() { return this.coord },
                    print: function(t) { t.println("node " + this.coord + " lbl: " + this.label) },
                    computeIM: function(t) {},
                    computeMergedLocation: function(t, e) {
                        var i = C.NONE;
                        if (i = this.label.getLocation(e), !t.isNull(e)) {
                            var n = t.getLocation(e);
                            i !== C.BOUNDARY && (i = n)
                        }
                        return i
                    },
                    setLabel: function() {
                        if (2 !== arguments.length) return yi.prototype.setLabel.apply(this, arguments);
                        var t = arguments[0],
                            e = arguments[1];
                        null === this.label ? this.label = new ci(t, e) : this.label.setLocation(t, e)
                    },
                    getEdges: function() { return this.edges },
                    mergeLabel: function() {
                        if (arguments[0] instanceof mi) {
                            var t = arguments[0];
                            this.mergeLabel(t.label)
                        } else if (arguments[0] instanceof ci)
                            for (var e = arguments[0], i = 0; 2 > i; i++) {
                                var n = this.computeMergedLocation(e, i),
                                    r = this.label.getLocation(i);
                                r === C.NONE && this.label.setLocation(i, n)
                            }
                    },
                    add: function(t) { this.edges.insert(t), t.setNode(this) },
                    setLabelBoundary: function(t) {
                        if (null === this.label) return null;
                        var e = C.NONE;
                        null !== this.label && (e = this.label.getLocation(t));
                        var i = null;
                        switch (e) {
                            case C.BOUNDARY:
                                i = C.INTERIOR;
                                break;
                            case C.INTERIOR:
                                i = C.BOUNDARY;
                                break;
                            default:
                                i = C.BOUNDARY
                        }
                        this.label.setLocation(t, i)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return mi }
                }), e(vi.prototype, {
                    find: function(t) { return this.nodeMap.get(t) },
                    addNode: function() {
                        if (arguments[0] instanceof f) {
                            var t = arguments[0],
                                e = this.nodeMap.get(t);
                            return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e
                        }
                        if (arguments[0] instanceof mi) {
                            var i = arguments[0],
                                e = this.nodeMap.get(i.getCoordinate());
                            return null === e ? (this.nodeMap.put(i.getCoordinate(), i), i) : (e.mergeLabel(i), e)
                        }
                    },
                    print: function(t) {
                        for (var e = this.iterator(); e.hasNext();) {
                            var i = e.next();
                            i.print(t)
                        }
                    },
                    iterator: function() { return this.nodeMap.values().iterator() },
                    values: function() { return this.nodeMap.values() },
                    getBoundaryNodes: function(t) {
                        for (var e = new x, i = this.iterator(); i.hasNext();) {
                            var n = i.next();
                            n.getLabel().getLocation(t) === C.BOUNDARY && e.add(n)
                        }
                        return e
                    },
                    add: function(t) {
                        var e = t.getCoordinate(),
                            i = this.addNode(e);
                        i.add(t)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return vi }
                }), e(bi.prototype, {
                    compareDirection: function(t) { return this.dx === t.dx && this.dy === t.dy ? 0 : this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : ue.computeOrientation(t.p0, t.p1, this.p1) },
                    getDy: function() { return this.dy },
                    getCoordinate: function() { return this.p0 },
                    setNode: function(t) { this.node = t },
                    print: function(t) {
                        var e = Math.atan2(this.dy, this.dx),
                            i = this.getClass().getName(),
                            n = i.lastIndexOf("."),
                            r = i.substring(n + 1);
                        t.print("  " + r + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + e + "   " + this.label)
                    },
                    compareTo: function(t) { var e = t; return this.compareDirection(e) },
                    getDirectedCoordinate: function() { return this.p1 },
                    getDx: function() { return this.dx },
                    getLabel: function() { return this.label },
                    getEdge: function() { return this.edge },
                    getQuadrant: function() { return this.quadrant },
                    getNode: function() { return this.node },
                    toString: function() {
                        var t = Math.atan2(this.dy, this.dx),
                            e = this.getClass().getName(),
                            i = e.lastIndexOf("."),
                            n = e.substring(i + 1);
                        return "  " + n + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + t + "   " + this.label
                    },
                    computeLabel: function(t) {},
                    init: function(t, e) { this.p0 = t, this.p1 = e, this.dx = e.x - t.x, this.dy = e.y - t.y, this.quadrant = Je.quadrant(this.dx, this.dy), c.isTrue(!(0 === this.dx && 0 === this.dy), "EdgeEnd with identical endpoints found") },
                    interfaces_: function() { return [o] },
                    getClass: function() { return bi }
                }), u(wi, bi), e(wi.prototype, {
                    getNextMin: function() { return this.nextMin },
                    getDepth: function(t) { return this.depth[t] },
                    setVisited: function(t) { this._isVisited = t },
                    computeDirectedLabel: function() { this.label = new ci(this.edge.getLabel()), this._isForward || this.label.flip() },
                    getNext: function() { return this.next },
                    setDepth: function(t, e) {
                        if (-999 !== this.depth[t] && this.depth[t] !== e) throw new ri("assigned depths do not match", this.getCoordinate());
                        this.depth[t] = e
                    },
                    isInteriorAreaEdge: function t() { for (var t = !0, e = 0; 2 > e; e++) this.label.isArea(e) && this.label.getLocation(e, ui.LEFT) === C.INTERIOR && this.label.getLocation(e, ui.RIGHT) === C.INTERIOR || (t = !1); return t },
                    setNextMin: function(t) { this.nextMin = t },
                    print: function(t) { bi.prototype.print.call(this, t), t.print(" " + this.depth[ui.LEFT] + "/" + this.depth[ui.RIGHT]), t.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t.print(" inResult") },
                    setMinEdgeRing: function(t) { this.minEdgeRing = t },
                    isLineEdge: function() {
                        var t = this.label.isLine(0) || this.label.isLine(1),
                            e = !this.label.isArea(0) || this.label.allPositionsEqual(0, C.EXTERIOR),
                            i = !this.label.isArea(1) || this.label.allPositionsEqual(1, C.EXTERIOR);
                        return t && e && i
                    },
                    setEdgeRing: function(t) { this.edgeRing = t },
                    getMinEdgeRing: function() { return this.minEdgeRing },
                    getDepthDelta: function() { var t = this.edge.getDepthDelta(); return this._isForward || (t = -t), t },
                    setInResult: function(t) { this._isInResult = t },
                    getSym: function() { return this.sym },
                    isForward: function() { return this._isForward },
                    getEdge: function() { return this.edge },
                    printEdge: function(t) { this.print(t), t.print(" "), this._isForward ? this.edge.print(t) : this.edge.printReverse(t) },
                    setSym: function(t) { this.sym = t },
                    setVisitedEdge: function(t) { this.setVisited(t), this.sym.setVisited(t) },
                    setEdgeDepths: function(t, e) {
                        var i = this.getEdge().getDepthDelta();
                        this._isForward || (i = -i);
                        var n = 1;
                        t === ui.LEFT && (n = -1);
                        var r = ui.opposite(t),
                            o = i * n,
                            s = e + o;
                        this.setDepth(t, e), this.setDepth(r, s)
                    },
                    getEdgeRing: function() { return this.edgeRing },
                    isInResult: function() { return this._isInResult },
                    setNext: function(t) { this.next = t },
                    isVisited: function() { return this._isVisited },
                    interfaces_: function() { return [] },
                    getClass: function() { return wi }
                }), wi.depthFactor = function(t, e) { return t === C.EXTERIOR && e === C.INTERIOR ? 1 : t === C.INTERIOR && e === C.EXTERIOR ? -1 : 0 }, e(xi.prototype, { createNode: function(t) { return new mi(t, null) }, interfaces_: function() { return [] }, getClass: function() { return xi } }), e(Ei.prototype, {
                    printEdges: function(t) {
                        t.println("Edges:");
                        for (var e = 0; e < this.edges.size(); e++) {
                            t.println("edge " + e + ":");
                            var i = this.edges.get(e);
                            i.print(t), i.eiList.print(t)
                        }
                    },
                    find: function(t) { return this.nodes.find(t) },
                    addNode: function() { if (arguments[0] instanceof mi) { var t = arguments[0]; return this.nodes.addNode(t) } if (arguments[0] instanceof f) { var e = arguments[0]; return this.nodes.addNode(e) } },
                    getNodeIterator: function() { return this.nodes.iterator() },
                    linkResultDirectedEdges: function() {
                        for (var t = this.nodes.iterator(); t.hasNext();) {
                            var e = t.next();
                            e.getEdges().linkResultDirectedEdges()
                        }
                    },
                    debugPrintln: function(t) { O.out.println(t) },
                    isBoundaryNode: function(t, e) { var i = this.nodes.find(e); if (null === i) return !1; var n = i.getLabel(); return null !== n && n.getLocation(t) === C.BOUNDARY },
                    linkAllDirectedEdges: function() {
                        for (var t = this.nodes.iterator(); t.hasNext();) {
                            var e = t.next();
                            e.getEdges().linkAllDirectedEdges()
                        }
                    },
                    matchInSameDirection: function(t, e, i, n) { return !!t.equals(i) && (ue.computeOrientation(t, e, n) === ue.COLLINEAR && Je.quadrant(t, e) === Je.quadrant(i, n)) },
                    getEdgeEnds: function() { return this.edgeEndList },
                    debugPrint: function(t) { O.out.print(t) },
                    getEdgeIterator: function() { return this.edges.iterator() },
                    findEdgeInSameDirection: function(t, e) {
                        for (var i = 0; i < this.edges.size(); i++) {
                            var n = this.edges.get(i),
                                r = n.getCoordinates();
                            if (this.matchInSameDirection(t, e, r[0], r[1])) return n;
                            if (this.matchInSameDirection(t, e, r[r.length - 1], r[r.length - 2])) return n
                        }
                        return null
                    },
                    insertEdge: function(t) { this.edges.add(t) },
                    findEdgeEnd: function(t) { for (var e = this.getEdgeEnds().iterator(); e.hasNext();) { var i = e.next(); if (i.getEdge() === t) return i } return null },
                    addEdges: function(t) {
                        for (var e = t.iterator(); e.hasNext();) {
                            var i = e.next();
                            this.edges.add(i);
                            var n = new wi(i, !0),
                                r = new wi(i, !1);
                            n.setSym(r), r.setSym(n), this.add(n), this.add(r)
                        }
                    },
                    add: function(t) { this.nodes.add(t), this.edgeEndList.add(t) },
                    getNodes: function() { return this.nodes.values() },
                    findEdge: function(t, e) {
                        for (var i = 0; i < this.edges.size(); i++) {
                            var n = this.edges.get(i),
                                r = n.getCoordinates();
                            if (t.equals(r[0]) && e.equals(r[1])) return n
                        }
                        return null
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Ei }
                }), Ei.linkResultDirectedEdges = function(t) {
                    for (var e = t.iterator(); e.hasNext();) {
                        var i = e.next();
                        i.getEdges().linkResultDirectedEdges()
                    }
                }, e(Si.prototype, {
                    sortShellsAndHoles: function(t, e, i) {
                        for (var n = t.iterator(); n.hasNext();) {
                            var r = n.next();
                            r.isHole() ? i.add(r) : e.add(r)
                        }
                    },
                    computePolygons: function(t) {
                        for (var e = new x, i = t.iterator(); i.hasNext();) {
                            var n = i.next(),
                                r = n.toPolygon(this.geometryFactory);
                            e.add(r)
                        }
                        return e
                    },
                    placeFreeHoles: function(t, e) {
                        for (var i = e.iterator(); i.hasNext();) {
                            var n = i.next();
                            if (null === n.getShell()) {
                                var r = this.findEdgeRingContaining(n, t);
                                if (null === r) throw new ri("unable to assign hole to a shell", n.getCoordinate(0));
                                n.setShell(r)
                            }
                        }
                    },
                    buildMinimalEdgeRings: function(t, e, i) {
                        for (var n = new x, r = t.iterator(); r.hasNext();) {
                            var o = r.next();
                            if (o.getMaxNodeDegree() > 2) {
                                o.linkDirectedEdgesForMinimalEdgeRings();
                                var s = o.buildMinimalRings(),
                                    a = this.findShell(s);
                                null !== a ? (this.placePolygonHoles(a, s), e.add(a)) : i.addAll(s)
                            } else n.add(o)
                        }
                        return n
                    },
                    containsPoint: function(t) { for (var e = this.shellList.iterator(); e.hasNext();) { var i = e.next(); if (i.containsPoint(t)) return !0 } return !1 },
                    buildMaximalEdgeRings: function(t) {
                        for (var e = new x, i = t.iterator(); i.hasNext();) {
                            var n = i.next();
                            if (n.isInResult() && n.getLabel().isArea() && null === n.getEdgeRing()) {
                                var r = new di(n, this.geometryFactory);
                                e.add(r), r.setInResult()
                            }
                        }
                        return e
                    },
                    placePolygonHoles: function(t, e) {
                        for (var i = e.iterator(); i.hasNext();) {
                            var n = i.next();
                            n.isHole() && n.setShell(t)
                        }
                    },
                    getPolygons: function() { var t = this.computePolygons(this.shellList); return t },
                    findEdgeRingContaining: function(t, e) {
                        for (var i = t.getLinearRing(), n = i.getEnvelopeInternal(), r = i.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext();) {
                            var h = a.next(),
                                l = h.getLinearRing(),
                                u = l.getEnvelopeInternal();
                            null !== o && (s = o.getLinearRing().getEnvelopeInternal());
                            var p = !1;
                            u.contains(n) && ue.isPointInRing(r, l.getCoordinates()) && (p = !0), p && (null === o || s.contains(u)) && (o = h)
                        }
                        return o
                    },
                    findShell: function(t) {
                        for (var e = 0, i = null, n = t.iterator(); n.hasNext();) {
                            var r = n.next();
                            r.isHole() || (i = r, e++)
                        }
                        return c.isTrue(1 >= e, "found two shells in MinimalEdgeRing list"), i
                    },
                    add: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.add(t.getEdgeEnds(), t.getNodes())
                        } else if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1];
                            Ei.linkResultDirectedEdges(i);
                            var n = this.buildMaximalEdgeRings(e),
                                r = new x,
                                o = this.buildMinimalEdgeRings(n, this.shellList, r);
                            this.sortShellsAndHoles(o, this.shellList, r), this.placeFreeHoles(this.shellList, r)
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Si }
                }), e(Ni.prototype, {
                    collectLines: function(t) {
                        for (var e = this.op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
                            var i = e.next();
                            this.collectLineEdge(i, t, this.lineEdgesList), this.collectBoundaryTouchEdge(i, t, this.lineEdgesList)
                        }
                    },
                    labelIsolatedLine: function(t, e) {
                        var i = this.ptLocator.locate(t.getCoordinate(), this.op.getArgGeometry(e));
                        t.getLabel().setLocation(e, i)
                    },
                    build: function(t) { return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this.resultLineList },
                    collectLineEdge: function(t, e, i) {
                        var n = t.getLabel(),
                            r = t.getEdge();
                        t.isLineEdge() && (t.isVisited() || !nn.isResultOfOp(n, e) || r.isCovered() || (i.add(r), t.setVisitedEdge(!0)))
                    },
                    findCoveredLineEdges: function() {
                        for (var t = this.op.getGraph().getNodes().iterator(); t.hasNext();) {
                            var e = t.next();
                            e.getEdges().findCoveredLineEdges()
                        }
                        for (var i = this.op.getGraph().getEdgeEnds().iterator(); i.hasNext();) {
                            var n = i.next(),
                                r = n.getEdge();
                            if (n.isLineEdge() && !r.isCoveredSet()) {
                                var o = this.op.isCoveredByA(n.getCoordinate());
                                r.setCovered(o)
                            }
                        }
                    },
                    labelIsolatedLines: function(t) {
                        for (var e = t.iterator(); e.hasNext();) {
                            var i = e.next(),
                                n = i.getLabel();
                            i.isIsolated() && (n.isNull(0) ? this.labelIsolatedLine(i, 0) : this.labelIsolatedLine(i, 1))
                        }
                    },
                    buildLines: function(t) {
                        for (var e = this.lineEdgesList.iterator(); e.hasNext();) {
                            var i = e.next(),
                                n = (i.getLabel(), this.geometryFactory.createLineString(i.getCoordinates()));
                            this.resultLineList.add(n), i.setInResult(!0)
                        }
                    },
                    collectBoundaryTouchEdge: function(t, e, i) { var n = t.getLabel(); return t.isLineEdge() ? null : t.isVisited() ? null : t.isInteriorAreaEdge() ? null : t.getEdge().isInResult() ? null : (c.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void(nn.isResultOfOp(n, e) && e === nn.INTERSECTION && (i.add(t.getEdge()), t.setVisitedEdge(!0)))) },
                    interfaces_: function() { return [] },
                    getClass: function() { return Ni }
                }), e(Li.prototype, {
                    filterCoveredNodeToPoint: function(t) {
                        var e = t.getCoordinate();
                        if (!this.op.isCoveredByLA(e)) {
                            var i = this.geometryFactory.createPoint(e);
                            this.resultPointList.add(i)
                        }
                    },
                    extractNonCoveredResultNodes: function(t) {
                        for (var e = this.op.getGraph().getNodes().iterator(); e.hasNext();) {
                            var i = e.next();
                            if (!(i.isInResult() || i.isIncidentEdgeInResult() || 0 !== i.getEdges().getDegree() && t !== nn.INTERSECTION)) {
                                var n = i.getLabel();
                                nn.isResultOfOp(n, t) && this.filterCoveredNodeToPoint(i)
                            }
                        }
                    },
                    build: function(t) { return this.extractNonCoveredResultNodes(t), this.resultPointList },
                    interfaces_: function() { return [] },
                    getClass: function() { return Li }
                }), e(Ci.prototype, { locate: function(t) {}, interfaces_: function() { return [] }, getClass: function() { return Ci } }), e(Mi.prototype, { locate: function(t) { return Mi.locate(t, this.geom) }, interfaces_: function() { return [Ci] }, getClass: function() { return Mi } }), Mi.isPointInRing = function(t, e) { return !!e.getEnvelopeInternal().intersects(t) && ue.isPointInRing(t, e.getCoordinates()) }, Mi.containsPointInPolygon = function(t, e) { if (e.isEmpty()) return !1; var i = e.getExteriorRing(); if (!Mi.isPointInRing(t, i)) return !1; for (var n = 0; n < e.getNumInteriorRing(); n++) { var r = e.getInteriorRingN(n); if (Mi.isPointInRing(t, r)) return !1 } return !0 }, Mi.containsPoint = function(t, e) {
                    if (e instanceof It) return Mi.containsPointInPolygon(t, e);
                    if (e instanceof ct)
                        for (var i = new Me(e); i.hasNext();) { var n = i.next(); if (n !== e && Mi.containsPoint(t, n)) return !0 }
                    return !1
                }, Mi.locate = function(t, e) { return e.isEmpty() ? C.EXTERIOR : Mi.containsPoint(t, e) ? C.INTERIOR : C.EXTERIOR }, e(Ii.prototype, {
                    getNextCW: function(t) {
                        this.getEdges();
                        var e = this.edgeList.indexOf(t),
                            i = e - 1;
                        return 0 === e && (i = this.edgeList.size() - 1), this.edgeList.get(i)
                    },
                    propagateSideLabels: function(t) {
                        for (var e = C.NONE, i = this.iterator(); i.hasNext();) {
                            var n = i.next(),
                                r = n.getLabel();
                            r.isArea(t) && r.getLocation(t, ui.LEFT) !== C.NONE && (e = r.getLocation(t, ui.LEFT))
                        }
                        if (e === C.NONE) return null;
                        for (var o = e, i = this.iterator(); i.hasNext();) {
                            var n = i.next(),
                                r = n.getLabel();
                            if (r.getLocation(t, ui.ON) === C.NONE && r.setLocation(t, ui.ON, o), r.isArea(t)) {
                                var s = r.getLocation(t, ui.LEFT),
                                    a = r.getLocation(t, ui.RIGHT);
                                if (a !== C.NONE) {
                                    if (a !== o) throw new ri("side location conflict", n.getCoordinate());
                                    s === C.NONE && c.shouldNeverReachHere("found single null side (at " + n.getCoordinate() + ")"), o = s
                                } else c.isTrue(r.getLocation(t, ui.LEFT) === C.NONE, "found single null side"), r.setLocation(t, ui.RIGHT, o), r.setLocation(t, ui.LEFT, o)
                            }
                        }
                    },
                    getCoordinate: function() { var t = this.iterator(); if (!t.hasNext()) return null; var e = t.next(); return e.getCoordinate() },
                    print: function(t) {
                        O.out.println("EdgeEndStar:   " + this.getCoordinate());
                        for (var e = this.iterator(); e.hasNext();) {
                            var i = e.next();
                            i.print(t)
                        }
                    },
                    isAreaLabelsConsistent: function(t) { return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0) },
                    checkAreaLabelsConsistent: function(t) {
                        var e = this.getEdges();
                        if (e.size() <= 0) return !0;
                        var i = e.size() - 1,
                            n = e.get(i).getLabel(),
                            r = n.getLocation(t, ui.LEFT);
                        c.isTrue(r !== C.NONE, "Found unlabelled area edge");
                        for (var o = r, s = this.iterator(); s.hasNext();) {
                            var a = s.next(),
                                h = a.getLabel();
                            c.isTrue(h.isArea(t), "Found non-area edge");
                            var l = h.getLocation(t, ui.LEFT),
                                u = h.getLocation(t, ui.RIGHT);
                            if (l === u) return !1;
                            if (u !== o) return !1;
                            o = l
                        }
                        return !0
                    },
                    findIndex: function(t) { this.iterator(); for (var e = 0; e < this.edgeList.size(); e++) { var i = this.edgeList.get(e); if (i === t) return e } return -1 },
                    iterator: function() { return this.getEdges().iterator() },
                    getEdges: function() { return null === this.edgeList && (this.edgeList = new x(this.edgeMap.values())), this.edgeList },
                    getLocation: function(t, e, i) { return this.ptInAreaLocation[t] === C.NONE && (this.ptInAreaLocation[t] = Mi.locate(e, i[t].getGeometry())), this.ptInAreaLocation[t] },
                    toString: function() {
                        var t = new k;
                        t.append("EdgeEndStar:   " + this.getCoordinate()), t.append("\n");
                        for (var e = this.iterator(); e.hasNext();) {
                            var i = e.next();
                            t.append(i), t.append("\n")
                        }
                        return t.toString()
                    },
                    computeEdgeEndLabels: function(t) {
                        for (var e = this.iterator(); e.hasNext();) {
                            var i = e.next();
                            i.computeLabel(t)
                        }
                    },
                    computeLabelling: function(t) {
                        this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
                        for (var e = [!1, !1], i = this.iterator(); i.hasNext();)
                            for (var n = i.next(), r = n.getLabel(), o = 0; 2 > o; o++) r.isLine(o) && r.getLocation(o) === C.BOUNDARY && (e[o] = !0);
                        for (var i = this.iterator(); i.hasNext();)
                            for (var n = i.next(), r = n.getLabel(), o = 0; 2 > o; o++)
                                if (r.isAnyNull(o)) {
                                    var s = C.NONE;
                                    if (e[o]) s = C.EXTERIOR;
                                    else {
                                        var a = n.getCoordinate();
                                        s = this.getLocation(o, a, t)
                                    }
                                    r.setAllLocationsIfNull(o, s)
                                }
                    },
                    getDegree: function() { return this.edgeMap.size() },
                    insertEdgeEnd: function(t, e) { this.edgeMap.put(t, e), this.edgeList = null },
                    interfaces_: function() { return [] },
                    getClass: function() { return Ii }
                }), u(ki, Ii), e(ki.prototype, {
                    linkResultDirectedEdges: function() {
                        this.getResultAreaEdges();
                        for (var t = null, e = null, i = this.SCANNING_FOR_INCOMING, n = 0; n < this.resultAreaEdgeList.size(); n++) {
                            var r = this.resultAreaEdgeList.get(n),
                                o = r.getSym();
                            if (r.getLabel().isArea()) switch (null === t && r.isInResult() && (t = r), i) {
                                case this.SCANNING_FOR_INCOMING:
                                    if (!o.isInResult()) continue;
                                    e = o, i = this.LINKING_TO_OUTGOING;
                                    break;
                                case this.LINKING_TO_OUTGOING:
                                    if (!r.isInResult()) continue;
                                    e.setNext(r), i = this.SCANNING_FOR_INCOMING
                            }
                        }
                        if (i === this.LINKING_TO_OUTGOING) {
                            if (null === t) throw new ri("no outgoing dirEdge found", this.getCoordinate());
                            c.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t)
                        }
                    },
                    insert: function(t) {
                        var e = t;
                        this.insertEdgeEnd(e, e)
                    },
                    getRightmostEdge: function() {
                        var t = this.getEdges(),
                            e = t.size();
                        if (1 > e) return null;
                        var i = t.get(0);
                        if (1 === e) return i;
                        var n = t.get(e - 1),
                            r = i.getQuadrant(),
                            o = n.getQuadrant();
                        return Je.isNorthern(r) && Je.isNorthern(o) ? i : Je.isNorthern(r) || Je.isNorthern(o) ? 0 !== i.getDy() ? i : 0 !== n.getDy() ? n : (c.shouldNeverReachHere("found two horizontal edges incident on node"), null) : n
                    },
                    print: function(t) {
                        O.out.println("DirectedEdgeStar: " + this.getCoordinate());
                        for (var e = this.iterator(); e.hasNext();) {
                            var i = e.next();
                            t.print("out "), i.print(t), t.println(), t.print("in "), i.getSym().print(t), t.println()
                        }
                    },
                    getResultAreaEdges: function() {
                        if (null !== this.resultAreaEdgeList) return this.resultAreaEdgeList;
                        this.resultAreaEdgeList = new x;
                        for (var t = this.iterator(); t.hasNext();) {
                            var e = t.next();
                            (e.isInResult() || e.getSym().isInResult()) && this.resultAreaEdgeList.add(e)
                        }
                        return this.resultAreaEdgeList
                    },
                    updateLabelling: function(t) {
                        for (var e = this.iterator(); e.hasNext();) {
                            var i = e.next(),
                                n = i.getLabel();
                            n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1))
                        }
                    },
                    linkAllDirectedEdges: function() {
                        this.getEdges();
                        for (var t = null, e = null, i = this.edgeList.size() - 1; i >= 0; i--) {
                            var n = this.edgeList.get(i),
                                r = n.getSym();
                            null === e && (e = r), null !== t && r.setNext(t), t = n
                        }
                        e.setNext(t)
                    },
                    computeDepths: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0],
                                e = this.findIndex(t),
                                i = (t.getLabel(), t.getDepth(ui.LEFT)),
                                n = t.getDepth(ui.RIGHT),
                                r = this.computeDepths(e + 1, this.edgeList.size(), i),
                                o = this.computeDepths(0, e, r);
                            if (o !== n) throw new ri("depth mismatch at " + t.getCoordinate())
                        } else if (3 === arguments.length) {
                            for (var s = arguments[0], a = arguments[1], h = arguments[2], l = h, u = s; a > u; u++) {
                                var p = this.edgeList.get(u);
                                p.getLabel(), p.setEdgeDepths(ui.RIGHT, l), l = p.getDepth(ui.LEFT)
                            }
                            return l
                        }
                    },
                    mergeSymLabels: function() {
                        for (var t = this.iterator(); t.hasNext();) {
                            var e = t.next(),
                                i = e.getLabel();
                            i.merge(e.getSym().getLabel())
                        }
                    },
                    linkMinimalDirectedEdges: function(t) {
                        for (var e = null, i = null, n = this.SCANNING_FOR_INCOMING, r = this.resultAreaEdgeList.size() - 1; r >= 0; r--) {
                            var o = this.resultAreaEdgeList.get(r),
                                s = o.getSym();
                            switch (null === e && o.getEdgeRing() === t && (e = o), n) {
                                case this.SCANNING_FOR_INCOMING:
                                    if (s.getEdgeRing() !== t) continue;
                                    i = s, n = this.LINKING_TO_OUTGOING;
                                    break;
                                case this.LINKING_TO_OUTGOING:
                                    if (o.getEdgeRing() !== t) continue;
                                    i.setNextMin(o), n = this.SCANNING_FOR_INCOMING
                            }
                        }
                        n === this.LINKING_TO_OUTGOING && (c.isTrue(null !== e, "found null for first outgoing dirEdge"), c.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), i.setNextMin(e))
                    },
                    getOutgoingDegree: function() {
                        if (0 === arguments.length) {
                            for (var t = 0, e = this.iterator(); e.hasNext();) {
                                var i = e.next();
                                i.isInResult() && t++
                            }
                            return t
                        }
                        if (1 === arguments.length) {
                            for (var n = arguments[0], t = 0, e = this.iterator(); e.hasNext();) {
                                var i = e.next();
                                i.getEdgeRing() === n && t++
                            }
                            return t
                        }
                    },
                    getLabel: function() { return this.label },
                    findCoveredLineEdges: function() {
                        for (var t = C.NONE, e = this.iterator(); e.hasNext();) {
                            var i = e.next(),
                                n = i.getSym();
                            if (!i.isLineEdge()) { if (i.isInResult()) { t = C.INTERIOR; break } if (n.isInResult()) { t = C.EXTERIOR; break } }
                        }
                        if (t === C.NONE) return null;
                        for (var r = t, e = this.iterator(); e.hasNext();) {
                            var i = e.next(),
                                n = i.getSym();
                            i.isLineEdge() ? i.getEdge().setCovered(r === C.INTERIOR) : (i.isInResult() && (r = C.EXTERIOR), n.isInResult() && (r = C.INTERIOR))
                        }
                    },
                    computeLabelling: function(t) {
                        Ii.prototype.computeLabelling.call(this, t), this.label = new ci(C.NONE);
                        for (var e = this.iterator(); e.hasNext();)
                            for (var i = e.next(), n = i.getEdge(), r = n.getLabel(), o = 0; 2 > o; o++) {
                                var s = r.getLocation(o);
                                s !== C.INTERIOR && s !== C.BOUNDARY || this.label.setLocation(o, C.INTERIOR)
                            }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return ki }
                }), u(Ti, xi), e(Ti.prototype, { createNode: function(t) { return new mi(t, new ki) }, interfaces_: function() { return [] }, getClass: function() { return Ti } }), e(Ai.prototype, { computeIntersections: function(t, e) { this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e) }, interfaces_: function() { return [] }, getClass: function() { return Ai } }), e(Ri.prototype, { isDelete: function() { return this.eventType === Ri.DELETE }, setDeleteEventIndex: function(t) { this.deleteEventIndex = t }, getObject: function() { return this.obj }, compareTo: function(t) { var e = t; return this.xValue < e.xValue ? -1 : this.xValue > e.xValue ? 1 : this.eventType < e.eventType ? -1 : this.eventType > e.eventType ? 1 : 0 }, getInsertEvent: function() { return this.insertEvent }, isInsert: function() { return this.eventType === Ri.INSERT }, isSameLabel: function(t) { return null !== this.label && this.label === t.label }, getDeleteEventIndex: function() { return this.deleteEventIndex }, interfaces_: function() { return [o] }, getClass: function() { return Ri } }), Ri.INSERT = 1, Ri.DELETE = 2, e(_i.prototype, { interfaces_: function() { return [] }, getClass: function() { return _i } }), e(Pi.prototype, {
                    isTrivialIntersection: function(t, e, i, n) { if (t === i && 1 === this.li.getIntersectionNum()) { if (Pi.isAdjacentSegments(e, n)) return !0; if (t.isClosed()) { var r = t.getNumPoints() - 1; if (0 === e && n === r || 0 === n && e === r) return !0 } } return !1 },
                    getProperIntersectionPoint: function() { return this.properIntersectionPoint },
                    setIsDoneIfProperInt: function(t) { this.isDoneWhenProperInt = t },
                    hasProperInteriorIntersection: function() { return this.hasProperInterior },
                    isBoundaryPointInternal: function(t, e) {
                        for (var i = e.iterator(); i.hasNext();) {
                            var n = i.next(),
                                r = n.getCoordinate();
                            if (t.isIntersection(r)) return !0
                        }
                        return !1
                    },
                    hasProperIntersection: function() { return this.hasProper },
                    hasIntersection: function() { return this._hasIntersection },
                    isDone: function() { return this._isDone },
                    isBoundaryPoint: function(t, e) { return null !== e && (!!this.isBoundaryPointInternal(t, e[0]) || !!this.isBoundaryPointInternal(t, e[1])) },
                    setBoundaryNodes: function(t, e) { this.bdyNodes = new Array(2).fill(null), this.bdyNodes[0] = t, this.bdyNodes[1] = e },
                    addIntersections: function(t, e, i, n) {
                        if (t === i && e === n) return null;
                        this.numTests++;
                        var r = t.getCoordinates()[e],
                            o = t.getCoordinates()[e + 1],
                            s = i.getCoordinates()[n],
                            a = i.getCoordinates()[n + 1];
                        this.li.computeIntersection(r, o, s, a), this.li.hasIntersection() && (this.recordIsolated && (t.setIsolated(!1), i.setIsolated(!1)), this.numIntersections++, this.isTrivialIntersection(t, e, i, n) || (this._hasIntersection = !0, !this.includeProper && this.li.isProper() || (t.addIntersections(this.li, e, 0), i.addIntersections(this.li, n, 1)), this.li.isProper() && (this.properIntersectionPoint = this.li.getIntersection(0).copy(), this.hasProper = !0, this.isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this.li, this.bdyNodes) || (this.hasProperInterior = !0))))
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Pi }
                }), Pi.isAdjacentSegments = function(t, e) { return 1 === Math.abs(t - e) }, u(Oi, _i), e(Oi.prototype, {
                    prepareEvents: function() {
                        ps.sort(this.events);
                        for (var t = 0; t < this.events.size(); t++) {
                            var e = this.events.get(t);
                            e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t)
                        }
                    },
                    computeIntersections: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.nOverlaps = 0, this.prepareEvents();
                            for (var e = 0; e < this.events.size(); e++) { var i = this.events.get(e); if (i.isInsert() && this.processOverlaps(e, i.getDeleteEventIndex(), i, t), t.isDone()) break }
                        } else if (3 === arguments.length)
                            if (arguments[2] instanceof Pi && M(arguments[0], v) && M(arguments[1], v)) {
                                var n = arguments[0],
                                    r = arguments[1],
                                    o = arguments[2];
                                this.addEdges(n, n), this.addEdges(r, r), this.computeIntersections(o)
                            } else if ("boolean" == typeof arguments[2] && M(arguments[0], v) && arguments[1] instanceof Pi) {
                            var s = arguments[0],
                                a = arguments[1],
                                h = arguments[2];
                            h ? this.addEdges(s, null) : this.addEdges(s), this.computeIntersections(a)
                        }
                    },
                    addEdge: function(t, e) {
                        for (var i = t.getMonotoneChainEdge(), n = i.getStartIndexes(), r = 0; r < n.length - 1; r++) {
                            var o = new Ai(i, r),
                                s = new Ri(e, i.getMinX(r), o);
                            this.events.add(s), this.events.add(new Ri(i.getMaxX(r), s))
                        }
                    },
                    processOverlaps: function(t, e, i, n) {
                        for (var r = i.getObject(), o = t; e > o; o++) {
                            var s = this.events.get(o);
                            if (s.isInsert()) {
                                var a = s.getObject();
                                i.isSameLabel(s) || (r.computeIntersections(a, n), this.nOverlaps++)
                            }
                        }
                    },
                    addEdges: function() {
                        if (1 === arguments.length)
                            for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
                                var i = e.next();
                                this.addEdge(i, i)
                            } else if (2 === arguments.length)
                                for (var n = arguments[0], r = arguments[1], e = n.iterator(); e.hasNext();) {
                                    var i = e.next();
                                    this.addEdge(i, r)
                                }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Oi }
                }), e(Di.prototype, { getMin: function() { return this.min }, intersects: function(t, e) { return !(this.min > e || this.max < t) }, getMax: function() { return this.max }, toString: function() { return oe.toLineString(new f(this.min, 0), new f(this.max, 0)) }, interfaces_: function() { return [] }, getClass: function() { return Di } }), e(Fi.prototype, {
                    compare: function(t, e) {
                        var i = t,
                            n = e,
                            r = (i.min + i.max) / 2,
                            o = (n.min + n.max) / 2;
                        return o > r ? -1 : r > o ? 1 : 0
                    },
                    interfaces_: function() { return [a] },
                    getClass: function() { return Fi }
                }), Di.NodeComparator = Fi, u(Ui, Di), e(Ui.prototype, { query: function(t, e, i) { return this.intersects(t, e) ? void i.visitItem(this.item) : null }, interfaces_: function() { return [] }, getClass: function() { return Ui } }), u(Bi, Di), e(Bi.prototype, { buildExtent: function(t, e) { this.min = Math.min(t.min, e.min), this.max = Math.max(t.max, e.max) }, query: function(t, e, i) { return this.intersects(t, e) ? (null !== this.node1 && this.node1.query(t, e, i), void(null !== this.node2 && this.node2.query(t, e, i))) : null }, interfaces_: function() { return [] }, getClass: function() { return Bi } }), e(ji.prototype, {
                    buildTree: function() {
                        ps.sort(this.leaves, new IntervalRTreeNode.NodeComparator);
                        for (var t = this.leaves, e = null, i = new x;;) {
                            if (this.buildLevel(t, i), 1 === i.size()) return i.get(0);
                            e = t, t = i, i = e
                        }
                    },
                    insert: function(t, e, i) {
                        if (null !== this.root) throw new IllegalStateException("Index cannot be added to once it has been queried");
                        this.leaves.add(new Ui(t, e, i))
                    },
                    query: function(t, e, i) { this.init(), this.root.query(t, e, i) },
                    buildRoot: function() { return null !== this.root ? null : void(this.root = this.buildTree()) },
                    printNode: function(t) { O.out.println(oe.toLineString(new f(t.min, this.level), new f(t.max, this.level))) },
                    init: function() { return null !== this.root ? null : void this.buildRoot() },
                    buildLevel: function(t, e) {
                        this.level++, e.clear();
                        for (var i = 0; i < t.size(); i += 2) {
                            var n = t.get(i),
                                r = i + 1 < t.size() ? t.get(i) : null;
                            if (null === r) e.add(n);
                            else {
                                var o = new Bi(t.get(i), t.get(i + 1));
                                e.add(o)
                            }
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return ji }
                }), e(zi.prototype, {
                    filter: function(t) {
                        if (this.isForcedToLineString && t instanceof Tt) { var e = t.getFactory().createLineString(t.getCoordinateSequence()); return this.lines.add(e), null }
                        t instanceof Nt && this.lines.add(t)
                    },
                    setForceToLineString: function(t) { this.isForcedToLineString = t },
                    interfaces_: function() { return [U] },
                    getClass: function() { return zi }
                }), zi.getGeometry = function() {
                    if (1 === arguments.length) { var t = arguments[0]; return t.getFactory().buildGeometry(zi.getLines(t)) }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        return e.getFactory().buildGeometry(zi.getLines(e, i))
                    }
                }, zi.getLines = function() {
                    if (1 === arguments.length) { var t = arguments[0]; return zi.getLines(t, !1) }
                    if (2 === arguments.length) {
                        if (M(arguments[0], y) && M(arguments[1], y)) {
                            for (var e = arguments[0], i = arguments[1], n = e.iterator(); n.hasNext();) {
                                var r = n.next();
                                zi.getLines(r, i)
                            }
                            return i
                        }
                        if (arguments[0] instanceof B && "boolean" == typeof arguments[1]) {
                            var o = arguments[0],
                                s = arguments[1],
                                a = new x;
                            return o.apply(new zi(a, s)), a
                        }
                        if (arguments[0] instanceof B && M(arguments[1], y)) {
                            var h = arguments[0],
                                l = arguments[1];
                            return h instanceof Nt ? l.add(h) : h.apply(new zi(l)), l
                        }
                    } else if (3 === arguments.length) {
                        if ("boolean" == typeof arguments[2] && M(arguments[0], y) && M(arguments[1], y)) {
                            for (var u = arguments[0], p = arguments[1], c = arguments[2], n = u.iterator(); n.hasNext();) {
                                var r = n.next();
                                zi.getLines(r, p, c)
                            }
                            return p
                        }
                        if ("boolean" == typeof arguments[2] && arguments[0] instanceof B && M(arguments[1], y)) {
                            var f = arguments[0],
                                g = arguments[1],
                                d = arguments[2];
                            return f.apply(new zi(g, d)), g
                        }
                    }
                }, e(Gi.prototype, { visitItem: function(t) { this.items.add(t) }, getItems: function() { return this.items }, interfaces_: function() { return [Oe] }, getClass: function() { return Gi } }), e(qi.prototype, {
                    locate: function(t) {
                        var e = new le(t),
                            i = new Vi(e);
                        return this.index.query(t.y, t.y, i), e.getLocation()
                    },
                    interfaces_: function() { return [Ci] },
                    getClass: function() { return qi }
                }), e(Vi.prototype, {
                    visitItem: function(t) {
                        var e = t;
                        this.counter.countSegment(e.getCoordinate(0), e.getCoordinate(1))
                    },
                    interfaces_: function() { return [Oe] },
                    getClass: function() { return Vi }
                }), e(Wi.prototype, {
                    init: function(t) {
                        for (var e = zi.getLines(t), i = e.iterator(); i.hasNext();) {
                            var n = i.next(),
                                r = n.getCoordinates();
                            this.addLine(r)
                        }
                    },
                    addLine: function(t) {
                        for (var e = 1; e < t.length; e++) {
                            var i = new pe(t[e - 1], t[e]),
                                n = Math.min(i.p0.y, i.p1.y),
                                r = Math.max(i.p0.y, i.p1.y);
                            this.index.insert(n, r, i)
                        }
                    },
                    query: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1],
                                i = new Gi;
                            return this.index.query(t, e, i), i.getItems()
                        }
                        if (3 === arguments.length) {
                            var n = arguments[0],
                                r = arguments[1],
                                o = arguments[2];
                            this.index.query(n, r, o)
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Wi }
                }), qi.SegmentVisitor = Vi, qi.IntervalIndexedGeometry = Wi, e(Xi.prototype, { getSegmentIndex: function() { return this.segmentIndex }, getCoordinate: function() { return this.coord }, print: function(t) { t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist) }, compareTo: function(t) { var e = t; return this.compare(e.segmentIndex, e.dist) }, isEndPoint: function(t) { return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t }, toString: function() { return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist }, getDistance: function() { return this.dist }, compare: function(t, e) { return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0 }, interfaces_: function() { return [o] }, getClass: function() { return Xi } }), e(Hi.prototype, {
                    print: function(t) {
                        t.println("Intersections:");
                        for (var e = this.iterator(); e.hasNext();) {
                            var i = e.next();
                            i.print(t)
                        }
                    },
                    iterator: function() { return this.nodeMap.values().iterator() },
                    addSplitEdges: function(t) {
                        this.addEndpoints();
                        for (var e = this.iterator(), i = e.next(); e.hasNext();) {
                            var n = e.next(),
                                r = this.createSplitEdge(i, n);
                            t.add(r), i = n
                        }
                    },
                    addEndpoints: function() {
                        var t = this.edge.pts.length - 1;
                        this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0)
                    },
                    createSplitEdge: function(t, e) {
                        var i = e.segmentIndex - t.segmentIndex + 2,
                            n = this.edge.pts[e.segmentIndex],
                            r = e.dist > 0 || !e.coord.equals2D(n);
                        r || i--;
                        var o = new Array(i).fill(null),
                            s = 0;
                        o[s++] = new f(t.coord);
                        for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) o[s++] = this.edge.pts[a];
                        return r && (o[s] = e.coord), new Zi(o, new ci(this.edge.label))
                    },
                    add: function(t, e, i) {
                        var n = new Xi(t, e, i),
                            r = this.nodeMap.get(n);
                        return null !== r ? r : (this.nodeMap.put(n, n), n)
                    },
                    isIntersection: function(t) { for (var e = this.iterator(); e.hasNext();) { var i = e.next(); if (i.coord.equals(t)) return !0 } return !1 },
                    interfaces_: function() { return [] },
                    getClass: function() { return Hi }
                }), e(Yi.prototype, {
                    getChainStartIndices: function(t) {
                        var e = 0,
                            i = new x;
                        i.add(new T(e));
                        do {
                            var n = this.findChainEnd(t, e);
                            i.add(new T(n)), e = n
                        } while (e < t.length - 1);
                        var r = Yi.toIntArray(i);
                        return r
                    },
                    findChainEnd: function(t, e) {
                        for (var i = Je.quadrant(t[e], t[e + 1]), n = e + 1; n < t.length;) {
                            var r = Je.quadrant(t[n - 1], t[n]);
                            if (r !== i) break;
                            n++
                        }
                        return n - 1
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Yi }
                }), Yi.toIntArray = function(t) { for (var e = new Array(t.size()).fill(null), i = 0; i < e.length; i++) e[i] = t.get(i).intValue(); return e }, e(Ki.prototype, {
                    getCoordinates: function() { return this.pts },
                    getMaxX: function(t) {
                        var e = this.pts[this.startIndex[t]].x,
                            i = this.pts[this.startIndex[t + 1]].x;
                        return e > i ? e : i
                    },
                    getMinX: function(t) {
                        var e = this.pts[this.startIndex[t]].x,
                            i = this.pts[this.startIndex[t + 1]].x;
                        return i > e ? e : i
                    },
                    computeIntersectsForChain: function() {
                        if (4 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1],
                                i = arguments[2],
                                n = arguments[3];
                            this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[i], e.startIndex[i + 1], n)
                        } else if (6 === arguments.length) {
                            var r = arguments[0],
                                o = arguments[1],
                                s = arguments[2],
                                a = arguments[3],
                                h = arguments[4],
                                l = arguments[5],
                                u = this.pts[r],
                                p = this.pts[o],
                                c = s.pts[a],
                                f = s.pts[h];
                            if (o - r === 1 && h - a === 1) return l.addIntersections(this.e, r, s.e, a), null;
                            if (this.env1.init(u, p), this.env2.init(c, f), !this.env1.intersects(this.env2)) return null;
                            var g = Math.trunc((r + o) / 2),
                                d = Math.trunc((a + h) / 2);
                            g > r && (d > a && this.computeIntersectsForChain(r, g, s, a, d, l), h > d && this.computeIntersectsForChain(r, g, s, d, h, l)), o > g && (d > a && this.computeIntersectsForChain(g, o, s, a, d, l), h > d && this.computeIntersectsForChain(g, o, s, d, h, l))
                        }
                    },
                    getStartIndexes: function() { return this.startIndex },
                    computeIntersects: function(t, e) {
                        for (var i = 0; i < this.startIndex.length - 1; i++)
                            for (var n = 0; n < t.startIndex.length - 1; n++) this.computeIntersectsForChain(i, t, n, e)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Ki }
                }), e($i.prototype, {
                    getDepth: function(t, e) { return this.depth[t][e] },
                    setDepth: function(t, e, i) { this.depth[t][e] = i },
                    isNull: function() {
                        if (0 === arguments.length) {
                            for (var t = 0; 2 > t; t++)
                                for (var e = 0; 3 > e; e++)
                                    if (this.depth[t][e] !== $i.NULL_VALUE) return !1;
                            return !0
                        }
                        if (1 === arguments.length) { var i = arguments[0]; return this.depth[i][1] === $i.NULL_VALUE }
                        if (2 === arguments.length) {
                            var n = arguments[0],
                                r = arguments[1];
                            return this.depth[n][r] === $i.NULL_VALUE
                        }
                    },
                    normalize: function() {
                        for (var t = 0; 2 > t; t++)
                            if (!this.isNull(t)) {
                                var e = this.depth[t][1];
                                this.depth[t][2] < e && (e = this.depth[t][2]), 0 > e && (e = 0);
                                for (var i = 1; 3 > i; i++) {
                                    var n = 0;
                                    this.depth[t][i] > e && (n = 1), this.depth[t][i] = n
                                }
                            }
                    },
                    getDelta: function(t) { return this.depth[t][ui.RIGHT] - this.depth[t][ui.LEFT] },
                    getLocation: function(t, e) { return this.depth[t][e] <= 0 ? C.EXTERIOR : C.INTERIOR },
                    toString: function() { return "A: " + this.depth[0][1] + "," + this.depth[0][2] + " B: " + this.depth[1][1] + "," + this.depth[1][2] },
                    add: function() {
                        if (1 === arguments.length)
                            for (var t = arguments[0], e = 0; 2 > e; e++)
                                for (var i = 1; 3 > i; i++) {
                                    var n = t.getLocation(e, i);
                                    n !== C.EXTERIOR && n !== C.INTERIOR || (this.isNull(e, i) ? this.depth[e][i] = $i.depthAtLocation(n) : this.depth[e][i] += $i.depthAtLocation(n))
                                } else if (3 === arguments.length) {
                                    var r = arguments[0],
                                        o = arguments[1],
                                        s = arguments[2];
                                    s === C.INTERIOR && this.depth[r][o]++
                                }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return $i }
                }), $i.depthAtLocation = function(t) { return t === C.EXTERIOR ? 0 : t === C.INTERIOR ? 1 : $i.NULL_VALUE }, $i.NULL_VALUE = -1, u(Zi, yi), e(Zi.prototype, {
                    getDepth: function() { return this.depth },
                    getCollapsedEdge: function() {
                        var t = new Array(2).fill(null);
                        t[0] = this.pts[0], t[1] = this.pts[1];
                        var e = new Zi(t, ci.toLineLabel(this.label));
                        return e
                    },
                    isIsolated: function() { return this._isIsolated },
                    getCoordinates: function() { return this.pts },
                    setIsolated: function(t) { this._isIsolated = t },
                    setName: function(t) { this.name = t },
                    equals: function(t) {
                        if (!(t instanceof Zi)) return !1;
                        var e = t;
                        if (this.pts.length !== e.pts.length) return !1;
                        for (var i = !0, n = !0, r = this.pts.length, o = 0; o < this.pts.length; o++)
                            if (this.pts[o].equals2D(e.pts[o]) || (i = !1), this.pts[o].equals2D(e.pts[--r]) || (n = !1), !i && !n) return !1;
                        return !0
                    },
                    getCoordinate: function() { if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null; if (1 === arguments.length) { var t = arguments[0]; return this.pts[t] } },
                    print: function(t) {
                        t.print("edge " + this.name + ": "), t.print("LINESTRING (");
                        for (var e = 0; e < this.pts.length; e++) e > 0 && t.print(","), t.print(this.pts[e].x + " " + this.pts[e].y);
                        t.print(")  " + this.label + " " + this.depthDelta)
                    },
                    computeIM: function(t) { Zi.updateIM(this.label, t) },
                    isCollapsed: function() { return !!this.label.isArea() && (3 === this.pts.length && !!this.pts[0].equals(this.pts[2])) },
                    isClosed: function() { return this.pts[0].equals(this.pts[this.pts.length - 1]) },
                    getMaximumSegmentIndex: function() { return this.pts.length - 1 },
                    getDepthDelta: function() { return this.depthDelta },
                    getNumPoints: function() { return this.pts.length },
                    printReverse: function(t) {
                        t.print("edge " + this.name + ": ");
                        for (var e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + " ");
                        t.println("")
                    },
                    getMonotoneChainEdge: function() { return null === this.mce && (this.mce = new Ki(this)), this.mce },
                    getEnvelope: function() { if (null === this.env) { this.env = new S; for (var t = 0; t < this.pts.length; t++) this.env.expandToInclude(this.pts[t]) } return this.env },
                    addIntersection: function(t, e, i, n) {
                        var r = new f(t.getIntersection(n)),
                            o = e,
                            s = t.getEdgeDistance(i, n),
                            a = o + 1;
                        if (a < this.pts.length) {
                            var h = this.pts[a];
                            r.equals2D(h) && (o = a, s = 0)
                        }
                        this.eiList.add(r, o, s)
                    },
                    toString: function() {
                        var t = new k;
                        t.append("edge " + this.name + ": "), t.append("LINESTRING (");
                        for (var e = 0; e < this.pts.length; e++) e > 0 && t.append(","), t.append(this.pts[e].x + " " + this.pts[e].y);
                        return t.append(")  " + this.label + " " + this.depthDelta), t.toString()
                    },
                    isPointwiseEqual: function(t) {
                        if (this.pts.length !== t.pts.length) return !1;
                        for (var e = 0; e < this.pts.length; e++)
                            if (!this.pts[e].equals2D(t.pts[e])) return !1;
                        return !0
                    },
                    setDepthDelta: function(t) { this.depthDelta = t },
                    getEdgeIntersectionList: function() { return this.eiList },
                    addIntersections: function(t, e, i) { for (var n = 0; n < t.getIntersectionNum(); n++) this.addIntersection(t, e, i, n) },
                    interfaces_: function() { return [] },
                    getClass: function() { return Zi }
                }), Zi.updateIM = function() {
                    if (2 !== arguments.length) return yi.prototype.updateIM.apply(this, arguments);
                    var t = arguments[0],
                        e = arguments[1];
                    e.setAtLeastIfValid(t.getLocation(0, ui.ON), t.getLocation(1, ui.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, ui.LEFT), t.getLocation(1, ui.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, ui.RIGHT), t.getLocation(1, ui.RIGHT), 2))
                }, u(Ji, Ei), e(Ji.prototype, {
                    insertBoundaryPoint: function(t, e) {
                        var i = this.nodes.addNode(e),
                            n = i.getLabel(),
                            r = 1,
                            o = C.NONE;
                        o = n.getLocation(t, ui.ON), o === C.BOUNDARY && r++;
                        var s = Ji.determineBoundary(this.boundaryNodeRule, r);
                        n.setLocation(t, s)
                    },
                    computeSelfNodes: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            return this.computeSelfNodes(t, e, !1)
                        }
                        if (3 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1],
                                r = arguments[2],
                                o = new Pi(i, !0, !1);
                            o.setIsDoneIfProperInt(r);
                            var s = this.createEdgeSetIntersector(),
                                a = this.parentGeom instanceof Tt || this.parentGeom instanceof It || this.parentGeom instanceof At,
                                h = n || !a;
                            return s.computeIntersections(this.edges, o, h), this.addSelfIntersectionNodes(this.argIndex), o
                        }
                    },
                    computeSplitEdges: function(t) {
                        for (var e = this.edges.iterator(); e.hasNext();) {
                            var i = e.next();
                            i.eiList.addSplitEdges(t)
                        }
                    },
                    computeEdgeIntersections: function(t, e, i) {
                        var n = new Pi(e, i, !0);
                        n.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes());
                        var r = this.createEdgeSetIntersector();
                        return r.computeIntersections(this.edges, t.edges, n), n
                    },
                    getGeometry: function() { return this.parentGeom },
                    getBoundaryNodeRule: function() { return this.boundaryNodeRule },
                    hasTooFewPoints: function() { return this._hasTooFewPoints },
                    addPoint: function() {
                        if (arguments[0] instanceof Ct) {
                            var t = arguments[0],
                                e = t.getCoordinate();
                            this.insertPoint(this.argIndex, e, C.INTERIOR)
                        } else if (arguments[0] instanceof f) {
                            var i = arguments[0];
                            this.insertPoint(this.argIndex, i, C.INTERIOR)
                        }
                    },
                    addPolygon: function(t) {
                        this.addPolygonRing(t.getExteriorRing(), C.EXTERIOR, C.INTERIOR);
                        for (var e = 0; e < t.getNumInteriorRing(); e++) {
                            var i = t.getInteriorRingN(e);
                            this.addPolygonRing(i, C.INTERIOR, C.EXTERIOR)
                        }
                    },
                    addEdge: function(t) {
                        this.insertEdge(t);
                        var e = t.getCoordinates();
                        this.insertPoint(this.argIndex, e[0], C.BOUNDARY), this.insertPoint(this.argIndex, e[e.length - 1], C.BOUNDARY)
                    },
                    addLineString: function(t) {
                        var e = X.removeRepeatedPoints(t.getCoordinates());
                        if (e.length < 2) return this._hasTooFewPoints = !0, this.invalidPoint = e[0], null;
                        var i = new Zi(e, new ci(this.argIndex, C.INTERIOR));
                        this.lineEdgeMap.put(t, i), this.insertEdge(i), c.isTrue(e.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this.argIndex, e[0]), this.insertBoundaryPoint(this.argIndex, e[e.length - 1])
                    },
                    getInvalidPoint: function() { return this.invalidPoint },
                    getBoundaryPoints: function() {
                        for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), i = 0, n = t.iterator(); n.hasNext();) {
                            var r = n.next();
                            e[i++] = r.getCoordinate().copy()
                        }
                        return e
                    },
                    getBoundaryNodes: function() { return null === this.boundaryNodes && (this.boundaryNodes = this.nodes.getBoundaryNodes(this.argIndex)), this.boundaryNodes },
                    addSelfIntersectionNode: function(t, e, i) { return this.isBoundaryNode(t, e) ? null : void(i === C.BOUNDARY && this.useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, i)) },
                    addPolygonRing: function(t, e, i) {
                        if (t.isEmpty()) return null;
                        var n = X.removeRepeatedPoints(t.getCoordinates());
                        if (n.length < 4) return this._hasTooFewPoints = !0, this.invalidPoint = n[0], null;
                        var r = e,
                            o = i;
                        ue.isCCW(n) && (r = i, o = e);
                        var s = new Zi(n, new ci(this.argIndex, C.BOUNDARY, r, o));
                        this.lineEdgeMap.put(t, s), this.insertEdge(s), this.insertPoint(this.argIndex, n[0], C.BOUNDARY)
                    },
                    insertPoint: function(t, e, i) {
                        var n = this.nodes.addNode(e),
                            r = n.getLabel();
                        null === r ? n.label = new ci(t, i) : r.setLocation(t, i)
                    },
                    createEdgeSetIntersector: function() { return new Oi },
                    addSelfIntersectionNodes: function(t) {
                        for (var e = this.edges.iterator(); e.hasNext();)
                            for (var i = e.next(), n = i.getLabel().getLocation(t), r = i.eiList.iterator(); r.hasNext();) {
                                var o = r.next();
                                this.addSelfIntersectionNode(t, o.coord, n)
                            }
                    },
                    add: function() {
                        if (1 !== arguments.length) return Ei.prototype.add.apply(this, arguments);
                        var t = arguments[0];
                        if (t.isEmpty()) return null;
                        if (t instanceof At && (this.useBoundaryDeterminationRule = !1), t instanceof It) this.addPolygon(t);
                        else if (t instanceof Nt) this.addLineString(t);
                        else if (t instanceof Ct) this.addPoint(t);
                        else if (t instanceof kt) this.addCollection(t);
                        else if (t instanceof ft) this.addCollection(t);
                        else if (t instanceof At) this.addCollection(t);
                        else {
                            if (!(t instanceof ct)) throw new UnsupportedOperationException(t.getClass().getName());
                            this.addCollection(t)
                        }
                    },
                    addCollection: function(t) {
                        for (var e = 0; e < t.getNumGeometries(); e++) {
                            var i = t.getGeometryN(e);
                            this.add(i)
                        }
                    },
                    locate: function(t) { return M(this.parentGeom, Mt) && this.parentGeom.getNumGeometries() > 50 ? (null === this.areaPtLocator && (this.areaPtLocator = new qi(this.parentGeom)), this.areaPtLocator.locate(t)) : this.ptLocator.locate(t, this.parentGeom) },
                    findEdge: function() { if (1 === arguments.length) { var t = arguments[0]; return this.lineEdgeMap.get(t) } return Ei.prototype.findEdge.apply(this, arguments) },
                    interfaces_: function() { return [] },
                    getClass: function() { return Ji }
                }), Ji.determineBoundary = function(t, e) { return t.isInBoundary(e) ? C.BOUNDARY : C.INTERIOR }, e(Qi.prototype, { getArgGeometry: function(t) { return this.arg[t].getGeometry() }, setComputationPrecision: function(t) { this.resultPrecisionModel = t, this.li.setPrecisionModel(this.resultPrecisionModel) }, interfaces_: function() { return [] }, getClass: function() { return Qi } }), e(tn.prototype, {
                    compareTo: function(t) {
                        var e = t,
                            i = tn.compareOriented(this.pts, this._orientation, e.pts, e._orientation);
                        return i
                    },
                    interfaces_: function() { return [o] },
                    getClass: function() { return tn }
                }), tn.orientation = function(t) { return 1 === X.increasingDirection(t) }, tn.compareOriented = function(t, e, i, n) {
                    for (var r = e ? 1 : -1, o = n ? 1 : -1, s = e ? t.length : -1, a = n ? i.length : -1, h = e ? 0 : t.length - 1, l = n ? 0 : i.length - 1;;) {
                        var u = t[h].compareTo(i[l]);
                        if (0 !== u) return u;
                        h += r, l += o;
                        var p = h === s,
                            c = l === a;
                        if (p && !c) return -1;
                        if (!p && c) return 1;
                        if (p && c) return 0
                    }
                }, e(en.prototype, {
                    print: function(t) {
                        t.print("MULTILINESTRING ( ");
                        for (var e = 0; e < this.edges.size(); e++) {
                            var i = this.edges.get(e);
                            e > 0 && t.print(","), t.print("(");
                            for (var n = i.getCoordinates(), r = 0; r < n.length; r++) r > 0 && t.print(","), t.print(n[r].x + " " + n[r].y);
                            t.println(")")
                        }
                        t.print(")  ")
                    },
                    addAll: function(t) { for (var e = t.iterator(); e.hasNext();) this.add(e.next()) },
                    findEdgeIndex: function(t) {
                        for (var e = 0; e < this.edges.size(); e++)
                            if (this.edges.get(e).equals(t)) return e;
                        return -1
                    },
                    iterator: function() { return this.edges.iterator() },
                    getEdges: function() { return this.edges },
                    get: function(t) { return this.edges.get(t) },
                    findEqualEdge: function(t) {
                        var e = new tn(t.getCoordinates()),
                            i = this.ocaMap.get(e);
                        return i
                    },
                    add: function(t) {
                        this.edges.add(t);
                        var e = new tn(t.getCoordinates());
                        this.ocaMap.put(e, t)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return en }
                }), u(nn, Qi), e(nn.prototype, {
                    insertUniqueEdge: function(t) {
                        var e = this.edgeList.findEqualEdge(t);
                        if (null !== e) {
                            var i = e.getLabel(),
                                n = t.getLabel();
                            e.isPointwiseEqual(t) || (n = new ci(t.getLabel()), n.flip());
                            var r = e.getDepth();
                            r.isNull() && r.add(i), r.add(n), i.merge(n)
                        } else this.edgeList.add(t)
                    },
                    getGraph: function() { return this.graph },
                    cancelDuplicateResultEdges: function() {
                        for (var t = this.graph.getEdgeEnds().iterator(); t.hasNext();) {
                            var e = t.next(),
                                i = e.getSym();
                            e.isInResult() && i.isInResult() && (e.setInResult(!1), i.setInResult(!1))
                        }
                    },
                    isCoveredByLA: function(t) { return !!this.isCovered(t, this.resultLineList) || !!this.isCovered(t, this.resultPolyList) },
                    computeGeometry: function(t, e, i, n) { var r = new x; return r.addAll(t), r.addAll(e), r.addAll(i), r.isEmpty() ? nn.createEmptyResult(n, this.arg[0].getGeometry(), this.arg[1].getGeometry(), this.geomFact) : this.geomFact.buildGeometry(r) },
                    mergeSymLabels: function() {
                        for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
                            var e = t.next();
                            e.getEdges().mergeSymLabels()
                        }
                    },
                    isCovered: function(t, e) {
                        for (var i = e.iterator(); i.hasNext();) {
                            var n = i.next(),
                                r = this.ptLocator.locate(t, n);
                            if (r !== C.EXTERIOR) return !0
                        }
                        return !1
                    },
                    replaceCollapsedEdges: function() {
                        for (var t = new x, e = this.edgeList.iterator(); e.hasNext();) {
                            var i = e.next();
                            i.isCollapsed() && (e.remove(), t.add(i.getCollapsedEdge()))
                        }
                        this.edgeList.addAll(t)
                    },
                    updateNodeLabelling: function() {
                        for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
                            var e = t.next(),
                                i = e.getEdges().getLabel();
                            e.getLabel().merge(i)
                        }
                    },
                    getResultGeometry: function(t) { return this.computeOverlay(t), this.resultGeom },
                    insertUniqueEdges: function(t) {
                        for (var e = t.iterator(); e.hasNext();) {
                            var i = e.next();
                            this.insertUniqueEdge(i)
                        }
                    },
                    computeOverlay: function(t) {
                        this.copyPoints(0), this.copyPoints(1), this.arg[0].computeSelfNodes(this.li, !1), this.arg[1].computeSelfNodes(this.li, !1), this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !0);
                        var e = new x;
                        this.arg[0].computeSplitEdges(e), this.arg[1].computeSplitEdges(e), this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), hi.checkValid(this.edgeList.getEdges()), this.graph.addEdges(this.edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();
                        var i = new Si(this.geomFact);
                        i.add(this.graph), this.resultPolyList = i.getPolygons();
                        var n = new Ni(this, this.geomFact, this.ptLocator);
                        this.resultLineList = n.build(t);
                        var r = new Li(this, this.geomFact, this.ptLocator);
                        this.resultPointList = r.build(t), this.resultGeom = this.computeGeometry(this.resultPointList, this.resultLineList, this.resultPolyList, t)
                    },
                    labelIncompleteNode: function(t, e) {
                        var i = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());
                        t.getLabel().setLocation(e, i)
                    },
                    copyPoints: function(t) {
                        for (var e = this.arg[t].getNodeIterator(); e.hasNext();) {
                            var i = e.next(),
                                n = this.graph.addNode(i.getCoordinate());
                            n.setLabel(t, i.getLabel().getLocation(t))
                        }
                    },
                    findResultAreaEdges: function(t) {
                        for (var e = this.graph.getEdgeEnds().iterator(); e.hasNext();) {
                            var i = e.next(),
                                n = i.getLabel();
                            n.isArea() && !i.isInteriorAreaEdge() && nn.isResultOfOp(n.getLocation(0, ui.RIGHT), n.getLocation(1, ui.RIGHT), t) && i.setInResult(!0)
                        }
                    },
                    computeLabelsFromDepths: function() {
                        for (var t = this.edgeList.iterator(); t.hasNext();) {
                            var e = t.next(),
                                i = e.getLabel(),
                                n = e.getDepth();
                            if (!n.isNull()) { n.normalize(); for (var r = 0; 2 > r; r++) i.isNull(r) || !i.isArea() || n.isNull(r) || (0 === n.getDelta(r) ? i.toLine(r) : (c.isTrue(!n.isNull(r, ui.LEFT), "depth of LEFT side has not been initialized"), i.setLocation(r, ui.LEFT, n.getLocation(r, ui.LEFT)), c.isTrue(!n.isNull(r, ui.RIGHT), "depth of RIGHT side has not been initialized"), i.setLocation(r, ui.RIGHT, n.getLocation(r, ui.RIGHT)))) }
                        }
                    },
                    computeLabelling: function() {
                        for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
                            var e = t.next();
                            e.getEdges().computeLabelling(this.arg)
                        }
                        this.mergeSymLabels(), this.updateNodeLabelling()
                    },
                    labelIncompleteNodes: function() {
                        for (var t = 0, e = this.graph.getNodes().iterator(); e.hasNext();) {
                            var i = e.next(),
                                n = i.getLabel();
                            i.isIsolated() && (t++, n.isNull(0) ? this.labelIncompleteNode(i, 0) : this.labelIncompleteNode(i, 1)), i.getEdges().updateLabelling(n)
                        }
                    },
                    isCoveredByA: function(t) { return !!this.isCovered(t, this.resultPolyList) },
                    interfaces_: function() { return [] },
                    getClass: function() { return nn }
                }), nn.overlayOp = function(t, e, i) {
                    var n = new nn(t, e),
                        r = n.getResultGeometry(i);
                    return r
                }, nn.intersection = function(t, e) { if (t.isEmpty() || e.isEmpty()) return nn.createEmptyResult(nn.INTERSECTION, t, e, t.getFactory()); if (t.isGeometryCollection()) { var i = e; return li.map(t, { interfaces_: function() { return [MapOp] }, map: function(t) { return t.intersection(i) } }) } return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), on.overlayOp(t, e, nn.INTERSECTION) }, nn.symDifference = function(t, e) { if (t.isEmpty() || e.isEmpty()) { if (t.isEmpty() && e.isEmpty()) return nn.createEmptyResult(nn.SYMDIFFERENCE, t, e, t.getFactory()); if (t.isEmpty()) return e.copy(); if (e.isEmpty()) return t.copy() } return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), on.overlayOp(t, e, nn.SYMDIFFERENCE) }, nn.resultDimension = function(t, e, i) {
                    var n = e.getDimension(),
                        r = i.getDimension(),
                        o = -1;
                    switch (t) {
                        case nn.INTERSECTION:
                            o = Math.min(n, r);
                            break;
                        case nn.UNION:
                            o = Math.max(n, r);
                            break;
                        case nn.DIFFERENCE:
                            o = n;
                            break;
                        case nn.SYMDIFFERENCE:
                            o = Math.max(n, r)
                    }
                    return o
                }, nn.createEmptyResult = function(t, e, i, n) {
                    var r = null;
                    switch (nn.resultDimension(t, e, i)) {
                        case -1:
                            r = n.createGeometryCollection(new Array(0).fill(null));
                            break;
                        case 0:
                            r = n.createPoint();
                            break;
                        case 1:
                            r = n.createLineString();
                            break;
                        case 2:
                            r = n.createPolygon()
                    }
                    return r
                }, nn.difference = function(t, e) { return t.isEmpty() ? nn.createEmptyResult(nn.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), on.overlayOp(t, e, nn.DIFFERENCE)) }, nn.isResultOfOp = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            i = t.getLocation(0),
                            n = t.getLocation(1);
                        return nn.isResultOfOp(i, n, e)
                    }
                    if (3 === arguments.length) {
                        var r = arguments[0],
                            o = arguments[1],
                            s = arguments[2];
                        switch (r === C.BOUNDARY && (r = C.INTERIOR), o === C.BOUNDARY && (o = C.INTERIOR), s) {
                            case nn.INTERSECTION:
                                return r === C.INTERIOR && o === C.INTERIOR;
                            case nn.UNION:
                                return r === C.INTERIOR || o === C.INTERIOR;
                            case nn.DIFFERENCE:
                                return r === C.INTERIOR && o !== C.INTERIOR;
                            case nn.SYMDIFFERENCE:
                                return r === C.INTERIOR && o !== C.INTERIOR || r !== C.INTERIOR && o === C.INTERIOR
                        }
                        return !1
                    }
                }, nn.INTERSECTION = 1, nn.UNION = 2, nn.DIFFERENCE = 3, nn.SYMDIFFERENCE = 4, e(rn.prototype, {
                    selfSnap: function(t) {
                        var e = new xe(t),
                            i = e.snapTo(t, this.snapTolerance);
                        return i
                    },
                    removeCommonBits: function(t) { this.cbr = new Ne, this.cbr.add(t[0]), this.cbr.add(t[1]); var e = new Array(2).fill(null); return e[0] = this.cbr.removeCommonBits(t[0].copy()), e[1] = this.cbr.removeCommonBits(t[1].copy()), e },
                    prepareResult: function(t) { return this.cbr.addCommonBits(t), t },
                    getResultGeometry: function(t) {
                        var e = this.snap(this.geom),
                            i = nn.overlayOp(e[0], e[1], t);
                        return this.prepareResult(i)
                    },
                    checkValid: function(t) { t.isValid() || O.out.println("Snapped geometry is invalid") },
                    computeSnapTolerance: function() { this.snapTolerance = xe.computeOverlaySnapTolerance(this.geom[0], this.geom[1]) },
                    snap: function(t) {
                        var e = this.removeCommonBits(t),
                            i = xe.snap(e[0], e[1], this.snapTolerance);
                        return i
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return rn }
                }), rn.overlayOp = function(t, e, i) { var n = new rn(t, e); return n.getResultGeometry(i) }, rn.union = function(t, e) { return rn.overlayOp(t, e, nn.UNION) }, rn.intersection = function(t, e) { return rn.overlayOp(t, e, nn.INTERSECTION) }, rn.symDifference = function(t, e) { return rn.overlayOp(t, e, nn.SYMDIFFERENCE) }, rn.difference = function(t, e) { return rn.overlayOp(t, e, nn.DIFFERENCE) }, e(on.prototype, {
                    getResultGeometry: function(t) {
                        var e = null,
                            i = !1,
                            n = null;
                        try {
                            e = nn.overlayOp(this.geom[0], this.geom[1], t);
                            var r = !0;
                            r && (i = !0)
                        } catch (t) {
                            if (!(t instanceof l)) throw t;
                            n = t
                        } finally {}
                        if (!i) try { e = rn.overlayOp(this.geom[0], this.geom[1], t) } catch (t) { throw t instanceof l ? n : t } finally {}
                        return e
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return on }
                }), on.overlayOp = function(t, e, i) { var n = new on(t, e); return n.getResultGeometry(i) }, on.union = function(t, e) { return on.overlayOp(t, e, nn.UNION) }, on.intersection = function(t, e) { return on.overlayOp(t, e, nn.INTERSECTION) }, on.symDifference = function(t, e) { return on.overlayOp(t, e, nn.SYMDIFFERENCE) }, on.difference = function(t, e) { return on.overlayOp(t, e, nn.DIFFERENCE) }, e(sn.prototype, {
                    addPolygon: function(t) {
                        if (t.isEmpty()) return null;
                        var e = null,
                            i = 0,
                            n = this.horizontalBisector(t);
                        if (0 === n.getLength()) i = 0, e = n.getCoordinate();
                        else {
                            var r = on.overlayOp(n, t, nn.INTERSECTION),
                                o = this.widestGeometry(r);
                            i = o.getEnvelopeInternal().getWidth(), e = sn.centre(o.getEnvelopeInternal())
                        }(null === this.interiorPoint || i > this.maxWidth) && (this.interiorPoint = e, this.maxWidth = i)
                    },
                    getInteriorPoint: function() { return this.interiorPoint },
                    widestGeometry: function t() { if (arguments[0] instanceof ct) { var e = arguments[0]; if (e.isEmpty()) return e; for (var t = e.getGeometryN(0), i = 1; i < e.getNumGeometries(); i++) e.getGeometryN(i).getEnvelopeInternal().getWidth() > t.getEnvelopeInternal().getWidth() && (t = e.getGeometryN(i)); return t } if (arguments[0] instanceof B) { var n = arguments[0]; return n instanceof ct ? this.widestGeometry(n) : n } },
                    horizontalBisector: function(t) {
                        var e = t.getEnvelopeInternal(),
                            i = an.getBisectorY(t);
                        return this.factory.createLineString([new f(e.getMinX(), i), new f(e.getMaxX(), i)])
                    },
                    add: function(t) {
                        if (t instanceof It) this.addPolygon(t);
                        else if (t instanceof ct)
                            for (var e = t, i = 0; i < e.getNumGeometries(); i++) this.add(e.getGeometryN(i))
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return sn }
                }), sn.centre = function(t) { return new f(sn.avg(t.getMinX(), t.getMaxX()), sn.avg(t.getMinY(), t.getMaxY())) }, sn.avg = function(t, e) { return (t + e) / 2 }, e(an.prototype, {
                    updateInterval: function(t) { t <= this.centreY ? t > this.loY && (this.loY = t) : t > this.centreY && t < this.hiY && (this.hiY = t) },
                    getBisectorY: function() { this.process(this.poly.getExteriorRing()); for (var t = 0; t < this.poly.getNumInteriorRing(); t++) this.process(this.poly.getInteriorRingN(t)); var e = sn.avg(this.hiY, this.loY); return e },
                    process: function(t) {
                        for (var e = t.getCoordinateSequence(), i = 0; i < e.size(); i++) {
                            var n = e.getY(i);
                            this.updateInterval(n)
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return an }
                }), an.getBisectorY = function(t) { var e = new an(t); return e.getBisectorY() }, sn.SafeBisectorFinder = an, e(hn.prototype, {
                    addEndpoints: function() {
                        if (arguments[0] instanceof B) {
                            var t = arguments[0];
                            if (t instanceof Nt) this.addEndpoints(t.getCoordinates());
                            else if (t instanceof ct)
                                for (var e = t, i = 0; i < e.getNumGeometries(); i++) this.addEndpoints(e.getGeometryN(i))
                        } else if (arguments[0] instanceof Array) {
                            var n = arguments[0];
                            this.add(n[0]), this.add(n[n.length - 1])
                        }
                    },
                    getInteriorPoint: function() { return this.interiorPoint },
                    addInterior: function() {
                        if (arguments[0] instanceof B) {
                            var t = arguments[0];
                            if (t instanceof Nt) this.addInterior(t.getCoordinates());
                            else if (t instanceof ct)
                                for (var e = t, i = 0; i < e.getNumGeometries(); i++) this.addInterior(e.getGeometryN(i))
                        } else if (arguments[0] instanceof Array)
                            for (var n = arguments[0], i = 1; i < n.length - 1; i++) this.add(n[i])
                    },
                    add: function(t) {
                        var e = t.distance(this.centroid);
                        e < this.minDistance && (this.interiorPoint = new f(t), this.minDistance = e)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return hn }
                }), e(ln.prototype, {
                    getInteriorPoint: function() { return this.interiorPoint },
                    add: function() {
                        if (arguments[0] instanceof B) {
                            var t = arguments[0];
                            if (t instanceof Ct) this.add(t.getCoordinate());
                            else if (t instanceof ct)
                                for (var e = t, i = 0; i < e.getNumGeometries(); i++) this.add(e.getGeometryN(i))
                        } else if (arguments[0] instanceof f) {
                            var n = arguments[0],
                                r = n.distance(this.centroid);
                            r < this.minDistance && (this.interiorPoint = new f(n), this.minDistance = r)
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return ln }
                }), e(un.prototype, {
                    select: function() {
                        if (1 === arguments.length) arguments[0];
                        else if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            t.getLineSegment(e, this.selectedSegment), this.select(this.selectedSegment)
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return un }
                }), e(pn.prototype, {
                    hasChildren: function() {
                        for (var t = 0; 2 > t; t++)
                            if (null !== this.subnode[t]) return !0;
                        return !1
                    },
                    isPrunable: function() { return !(this.hasChildren() || this.hasItems()) },
                    addAllItems: function(t) { t.addAll(this.items); for (var e = 0; 2 > e; e++) null !== this.subnode[e] && this.subnode[e].addAllItems(t); return t },
                    size: function() { for (var t = 0, e = 0; 2 > e; e++) null !== this.subnode[e] && (t += this.subnode[e].size()); return t + this.items.size() },
                    addAllItemsFromOverlapping: function(t, e) { return null === t || this.isSearchMatch(t) ? (e.addAll(this.items), null !== this.subnode[0] && this.subnode[0].addAllItemsFromOverlapping(t, e), void(null !== this.subnode[1] && this.subnode[1].addAllItemsFromOverlapping(t, e))) : null },
                    hasItems: function() { return !this.items.isEmpty() },
                    remove: function(t, e) {
                        if (!this.isSearchMatch(t)) return !1;
                        for (var i = !1, n = 0; 2 > n; n++)
                            if (null !== this.subnode[n] && (i = this.subnode[n].remove(t, e))) { this.subnode[n].isPrunable() && (this.subnode[n] = null); break }
                        return i ? i : i = this.items.remove(e)
                    },
                    getItems: function() { return this.items },
                    depth: function() {
                        for (var t = 0, e = 0; 2 > e; e++)
                            if (null !== this.subnode[e]) {
                                var i = this.subnode[e].depth();
                                i > t && (t = i)
                            }
                        return t + 1
                    },
                    nodeSize: function() { for (var t = 0, e = 0; 2 > e; e++) null !== this.subnode[e] && (t += this.subnode[e].nodeSize()); return t + 1 },
                    add: function(t) { this.items.add(t) },
                    interfaces_: function() { return [] },
                    getClass: function() { return pn }
                }), pn.getSubnodeIndex = function(t, e) { var i = -1; return t.min >= e && (i = 1), t.max <= e && (i = 0), i }, e(cn.prototype, {
                    expandToInclude: function(t) { t.max > this.max && (this.max = t.max), t.min < this.min && (this.min = t.min) },
                    getWidth: function() { return this.max - this.min },
                    overlaps: function() {
                        if (1 === arguments.length) { var t = arguments[0]; return this.overlaps(t.min, t.max) }
                        if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1];
                            return !(this.min > i || this.max < e)
                        }
                    },
                    getMin: function() { return this.min },
                    toString: function() { return "[" + this.min + ", " + this.max + "]" },
                    contains: function() {
                        if (1 === arguments.length) { if (arguments[0] instanceof cn) { var t = arguments[0]; return this.contains(t.min, t.max) } if ("number" == typeof arguments[0]) { var e = arguments[0]; return e >= this.min && e <= this.max } } else if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1];
                            return i >= this.min && n <= this.max
                        }
                    },
                    init: function(t, e) { this.min = t, this.max = e, t > e && (this.min = e, this.max = t) },
                    getMax: function() { return this.max },
                    interfaces_: function() { return [] },
                    getClass: function() { return cn }
                }), fn.exponent = function(t) { return gn(64, t) - 1023 }, fn.powerOf2 = function(t) { return Math.pow(2, t) }, e(dn.prototype, {
                    getInterval: function() { return this.interval },
                    getLevel: function() { return this.level },
                    computeKey: function(t) { for (this.level = dn.computeLevel(t), this.interval = new cn, this.computeInterval(this.level, t); !this.interval.contains(t);) this.level += 1, this.computeInterval(this.level, t) },
                    computeInterval: function(t, e) {
                        var i = fn.powerOf2(t);
                        this.pt = Math.floor(e.getMin() / i) * i, this.interval.init(this.pt, this.pt + i)
                    },
                    getPoint: function() { return this.pt },
                    interfaces_: function() { return [] },
                    getClass: function() { return dn }
                }), dn.computeLevel = function(t) {
                    var e = t.getWidth(),
                        i = fn.exponent(e) + 1;
                    return i
                }, u(yn, pn), e(yn.prototype, {
                    getInterval: function() { return this.interval },
                    find: function(t) { var e = pn.getSubnodeIndex(t, this.centre); if (-1 === e) return this; if (null !== this.subnode[e]) { var i = this.subnode[e]; return i.find(t) } return this },
                    insert: function(t) {
                        c.isTrue(null === this.interval || this.interval.contains(t.interval));
                        var e = pn.getSubnodeIndex(t.interval, this.centre);
                        if (t.level === this.level - 1) this.subnode[e] = t;
                        else {
                            var i = this.createSubnode(e);
                            i.insert(t), this.subnode[e] = i
                        }
                    },
                    isSearchMatch: function(t) { return t.overlaps(this.interval) },
                    getSubnode: function(t) { return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)), this.subnode[t] },
                    getNode: function(t) { var e = pn.getSubnodeIndex(t, this.centre); if (-1 !== e) { var i = this.getSubnode(e); return i.getNode(t) } return this },
                    createSubnode: function(t) {
                        var e = 0,
                            i = 0;
                        switch (t) {
                            case 0:
                                e = this.interval.getMin(), i = this.centre;
                                break;
                            case 1:
                                e = this.centre, i = this.interval.getMax()
                        }
                        var n = new cn(e, i),
                            r = new yn(n, this.level - 1);
                        return r
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return yn }
                }), yn.createNode = function(t) {
                    var e = new dn(t),
                        i = new yn(e.getInterval(), e.getLevel());
                    return i
                }, yn.createExpanded = function(t, e) {
                    var i = new cn(e);
                    null !== t && i.expandToInclude(t.interval);
                    var n = yn.createNode(i);
                    return null !== t && n.insert(t), n
                }, e(mn.prototype, { interfaces_: function() { return [] }, getClass: function() { return mn } }), mn.isZeroWidth = function(t, e) {
                    var i = e - t;
                    if (0 === i) return !0;
                    var n = Math.max(Math.abs(t), Math.abs(e)),
                        r = i / n,
                        o = fn.exponent(r);
                    return o <= mn.MIN_BINARY_EXPONENT
                }, mn.MIN_BINARY_EXPONENT = -50, u(vn, pn), e(vn.prototype, {
                    insert: function(t, e) {
                        var i = pn.getSubnodeIndex(t, vn.origin);
                        if (-1 === i) return this.add(e), null;
                        var n = this.subnode[i];
                        if (null === n || !n.getInterval().contains(t)) {
                            var r = yn.createExpanded(n, t);
                            this.subnode[i] = r
                        }
                        this.insertContained(this.subnode[i], t, e)
                    },
                    isSearchMatch: function(t) { return !0 },
                    insertContained: function(t, e, i) {
                        c.isTrue(t.getInterval().contains(e));
                        var n = mn.isZeroWidth(e.getMin(), e.getMax()),
                            r = null;
                        r = n ? t.find(e) : t.getNode(e), r.add(i)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return vn }
                }), vn.origin = 0, e(bn.prototype, {
                    size: function() { return null !== this.root ? this.root.size() : 0 },
                    insert: function(t, e) {
                        this.collectStats(t);
                        var i = bn.ensureExtent(t, this.minExtent);
                        this.root.insert(i, e)
                    },
                    query: function() {
                        if (1 === arguments.length) {
                            if ("number" == typeof arguments[0]) { var t = arguments[0]; return this.query(new cn(t, t)) }
                            if (arguments[0] instanceof cn) {
                                var e = arguments[0],
                                    i = new x;
                                return this.query(e, i), i
                            }
                        } else if (2 === arguments.length) {
                            var n = arguments[0],
                                r = arguments[1];
                            this.root.addAllItemsFromOverlapping(n, r)
                        }
                    },
                    iterator: function() { var t = new x; return this.root.addAllItems(t), t.iterator() },
                    remove: function(t, e) { var i = bn.ensureExtent(t, this.minExtent); return this.root.remove(i, e) },
                    collectStats: function(t) {
                        var e = t.getWidth();
                        e < this.minExtent && e > 0 && (this.minExtent = e)
                    },
                    depth: function() { return null !== this.root ? this.root.depth() : 0 },
                    nodeSize: function() { return null !== this.root ? this.root.nodeSize() : 0 },
                    interfaces_: function() { return [] },
                    getClass: function() { return bn }
                }), bn.ensureExtent = function(t, e) {
                    var i = t.getMin(),
                        n = t.getMax();
                    return i !== n ? t : (i === n && (i -= e / 2, n = i + e / 2), new cn(i, n))
                }, e(wn.prototype, { isInside: function(t) {}, interfaces_: function() { return [] }, getClass: function() { return wn } }), e(xn.prototype, {
                    testLineSegment: function(t, e) {
                        var i = null,
                            n = null,
                            r = null,
                            o = null,
                            s = null,
                            a = e.p0,
                            h = e.p1;
                        n = a.x - t.x, r = a.y - t.y, o = h.x - t.x, s = h.y - t.y, (r > 0 && 0 >= s || s > 0 && 0 >= r) && (i = he.signOfDet2x2(n, r, o, s) / (s - r), i > 0 && this.crossings++)
                    },
                    buildIndex: function() {
                        this.tree = new bn;
                        for (var t = X.removeRepeatedPoints(this.ring.getCoordinates()), e = Qe.getChains(t), i = 0; i < e.size(); i++) {
                            var n = e.get(i),
                                r = n.getEnvelope();
                            this.interval.min = r.getMinY(), this.interval.max = r.getMaxY(), this.tree.insert(this.interval, n)
                        }
                    },
                    testMonotoneChain: function(t, e, i) { i.select(t, e) },
                    isInside: function(t) {
                        this.crossings = 0;
                        var e = new S(r.NEGATIVE_INFINITY, r.POSITIVE_INFINITY, t.y, t.y);
                        this.interval.min = t.y, this.interval.max = t.y;
                        for (var i = this.tree.query(this.interval), n = new En(this, t), o = i.iterator(); o.hasNext();) {
                            var s = o.next();
                            this.testMonotoneChain(e, n, s)
                        }
                        return this.crossings % 2 === 1
                    },
                    interfaces_: function() { return [wn] },
                    getClass: function() { return xn }
                }), u(En, un), e(En.prototype, {
                    select: function() {
                        if (1 !== arguments.length) return un.prototype.select.apply(this, arguments);
                        var t = arguments[0];
                        this.mcp.testLineSegment(this.p, t)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return En }
                }), xn.MCSelecter = En, e(Sn.prototype, { interfaces_: function() { return [] }, getClass: function() { return Sn } }), Sn.toDegrees = function(t) { return 180 * t / Math.PI }, Sn.normalize = function(t) { for (; t > Math.PI;) t -= Sn.PI_TIMES_2; for (; t <= -Math.PI;) t += Sn.PI_TIMES_2; return t }, Sn.angle = function() {
                    if (1 === arguments.length) { var t = arguments[0]; return Math.atan2(t.y, t.x) }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1],
                            n = i.x - e.x,
                            r = i.y - e.y;
                        return Math.atan2(r, n)
                    }
                }, Sn.isAcute = function(t, e, i) {
                    var n = t.x - e.x,
                        r = t.y - e.y,
                        o = i.x - e.x,
                        s = i.y - e.y,
                        a = n * o + r * s;
                    return a > 0
                }, Sn.isObtuse = function(t, e, i) {
                    var n = t.x - e.x,
                        r = t.y - e.y,
                        o = i.x - e.x,
                        s = i.y - e.y,
                        a = n * o + r * s;
                    return 0 > a
                }, Sn.interiorAngle = function(t, e, i) {
                    var n = Sn.angle(e, t),
                        r = Sn.angle(e, i);
                    return Math.abs(r - n)
                }, Sn.normalizePositive = function(t) {
                    if (0 > t) {
                        for (; 0 > t;) t += Sn.PI_TIMES_2;
                        t >= Sn.PI_TIMES_2 && (t = 0)
                    } else {
                        for (; t >= Sn.PI_TIMES_2;) t -= Sn.PI_TIMES_2;
                        0 > t && (t = 0)
                    }
                    return t
                }, Sn.angleBetween = function(t, e, i) {
                    var n = Sn.angle(e, t),
                        r = Sn.angle(e, i);
                    return Sn.diff(n, r)
                }, Sn.diff = function(t, e) { var i = null; return i = e > t ? e - t : t - e, i > Math.PI && (i = 2 * Math.PI - i), i }, Sn.toRadians = function(t) { return t * Math.PI / 180 }, Sn.getTurn = function(t, e) { var i = Math.sin(e - t); return i > 0 ? Sn.COUNTERCLOCKWISE : 0 > i ? Sn.CLOCKWISE : Sn.NONE }, Sn.angleBetweenOriented = function(t, e, i) {
                    var n = Sn.angle(e, t),
                        r = Sn.angle(e, i),
                        o = r - n;
                    return o <= -Math.PI ? o + Sn.PI_TIMES_2 : o > Math.PI ? o - Sn.PI_TIMES_2 : o
                }, Sn.PI_TIMES_2 = 2 * Math.PI, Sn.PI_OVER_2 = Math.PI / 2, Sn.PI_OVER_4 = Math.PI / 4, Sn.COUNTERCLOCKWISE = ue.COUNTERCLOCKWISE, Sn.CLOCKWISE = ue.CLOCKWISE, Sn.NONE = ue.COLLINEAR, e(Nn.prototype, { area: function() { return Nn.area(this.p0, this.p1, this.p2) }, signedArea: function() { return Nn.signedArea(this.p0, this.p1, this.p2) }, interpolateZ: function(t) { if (null === t) throw new n("Supplied point is null."); return Nn.interpolateZ(t, this.p0, this.p1, this.p2) }, longestSideLength: function() { return Nn.longestSideLength(this.p0, this.p1, this.p2) }, isAcute: function() { return Nn.isAcute(this.p0, this.p1, this.p2) }, circumcentre: function() { return Nn.circumcentre(this.p0, this.p1, this.p2) }, area3D: function() { return Nn.area3D(this.p0, this.p1, this.p2) }, centroid: function() { return Nn.centroid(this.p0, this.p1, this.p2) }, inCentre: function() { return Nn.inCentre(this.p0, this.p1, this.p2) }, interfaces_: function() { return [] }, getClass: function() { return Nn } }), Nn.area = function(t, e, i) { return Math.abs(((i.x - t.x) * (e.y - t.y) - (e.x - t.x) * (i.y - t.y)) / 2) }, Nn.signedArea = function(t, e, i) { return ((i.x - t.x) * (e.y - t.y) - (e.x - t.x) * (i.y - t.y)) / 2 }, Nn.det = function(t, e, i, n) { return t * n - e * i }, Nn.interpolateZ = function(t, e, i, n) {
                    var r = e.x,
                        o = e.y,
                        s = i.x - r,
                        a = n.x - r,
                        h = i.y - o,
                        l = n.y - o,
                        u = s * l - a * h,
                        p = t.x - r,
                        c = t.y - o,
                        f = (l * p - a * c) / u,
                        g = (-h * p + s * c) / u,
                        d = e.z + f * (i.z - e.z) + g * (n.z - e.z);
                    return d
                }, Nn.longestSideLength = function(t, e, i) {
                    var n = t.distance(e),
                        r = e.distance(i),
                        o = i.distance(t),
                        s = n;
                    return r > s && (s = r), o > s && (s = o), s
                }, Nn.isAcute = function(t, e, i) { return !(!Sn.isAcute(t, e, i) || !Sn.isAcute(e, i, t)) && !!Sn.isAcute(i, t, e) }, Nn.circumcentre = function(t, e, i) {
                    var n = i.x,
                        r = i.y,
                        o = t.x - n,
                        s = t.y - r,
                        a = e.x - n,
                        h = e.y - r,
                        l = 2 * Nn.det(o, s, a, h),
                        u = Nn.det(s, o * o + s * s, h, a * a + h * h),
                        p = Nn.det(o, o * o + s * s, a, a * a + h * h),
                        c = n - u / l,
                        g = r + p / l;
                    return new f(c, g)
                }, Nn.perpendicularBisector = function(t, e) {
                    var i = e.x - t.x,
                        n = e.y - t.y,
                        r = new D(t.x + i / 2, t.y + n / 2, 1),
                        o = new D(t.x - n + i / 2, t.y + i + n / 2, 1);
                    return new D(r, o)
                }, Nn.angleBisector = function(t, e, i) {
                    var n = e.distance(t),
                        r = e.distance(i),
                        o = n / (n + r),
                        s = i.x - t.x,
                        a = i.y - t.y,
                        h = new f(t.x + o * s, t.y + o * a);
                    return h
                }, Nn.area3D = function(t, e, i) {
                    var n = e.x - t.x,
                        r = e.y - t.y,
                        o = e.z - t.z,
                        s = i.x - t.x,
                        a = i.y - t.y,
                        h = i.z - t.z,
                        l = r * h - o * a,
                        u = o * s - n * h,
                        p = n * a - r * s,
                        c = l * l + u * u + p * p,
                        f = Math.sqrt(c) / 2;
                    return f
                }, Nn.centroid = function(t, e, i) {
                    var n = (t.x + e.x + i.x) / 3,
                        r = (t.y + e.y + i.y) / 3;
                    return new f(n, r)
                }, Nn.inCentre = function(t, e, i) {
                    var n = e.distance(i),
                        r = t.distance(i),
                        o = t.distance(e),
                        s = n + r + o,
                        a = (n * t.x + r * e.x + o * i.x) / s,
                        h = (n * t.y + r * e.y + o * i.y) / s;
                    return new f(a, h)
                }, e(Ln.prototype, {
                    getRadius: function() { return this.compute(), this.radius },
                    getDiameter: function() {
                        switch (this.compute(), this.extremalPts.length) {
                            case 0:
                                return this.input.getFactory().createLineString();
                            case 1:
                                return this.input.getFactory().createPoint(this.centre)
                        }
                        var t = this.extremalPts[0],
                            e = this.extremalPts[1];
                        return this.input.getFactory().createLineString([t, e])
                    },
                    getExtremalPoints: function() { return this.compute(), this.extremalPts },
                    computeCirclePoints: function() {
                        if (this.input.isEmpty()) return this.extremalPts = new Array(0).fill(null), null;
                        if (1 === this.input.getNumPoints()) { var t = this.input.getCoordinates(); return this.extremalPts = [new f(t[0])], null }
                        var e = this.input.convexHull(),
                            i = e.getCoordinates(),
                            t = i;
                        if (i[0].equals2D(i[i.length - 1]) && (t = new Array(i.length - 1).fill(null), X.copyDeep(i, 0, t, 0, i.length - 1)), t.length <= 2) return this.extremalPts = X.copyDeep(t), null;
                        for (var n = Ln.lowestPoint(t), r = Ln.pointWitMinAngleWithX(t, n), o = 0; o < t.length; o++) {
                            var s = Ln.pointWithMinAngleWithSegment(t, n, r);
                            if (Sn.isObtuse(n, s, r)) return this.extremalPts = [new f(n), new f(r)], null;
                            if (Sn.isObtuse(s, n, r)) n = s;
                            else {
                                if (!Sn.isObtuse(s, r, n)) return this.extremalPts = [new f(n), new f(r), new f(s)], null;
                                r = s
                            }
                        }
                        c.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")
                    },
                    compute: function() { return null !== this.extremalPts ? null : (this.computeCirclePoints(), this.computeCentre(), void(null !== this.centre && (this.radius = this.centre.distance(this.extremalPts[0])))) },
                    getFarthestPoints: function() {
                        switch (this.compute(), this.extremalPts.length) {
                            case 0:
                                return this.input.getFactory().createLineString();
                            case 1:
                                return this.input.getFactory().createPoint(this.centre)
                        }
                        var t = this.extremalPts[0],
                            e = this.extremalPts[this.extremalPts.length - 1];
                        return this.input.getFactory().createLineString([t, e])
                    },
                    getCircle: function() { if (this.compute(), null === this.centre) return this.input.getFactory().createPolygon(); var t = this.input.getFactory().createPoint(this.centre); return 0 === this.radius ? t : t.buffer(this.radius) },
                    getCentre: function() { return this.compute(), this.centre },
                    computeCentre: function() {
                        switch (this.extremalPts.length) {
                            case 0:
                                this.centre = null;
                                break;
                            case 1:
                                this.centre = this.extremalPts[0];
                                break;
                            case 2:
                                this.centre = new f((this.extremalPts[0].x + this.extremalPts[1].x) / 2, (this.extremalPts[0].y + this.extremalPts[1].y) / 2);
                                break;
                            case 3:
                                this.centre = Nn.circumcentre(this.extremalPts[0], this.extremalPts[1], this.extremalPts[2])
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Ln }
                }), Ln.pointWitMinAngleWithX = function(t, e) {
                    for (var i = r.MAX_VALUE, n = null, o = 0; o < t.length; o++) {
                        var s = t[o];
                        if (s !== e) {
                            var a = s.x - e.x,
                                h = s.y - e.y;
                            0 > h && (h = -h);
                            var l = Math.sqrt(a * a + h * h),
                                u = h / l;
                            i > u && (i = u, n = s)
                        }
                    }
                    return n
                }, Ln.lowestPoint = function(t) { for (var e = t[0], i = 1; i < t.length; i++) t[i].y < e.y && (e = t[i]); return e }, Ln.pointWithMinAngleWithSegment = function(t, e, i) {
                    for (var n = r.MAX_VALUE, o = null, s = 0; s < t.length; s++) {
                        var a = t[s];
                        if (a !== e && a !== i) {
                            var h = Sn.angleBetween(e, a, i);
                            n > h && (n = h, o = a)
                        }
                    }
                    return o
                }, e(Cn.prototype, {
                    getWidthCoordinate: function() { return this.computeMinimumDiameter(), this.minWidthPt },
                    getSupportingSegment: function() { return this.computeMinimumDiameter(), this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0, this.minBaseSeg.p1]) },
                    getDiameter: function() { if (this.computeMinimumDiameter(), null === this.minWidthPt) return this.inputGeom.getFactory().createLineString(null); var t = this.minBaseSeg.project(this.minWidthPt); return this.inputGeom.getFactory().createLineString([t, this.minWidthPt]) },
                    computeWidthConvex: function(t) { t instanceof It ? this.convexHullPts = t.getExteriorRing().getCoordinates() : this.convexHullPts = t.getCoordinates(), 0 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = null, this.minBaseSeg = null) : 1 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[0]) : 2 === this.convexHullPts.length || 3 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[1]) : this.computeConvexRingMinDiameter(this.convexHullPts) },
                    computeConvexRingMinDiameter: function(t) { this.minWidth = r.MAX_VALUE; for (var e = 1, i = new pe, n = 0; n < t.length - 1; n++) i.p0 = t[n], i.p1 = t[n + 1], e = this.findMaxPerpDistance(t, i, e) },
                    computeMinimumDiameter: function() {
                        if (null !== this.minWidthPt) return null;
                        if (this.isConvex) this.computeWidthConvex(this.inputGeom);
                        else {
                            var t = new me(this.inputGeom).getConvexHull();
                            this.computeWidthConvex(t)
                        }
                    },
                    getLength: function() { return this.computeMinimumDiameter(), this.minWidth },
                    findMaxPerpDistance: function(t, e, i) { for (var n = e.distancePerpendicular(t[i]), r = n, o = i, s = o; r >= n;) n = r, o = s, s = Cn.nextIndex(t, o), r = e.distancePerpendicular(t[s]); return n < this.minWidth && (this.minPtIndex = o, this.minWidth = n, this.minWidthPt = t[this.minPtIndex], this.minBaseSeg = new pe(e)), o },
                    getMinimumRectangle: function() {
                        if (this.computeMinimumDiameter(), 0 === this.minWidth) return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1) ? this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0) : this.minBaseSeg.toGeometry(this.inputGeom.getFactory());
                        for (var t = this.minBaseSeg.p1.x - this.minBaseSeg.p0.x, e = this.minBaseSeg.p1.y - this.minBaseSeg.p0.y, i = r.MAX_VALUE, n = -r.MAX_VALUE, o = r.MAX_VALUE, s = -r.MAX_VALUE, a = 0; a < this.convexHullPts.length; a++) {
                            var h = Cn.computeC(t, e, this.convexHullPts[a]);
                            h > n && (n = h), i > h && (i = h);
                            var l = Cn.computeC(-e, t, this.convexHullPts[a]);
                            l > s && (s = l), o > l && (o = l)
                        }
                        var u = Cn.computeSegmentForLine(-t, -e, s),
                            p = Cn.computeSegmentForLine(-t, -e, o),
                            c = Cn.computeSegmentForLine(-e, t, n),
                            f = Cn.computeSegmentForLine(-e, t, i),
                            g = c.lineIntersection(u),
                            d = f.lineIntersection(u),
                            y = f.lineIntersection(p),
                            m = c.lineIntersection(p),
                            v = this.inputGeom.getFactory().createLinearRing([g, d, y, m, g]);
                        return this.inputGeom.getFactory().createPolygon(v, null)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Cn }
                }), Cn.nextIndex = function(t, e) { return e++, e >= t.length && (e = 0), e }, Cn.computeC = function(t, e, i) { return t * i.y - e * i.x }, Cn.getMinimumDiameter = function(t) { return new Cn(t).getDiameter() }, Cn.getMinimumRectangle = function(t) { return new Cn(t).getMinimumRectangle() }, Cn.computeSegmentForLine = function(t, e, i) {
                    var n = null,
                        r = null;
                    return Math.abs(e) > Math.abs(t) ? (n = new f(0, i / e), r = new f(1, i / e - t / e)) : (n = new f(i / t, 0), r = new f(i / t - e / t, 1)), new pe(n, r)
                };
                var cs = Object.freeze({ Centroid: fe, CGAlgorithms: ue, ConvexHull: me, InteriorPointArea: sn, InteriorPointLine: hn, InteriorPointPoint: ln, RobustLineIntersector: ae, MCPointInRing: xn, MinimumBoundingCircle: Ln, MinimumDiameter: Cn });
                e(Mn.prototype, {
                    getResultGeometry: function() { return new In(this.distanceTolerance).transform(this.inputGeom) },
                    setDistanceTolerance: function(t) {
                        if (0 >= t) throw new n("Tolerance must be positive");
                        this.distanceTolerance = t
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Mn }
                }), Mn.densifyPoints = function(t, e, i) {
                    for (var n = new pe, r = new E, o = 0; o < t.length - 1; o++) {
                        n.p0 = t[o], n.p1 = t[o + 1], r.add(n.p0, !1);
                        var s = n.getLength(),
                            a = Math.trunc(s / e) + 1;
                        if (a > 1)
                            for (var h = s / a, l = 1; a > l; l++) {
                                var u = l * h / s,
                                    p = n.pointAlong(u);
                                i.makePrecise(p), r.add(p, !1)
                            }
                    }
                    return r.add(t[t.length - 1], !1), r.toCoordinateArray()
                }, Mn.densify = function(t, e) { var i = new Mn(t); return i.setDistanceTolerance(e), i.getResultGeometry() }, u(In, be), e(In.prototype, {
                    transformMultiPolygon: function(t, e) { var i = be.prototype.transformMultiPolygon.call(this, t, e); return this.createValidArea(i) },
                    transformPolygon: function(t, e) { var i = be.prototype.transformPolygon.call(this, t, e); return e instanceof At ? i : this.createValidArea(i) },
                    transformCoordinates: function(t, e) {
                        var i = t.toCoordinateArray(),
                            n = Mn.densifyPoints(i, this.distanceTolerance, e.getPrecisionModel());
                        return e instanceof Nt && 1 === n.length && (n = new Array(0).fill(null)), this.factory.getCoordinateSequenceFactory().create(n)
                    },
                    createValidArea: function(t) { return t.buffer(0) },
                    interfaces_: function() { return [] },
                    getClass: function() { return In }
                }), Mn.DensifyTransformer = In;
                var fs = Object.freeze({ Densifier: Mn });
                e(kn.prototype, {
                    find: function(t) {
                        var e = this;
                        do {
                            if (null === e) return null;
                            if (e.dest().equals2D(t)) return e;
                            e = e.oNext()
                        } while (e !== this);
                        return null
                    },
                    dest: function() { return this._sym._orig },
                    oNext: function() { return this._sym._next },
                    insert: function(t) {
                        if (this.oNext() === this) return this.insertAfter(t), null;
                        var e = this.compareTo(t),
                            i = this;
                        do {
                            var n = i.oNext(),
                                r = n.compareTo(t);
                            if (r !== e || n === this) return i.insertAfter(t), null;
                            i = n
                        } while (i !== this);
                        c.shouldNeverReachHere()
                    },
                    insertAfter: function(t) {
                        c.equals(this._orig, t.orig());
                        var e = this.oNext();
                        this._sym.setNext(t), t.sym().setNext(e)
                    },
                    degree: function t() {
                        var t = 0,
                            e = this;
                        do t++, e = e.oNext(); while (e !== this);
                        return t
                    },
                    equals: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1];
                            return this._orig.equals2D(t) && this._sym._orig.equals(e)
                        }
                    },
                    deltaY: function() { return this._sym._orig.y - this._orig.y },
                    sym: function() { return this._sym },
                    prev: function() { return this._sym.next()._sym },
                    compareAngularDirection: function(t) {
                        var e = this.deltaX(),
                            i = this.deltaY(),
                            n = t.deltaX(),
                            r = t.deltaY();
                        if (e === n && i === r) return 0;
                        var o = Je.quadrant(e, i),
                            s = Je.quadrant(n, r);
                        return o > s ? 1 : s > o ? -1 : ue.computeOrientation(t._orig, t.dest(), this.dest())
                    },
                    prevNode: function() {
                        for (var t = this; 2 === t.degree();)
                            if (t = t.prev(), t === this) return null;
                        return t
                    },
                    compareTo: function(t) {
                        var e = t,
                            i = this.compareAngularDirection(e);
                        return i
                    },
                    next: function() { return this._next },
                    setSym: function(t) { this._sym = t },
                    orig: function() { return this._orig },
                    toString: function() { return "HE(" + this._orig.x + " " + this._orig.y + ", " + this._sym._orig.x + " " + this._sym._orig.y + ")" },
                    setNext: function(t) { this._next = t },
                    init: function(t) { this.setSym(t), t.setSym(this), this.setNext(t), t.setNext(this) },
                    deltaX: function() { return this._sym._orig.x - this._orig.x },
                    interfaces_: function() { return [] },
                    getClass: function() { return kn }
                }), kn.init = function(t, e) { if (null !== t._sym || null !== e._sym || null !== t._next || null !== e._next) throw new IllegalStateException("Edges are already initialized"); return t.init(e), t }, kn.create = function(t, e) {
                    var i = new kn(t),
                        n = new kn(e);
                    return i.init(n), i
                }, u(Tn, kn), e(Tn.prototype, { mark: function() { this._isMarked = !0 }, setMark: function(t) { this._isMarked = t }, isMarked: function() { return this._isMarked }, interfaces_: function() { return [] }, getClass: function() { return Tn } }), Tn.setMarkBoth = function(t, e) { t.setMark(e), t.sym().setMark(e) }, Tn.isMarked = function(t) { return t.isMarked() }, Tn.setMark = function(t, e) { t.setMark(e) }, Tn.markBoth = function(t) { t.mark(), t.sym().mark() }, Tn.mark = function(t) { t.mark() }, e(An.prototype, {
                    insert: function(t, e, i) {
                        var n = this.create(t, e);
                        null !== i ? i.insert(n) : this.vertexMap.put(t, n);
                        var r = this.vertexMap.get(e);
                        return null !== r ? r.insert(n.sym()) : this.vertexMap.put(e, n.sym()), n
                    },
                    create: function(t, e) {
                        var i = this.createEdge(t),
                            n = this.createEdge(e);
                        return kn.init(i, n), i
                    },
                    createEdge: function(t) { return new kn(t) },
                    addEdge: function(t, e) {
                        if (!An.isValidEdge(t, e)) return null;
                        var i = this.vertexMap.get(t),
                            n = null;
                        if (null !== i && (n = i.find(e)), null !== n) return n;
                        var r = this.insert(t, e, i);
                        return r
                    },
                    getVertexEdges: function() { return this.vertexMap.values() },
                    findEdge: function(t, e) { var i = this.vertexMap.get(t); return null === i ? null : i.find(e) },
                    interfaces_: function() { return [] },
                    getClass: function() { return An }
                }), An.isValidEdge = function(t, e) { var i = e.compareTo(t); return 0 !== i }, u(Rn, Tn), e(Rn.prototype, { setStart: function() { this._isStart = !0 }, isStart: function() { return this._isStart }, interfaces_: function() { return [] }, getClass: function() { return Rn } }), u(_n, An), e(_n.prototype, { createEdge: function(t) { return new Rn(t) }, interfaces_: function() { return [] }, getClass: function() { return _n } }), e(Pn.prototype, {
                    addLine: function(t) { this.lines.add(this.factory.createLineString(t.toCoordinateArray())) },
                    updateRingStartEdge: function(t) { return t.isStart() || (t = t.sym(), t.isStart()) ? null === this.ringStartEdge ? (this.ringStartEdge = t, null) : void(t.orig().compareTo(this.ringStartEdge.orig()) < 0 && (this.ringStartEdge = t)) : null },
                    getResult: function() { return null === this.result && this.computeResult(), this.result },
                    process: function(t) {
                        var e = t.prevNode();
                        null === e && (e = t), this.stackEdges(e), this.buildLines()
                    },
                    buildRing: function(t) {
                        var e = new E,
                            i = t;
                        for (e.add(i.orig().copy(), !1); 2 === i.sym().degree();) {
                            var n = i.next();
                            if (n === t) break;
                            e.add(n.orig().copy(), !1), i = n
                        }
                        e.add(i.dest().copy(), !1), this.addLine(e)
                    },
                    buildLine: function(t) {
                        var e = new E,
                            i = t;
                        for (this.ringStartEdge = null, Tn.markBoth(i), e.add(i.orig().copy(), !1); 2 === i.sym().degree();) {
                            this.updateRingStartEdge(i);
                            var n = i.next();
                            if (n === t) return this.buildRing(this.ringStartEdge), null;
                            e.add(n.orig().copy(), !1), i = n, Tn.markBoth(i)
                        }
                        e.add(i.dest().copy(), !1), this.stackEdges(i.sym()), this.addLine(e)
                    },
                    stackEdges: function(t) {
                        var e = t;
                        do Tn.isMarked(e) || this.nodeEdgeStack.add(e), e = e.oNext(); while (e !== t)
                    },
                    computeResult: function() {
                        for (var t = this.graph.getVertexEdges(), e = t.iterator(); e.hasNext();) {
                            var i = e.next();
                            Tn.isMarked(i) || this.process(i)
                        }
                        this.result = this.factory.buildGeometry(this.lines)
                    },
                    buildLines: function() {
                        for (; !this.nodeEdgeStack.empty();) {
                            var t = this.nodeEdgeStack.pop();
                            Tn.isMarked(t) || this.buildLine(t)
                        }
                    },
                    add: function() {
                        if (arguments[0] instanceof B) {
                            var t = arguments[0];
                            t.apply({ interfaces_: function() { return [U] }, filter: function(t) { t instanceof Nt && this.add(t) } })
                        } else if (M(arguments[0], y))
                            for (var e = arguments[0], i = e.iterator(); i.hasNext();) {
                                var n = i.next();
                                this.add(n)
                            } else if (arguments[0] instanceof Nt) {
                                var r = arguments[0];
                                null === this.factory && (this.factory = r.getFactory());
                                for (var o = r.getCoordinateSequence(), s = !1, i = 1; i < o.size(); i++) {
                                    var a = this.graph.addEdge(o.getCoordinate(i - 1), o.getCoordinate(i));
                                    null !== a && (s || (a.setStart(), s = !0))
                                }
                            }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Pn }
                }), Pn.dissolve = function(t) { var e = new Pn; return e.add(t), e.getResult() };
                var gs = Object.freeze({ LineDissolver: Pn }),
                    ds = Object.freeze({ GeometryGraph: Ji });
                e(On.prototype, {
                    hasChildren: function() {
                        for (var t = 0; 4 > t; t++)
                            if (null !== this.subnode[t]) return !0;
                        return !1
                    },
                    isPrunable: function() { return !(this.hasChildren() || this.hasItems()) },
                    addAllItems: function(t) { t.addAll(this.items); for (var e = 0; 4 > e; e++) null !== this.subnode[e] && this.subnode[e].addAllItems(t); return t },
                    getNodeCount: function() { for (var t = 0, e = 0; 4 > e; e++) null !== this.subnode[e] && (t += this.subnode[e].size()); return t + 1 },
                    size: function() { for (var t = 0, e = 0; 4 > e; e++) null !== this.subnode[e] && (t += this.subnode[e].size()); return t + this.items.size() },
                    addAllItemsFromOverlapping: function(t, e) {
                        if (!this.isSearchMatch(t)) return null;
                        e.addAll(this.items);
                        for (var i = 0; 4 > i; i++) null !== this.subnode[i] && this.subnode[i].addAllItemsFromOverlapping(t, e)
                    },
                    visitItems: function(t, e) { for (var i = this.items.iterator(); i.hasNext();) e.visitItem(i.next()) },
                    hasItems: function() { return !this.items.isEmpty() },
                    remove: function(t, e) {
                        if (!this.isSearchMatch(t)) return !1;
                        for (var i = !1, n = 0; 4 > n; n++)
                            if (null !== this.subnode[n] && (i = this.subnode[n].remove(t, e))) { this.subnode[n].isPrunable() && (this.subnode[n] = null); break }
                        return i ? i : i = this.items.remove(e)
                    },
                    visit: function(t, e) {
                        if (!this.isSearchMatch(t)) return null;
                        this.visitItems(t, e);
                        for (var i = 0; 4 > i; i++) null !== this.subnode[i] && this.subnode[i].visit(t, e)
                    },
                    getItems: function() { return this.items },
                    depth: function() {
                        for (var t = 0, e = 0; 4 > e; e++)
                            if (null !== this.subnode[e]) {
                                var i = this.subnode[e].depth();
                                i > t && (t = i)
                            }
                        return t + 1
                    },
                    isEmpty: function t() {
                        var t = !0;
                        this.items.isEmpty() || (t = !1);
                        for (var e = 0; 4 > e; e++) null !== this.subnode[e] && (this.subnode[e].isEmpty() || (t = !1));
                        return t
                    },
                    add: function(t) { this.items.add(t) },
                    interfaces_: function() { return [h] },
                    getClass: function() {
                        return On;
                    }
                }), On.getSubnodeIndex = function(t, e, i) { var n = -1; return t.getMinX() >= e && (t.getMinY() >= i && (n = 3), t.getMaxY() <= i && (n = 1)), t.getMaxX() <= e && (t.getMinY() >= i && (n = 2), t.getMaxY() <= i && (n = 0)), n }, e(Dn.prototype, {
                    getLevel: function() { return this.level },
                    computeKey: function() {
                        if (1 === arguments.length) { var t = arguments[0]; for (this.level = Dn.computeQuadLevel(t), this.env = new S, this.computeKey(this.level, t); !this.env.contains(t);) this.level += 1, this.computeKey(this.level, t) } else if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1],
                                n = fn.powerOf2(e);
                            this.pt.x = Math.floor(i.getMinX() / n) * n, this.pt.y = Math.floor(i.getMinY() / n) * n, this.env.init(this.pt.x, this.pt.x + n, this.pt.y, this.pt.y + n)
                        }
                    },
                    getEnvelope: function() { return this.env },
                    getCentre: function() { return new f((this.env.getMinX() + this.env.getMaxX()) / 2, (this.env.getMinY() + this.env.getMaxY()) / 2) },
                    getPoint: function() { return this.pt },
                    interfaces_: function() { return [] },
                    getClass: function() { return Dn }
                }), Dn.computeQuadLevel = function(t) {
                    var e = t.getWidth(),
                        i = t.getHeight(),
                        n = e > i ? e : i,
                        r = fn.exponent(n) + 1;
                    return r
                }, u(Fn, On), e(Fn.prototype, {
                    find: function(t) { var e = On.getSubnodeIndex(t, this.centrex, this.centrey); if (-1 === e) return this; if (null !== this.subnode[e]) { var i = this.subnode[e]; return i.find(t) } return this },
                    isSearchMatch: function(t) { return this.env.intersects(t) },
                    getSubnode: function(t) { return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)), this.subnode[t] },
                    getEnvelope: function() { return this.env },
                    getNode: function(t) { var e = On.getSubnodeIndex(t, this.centrex, this.centrey); if (-1 !== e) { var i = this.getSubnode(e); return i.getNode(t) } return this },
                    createSubnode: function(t) {
                        var e = 0,
                            i = 0,
                            n = 0,
                            r = 0;
                        switch (t) {
                            case 0:
                                e = this.env.getMinX(), i = this.centrex, n = this.env.getMinY(), r = this.centrey;
                                break;
                            case 1:
                                e = this.centrex, i = this.env.getMaxX(), n = this.env.getMinY(), r = this.centrey;
                                break;
                            case 2:
                                e = this.env.getMinX(), i = this.centrex, n = this.centrey, r = this.env.getMaxY();
                                break;
                            case 3:
                                e = this.centrex, i = this.env.getMaxX(), n = this.centrey, r = this.env.getMaxY()
                        }
                        var o = new S(e, i, n, r),
                            s = new Fn(o, this.level - 1);
                        return s
                    },
                    insertNode: function(t) {
                        c.isTrue(null === this.env || this.env.contains(t.env));
                        var e = On.getSubnodeIndex(t.env, this.centrex, this.centrey);
                        if (t.level === this.level - 1) this.subnode[e] = t;
                        else {
                            var i = this.createSubnode(e);
                            i.insertNode(t), this.subnode[e] = i
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Fn }
                }), Fn.createNode = function(t) {
                    var e = new Dn(t),
                        i = new Fn(e.getEnvelope(), e.getLevel());
                    return i
                }, Fn.createExpanded = function(t, e) {
                    var i = new S(e);
                    null !== t && i.expandToInclude(t.env);
                    var n = Fn.createNode(i);
                    return null !== t && n.insertNode(t), n
                }, u(Un, On), e(Un.prototype, {
                    insert: function(t, e) {
                        var i = On.getSubnodeIndex(t, Un.origin.x, Un.origin.y);
                        if (-1 === i) return this.add(e), null;
                        var n = this.subnode[i];
                        if (null === n || !n.getEnvelope().contains(t)) {
                            var r = Fn.createExpanded(n, t);
                            this.subnode[i] = r
                        }
                        this.insertContained(this.subnode[i], t, e)
                    },
                    isSearchMatch: function(t) { return !0 },
                    insertContained: function(t, e, i) {
                        c.isTrue(t.getEnvelope().contains(e));
                        var n = mn.isZeroWidth(e.getMinX(), e.getMaxX()),
                            r = mn.isZeroWidth(e.getMinY(), e.getMaxY()),
                            o = null;
                        o = n || r ? t.find(e) : t.getNode(e), o.add(i)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Un }
                }), Un.origin = new f(0, 0), e(Bn.prototype, {
                    size: function() { return null !== this.root ? this.root.size() : 0 },
                    insert: function(t, e) {
                        this.collectStats(t);
                        var i = Bn.ensureExtent(t, this.minExtent);
                        this.root.insert(i, e)
                    },
                    query: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0],
                                e = new Gi;
                            return this.query(t, e), e.getItems()
                        }
                        if (2 === arguments.length) {
                            var i = arguments[0],
                                n = arguments[1];
                            this.root.visit(i, n)
                        }
                    },
                    queryAll: function() { var t = new x; return this.root.addAllItems(t), t },
                    remove: function(t, e) { var i = Bn.ensureExtent(t, this.minExtent); return this.root.remove(i, e) },
                    collectStats: function(t) {
                        var e = t.getWidth();
                        e < this.minExtent && e > 0 && (this.minExtent = e);
                        var i = t.getHeight();
                        i < this.minExtent && i > 0 && (this.minExtent = i)
                    },
                    depth: function() { return null !== this.root ? this.root.depth() : 0 },
                    isEmpty: function() { return null === this.root },
                    interfaces_: function() { return [De, h] },
                    getClass: function() { return Bn }
                }), Bn.ensureExtent = function(t, e) {
                    var i = t.getMinX(),
                        n = t.getMaxX(),
                        r = t.getMinY(),
                        o = t.getMaxY();
                    return i !== n && r !== o ? t : (i === n && (i -= e / 2, n = i + e / 2), r === o && (r -= e / 2, o = r + e / 2), new S(i, n, r, o))
                }, Bn.serialVersionUID = -0x678b60c967a25400;
                var ys = Object.freeze({ Quadtree: Bn }),
                    ms = Object.freeze({ STRtree: Ge }),
                    vs = Object.freeze({ quadtree: ys, strtree: ms }),
                    bs = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"];
                e(jn.prototype, {
                    read: function(t) {
                        var e = void 0;
                        e = "string" == typeof t ? JSON.parse(t) : t;
                        var i = e.type;
                        if (!ws[i]) throw new Error("Unknown GeoJSON type: " + e.type);
                        return -1 !== bs.indexOf(i) ? ws[i].apply(this, [e.coordinates]) : "GeometryCollection" === i ? ws[i].apply(this, [e.geometries]) : ws[i].apply(this, [e])
                    },
                    write: function(t) { var e = t.getGeometryType(); if (!xs[e]) throw new Error("Geometry is not supported"); return xs[e].apply(this, [t]) }
                });
                var ws = {
                        Feature: function(t) {
                            var e = {};
                            for (var i in t) e[i] = t[i];
                            if (t.geometry) {
                                var n = t.geometry.type;
                                if (!ws[n]) throw new Error("Unknown GeoJSON type: " + t.type);
                                e.geometry = this.read(t.geometry)
                            }
                            return t.bbox && (e.bbox = ws.bbox.apply(this, [t.bbox])), e
                        },
                        FeatureCollection: function(t) { var e = {}; if (t.features) { e.features = []; for (var i = 0; i < t.features.length; ++i) e.features.push(this.read(t.features[i])) } return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e },
                        coordinates: function t(e) {
                            for (var t = [], i = 0; i < e.length; ++i) {
                                var n = e[i];
                                t.push(new f(n[0], n[1]))
                            }
                            return t
                        },
                        bbox: function(t) { return this.geometryFactory.createLinearRing([new f(t[0], t[1]), new f(t[2], t[1]), new f(t[2], t[3]), new f(t[0], t[3]), new f(t[0], t[1])]) },
                        Point: function(t) { var e = new f(t[0], t[1]); return this.geometryFactory.createPoint(e) },
                        MultiPoint: function(t) { for (var e = [], i = 0; i < t.length; ++i) e.push(ws.Point.apply(this, [t[i]])); return this.geometryFactory.createMultiPoint(e) },
                        LineString: function(t) { var e = ws.coordinates.apply(this, [t]); return this.geometryFactory.createLineString(e) },
                        MultiLineString: function(t) { for (var e = [], i = 0; i < t.length; ++i) e.push(ws.LineString.apply(this, [t[i]])); return this.geometryFactory.createMultiLineString(e) },
                        Polygon: function(t) {
                            for (var e = ws.coordinates.apply(this, [t[0]]), i = this.geometryFactory.createLinearRing(e), n = [], r = 1; r < t.length; ++r) {
                                var o = t[r],
                                    s = ws.coordinates.apply(this, [o]),
                                    a = this.geometryFactory.createLinearRing(s);
                                n.push(a)
                            }
                            return this.geometryFactory.createPolygon(i, n)
                        },
                        MultiPolygon: function(t) {
                            for (var e = [], i = 0; i < t.length; ++i) {
                                var n = t[i];
                                e.push(ws.Polygon.apply(this, [n]))
                            }
                            return this.geometryFactory.createMultiPolygon(e)
                        },
                        GeometryCollection: function(t) {
                            for (var e = [], i = 0; i < t.length; ++i) {
                                var n = t[i];
                                e.push(this.read(n))
                            }
                            return this.geometryFactory.createGeometryCollection(e)
                        }
                    },
                    xs = {
                        coordinate: function(t) { return [t.x, t.y] },
                        Point: function(t) { var e = xs.coordinate.apply(this, [t.getCoordinate()]); return { type: "Point", coordinates: e } },
                        MultiPoint: function(t) {
                            for (var e = [], i = 0; i < t.geometries.length; ++i) {
                                var n = t.geometries[i],
                                    r = xs.Point.apply(this, [n]);
                                e.push(r.coordinates)
                            }
                            return { type: "MultiPoint", coordinates: e }
                        },
                        LineString: function(t) {
                            for (var e = [], i = t.getCoordinates(), n = 0; n < i.length; ++n) {
                                var r = i[n];
                                e.push(xs.coordinate.apply(this, [r]))
                            }
                            return { type: "LineString", coordinates: e }
                        },
                        MultiLineString: function(t) {
                            for (var e = [], i = 0; i < t.geometries.length; ++i) {
                                var n = t.geometries[i],
                                    r = xs.LineString.apply(this, [n]);
                                e.push(r.coordinates)
                            }
                            return { type: "MultiLineString", coordinates: e }
                        },
                        Polygon: function(t) {
                            var e = [],
                                i = xs.LineString.apply(this, [t.shell]);
                            e.push(i.coordinates);
                            for (var n = 0; n < t.holes.length; ++n) {
                                var r = t.holes[n],
                                    o = xs.LineString.apply(this, [r]);
                                e.push(o.coordinates)
                            }
                            return { type: "Polygon", coordinates: e }
                        },
                        MultiPolygon: function(t) {
                            for (var e = [], i = 0; i < t.geometries.length; ++i) {
                                var n = t.geometries[i],
                                    r = xs.Polygon.apply(this, [n]);
                                e.push(r.coordinates)
                            }
                            return { type: "MultiPolygon", coordinates: e }
                        },
                        GeometryCollection: function(t) {
                            for (var e = [], i = 0; i < t.geometries.length; ++i) {
                                var n = t.geometries[i],
                                    r = n.getGeometryType();
                                e.push(xs[r].apply(this, [n]))
                            }
                            return { type: "GeometryCollection", geometries: e }
                        }
                    };
                e(zn.prototype, {
                    read: function(t) { var e = this.parser.read(t); return this.precisionModel.getType() === ee.FIXED && this.reducePrecision(e), e },
                    reducePrecision: function(t) {
                        var e, i;
                        if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);
                        else if (t.points)
                            for (e = 0, i = t.points.length; i > e; e++) this.precisionModel.makePrecise(t.points[e]);
                        else if (t.geometries)
                            for (e = 0, i = t.geometries.length; i > e; e++) this.reducePrecision(t.geometries[e])
                    }
                }), e(Gn.prototype, { write: function(t) { return this.parser.write(t) } }), e(qn.prototype, {
                    read: function(t) { var e = this.parser.read(t); return this.precisionModel.getType() === ee.FIXED && this.reducePrecision(e), e },
                    reducePrecision: function(t) {
                        if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);
                        else if (t.points)
                            for (var e = 0, i = t.points.coordinates.length; i > e; e++) this.precisionModel.makePrecise(t.points.coordinates[e]);
                        else if (t.geometries)
                            for (var n = 0, r = t.geometries.length; r > n; n++) this.reducePrecision(t.geometries[n])
                    }
                }), e(Wn.prototype, {
                    read: function(t) { return t instanceof ol.geom.Point ? this.convertFromPoint(t) : t instanceof ol.geom.LineString ? this.convertFromLineString(t) : t instanceof ol.geom.LinearRing ? this.convertFromLinearRing(t) : t instanceof ol.geom.Polygon ? this.convertFromPolygon(t) : t instanceof ol.geom.MultiPoint ? this.convertFromMultiPoint(t) : t instanceof ol.geom.MultiLineString ? this.convertFromMultiLineString(t) : t instanceof ol.geom.MultiPolygon ? this.convertFromMultiPolygon(t) : t instanceof ol.geom.GeometryCollection ? this.convertFromCollection(t) : void 0 },
                    convertFromPoint: function(t) { var e = t.getCoordinates(); return this.geometryFactory.createPoint(new f(e[0], e[1])) },
                    convertFromLineString: function(t) { return this.geometryFactory.createLineString(t.getCoordinates().map(function(t) { return new f(t[0], t[1]) })) },
                    convertFromLinearRing: function(t) { return this.geometryFactory.createLinearRing(t.getCoordinates().map(function(t) { return new f(t[0], t[1]) })) },
                    convertFromPolygon: function(t) {
                        for (var e = t.getLinearRings(), i = null, n = [], r = 0; r < e.length; r++) {
                            var o = this.convertFromLinearRing(e[r]);
                            0 === r ? i = o : n.push(o)
                        }
                        return this.geometryFactory.createPolygon(i, n)
                    },
                    convertFromMultiPoint: function(t) { var e = t.getPoints().map(function(t) { return this.convertFromPoint(t) }, this); return this.geometryFactory.createMultiPoint(e) },
                    convertFromMultiLineString: function(t) { var e = t.getLineStrings().map(function(t) { return this.convertFromLineString(t) }, this); return this.geometryFactory.createMultiLineString(e) },
                    convertFromMultiPolygon: function(t) { var e = t.getPolygons().map(function(t) { return this.convertFromPolygon(t) }, this); return this.geometryFactory.createMultiPolygon(e) },
                    convertFromCollection: function(t) { var e = t.getGeometries().map(function(t) { return this.read(t) }, this); return this.geometryFactory.createGeometryCollection(e) },
                    write: function(t) { return "Point" === t.getGeometryType() ? this.convertToPoint(t.getCoordinate()) : "LineString" === t.getGeometryType() ? this.convertToLineString(t) : "LinearRing" === t.getGeometryType() ? this.convertToLinearRing(t) : "Polygon" === t.getGeometryType() ? this.convertToPolygon(t) : "MultiPoint" === t.getGeometryType() ? this.convertToMultiPoint(t) : "MultiLineString" === t.getGeometryType() ? this.convertToMultiLineString(t) : "MultiPolygon" === t.getGeometryType() ? this.convertToMultiPolygon(t) : "GeometryCollection" === t.getGeometryType() ? this.convertToCollection(t) : void 0 },
                    convertToPoint: function(t) { return new ol.geom.Point([t.x, t.y]) },
                    convertToLineString: function(t) { var e = t.points.coordinates.map(Vn); return new ol.geom.LineString(e) },
                    convertToLinearRing: function(t) { var e = t.points.coordinates.map(Vn); return new ol.geom.LinearRing(e) },
                    convertToPolygon: function(t) { for (var e = [t.shell.points.coordinates.map(Vn)], i = 0; i < t.holes.length; i++) e.push(t.holes[i].points.coordinates.map(Vn)); return new ol.geom.Polygon(e) },
                    convertToMultiPoint: function(t) { return new ol.geom.MultiPoint(t.getCoordinates().map(Vn)) },
                    convertToMultiLineString: function(t) { for (var e = [], i = 0; i < t.geometries.length; i++) e.push(this.convertToLineString(t.geometries[i]).getCoordinates()); return new ol.geom.MultiLineString(e) },
                    convertToMultiPolygon: function(t) { for (var e = [], i = 0; i < t.geometries.length; i++) e.push(this.convertToPolygon(t.geometries[i]).getCoordinates()); return new ol.geom.MultiPolygon(e) },
                    convertToCollection: function(t) {
                        for (var e = [], i = 0; i < t.geometries.length; i++) {
                            var n = t.geometries[i];
                            e.push(this.write(n))
                        }
                        return new ol.geom.GeometryCollection(e)
                    }
                });
                var Es = Object.freeze({ GeoJSONReader: zn, GeoJSONWriter: Gn, OL3Parser: Wn, WKTReader: qn, WKTWriter: oe });
                e(Xn.prototype, {
                    rescale: function() {
                        if (M(arguments[0], y))
                            for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
                                var i = e.next();
                                this.rescale(i.getCoordinates())
                            } else if (arguments[0] instanceof Array) {
                                var n = arguments[0],
                                    r = null,
                                    o = null;
                                2 === n.length && (r = new f(n[0]), o = new f(n[1]));
                                for (var e = 0; e < n.length; e++) n[e].x = n[e].x / this.scaleFactor + this.offsetX, n[e].y = n[e].y / this.scaleFactor + this.offsetY;
                                2 === n.length && n[0].equals2D(n[1]) && O.out.println(n)
                            }
                    },
                    scale: function() {
                        if (M(arguments[0], y)) {
                            for (var t = arguments[0], e = new x, i = t.iterator(); i.hasNext();) {
                                var n = i.next();
                                e.add(new Ke(this.scale(n.getCoordinates()), n.getData()))
                            }
                            return e
                        }
                        if (arguments[0] instanceof Array) { for (var r = arguments[0], o = new Array(r.length).fill(null), i = 0; i < r.length; i++) o[i] = new f(Math.round((r[i].x - this.offsetX) * this.scaleFactor), Math.round((r[i].y - this.offsetY) * this.scaleFactor), r[i].z); var s = X.removeRepeatedPoints(o); return s }
                    },
                    isIntegerPrecision: function() { return 1 === this.scaleFactor },
                    getNodedSubstrings: function() { var t = this.noder.getNodedSubstrings(); return this.isScaled && this.rescale(t), t },
                    computeNodes: function(t) {
                        var e = t;
                        this.isScaled && (e = this.scale(t)), this.noder.computeNodes(e)
                    },
                    interfaces_: function() { return [ti] },
                    getClass: function() { return Xn }
                });
                var Ss = Object.freeze({ MCIndexNoder: ii, ScaledNoder: Xn, SegmentString: Te });
                e(Hn.prototype, {
                    isSimpleMultiPoint: function(t) {
                        if (t.isEmpty()) return !0;
                        for (var e = new at, i = 0; i < t.getNumGeometries(); i++) {
                            var n = t.getGeometryN(i),
                                r = n.getCoordinate();
                            if (e.contains(r)) return this.nonSimpleLocation = r, !1;
                            e.add(r)
                        }
                        return !0
                    },
                    isSimplePolygonal: function(t) { for (var e = zi.getLines(t), i = e.iterator(); i.hasNext();) { var n = i.next(); if (!this.isSimpleLinearGeometry(n)) return !1 } return !0 },
                    hasClosedEndpointIntersection: function(t) {
                        for (var e = new rt, i = t.getEdgeIterator(); i.hasNext();) {
                            var n = i.next(),
                                r = (n.getMaximumSegmentIndex(), n.isClosed()),
                                o = n.getCoordinate(0);
                            this.addEndpoint(e, o, r);
                            var s = n.getCoordinate(n.getNumPoints() - 1);
                            this.addEndpoint(e, s, r)
                        }
                        for (var i = e.values().iterator(); i.hasNext();) { var a = i.next(); if (a.isClosed && 2 !== a.degree) return this.nonSimpleLocation = a.getCoordinate(), !0 }
                        return !1
                    },
                    getNonSimpleLocation: function() { return this.nonSimpleLocation },
                    isSimpleLinearGeometry: function(t) {
                        if (t.isEmpty()) return !0;
                        var e = new Ji(0, t),
                            i = new ae,
                            n = e.computeSelfNodes(i, !0);
                        return !n.hasIntersection() || (n.hasProperIntersection() ? (this.nonSimpleLocation = n.getProperIntersectionPoint(), !1) : !this.hasNonEndpointIntersection(e) && (!this.isClosedEndpointsInInterior || !this.hasClosedEndpointIntersection(e)))
                    },
                    hasNonEndpointIntersection: function(t) {
                        for (var e = t.getEdgeIterator(); e.hasNext();)
                            for (var i = e.next(), n = i.getMaximumSegmentIndex(), r = i.getEdgeIntersectionList().iterator(); r.hasNext();) { var o = r.next(); if (!o.isEndPoint(n)) return this.nonSimpleLocation = o.getCoordinate(), !0 }
                        return !1
                    },
                    addEndpoint: function(t, e, i) {
                        var n = t.get(e);
                        null === n && (n = new Yn(e), t.put(e, n)), n.addEndpoint(i)
                    },
                    computeSimple: function(t) { return this.nonSimpleLocation = null, !!t.isEmpty() || (t instanceof Nt ? this.isSimpleLinearGeometry(t) : t instanceof ft ? this.isSimpleLinearGeometry(t) : t instanceof kt ? this.isSimpleMultiPoint(t) : M(t, Mt) ? this.isSimplePolygonal(t) : !(t instanceof ct) || this.isSimpleGeometryCollection(t)) },
                    isSimple: function() { return this.nonSimpleLocation = null, this.computeSimple(this.inputGeom) },
                    isSimpleGeometryCollection: function(t) { for (var e = 0; e < t.getNumGeometries(); e++) { var i = t.getGeometryN(e); if (!this.computeSimple(i)) return !1 } return !0 },
                    interfaces_: function() { return [] },
                    getClass: function() { return Hn }
                }), e(Yn.prototype, { addEndpoint: function(t) { this.degree++, this.isClosed |= t }, getCoordinate: function() { return this.pt }, interfaces_: function() { return [] }, getClass: function() { return Yn } }), Hn.EndpointInfo = Yn, e(Kn.prototype, { getEndCapStyle: function() { return this.endCapStyle }, isSingleSided: function() { return this._isSingleSided }, setQuadrantSegments: function(t) { this.quadrantSegments = t, 0 === this.quadrantSegments && (this.joinStyle = Kn.JOIN_BEVEL), this.quadrantSegments < 0 && (this.joinStyle = Kn.JOIN_MITRE, this.mitreLimit = Math.abs(this.quadrantSegments)), 0 >= t && (this.quadrantSegments = 1), this.joinStyle !== Kn.JOIN_ROUND && (this.quadrantSegments = Kn.DEFAULT_QUADRANT_SEGMENTS) }, getJoinStyle: function() { return this.joinStyle }, setJoinStyle: function(t) { this.joinStyle = t }, setSimplifyFactor: function(t) { this.simplifyFactor = 0 > t ? 0 : t }, getSimplifyFactor: function() { return this.simplifyFactor }, getQuadrantSegments: function() { return this.quadrantSegments }, setEndCapStyle: function(t) { this.endCapStyle = t }, getMitreLimit: function() { return this.mitreLimit }, setMitreLimit: function(t) { this.mitreLimit = t }, setSingleSided: function(t) { this._isSingleSided = t }, interfaces_: function() { return [] }, getClass: function() { return Kn } }), Kn.bufferDistanceError = function(t) { var e = Math.PI / 2 / t; return 1 - Math.cos(e / 2) }, Kn.CAP_ROUND = 1, Kn.CAP_FLAT = 2, Kn.CAP_SQUARE = 3, Kn.JOIN_ROUND = 1, Kn.JOIN_MITRE = 2, Kn.JOIN_BEVEL = 3, Kn.DEFAULT_QUADRANT_SEGMENTS = 8, Kn.DEFAULT_MITRE_LIMIT = 5, Kn.DEFAULT_SIMPLIFY_FACTOR = .01, e($n.prototype, {
                    getCoordinate: function() { return this.minCoord },
                    getRightmostSide: function(t, e) { var i = this.getRightmostSideOfSegment(t, e); return 0 > i && (i = this.getRightmostSideOfSegment(t, e - 1)), 0 > i && (this.minCoord = null, this.checkForRightmostCoordinate(t)), i },
                    findRightmostEdgeAtVertex: function() {
                        var t = this.minDe.getEdge().getCoordinates();
                        c.isTrue(this.minIndex > 0 && this.minIndex < t.length, "rightmost point expected to be interior vertex of edge");
                        var e = t[this.minIndex - 1],
                            i = t[this.minIndex + 1],
                            n = ue.computeOrientation(this.minCoord, i, e),
                            r = !1;
                        e.y < this.minCoord.y && i.y < this.minCoord.y && n === ue.COUNTERCLOCKWISE ? r = !0 : e.y > this.minCoord.y && i.y > this.minCoord.y && n === ue.CLOCKWISE && (r = !0), r && (this.minIndex = this.minIndex - 1)
                    },
                    getRightmostSideOfSegment: function(t, e) {
                        var i = t.getEdge(),
                            n = i.getCoordinates();
                        if (0 > e || e + 1 >= n.length) return -1;
                        if (n[e].y === n[e + 1].y) return -1;
                        var r = ui.LEFT;
                        return n[e].y < n[e + 1].y && (r = ui.RIGHT), r
                    },
                    getEdge: function() { return this.orientedDe },
                    checkForRightmostCoordinate: function(t) { for (var e = t.getEdge().getCoordinates(), i = 0; i < e.length - 1; i++)(null === this.minCoord || e[i].x > this.minCoord.x) && (this.minDe = t, this.minIndex = i, this.minCoord = e[i]) },
                    findRightmostEdgeAtNode: function() {
                        var t = this.minDe.getNode(),
                            e = t.getEdges();
                        this.minDe = e.getRightmostEdge(), this.minDe.isForward() || (this.minDe = this.minDe.getSym(), this.minIndex = this.minDe.getEdge().getCoordinates().length - 1)
                    },
                    findEdge: function(t) {
                        for (var e = t.iterator(); e.hasNext();) {
                            var i = e.next();
                            i.isForward() && this.checkForRightmostCoordinate(i)
                        }
                        c.isTrue(0 !== this.minIndex || this.minCoord.equals(this.minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this.minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this.orientedDe = this.minDe;
                        var n = this.getRightmostSide(this.minDe, this.minIndex);
                        n === ui.LEFT && (this.orientedDe = this.minDe.getSym())
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return $n }
                }), Zn.prototype.addLast = function(t) { this.array_.push(t) }, Zn.prototype.removeFirst = function() { return this.array_.shift() }, Zn.prototype.isEmpty = function() { return 0 === this.array_.length }, e(Jn.prototype, {
                    clearVisitedEdges: function() {
                        for (var t = this.dirEdgeList.iterator(); t.hasNext();) {
                            var e = t.next();
                            e.setVisited(!1)
                        }
                    },
                    getRightmostCoordinate: function() { return this.rightMostCoord },
                    computeNodeDepth: function(t) {
                        for (var e = null, i = t.getEdges().iterator(); i.hasNext();) { var n = i.next(); if (n.isVisited() || n.getSym().isVisited()) { e = n; break } }
                        if (null === e) throw new ri("unable to find edge to compute depths at " + t.getCoordinate());
                        t.getEdges().computeDepths(e);
                        for (var i = t.getEdges().iterator(); i.hasNext();) {
                            var n = i.next();
                            n.setVisited(!0), this.copySymDepths(n)
                        }
                    },
                    computeDepth: function(t) {
                        this.clearVisitedEdges();
                        var e = this.finder.getEdge();
                        e.getNode(), e.getLabel(), e.setEdgeDepths(ui.RIGHT, t), this.copySymDepths(e), this.computeDepths(e)
                    },
                    create: function(t) { this.addReachable(t), this.finder.findEdge(this.dirEdgeList), this.rightMostCoord = this.finder.getCoordinate() },
                    findResultEdges: function() {
                        for (var t = this.dirEdgeList.iterator(); t.hasNext();) {
                            var e = t.next();
                            e.getDepth(ui.RIGHT) >= 1 && e.getDepth(ui.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0)
                        }
                    },
                    computeDepths: function(t) {
                        var e = new J,
                            i = new Zn,
                            n = t.getNode();
                        for (i.addLast(n), e.add(n), t.setVisited(!0); !i.isEmpty();) {
                            var r = i.removeFirst();
                            e.add(r), this.computeNodeDepth(r);
                            for (var o = r.getEdges().iterator(); o.hasNext();) {
                                var s = o.next(),
                                    a = s.getSym();
                                if (!a.isVisited()) {
                                    var h = a.getNode();
                                    e.contains(h) || (i.addLast(h), e.add(h))
                                }
                            }
                        }
                    },
                    compareTo: function(t) { var e = t; return this.rightMostCoord.x < e.rightMostCoord.x ? -1 : this.rightMostCoord.x > e.rightMostCoord.x ? 1 : 0 },
                    getEnvelope: function() {
                        if (null === this.env) {
                            for (var t = new S, e = this.dirEdgeList.iterator(); e.hasNext();)
                                for (var i = e.next(), n = i.getEdge().getCoordinates(), r = 0; r < n.length - 1; r++) t.expandToInclude(n[r]);
                            this.env = t
                        }
                        return this.env
                    },
                    addReachable: function(t) {
                        var e = new de;
                        for (e.add(t); !e.empty();) {
                            var i = e.pop();
                            this.add(i, e)
                        }
                    },
                    copySymDepths: function(t) {
                        var e = t.getSym();
                        e.setDepth(ui.LEFT, t.getDepth(ui.RIGHT)), e.setDepth(ui.RIGHT, t.getDepth(ui.LEFT))
                    },
                    add: function(t, e) {
                        t.setVisited(!0), this.nodes.add(t);
                        for (var i = t.getEdges().iterator(); i.hasNext();) {
                            var n = i.next();
                            this.dirEdgeList.add(n);
                            var r = n.getSym(),
                                o = r.getNode();
                            o.isVisited() || e.push(o)
                        }
                    },
                    getNodes: function() { return this.nodes },
                    getDirectedEdges: function() { return this.dirEdgeList },
                    interfaces_: function() { return [o] },
                    getClass: function() { return Jn }
                }), e(Qn.prototype, {
                    isDeletable: function(t, e, i, n) {
                        var r = this.inputLine[t],
                            o = this.inputLine[e],
                            s = this.inputLine[i];
                        return !(!this.isConcave(r, o, s) || !this.isShallow(r, o, s, n)) && this.isShallowSampled(r, o, t, i, n)
                    },
                    deleteShallowConcavities: function() {
                        for (var t = 1, e = (this.inputLine.length - 1, this.findNextNonDeletedIndex(t)), i = this.findNextNonDeletedIndex(e), n = !1; i < this.inputLine.length;) {
                            var r = !1;
                            this.isDeletable(t, e, i, this.distanceTol) && (this.isDeleted[e] = Qn.DELETE, r = !0, n = !0), t = r ? i : e, e = this.findNextNonDeletedIndex(t), i = this.findNextNonDeletedIndex(e)
                        }
                        return n
                    },
                    isShallowConcavity: function(t, e, i, n) {
                        var r = ue.computeOrientation(t, e, i),
                            o = r === this.angleOrientation;
                        if (!o) return !1;
                        var s = ue.distancePointLine(e, t, i);
                        return n > s
                    },
                    isShallowSampled: function(t, e, i, n, r) {
                        var o = Math.trunc((n - i) / Qn.NUM_PTS_TO_CHECK);
                        0 >= o && (o = 1);
                        for (var s = i; n > s; s += o)
                            if (!this.isShallow(t, e, this.inputLine[s], r)) return !1;
                        return !0
                    },
                    isConcave: function t(e, i, n) {
                        var r = ue.computeOrientation(e, i, n),
                            t = r === this.angleOrientation;
                        return t
                    },
                    simplify: function(t) {
                        this.distanceTol = Math.abs(t), 0 > t && (this.angleOrientation = ue.CLOCKWISE), this.isDeleted = new Array(this.inputLine.length).fill(null);
                        var e = !1;
                        do e = this.deleteShallowConcavities(); while (e);
                        return this.collapseLine()
                    },
                    findNextNonDeletedIndex: function(t) { for (var e = t + 1; e < this.inputLine.length && this.isDeleted[e] === Qn.DELETE;) e++; return e },
                    isShallow: function(t, e, i, n) { var r = ue.distancePointLine(e, t, i); return n > r },
                    collapseLine: function() { for (var t = new E, e = 0; e < this.inputLine.length; e++) this.isDeleted[e] !== Qn.DELETE && t.add(this.inputLine[e]); return t.toCoordinateArray() },
                    interfaces_: function() { return [] },
                    getClass: function() { return Qn }
                }), Qn.simplify = function(t, e) { var i = new Qn(t); return i.simplify(e) }, Qn.INIT = 0, Qn.DELETE = 1, Qn.KEEP = 1, Qn.NUM_PTS_TO_CHECK = 10, e(tr.prototype, {
                    getCoordinates: function() { var t = this.ptList.toArray(tr.COORDINATE_ARRAY_TYPE); return t },
                    setPrecisionModel: function(t) { this.precisionModel = t },
                    addPt: function(t) { var e = new f(t); return this.precisionModel.makePrecise(e), this.isRedundant(e) ? null : void this.ptList.add(e) },
                    reverse: function() {},
                    addPts: function(t, e) {
                        if (e)
                            for (var i = 0; i < t.length; i++) this.addPt(t[i]);
                        else
                            for (var i = t.length - 1; i >= 0; i--) this.addPt(t[i])
                    },
                    isRedundant: function(t) {
                        if (this.ptList.size() < 1) return !1;
                        var e = this.ptList.get(this.ptList.size() - 1),
                            i = t.distance(e);
                        return i < this.minimimVertexDistance
                    },
                    toString: function() {
                        var t = new ne,
                            e = t.createLineString(this.getCoordinates());
                        return e.toString()
                    },
                    closeRing: function() {
                        if (this.ptList.size() < 1) return null;
                        var t = new f(this.ptList.get(0)),
                            e = this.ptList.get(this.ptList.size() - 1),
                            i = null;
                        return this.ptList.size() >= 2 && (i = this.ptList.get(this.ptList.size() - 2)), t.equals(e) ? null : void this.ptList.add(t)
                    },
                    setMinimumVertexDistance: function(t) { this.minimimVertexDistance = t },
                    interfaces_: function() { return [] },
                    getClass: function() { return tr }
                }), tr.COORDINATE_ARRAY_TYPE = new Array(0).fill(null), e(er.prototype, {
                    addNextSegment: function(t, e) {
                        if (this.s0 = this.s1, this.s1 = this.s2, this.s2 = t, this.seg0.setCoordinates(this.s0, this.s1), this.computeOffsetSegment(this.seg0, this.side, this.distance, this.offset0), this.seg1.setCoordinates(this.s1, this.s2), this.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1), this.s1.equals(this.s2)) return null;
                        var i = ue.computeOrientation(this.s0, this.s1, this.s2),
                            n = i === ue.CLOCKWISE && this.side === ui.LEFT || i === ue.COUNTERCLOCKWISE && this.side === ui.RIGHT;
                        0 === i ? this.addCollinear(e) : n ? this.addOutsideTurn(i, e) : this.addInsideTurn(i, e)
                    },
                    addLineEndCap: function(t, e) {
                        var i = new pe(t, e),
                            n = new pe;
                        this.computeOffsetSegment(i, ui.LEFT, this.distance, n);
                        var r = new pe;
                        this.computeOffsetSegment(i, ui.RIGHT, this.distance, r);
                        var o = e.x - t.x,
                            s = e.y - t.y,
                            a = Math.atan2(s, o);
                        switch (this.bufParams.getEndCapStyle()) {
                            case Kn.CAP_ROUND:
                                this.segList.addPt(n.p1), this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, ue.CLOCKWISE, this.distance), this.segList.addPt(r.p1);
                                break;
                            case Kn.CAP_FLAT:
                                this.segList.addPt(n.p1), this.segList.addPt(r.p1);
                                break;
                            case Kn.CAP_SQUARE:
                                var h = new f;
                                h.x = Math.abs(this.distance) * Math.cos(a), h.y = Math.abs(this.distance) * Math.sin(a);
                                var l = new f(n.p1.x + h.x, n.p1.y + h.y),
                                    u = new f(r.p1.x + h.x, r.p1.y + h.y);
                                this.segList.addPt(l), this.segList.addPt(u)
                        }
                    },
                    getCoordinates: function() { var t = this.segList.getCoordinates(); return t },
                    addMitreJoin: function(t, e, i, n) {
                        var r = !0,
                            o = null;
                        try {
                            o = D.intersection(e.p0, e.p1, i.p0, i.p1);
                            var s = 0 >= n ? 1 : o.distance(t) / Math.abs(n);
                            s > this.bufParams.getMitreLimit() && (r = !1)
                        } catch (t) {
                            if (!(t instanceof L)) throw t;
                            o = new f(0, 0), r = !1
                        } finally {}
                        r ? this.segList.addPt(o) : this.addLimitedMitreJoin(e, i, n, this.bufParams.getMitreLimit())
                    },
                    addFilletCorner: function(t, e, i, n, r) {
                        var o = e.x - t.x,
                            s = e.y - t.y,
                            a = Math.atan2(s, o),
                            h = i.x - t.x,
                            l = i.y - t.y,
                            u = Math.atan2(l, h);
                        n === ue.CLOCKWISE ? u >= a && (a += 2 * Math.PI) : a >= u && (a -= 2 * Math.PI), this.segList.addPt(e), this.addFilletArc(t, a, u, n, r), this.segList.addPt(i)
                    },
                    addOutsideTurn: function(t, e) { return this.offset0.p1.distance(this.offset1.p0) < this.distance * er.OFFSET_SEGMENT_SEPARATION_FACTOR ? (this.segList.addPt(this.offset0.p1), null) : void(this.bufParams.getJoinStyle() === Kn.JOIN_MITRE ? this.addMitreJoin(this.s1, this.offset0, this.offset1, this.distance) : this.bufParams.getJoinStyle() === Kn.JOIN_BEVEL ? this.addBevelJoin(this.offset0, this.offset1) : (e && this.segList.addPt(this.offset0.p1), this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, t, this.distance), this.segList.addPt(this.offset1.p0))) },
                    createSquare: function(t) { this.segList.addPt(new f(t.x + this.distance, t.y + this.distance)), this.segList.addPt(new f(t.x + this.distance, t.y - this.distance)), this.segList.addPt(new f(t.x - this.distance, t.y - this.distance)), this.segList.addPt(new f(t.x - this.distance, t.y + this.distance)), this.segList.closeRing() },
                    addSegments: function(t, e) { this.segList.addPts(t, e) },
                    addFirstSegment: function() { this.segList.addPt(this.offset1.p0) },
                    addLastSegment: function() { this.segList.addPt(this.offset1.p1) },
                    initSideSegments: function(t, e, i) { this.s1 = t, this.s2 = e, this.side = i, this.seg1.setCoordinates(t, e), this.computeOffsetSegment(this.seg1, i, this.distance, this.offset1) },
                    addLimitedMitreJoin: function(t, e, i, n) {
                        var r = this.seg0.p1,
                            o = Sn.angle(r, this.seg0.p0),
                            s = (Sn.angle(r, this.seg1.p1), Sn.angleBetweenOriented(this.seg0.p0, r, this.seg1.p1)),
                            a = s / 2,
                            h = Sn.normalize(o + a),
                            l = Sn.normalize(h + Math.PI),
                            u = n * i,
                            p = u * Math.abs(Math.sin(a)),
                            c = i - p,
                            g = r.x + u * Math.cos(l),
                            d = r.y + u * Math.sin(l),
                            y = new f(g, d),
                            m = new pe(r, y),
                            v = m.pointAlongOffset(1, c),
                            b = m.pointAlongOffset(1, -c);
                        this.side === ui.LEFT ? (this.segList.addPt(v), this.segList.addPt(b)) : (this.segList.addPt(b), this.segList.addPt(v))
                    },
                    computeOffsetSegment: function(t, e, i, n) {
                        var r = e === ui.LEFT ? 1 : -1,
                            o = t.p1.x - t.p0.x,
                            s = t.p1.y - t.p0.y,
                            a = Math.sqrt(o * o + s * s),
                            h = r * i * o / a,
                            l = r * i * s / a;
                        n.p0.x = t.p0.x - l, n.p0.y = t.p0.y + h, n.p1.x = t.p1.x - l, n.p1.y = t.p1.y + h
                    },
                    addFilletArc: function(t, e, i, n, r) {
                        var o = n === ue.CLOCKWISE ? -1 : 1,
                            s = Math.abs(e - i),
                            a = Math.trunc(s / this.filletAngleQuantum + .5);
                        if (1 > a) return null;
                        var h = null,
                            l = null;
                        h = 0, l = s / a;
                        for (var u = h, p = new f; s > u;) {
                            var c = e + o * u;
                            p.x = t.x + r * Math.cos(c), p.y = t.y + r * Math.sin(c), this.segList.addPt(p), u += l
                        }
                    },
                    addInsideTurn: function(t, e) {
                        if (this.li.computeIntersection(this.offset0.p0, this.offset0.p1, this.offset1.p0, this.offset1.p1), this.li.hasIntersection()) this.segList.addPt(this.li.getIntersection(0));
                        else if (this._hasNarrowConcaveAngle = !0, this.offset0.p1.distance(this.offset1.p0) < this.distance * er.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this.segList.addPt(this.offset0.p1);
                        else {
                            if (this.segList.addPt(this.offset0.p1), this.closingSegLengthFactor > 0) {
                                var i = new f((this.closingSegLengthFactor * this.offset0.p1.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset0.p1.y + this.s1.y) / (this.closingSegLengthFactor + 1));
                                this.segList.addPt(i);
                                var n = new f((this.closingSegLengthFactor * this.offset1.p0.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset1.p0.y + this.s1.y) / (this.closingSegLengthFactor + 1));
                                this.segList.addPt(n)
                            } else this.segList.addPt(this.s1);
                            this.segList.addPt(this.offset1.p0)
                        }
                    },
                    createCircle: function(t) {
                        var e = new f(t.x + this.distance, t.y);
                        this.segList.addPt(e), this.addFilletArc(t, 0, 2 * Math.PI, -1, this.distance), this.segList.closeRing()
                    },
                    addBevelJoin: function(t, e) { this.segList.addPt(t.p1), this.segList.addPt(e.p0) },
                    init: function(t) { this.distance = t, this.maxCurveSegmentError = t * (1 - Math.cos(this.filletAngleQuantum / 2)), this.segList = new tr, this.segList.setPrecisionModel(this.precisionModel), this.segList.setMinimumVertexDistance(t * er.CURVE_VERTEX_SNAP_DISTANCE_FACTOR) },
                    addCollinear: function(t) {
                        this.li.computeIntersection(this.s0, this.s1, this.s1, this.s2);
                        var e = this.li.getIntersectionNum();
                        e >= 2 && (this.bufParams.getJoinStyle() === Kn.JOIN_BEVEL || this.bufParams.getJoinStyle() === Kn.JOIN_MITRE ? (t && this.segList.addPt(this.offset0.p1), this.segList.addPt(this.offset1.p0)) : this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, ue.CLOCKWISE, this.distance))
                    },
                    closeRing: function() { this.segList.closeRing() },
                    hasNarrowConcaveAngle: function() { return this._hasNarrowConcaveAngle },
                    interfaces_: function() { return [] },
                    getClass: function() { return er }
                }), er.OFFSET_SEGMENT_SEPARATION_FACTOR = .001, er.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001, er.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, er.MAX_CLOSING_SEG_LEN_FACTOR = 80, e(ir.prototype, {
                    getOffsetCurve: function(t, e) {
                        if (this.distance = e, 0 === e) return null;
                        var i = 0 > e,
                            n = Math.abs(e),
                            r = this.getSegGen(n);
                        t.length <= 1 ? this.computePointCurve(t[0], r) : this.computeOffsetCurve(t, i, r);
                        var o = r.getCoordinates();
                        return i && X.reverse(o), o
                    },
                    computeSingleSidedBufferCurve: function(t, e, i) {
                        var n = this.simplifyTolerance(this.distance);
                        if (e) {
                            i.addSegments(t, !0);
                            var r = Qn.simplify(t, -n),
                                o = r.length - 1;
                            i.initSideSegments(r[o], r[o - 1], ui.LEFT), i.addFirstSegment();
                            for (var s = o - 2; s >= 0; s--) i.addNextSegment(r[s], !0)
                        } else {
                            i.addSegments(t, !1);
                            var a = Qn.simplify(t, n),
                                h = a.length - 1;
                            i.initSideSegments(a[0], a[1], ui.LEFT), i.addFirstSegment();
                            for (var s = 2; h >= s; s++) i.addNextSegment(a[s], !0)
                        }
                        i.addLastSegment(), i.closeRing()
                    },
                    computeRingBufferCurve: function(t, e, i) {
                        var n = this.simplifyTolerance(this.distance);
                        e === ui.RIGHT && (n = -n);
                        var r = Qn.simplify(t, n),
                            o = r.length - 1;
                        i.initSideSegments(r[o - 1], r[0], e);
                        for (var s = 1; o >= s; s++) {
                            var a = 1 !== s;
                            i.addNextSegment(r[s], a)
                        }
                        i.closeRing()
                    },
                    computeLineBufferCurve: function(t, e) {
                        var i = this.simplifyTolerance(this.distance),
                            n = Qn.simplify(t, i),
                            r = n.length - 1;
                        e.initSideSegments(n[0], n[1], ui.LEFT);
                        for (var o = 2; r >= o; o++) e.addNextSegment(n[o], !0);
                        e.addLastSegment(), e.addLineEndCap(n[r - 1], n[r]);
                        var s = Qn.simplify(t, -i),
                            a = s.length - 1;
                        e.initSideSegments(s[a], s[a - 1], ui.LEFT);
                        for (var o = a - 2; o >= 0; o--) e.addNextSegment(s[o], !0);
                        e.addLastSegment(), e.addLineEndCap(s[1], s[0]), e.closeRing()
                    },
                    computePointCurve: function(t, e) {
                        switch (this.bufParams.getEndCapStyle()) {
                            case Kn.CAP_ROUND:
                                e.createCircle(t);
                                break;
                            case Kn.CAP_SQUARE:
                                e.createSquare(t)
                        }
                    },
                    getLineCurve: function(t, e) {
                        if (this.distance = e, 0 > e && !this.bufParams.isSingleSided()) return null;
                        if (0 === e) return null;
                        var i = Math.abs(e),
                            n = this.getSegGen(i);
                        if (t.length <= 1) this.computePointCurve(t[0], n);
                        else if (this.bufParams.isSingleSided()) {
                            var r = 0 > e;
                            this.computeSingleSidedBufferCurve(t, r, n)
                        } else this.computeLineBufferCurve(t, n);
                        var o = n.getCoordinates();
                        return o
                    },
                    getBufferParameters: function() { return this.bufParams },
                    simplifyTolerance: function(t) { return t * this.bufParams.getSimplifyFactor() },
                    getRingCurve: function(t, e, i) { if (this.distance = i, t.length <= 2) return this.getLineCurve(t, i); if (0 === i) return ir.copyCoordinates(t); var n = this.getSegGen(i); return this.computeRingBufferCurve(t, e, n), n.getCoordinates() },
                    computeOffsetCurve: function(t, e, i) {
                        var n = this.simplifyTolerance(this.distance);
                        if (e) {
                            var r = Qn.simplify(t, -n),
                                o = r.length - 1;
                            i.initSideSegments(r[o], r[o - 1], ui.LEFT), i.addFirstSegment();
                            for (var s = o - 2; s >= 0; s--) i.addNextSegment(r[s], !0)
                        } else {
                            var a = Qn.simplify(t, n),
                                h = a.length - 1;
                            i.initSideSegments(a[0], a[1], ui.LEFT), i.addFirstSegment();
                            for (var s = 2; h >= s; s++) i.addNextSegment(a[s], !0)
                        }
                        i.addLastSegment()
                    },
                    getSegGen: function(t) { return new er(this.precisionModel, this.bufParams, t) },
                    interfaces_: function() { return [] },
                    getClass: function() { return ir }
                }), ir.copyCoordinates = function(t) { for (var e = new Array(t.length).fill(null), i = 0; i < e.length; i++) e[i] = new f(t[i]); return e }, e(nr.prototype, {
                    findStabbedSegments: function() {
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = new x, i = this.subgraphs.iterator(); i.hasNext();) {
                                var n = i.next(),
                                    r = n.getEnvelope();
                                t.y < r.getMinY() || t.y > r.getMaxY() || this.findStabbedSegments(t, n.getDirectedEdges(), e)
                            }
                            return e
                        }
                        if (3 === arguments.length)
                            if (M(arguments[2], v) && arguments[0] instanceof f && arguments[1] instanceof wi)
                                for (var o = arguments[0], s = arguments[1], a = arguments[2], h = s.getEdge().getCoordinates(), i = 0; i < h.length - 1; i++) {
                                    this.seg.p0 = h[i], this.seg.p1 = h[i + 1], this.seg.p0.y > this.seg.p1.y && this.seg.reverse();
                                    var l = Math.max(this.seg.p0.x, this.seg.p1.x);
                                    if (!(l < o.x || this.seg.isHorizontal() || o.y < this.seg.p0.y || o.y > this.seg.p1.y || ue.computeOrientation(this.seg.p0, this.seg.p1, o) === ue.RIGHT)) {
                                        var u = s.getDepth(ui.LEFT);
                                        this.seg.p0.equals(h[i]) || (u = s.getDepth(ui.RIGHT));
                                        var p = new rr(this.seg, u);
                                        a.add(p)
                                    }
                                } else if (M(arguments[2], v) && arguments[0] instanceof f && M(arguments[1], v))
                                    for (var c = arguments[0], g = arguments[1], d = arguments[2], i = g.iterator(); i.hasNext();) {
                                        var y = i.next();
                                        y.isForward() && this.findStabbedSegments(c, y, d)
                                    }
                    },
                    getDepth: function(t) { var e = this.findStabbedSegments(t); if (0 === e.size()) return 0; var i = ps.min(e); return i.leftDepth },
                    interfaces_: function() { return [] },
                    getClass: function() { return nr }
                }), e(rr.prototype, { compareTo: function(t) { var e = t; if (this.upwardSeg.minX() >= e.upwardSeg.maxX()) return 1; if (this.upwardSeg.maxX() <= e.upwardSeg.minX()) return -1; var i = this.upwardSeg.orientationIndex(e.upwardSeg); return 0 !== i ? i : (i = -1 * e.upwardSeg.orientationIndex(this.upwardSeg), 0 !== i ? i : this.upwardSeg.compareTo(e.upwardSeg)) }, compareX: function(t, e) { var i = t.p0.compareTo(e.p0); return 0 !== i ? i : t.p1.compareTo(e.p1) }, toString: function() { return this.upwardSeg.toString() }, interfaces_: function() { return [o] }, getClass: function() { return rr } }), nr.DepthSegment = rr, e(or.prototype, {
                    addPoint: function(t) {
                        if (this.distance <= 0) return null;
                        var e = t.getCoordinates(),
                            i = this.curveBuilder.getLineCurve(e, this.distance);
                        this.addCurve(i, C.EXTERIOR, C.INTERIOR)
                    },
                    addPolygon: function(t) {
                        var e = this.distance,
                            i = ui.LEFT;
                        this.distance < 0 && (e = -this.distance, i = ui.RIGHT);
                        var n = t.getExteriorRing(),
                            r = X.removeRepeatedPoints(n.getCoordinates());
                        if (this.distance < 0 && this.isErodedCompletely(n, this.distance)) return null;
                        if (this.distance <= 0 && r.length < 3) return null;
                        this.addPolygonRing(r, e, i, C.EXTERIOR, C.INTERIOR);
                        for (var o = 0; o < t.getNumInteriorRing(); o++) {
                            var s = t.getInteriorRingN(o),
                                a = X.removeRepeatedPoints(s.getCoordinates());
                            this.distance > 0 && this.isErodedCompletely(s, -this.distance) || this.addPolygonRing(a, e, ui.opposite(i), C.INTERIOR, C.EXTERIOR)
                        }
                    },
                    isTriangleErodedCompletely: function(t, e) {
                        var i = new Nn(t[0], t[1], t[2]),
                            n = i.inCentre(),
                            r = ue.distancePointLine(n, i.p0, i.p1);
                        return r < Math.abs(e)
                    },
                    addLineString: function(t) {
                        if (this.distance <= 0 && !this.curveBuilder.getBufferParameters().isSingleSided()) return null;
                        var e = X.removeRepeatedPoints(t.getCoordinates()),
                            i = this.curveBuilder.getLineCurve(e, this.distance);
                        this.addCurve(i, C.EXTERIOR, C.INTERIOR)
                    },
                    addCurve: function(t, e, i) {
                        if (null === t || t.length < 2) return null;
                        var n = new Ke(t, new ci(0, C.BOUNDARY, e, i));
                        this.curveList.add(n)
                    },
                    getCurves: function() { return this.add(this.inputGeom), this.curveList },
                    addPolygonRing: function(t, e, i, n, r) {
                        if (0 === e && t.length < Tt.MINIMUM_VALID_SIZE) return null;
                        var o = n,
                            s = r;
                        t.length >= Tt.MINIMUM_VALID_SIZE && ue.isCCW(t) && (o = r, s = n, i = ui.opposite(i));
                        var a = this.curveBuilder.getRingCurve(t, i, e);
                        this.addCurve(a, o, s)
                    },
                    add: function(t) {
                        if (t.isEmpty()) return null;
                        if (t instanceof It) this.addPolygon(t);
                        else if (t instanceof Nt) this.addLineString(t);
                        else if (t instanceof Ct) this.addPoint(t);
                        else if (t instanceof kt) this.addCollection(t);
                        else if (t instanceof ft) this.addCollection(t);
                        else if (t instanceof At) this.addCollection(t);
                        else {
                            if (!(t instanceof ct)) throw new UnsupportedOperationException(t.getClass().getName());
                            this.addCollection(t)
                        }
                    },
                    isErodedCompletely: function(t, e) {
                        var i = t.getCoordinates();
                        if (i.length < 4) return 0 > e;
                        if (4 === i.length) return this.isTriangleErodedCompletely(i, e);
                        var n = t.getEnvelopeInternal(),
                            r = Math.min(n.getHeight(), n.getWidth());
                        return 0 > e && 2 * Math.abs(e) > r
                    },
                    addCollection: function(t) {
                        for (var e = 0; e < t.getNumGeometries(); e++) {
                            var i = t.getGeometryN(e);
                            this.add(i)
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return or }
                }), e(sr.prototype, {
                    isTrivialIntersection: function(t, e, i, n) { if (t === i && 1 === this.li.getIntersectionNum()) { if (sr.isAdjacentSegments(e, n)) return !0; if (t.isClosed()) { var r = t.size() - 1; if (0 === e && n === r || 0 === n && e === r) return !0 } } return !1 },
                    getProperIntersectionPoint: function() { return this.properIntersectionPoint },
                    hasProperInteriorIntersection: function() { return this.hasProperInterior },
                    getLineIntersector: function() { return this.li },
                    hasProperIntersection: function() { return this.hasProper },
                    processIntersections: function(t, e, i, n) {
                        if (t === i && e === n) return null;
                        this.numTests++;
                        var r = t.getCoordinates()[e],
                            o = t.getCoordinates()[e + 1],
                            s = i.getCoordinates()[n],
                            a = i.getCoordinates()[n + 1];
                        this.li.computeIntersection(r, o, s, a), this.li.hasIntersection() && (this.numIntersections++, this.li.isInteriorIntersection() && (this.numInteriorIntersections++, this.hasInterior = !0), this.isTrivialIntersection(t, e, i, n) || (this._hasIntersection = !0, t.addIntersections(this.li, e, 0), i.addIntersections(this.li, n, 1), this.li.isProper() && (this.numProperIntersections++, this.hasProper = !0, this.hasProperInterior = !0)))
                    },
                    hasIntersection: function() { return this._hasIntersection },
                    isDone: function() { return !1 },
                    hasInteriorIntersection: function() { return this.hasInterior },
                    interfaces_: function() { return [oi] },
                    getClass: function() { return sr }
                }), sr.isAdjacentSegments = function(t, e) { return 1 === Math.abs(t - e) }, e(ar.prototype, {
                    setWorkingPrecisionModel: function(t) { this.workingPrecisionModel = t },
                    insertUniqueEdge: function(t) {
                        var e = this.edgeList.findEqualEdge(t);
                        if (null !== e) {
                            var i = e.getLabel(),
                                n = t.getLabel();
                            e.isPointwiseEqual(t) || (n = new ci(t.getLabel()), n.flip()), i.merge(n);
                            var r = ar.depthDelta(n),
                                o = e.getDepthDelta(),
                                s = o + r;
                            e.setDepthDelta(s)
                        } else this.edgeList.add(t), t.setDepthDelta(ar.depthDelta(t.getLabel()))
                    },
                    buildSubgraphs: function(t, e) {
                        for (var i = new x, n = t.iterator(); n.hasNext();) {
                            var r = n.next(),
                                o = r.getRightmostCoordinate(),
                                s = new nr(i),
                                a = s.getDepth(o);
                            r.computeDepth(a), r.findResultEdges(), i.add(r), e.add(r.getDirectedEdges(), r.getNodes())
                        }
                    },
                    createSubgraphs: function(t) {
                        for (var e = new x, i = t.getNodes().iterator(); i.hasNext();) {
                            var n = i.next();
                            if (!n.isVisited()) {
                                var r = new Jn;
                                r.create(n), e.add(r)
                            }
                        }
                        return ps.sort(e, ps.reverseOrder()), e
                    },
                    createEmptyResultGeometry: function() { var t = this.geomFact.createPolygon(); return t },
                    getNoder: function(t) {
                        if (null !== this.workingNoder) return this.workingNoder;
                        var e = new ii,
                            i = new ae;
                        return i.setPrecisionModel(t), e.setSegmentIntersector(new sr(i)), e
                    },
                    buffer: function(t, e) {
                        var i = this.workingPrecisionModel;
                        null === i && (i = t.getPrecisionModel()), this.geomFact = t.getFactory();
                        var n = new ir(i, this.bufParams),
                            r = new or(t, e, n),
                            o = r.getCurves();
                        if (o.size() <= 0) return this.createEmptyResultGeometry();
                        this.computeNodedEdges(o, i), this.graph = new Ei(new Ti), this.graph.addEdges(this.edgeList.getEdges());
                        var s = this.createSubgraphs(this.graph),
                            a = new Si(this.geomFact);
                        this.buildSubgraphs(s, a);
                        var h = a.getPolygons();
                        if (h.size() <= 0) return this.createEmptyResultGeometry();
                        var l = this.geomFact.buildGeometry(h);
                        return l
                    },
                    computeNodedEdges: function(t, e) {
                        var i = this.getNoder(e);
                        i.computeNodes(t);
                        for (var n = i.getNodedSubstrings(), r = n.iterator(); r.hasNext();) {
                            var o = r.next(),
                                s = o.getCoordinates();
                            if (2 !== s.length || !s[0].equals2D(s[1])) {
                                var a = o.getData(),
                                    h = new Zi(o.getCoordinates(), new ci(a));
                                this.insertUniqueEdge(h)
                            }
                        }
                    },
                    setNoder: function(t) { this.workingNoder = t },
                    interfaces_: function() { return [] },
                    getClass: function() { return ar }
                }), ar.depthDelta = function(t) {
                    var e = t.getLocation(0, ui.LEFT),
                        i = t.getLocation(0, ui.RIGHT);
                    return e === C.INTERIOR && i === C.EXTERIOR ? 1 : e === C.EXTERIOR && i === C.INTERIOR ? -1 : 0
                }, ar.convertSegStrings = function(t) {
                    for (var e = new ne, i = new x; t.hasNext();) {
                        var n = t.next(),
                            r = e.createLineString(n.getCoordinates());
                        i.add(r)
                    }
                    return e.buildGeometry(i)
                }, e(hr.prototype, {
                    checkEndPtVertexIntersections: function() {
                        if (0 === arguments.length)
                            for (var t = this.segStrings.iterator(); t.hasNext();) {
                                var e = t.next(),
                                    i = e.getCoordinates();
                                this.checkEndPtVertexIntersections(i[0], this.segStrings), this.checkEndPtVertexIntersections(i[i.length - 1], this.segStrings)
                            } else if (2 === arguments.length)
                                for (var n = arguments[0], r = arguments[1], t = r.iterator(); t.hasNext();)
                                    for (var e = t.next(), i = e.getCoordinates(), o = 1; o < i.length - 1; o++)
                                        if (i[o].equals(n)) throw new l("found endpt/interior pt intersection at index " + o + " :pt " + n)
                    },
                    checkInteriorIntersections: function() {
                        if (0 === arguments.length)
                            for (var t = this.segStrings.iterator(); t.hasNext();)
                                for (var e = t.next(), i = this.segStrings.iterator(); i.hasNext();) {
                                    var n = i.next();
                                    this.checkInteriorIntersections(e, n)
                                } else if (2 === arguments.length)
                                    for (var r = arguments[0], o = arguments[1], s = r.getCoordinates(), a = o.getCoordinates(), h = 0; h < s.length - 1; h++)
                                        for (var u = 0; u < a.length - 1; u++) this.checkInteriorIntersections(r, h, o, u);
                                else if (4 === arguments.length) {
                            var p = arguments[0],
                                c = arguments[1],
                                f = arguments[2],
                                g = arguments[3];
                            if (p === f && c === g) return null;
                            var d = p.getCoordinates()[c],
                                y = p.getCoordinates()[c + 1],
                                m = f.getCoordinates()[g],
                                v = f.getCoordinates()[g + 1];
                            if (this.li.computeIntersection(d, y, m, v), this.li.hasIntersection() && (this.li.isProper() || this.hasInteriorIntersection(this.li, d, y) || this.hasInteriorIntersection(this.li, m, v))) throw new l("found non-noded intersection at " + d + "-" + y + " and " + m + "-" + v)
                        }
                    },
                    checkValid: function() { this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses() },
                    checkCollapses: function() {
                        if (0 === arguments.length)
                            for (var t = this.segStrings.iterator(); t.hasNext();) {
                                var e = t.next();
                                this.checkCollapses(e)
                            } else if (1 === arguments.length)
                                for (var i = arguments[0], n = i.getCoordinates(), t = 0; t < n.length - 2; t++) this.checkCollapse(n[t], n[t + 1], n[t + 2])
                    },
                    hasInteriorIntersection: function(t, e, i) { for (var n = 0; n < t.getIntersectionNum(); n++) { var r = t.getIntersection(n); if (!r.equals(e) && !r.equals(i)) return !0 } return !1 },
                    checkCollapse: function(t, e, i) { if (t.equals(i)) throw new l("found non-noded collapse at " + hr.fact.createLineString([t, e, i])) },
                    interfaces_: function() { return [] },
                    getClass: function() { return hr }
                }), hr.fact = new ne, e(lr.prototype, {
                    intersectsScaled: function(t, e) {
                        var i = Math.min(t.x, e.x),
                            n = Math.max(t.x, e.x),
                            r = Math.min(t.y, e.y),
                            o = Math.max(t.y, e.y),
                            s = this.maxx < i || this.minx > n || this.maxy < r || this.miny > o;
                        if (s) return !1;
                        var a = this.intersectsToleranceSquare(t, e);
                        return c.isTrue(!(s && a), "Found bad envelope test"), a
                    },
                    initCorners: function(t) {
                        var e = .5;
                        this.minx = t.x - e, this.maxx = t.x + e, this.miny = t.y - e, this.maxy = t.y + e, this.corner[0] = new f(this.maxx, this.maxy), this.corner[1] = new f(this.minx, this.maxy), this.corner[2] = new f(this.minx, this.miny), this.corner[3] = new f(this.maxx, this.miny)
                    },
                    intersects: function(t, e) { return 1 === this.scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this.p0Scaled), this.copyScaled(e, this.p1Scaled), this.intersectsScaled(this.p0Scaled, this.p1Scaled)) },
                    scale: function(t) { return Math.round(t * this.scaleFactor) },
                    getCoordinate: function() { return this.originalPt },
                    copyScaled: function(t, e) { e.x = this.scale(t.x), e.y = this.scale(t.y) },
                    getSafeEnvelope: function() {
                        if (null === this.safeEnv) {
                            var t = lr.SAFE_ENV_EXPANSION_FACTOR / this.scaleFactor;
                            this.safeEnv = new S(this.originalPt.x - t, this.originalPt.x + t, this.originalPt.y - t, this.originalPt.y + t)
                        }
                        return this.safeEnv
                    },
                    intersectsPixelClosure: function(t, e) { return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]), !!this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]), !!this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[2], this.corner[3]), !!this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[3], this.corner[0]), !!this.li.hasIntersection()))) },
                    intersectsToleranceSquare: function(t, e) {
                        var i = !1,
                            n = !1;
                        return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]), !!this.li.isProper() || (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]), !!this.li.isProper() || (this.li.hasIntersection() && (i = !0), this.li.computeIntersection(t, e, this.corner[2], this.corner[3]), !!this.li.isProper() || (this.li.hasIntersection() && (n = !0), this.li.computeIntersection(t, e, this.corner[3], this.corner[0]), !!this.li.isProper() || (!(!i || !n) || (!!t.equals(this.pt) || !!e.equals(this.pt))))))
                    },
                    addSnappedNode: function(t, e) {
                        var i = t.getCoordinate(e),
                            n = t.getCoordinate(e + 1);
                        return !!this.intersects(i, n) && (t.addIntersection(this.getCoordinate(), e), !0)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return lr }
                }), lr.SAFE_ENV_EXPANSION_FACTOR = .75, e(ur.prototype, {
                    snap: function() {
                        if (1 === arguments.length) { var t = arguments[0]; return this.snap(t, null, -1) }
                        if (3 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1],
                                n = arguments[2],
                                r = e.getSafeEnvelope(),
                                o = new pr(e, i, n);
                            return this.index.query(r, {
                                interfaces_: function() { return [Oe] },
                                visitItem: function(t) {
                                    var e = t;
                                    e.select(r, o)
                                }
                            }), o.isNodeAdded()
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return ur }
                }), u(pr, un), e(pr.prototype, {
                    isNodeAdded: function() { return this._isNodeAdded },
                    select: function() {
                        if (2 !== arguments.length) return un.prototype.select.apply(this, arguments);
                        var t = arguments[0],
                            e = arguments[1],
                            i = t.getContext();
                        return null !== this.parentEdge && i === this.parentEdge && e === this.hotPixelVertexIndex ? null : void(this._isNodeAdded = this.hotPixel.addSnappedNode(i, e))
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return pr }
                }), ur.HotPixelSnapAction = pr, e(cr.prototype, {
                    processIntersections: function(t, e, i, n) {
                        if (t === i && e === n) return null;
                        var r = t.getCoordinates()[e],
                            o = t.getCoordinates()[e + 1],
                            s = i.getCoordinates()[n],
                            a = i.getCoordinates()[n + 1];
                        if (this.li.computeIntersection(r, o, s, a), this.li.hasIntersection() && this.li.isInteriorIntersection()) {
                            for (var h = 0; h < this.li.getIntersectionNum(); h++) this.interiorIntersections.add(this.li.getIntersection(h));
                            t.addIntersections(this.li, e, 0), i.addIntersections(this.li, n, 1)
                        }
                    },
                    isDone: function() { return !1 },
                    getInteriorIntersections: function() { return this.interiorIntersections },
                    interfaces_: function() { return [oi] },
                    getClass: function() { return cr }
                }), e(fr.prototype, {
                    checkCorrectness: function(t) {
                        var e = Ke.getNodedSubstrings(t),
                            i = new hr(e);
                        try { i.checkValid() } catch (t) {
                            if (!(t instanceof N)) throw t;
                            t.printStackTrace()
                        } finally {}
                    },
                    getNodedSubstrings: function() { return Ke.getNodedSubstrings(this.nodedSegStrings) },
                    snapRound: function(t, e) {
                        var i = this.findInteriorIntersections(t, e);
                        this.computeIntersectionSnaps(i), this.computeVertexSnaps(t)
                    },
                    findInteriorIntersections: function(t, e) { var i = new cr(e); return this.noder.setSegmentIntersector(i), this.noder.computeNodes(t), i.getInteriorIntersections() },
                    computeVertexSnaps: function() {
                        if (M(arguments[0], y))
                            for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
                                var i = e.next();
                                this.computeVertexSnaps(i)
                            } else if (arguments[0] instanceof Ke)
                                for (var n = arguments[0], r = n.getCoordinates(), o = 0; o < r.length; o++) {
                                    var s = new lr(r[o], this.scaleFactor, this.li),
                                        a = this.pointSnapper.snap(s, n, o);
                                    a && n.addIntersection(r[o], o)
                                }
                    },
                    computeNodes: function(t) { this.nodedSegStrings = t, this.noder = new ii, this.pointSnapper = new ur(this.noder.getIndex()), this.snapRound(t, this.li) },
                    computeIntersectionSnaps: function(t) {
                        for (var e = t.iterator(); e.hasNext();) {
                            var i = e.next(),
                                n = new lr(i, this.scaleFactor, this.li);
                            this.pointSnapper.snap(n)
                        }
                    },
                    interfaces_: function() { return [ti] },
                    getClass: function() { return fr }
                }), e(gr.prototype, {
                    bufferFixedPrecision: function(t) {
                        var e = new Xn(new fr(new ee(1)), t.getScale()),
                            i = new ar(this.bufParams);
                        i.setWorkingPrecisionModel(t), i.setNoder(e), this.resultGeometry = i.buffer(this.argGeom, this.distance)
                    },
                    bufferReducedPrecision: function() {
                        if (0 === arguments.length) {
                            for (var t = gr.MAX_PRECISION_DIGITS; t >= 0; t--) {
                                try { this.bufferReducedPrecision(t) } catch (t) {
                                    if (!(t instanceof ri)) throw t;
                                    this.saveException = t
                                } finally {}
                                if (null !== this.resultGeometry) return null
                            }
                            throw this.saveException
                        }
                        if (1 === arguments.length) {
                            var e = arguments[0],
                                i = gr.precisionScaleFactor(this.argGeom, this.distance, e),
                                n = new ee(i);
                            this.bufferFixedPrecision(n)
                        }
                    },
                    computeGeometry: function() {
                        if (this.bufferOriginalPrecision(), null !== this.resultGeometry) return null;
                        var t = this.argGeom.getFactory().getPrecisionModel();
                        t.getType() === ee.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision()
                    },
                    setQuadrantSegments: function(t) { this.bufParams.setQuadrantSegments(t) },
                    bufferOriginalPrecision: function() {
                        try {
                            var t = new ar(this.bufParams);
                            this.resultGeometry = t.buffer(this.argGeom, this.distance)
                        } catch (t) {
                            if (!(t instanceof l)) throw t;
                            this.saveException = t
                        } finally {}
                    },
                    getResultGeometry: function(t) { return this.distance = t, this.computeGeometry(), this.resultGeometry },
                    setEndCapStyle: function(t) { this.bufParams.setEndCapStyle(t) },
                    interfaces_: function() { return [] },
                    getClass: function() { return gr }
                }), gr.bufferOp = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            i = new gr(t),
                            n = i.getResultGeometry(e);
                        return n
                    }
                    if (3 === arguments.length) {
                        if (Number.isInteger(arguments[2]) && arguments[0] instanceof B && "number" == typeof arguments[1]) {
                            var r = arguments[0],
                                o = arguments[1],
                                s = arguments[2],
                                a = new gr(r);
                            a.setQuadrantSegments(s);
                            var n = a.getResultGeometry(o);
                            return n
                        }
                        if (arguments[2] instanceof Kn && arguments[0] instanceof B && "number" == typeof arguments[1]) {
                            var h = arguments[0],
                                l = arguments[1],
                                u = arguments[2],
                                a = new gr(h, u),
                                n = a.getResultGeometry(l);
                            return n
                        }
                    } else if (4 === arguments.length) {
                        var p = arguments[0],
                            c = arguments[1],
                            f = arguments[2],
                            g = arguments[3],
                            a = new gr(p);
                        a.setQuadrantSegments(f), a.setEndCapStyle(g);
                        var n = a.getResultGeometry(c);
                        return n
                    }
                }, gr.precisionScaleFactor = function(t, e, i) {
                    var n = t.getEnvelopeInternal(),
                        r = I.max(Math.abs(n.getMaxX()), Math.abs(n.getMaxY()), Math.abs(n.getMinX()), Math.abs(n.getMinY())),
                        o = e > 0 ? e : 0,
                        s = r + 2 * o,
                        a = Math.trunc(Math.log(s) / Math.log(10) + 1),
                        h = i - a,
                        l = Math.pow(10, h);
                    return l
                }, gr.CAP_ROUND = Kn.CAP_ROUND, gr.CAP_BUTT = Kn.CAP_FLAT, gr.CAP_FLAT = Kn.CAP_FLAT, gr.CAP_SQUARE = Kn.CAP_SQUARE, gr.MAX_PRECISION_DIGITS = 12;
                var Ns = Object.freeze({ BufferOp: gr, BufferParameters: Kn });
                e(dr.prototype, { filter: function(t) { t instanceof It && this.comps.add(t) }, interfaces_: function() { return [ut] }, getClass: function() { return dr } }), dr.getPolygons = function() {
                    if (1 === arguments.length) { var t = arguments[0]; return dr.getPolygons(t, new x) }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        return e instanceof It ? i.add(e) : e instanceof ct && e.apply(new dr(i)), i
                    }
                }, e(yr.prototype, { isInsideArea: function() { return this.segIndex === yr.INSIDE_AREA }, getCoordinate: function() { return this.pt }, getGeometryComponent: function() { return this.component }, getSegmentIndex: function() { return this.segIndex }, interfaces_: function() { return [] }, getClass: function() { return yr } }), yr.INSIDE_AREA = -1, e(mr.prototype, { filter: function(t) { t instanceof Ct && this.pts.add(t) }, interfaces_: function() { return [ut] }, getClass: function() { return mr } }), mr.getPoints = function() {
                    if (1 === arguments.length) { var t = arguments[0]; return t instanceof Ct ? ps.singletonList(t) : mr.getPoints(t, new x) }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            i = arguments[1];
                        return e instanceof Ct ? i.add(e) : e instanceof ct && e.apply(new mr(i)), i
                    }
                }, e(vr.prototype, {
                    filter: function(t) {
                        (t instanceof Ct || t instanceof Nt || t instanceof It) && this.locations.add(new yr(t, 0, t.getCoordinate()))
                    },
                    interfaces_: function() { return [ut] },
                    getClass: function() { return vr }
                }), vr.getLocations = function(t) { var e = new x; return t.apply(new vr(e)), e }, e(br.prototype, {
                    computeContainmentDistance: function() {
                        if (0 === arguments.length) {
                            var t = new Array(2).fill(null);
                            if (this.computeContainmentDistance(0, t), this.minDistance <= this.terminateDistance) return null;
                            this.computeContainmentDistance(1, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1],
                                n = 1 - e,
                                r = dr.getPolygons(this.geom[e]);
                            if (r.size() > 0) { var o = vr.getLocations(this.geom[n]); if (this.computeContainmentDistance(o, r, i), this.minDistance <= this.terminateDistance) return this.minDistanceLocation[n] = i[0], this.minDistanceLocation[e] = i[1], null }
                        } else if (3 === arguments.length)
                            if (arguments[2] instanceof Array && M(arguments[0], v) && M(arguments[1], v)) {
                                for (var s = arguments[0], a = arguments[1], h = arguments[2], l = 0; l < s.size(); l++)
                                    for (var u = s.get(l), p = 0; p < a.size(); p++)
                                        if (this.computeContainmentDistance(u, a.get(p), h), this.minDistance <= this.terminateDistance) return null
                            } else if (arguments[2] instanceof Array && arguments[0] instanceof yr && arguments[1] instanceof It) {
                            var c = arguments[0],
                                f = arguments[1],
                                g = arguments[2],
                                d = c.getCoordinate();
                            if (C.EXTERIOR !== this.ptLocator.locate(d, f)) return this.minDistance = 0, g[0] = c, g[1] = new yr(f, d), null
                        }
                    },
                    computeMinDistanceLinesPoints: function(t, e, i) {
                        for (var n = 0; n < t.size(); n++)
                            for (var r = t.get(n), o = 0; o < e.size(); o++) { var s = e.get(o); if (this.computeMinDistance(r, s, i), this.minDistance <= this.terminateDistance) return null }
                    },
                    computeFacetDistance: function() {
                        var t = new Array(2).fill(null),
                            e = zi.getLines(this.geom[0]),
                            i = zi.getLines(this.geom[1]),
                            n = mr.getPoints(this.geom[0]),
                            r = mr.getPoints(this.geom[1]);
                        return this.computeMinDistanceLines(e, i, t), this.updateMinDistance(t, !1), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, r, t), this.updateMinDistance(t, !1), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(i, n, t), this.updateMinDistance(t, !0), this.minDistance <= this.terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(n, r, t), void this.updateMinDistance(t, !1))))
                    },
                    nearestLocations: function() { return this.computeMinDistance(), this.minDistanceLocation },
                    updateMinDistance: function(t, e) { return null === t[0] ? null : void(e ? (this.minDistanceLocation[0] = t[1], this.minDistanceLocation[1] = t[0]) : (this.minDistanceLocation[0] = t[0], this.minDistanceLocation[1] = t[1])) },
                    nearestPoints: function() { this.computeMinDistance(); var t = [this.minDistanceLocation[0].getCoordinate(), this.minDistanceLocation[1].getCoordinate()]; return t },
                    computeMinDistance: function() {
                        if (0 === arguments.length) {
                            if (null !== this.minDistanceLocation) return null;
                            if (this.minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this.minDistance <= this.terminateDistance) return null;
                            this.computeFacetDistance()
                        } else if (3 === arguments.length)
                            if (arguments[2] instanceof Array && arguments[0] instanceof Nt && arguments[1] instanceof Ct) {
                                var t = arguments[0],
                                    e = arguments[1],
                                    i = arguments[2];
                                if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this.minDistance) return null;
                                for (var n = t.getCoordinates(), r = e.getCoordinate(), o = 0; o < n.length - 1; o++) {
                                    var s = ue.distancePointLine(r, n[o], n[o + 1]);
                                    if (s < this.minDistance) {
                                        this.minDistance = s;
                                        var a = new pe(n[o], n[o + 1]),
                                            h = a.closestPoint(r);
                                        i[0] = new yr(t, o, h), i[1] = new yr(e, 0, r)
                                    }
                                    if (this.minDistance <= this.terminateDistance) return null
                                }
                            } else if (arguments[2] instanceof Array && arguments[0] instanceof Nt && arguments[1] instanceof Nt) {
                            var l = arguments[0],
                                u = arguments[1],
                                p = arguments[2];
                            if (l.getEnvelopeInternal().distance(u.getEnvelopeInternal()) > this.minDistance) return null;
                            for (var n = l.getCoordinates(), c = u.getCoordinates(), o = 0; o < n.length - 1; o++)
                                for (var f = 0; f < c.length - 1; f++) {
                                    var s = ue.distanceLineLine(n[o], n[o + 1], c[f], c[f + 1]);
                                    if (s < this.minDistance) {
                                        this.minDistance = s;
                                        var g = new pe(n[o], n[o + 1]),
                                            d = new pe(c[f], c[f + 1]),
                                            y = g.closestPoints(d);
                                        p[0] = new yr(l, o, y[0]), p[1] = new yr(u, f, y[1])
                                    }
                                    if (this.minDistance <= this.terminateDistance) return null
                                }
                        }
                    },
                    computeMinDistancePoints: function(t, e, i) {
                        for (var n = 0; n < t.size(); n++)
                            for (var r = t.get(n), o = 0; o < e.size(); o++) {
                                var s = e.get(o),
                                    a = r.getCoordinate().distance(s.getCoordinate());
                                if (a < this.minDistance && (this.minDistance = a, i[0] = new yr(r, 0, r.getCoordinate()), i[1] = new yr(s, 0, s.getCoordinate())), this.minDistance <= this.terminateDistance) return null
                            }
                    },
                    distance: function() { if (null === this.geom[0] || null === this.geom[1]) throw new n("null geometries are not supported"); return this.geom[0].isEmpty() || this.geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this.minDistance) },
                    computeMinDistanceLines: function(t, e, i) {
                        for (var n = 0; n < t.size(); n++)
                            for (var r = t.get(n), o = 0; o < e.size(); o++) { var s = e.get(o); if (this.computeMinDistance(r, s, i), this.minDistance <= this.terminateDistance) return null }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return br }
                }), br.distance = function(t, e) { var i = new br(t, e); return i.distance() }, br.isWithinDistance = function(t, e, i) { var n = new br(t, e, i); return n.distance() <= i }, br.nearestPoints = function(t, e) { var i = new br(t, e); return i.nearestPoints() };
                var Ls = Object.freeze({ DistanceOp: br });
                e(wr.prototype, {
                    getCoordinates: function() {
                        if (null === this.coordinates) {
                            for (var t = 0, e = 0, i = new E, n = this.directedEdges.iterator(); n.hasNext();) {
                                var r = n.next();
                                r.getEdgeDirection() ? t++ : e++, i.add(r.getEdge().getLine().getCoordinates(), !1, r.getEdgeDirection())
                            }
                            this.coordinates = i.toCoordinateArray(), e > t && X.reverse(this.coordinates)
                        }
                        return this.coordinates
                    },
                    toLineString: function() { return this.factory.createLineString(this.getCoordinates()) },
                    add: function(t) { this.directedEdges.add(t) },
                    interfaces_: function() { return [] },
                    getClass: function() { return wr }
                }), e(xr.prototype, { setVisited: function(t) { this._isVisited = t }, isMarked: function() { return this._isMarked }, setData: function(t) { this.data = t }, getData: function() { return this.data }, setMarked: function(t) { this._isMarked = t }, getContext: function() { return this.data }, isVisited: function() { return this._isVisited }, setContext: function(t) { this.data = t }, interfaces_: function() { return [] }, getClass: function() { return xr } }), xr.getComponentWithVisitedState = function(t, e) { for (; t.hasNext();) { var i = t.next(); if (i.isVisited() === e) return i } return null }, xr.setVisited = function(t, e) {
                    for (; t.hasNext();) {
                        var i = t.next();
                        i.setVisited(e)
                    }
                }, xr.setMarked = function(t, e) {
                    for (; t.hasNext();) {
                        var i = t.next();
                        i.setMarked(e)
                    }
                }, u(Er, xr), e(Er.prototype, {
                    isRemoved: function() { return null === this.parentEdge },
                    compareDirection: function(t) { return this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : ue.computeOrientation(t.p0, t.p1, this.p1) },
                    getCoordinate: function() { return this.from.getCoordinate() },
                    print: function(t) {
                        var e = this.getClass().getName(),
                            i = e.lastIndexOf("."),
                            n = e.substring(i + 1);
                        t.print("  " + n + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + this.angle)
                    },
                    getDirectionPt: function() { return this.p1 },
                    getAngle: function() { return this.angle },
                    compareTo: function(t) { var e = t; return this.compareDirection(e) },
                    getFromNode: function() { return this.from },
                    getSym: function() { return this.sym },
                    setEdge: function(t) { this.parentEdge = t },
                    remove: function() { this.sym = null, this.parentEdge = null },
                    getEdge: function() { return this.parentEdge },
                    getQuadrant: function() { return this.quadrant },
                    setSym: function(t) { this.sym = t },
                    getToNode: function() { return this.to },
                    getEdgeDirection: function() { return this.edgeDirection },
                    interfaces_: function() { return [o] },
                    getClass: function() { return Er }
                }), Er.toEdges = function(t) { for (var e = new x, i = t.iterator(); i.hasNext();) e.add(i.next().parentEdge); return e }, u(Sr, Er), e(Sr.prototype, { getNext: function() { return 2 !== this.getToNode().getDegree() ? null : this.getToNode().getOutEdges().getEdges().get(0) === this.getSym() ? this.getToNode().getOutEdges().getEdges().get(1) : (c.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym()), this.getToNode().getOutEdges().getEdges().get(0)) }, interfaces_: function() { return [] }, getClass: function() { return Sr } }), u(Nr, xr), e(Nr.prototype, { isRemoved: function() { return null === this.dirEdge }, setDirectedEdges: function(t, e) { this.dirEdge = [t, e], t.setEdge(this), e.setEdge(this), t.setSym(e), e.setSym(t), t.getFromNode().addOutEdge(t), e.getFromNode().addOutEdge(e) }, getDirEdge: function() { if (Number.isInteger(arguments[0])) { var t = arguments[0]; return this.dirEdge[t] } if (arguments[0] instanceof Cr) { var e = arguments[0]; return this.dirEdge[0].getFromNode() === e ? this.dirEdge[0] : this.dirEdge[1].getFromNode() === e ? this.dirEdge[1] : null } }, remove: function() { this.dirEdge = null }, getOppositeNode: function(t) { return this.dirEdge[0].getFromNode() === t ? this.dirEdge[0].getToNode() : this.dirEdge[1].getFromNode() === t ? this.dirEdge[1].getToNode() : null }, interfaces_: function() { return [] }, getClass: function() { return Nr } }), e(Lr.prototype, {
                    getNextEdge: function(t) { var e = this.getIndex(t); return this.outEdges.get(this.getIndex(e + 1)) },
                    getCoordinate: function() { var t = this.iterator(); if (!t.hasNext()) return null; var e = t.next(); return e.getCoordinate() },
                    iterator: function() { return this.sortEdges(), this.outEdges.iterator() },
                    sortEdges: function() { this.sorted || (ps.sort(this.outEdges), this.sorted = !0) },
                    remove: function(t) { this.outEdges.remove(t) },
                    getEdges: function() { return this.sortEdges(), this.outEdges },
                    getNextCWEdge: function(t) { var e = this.getIndex(t); return this.outEdges.get(this.getIndex(e - 1)) },
                    getIndex: function() {
                        if (arguments[0] instanceof Nr) {
                            var t = arguments[0];
                            this.sortEdges();
                            for (var e = 0; e < this.outEdges.size(); e++) { var i = this.outEdges.get(e); if (i.getEdge() === t) return e }
                            return -1
                        }
                        if (arguments[0] instanceof Er) {
                            var n = arguments[0];
                            this.sortEdges();
                            for (var e = 0; e < this.outEdges.size(); e++) { var i = this.outEdges.get(e); if (i === n) return e }
                            return -1
                        }
                        if (Number.isInteger(arguments[0])) {
                            var r = arguments[0],
                                o = r % this.outEdges.size();
                            return 0 > o && (o += this.outEdges.size()), o
                        }
                    },
                    add: function(t) { this.outEdges.add(t), this.sorted = !1 },
                    getDegree: function() { return this.outEdges.size() },
                    interfaces_: function() { return [] },
                    getClass: function() { return Lr }
                }), u(Cr, xr), e(Cr.prototype, {
                    isRemoved: function() { return null === this.pt },
                    addOutEdge: function(t) { this.deStar.add(t) },
                    getCoordinate: function() { return this.pt },
                    getOutEdges: function() { return this.deStar },
                    remove: function() {
                        if (0 === arguments.length) this.pt = null;
                        else if (1 === arguments.length) {
                            var t = arguments[0];
                            this.deStar.remove(t)
                        }
                    },
                    getIndex: function(t) { return this.deStar.getIndex(t) },
                    getDegree: function() { return this.deStar.getDegree() },
                    interfaces_: function() { return [] },
                    getClass: function() { return Cr }
                }), Cr.getEdgesBetween = function(t, e) {
                    var i = Er.toEdges(t.getOutEdges().getEdges()),
                        n = new J(i),
                        r = Er.toEdges(e.getOutEdges().getEdges());
                    return n.retainAll(r), n
                }, u(Mr, Nr), e(Mr.prototype, { getLine: function() { return this.line }, interfaces_: function() { return [] }, getClass: function() { return Mr } }), e(Ir.prototype, { find: function(t) { return this.nodeMap.get(t) }, iterator: function() { return this.nodeMap.values().iterator() }, remove: function(t) { return this.nodeMap.remove(t) }, values: function() { return this.nodeMap.values() }, add: function(t) { return this.nodeMap.put(t.getCoordinate(), t), t }, interfaces_: function() { return [] }, getClass: function() { return Ir } }), e(kr.prototype, {
                    findNodesOfDegree: function(t) {
                        for (var e = new x, i = this.nodeIterator(); i.hasNext();) {
                            var n = i.next();
                            n.getDegree() === t && e.add(n)
                        }
                        return e
                    },
                    dirEdgeIterator: function() { return this.dirEdges.iterator() },
                    edgeIterator: function() { return this.edges.iterator() },
                    remove: function() {
                        if (arguments[0] instanceof Nr) {
                            var t = arguments[0];
                            this.remove(t.getDirEdge(0)), this.remove(t.getDirEdge(1)), this.edges.remove(t), t.remove()
                        } else if (arguments[0] instanceof Er) {
                            var e = arguments[0],
                                i = e.getSym();
                            null !== i && i.setSym(null), e.getFromNode().remove(e), e.remove(), this.dirEdges.remove(e)
                        } else if (arguments[0] instanceof Cr) {
                            for (var n = arguments[0], r = n.getOutEdges().getEdges(), o = r.iterator(); o.hasNext();) {
                                var s = o.next(),
                                    i = s.getSym();
                                null !== i && this.remove(i), this.dirEdges.remove(s);
                                var a = s.getEdge();
                                null !== a && this.edges.remove(a)
                            }
                            this.nodeMap.remove(n.getCoordinate()), n.remove()
                        }
                    },
                    findNode: function(t) { return this.nodeMap.find(t) },
                    getEdges: function() { return this.edges },
                    nodeIterator: function() { return this.nodeMap.iterator() },
                    contains: function() { if (arguments[0] instanceof Nr) { var t = arguments[0]; return this.edges.contains(t) } if (arguments[0] instanceof Er) { var e = arguments[0]; return this.dirEdges.contains(e) } },
                    add: function() {
                        if (arguments[0] instanceof Cr) {
                            var t = arguments[0];
                            this.nodeMap.add(t)
                        } else if (arguments[0] instanceof Nr) {
                            var e = arguments[0];
                            this.edges.add(e), this.add(e.getDirEdge(0)), this.add(e.getDirEdge(1))
                        } else if (arguments[0] instanceof Er) {
                            var i = arguments[0];
                            this.dirEdges.add(i)
                        }
                    },
                    getNodes: function() { return this.nodeMap.values() },
                    interfaces_: function() { return [] },
                    getClass: function() { return kr }
                }), u(Tr, kr), e(Tr.prototype, {
                    addEdge: function(t) {
                        if (t.isEmpty()) return null;
                        var e = X.removeRepeatedPoints(t.getCoordinates());
                        if (e.length <= 1) return null;
                        var i = e[0],
                            n = e[e.length - 1],
                            r = this.getNode(i),
                            o = this.getNode(n),
                            s = new Sr(r, o, e[1], !0),
                            a = new Sr(o, r, e[e.length - 2], !1),
                            h = new Mr(t);
                        h.setDirectedEdges(s, a), this.add(h)
                    },
                    getNode: function(t) { var e = this.findNode(t); return null === e && (e = new Cr(t), this.add(e)), e },
                    interfaces_: function() { return [] },
                    getClass: function() { return Tr }
                }), e(Ar.prototype, {
                    buildEdgeStringsForUnprocessedNodes: function() {
                        for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
                            var e = t.next();
                            e.isMarked() || (c.isTrue(2 === e.getDegree()), this.buildEdgeStringsStartingAt(e), e.setMarked(!0))
                        }
                    },
                    buildEdgeStringsForNonDegree2Nodes: function() {
                        for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
                            var e = t.next();
                            2 !== e.getDegree() && (this.buildEdgeStringsStartingAt(e), e.setMarked(!0))
                        }
                    },
                    buildEdgeStringsForObviousStartNodes: function() { this.buildEdgeStringsForNonDegree2Nodes() },
                    getMergedLineStrings: function() { return this.merge(), this.mergedLineStrings },
                    buildEdgeStringsStartingAt: function(t) {
                        for (var e = t.getOutEdges().iterator(); e.hasNext();) {
                            var i = e.next();
                            i.getEdge().isMarked() || this.edgeStrings.add(this.buildEdgeStringStartingWith(i))
                        }
                    },
                    merge: function() {
                        if (null !== this.mergedLineStrings) return null;
                        xr.setMarked(this.graph.nodeIterator(), !1), xr.setMarked(this.graph.edgeIterator(), !1), this.edgeStrings = new x, this.buildEdgeStringsForObviousStartNodes(), this.buildEdgeStringsForIsolatedLoops(), this.mergedLineStrings = new x;
                        for (var t = this.edgeStrings.iterator(); t.hasNext();) {
                            var e = t.next();
                            this.mergedLineStrings.add(e.toLineString())
                        }
                    },
                    buildEdgeStringStartingWith: function(t) {
                        var e = new wr(this.factory),
                            i = t;
                        do e.add(i), i.getEdge().setMarked(!0), i = i.getNext(); while (null !== i && i !== t);
                        return e
                    },
                    add: function() {
                        if (arguments[0] instanceof B) {
                            var t = arguments[0];
                            t.apply({ interfaces_: function() { return [U] }, filter: function(t) { t instanceof Nt && this.add(t) } })
                        } else if (M(arguments[0], y)) {
                            var e = arguments[0];
                            this.mergedLineStrings = null;
                            for (var i = e.iterator(); i.hasNext();) {
                                var n = i.next();
                                this.add(n)
                            }
                        } else if (arguments[0] instanceof Nt) {
                            var r = arguments[0];
                            null === this.factory && (this.factory = r.getFactory()), this.graph.addEdge(r)
                        }
                    },
                    buildEdgeStringsForIsolatedLoops: function() { this.buildEdgeStringsForUnprocessedNodes() },
                    interfaces_: function() { return [] },
                    getClass: function() { return Ar }
                });
                var Cs = Object.freeze({ LineMerger: Ar }),
                    Ms = Object.freeze({ OverlayOp: nn });
                u(Rr, Er), e(Rr.prototype, { getNext: function() { return this.next }, isInRing: function() { return null !== this.edgeRing }, setRing: function(t) { this.edgeRing = t }, setLabel: function(t) { this.label = t }, getLabel: function() { return this.label }, setNext: function(t) { this.next = t }, getRing: function() { return this.edgeRing }, interfaces_: function() { return [] }, getClass: function() { return Rr } }), u(_r, Nr), e(_r.prototype, { getLine: function() { return this.line }, interfaces_: function() { return [] }, getClass: function() { return _r } }), e(Pr.prototype, {
                    isIncluded: function() { return this._isIncluded },
                    getCoordinates: function() {
                        if (null === this.ringPts) {
                            for (var t = new E, e = this.deList.iterator(); e.hasNext();) {
                                var i = e.next(),
                                    n = i.getEdge();
                                Pr.addEdge(n.getLine().getCoordinates(), i.getEdgeDirection(), t)
                            }
                            this.ringPts = t.toCoordinateArray()
                        }
                        return this.ringPts
                    },
                    isIncludedSet: function() { return this._isIncludedSet },
                    isValid: function() { return this.getCoordinates(), !(this.ringPts.length <= 3) && (this.getRing(), this.ring.isValid()) },
                    build: function(t) {
                        var e = t;
                        do this.add(e), e.setRing(this), e = e.getNext(), c.isTrue(null !== e, "found null DE in ring"), c.isTrue(e === t || !e.isInRing(), "found DE already in ring"); while (e !== t)
                    },
                    isOuterHole: function() { return !!this._isHole && !this.hasShell() },
                    getPolygon: function() { var t = null; if (null !== this.holes) { t = new Array(this.holes.size()).fill(null); for (var e = 0; e < this.holes.size(); e++) t[e] = this.holes.get(e) } var i = this.factory.createPolygon(this.ring, t); return i },
                    isHole: function() { return this._isHole },
                    isProcessed: function() { return this._isProcessed },
                    addHole: function() {
                        if (arguments[0] instanceof Tt) {
                            var t = arguments[0];
                            null === this.holes && (this.holes = new x), this.holes.add(t)
                        } else if (arguments[0] instanceof Pr) {
                            var e = arguments[0];
                            e.setShell(this);
                            var i = e.getRing();
                            null === this.holes && (this.holes = new x), this.holes.add(i)
                        }
                    },
                    setIncluded: function(t) { this._isIncluded = t, this._isIncludedSet = !0 },
                    getOuterHole: function() {
                        if (this.isHole()) return null;
                        for (var t = 0; t < this.deList.size(); t++) {
                            var e = this.deList.get(t),
                                i = e.getSym().getRing();
                            if (i.isOuterHole()) return i
                        }
                        return null
                    },
                    computeHole: function() {
                        var t = this.getRing();
                        this._isHole = ue.isCCW(t.getCoordinates())
                    },
                    hasShell: function() { return null !== this.shell },
                    isOuterShell: function() { return null !== this.getOuterHole() },
                    getLineString: function() { return this.getCoordinates(), this.factory.createLineString(this.ringPts) },
                    toString: function() { return oe.toLineString(new Ft(this.getCoordinates())) },
                    getShell: function() { return this.isHole() ? this.shell : this },
                    add: function(t) { this.deList.add(t) },
                    getRing: function() {
                        if (null !== this.ring) return this.ring;
                        this.getCoordinates(), this.ringPts.length < 3 && O.out.println(this.ringPts);
                        try { this.ring = this.factory.createLinearRing(this.ringPts) } catch (t) {
                            if (!(t instanceof N)) throw t;
                            O.out.println(this.ringPts)
                        } finally {}
                        return this.ring
                    },
                    updateIncluded: function() {
                        if (this.isHole()) return null;
                        for (var t = 0; t < this.deList.size(); t++) {
                            var e = this.deList.get(t),
                                i = e.getSym().getRing().getShell();
                            if (null !== i && i.isIncludedSet()) return this.setIncluded(!i.isIncluded()), null
                        }
                    },
                    setShell: function(t) { this.shell = t },
                    setProcessed: function(t) { this._isProcessed = t },
                    interfaces_: function() { return [] },
                    getClass: function() { return Pr }
                }), Pr.findDirEdgesInRing = function(t) {
                    var e = t,
                        i = new x;
                    do i.add(e), e = e.getNext(), c.isTrue(null !== e, "found null DE in ring"), c.isTrue(e === t || !e.isInRing(), "found DE already in ring"); while (e !== t);
                    return i
                }, Pr.addEdge = function(t, e, i) {
                    if (e)
                        for (var n = 0; n < t.length; n++) i.add(t[n], !1);
                    else
                        for (var n = t.length - 1; n >= 0; n--) i.add(t[n], !1)
                }, Pr.findEdgeRingContaining = function(t, e) {
                    for (var i = t.getRing(), n = i.getEnvelopeInternal(), r = i.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext();) {
                        var h = a.next(),
                            l = h.getRing(),
                            u = l.getEnvelopeInternal();
                        if (!u.equals(n) && u.contains(n)) {
                            r = X.ptNotInList(i.getCoordinates(), l.getCoordinates());
                            var p = !1;
                            ue.isPointInRing(r, l.getCoordinates()) && (p = !0), p && (null === o || s.contains(u)) && (o = h, s = o.getRing().getEnvelopeInternal())
                        }
                    }
                    return o
                }, e(Or.prototype, {
                    compare: function(t, e) {
                        var i = t,
                            n = e;
                        return i.getRing().getEnvelope().compareTo(n.getRing().getEnvelope())
                    },
                    interfaces_: function() { return [a] },
                    getClass: function() { return Or }
                }), Pr.EnvelopeComparator = Or, u(Dr, kr), e(Dr.prototype, {
                    findEdgeRing: function(t) { var e = new Pr(this.factory); return e.build(t), e },
                    computeDepthParity: function() {
                        if (0 === arguments.length)
                            for (;;) {
                                var t = null;
                                if (null === t) return null;
                                this.computeDepthParity(t)
                            } else 1 === arguments.length && arguments[0]
                    },
                    computeNextCWEdges: function() {
                        for (var t = this.nodeIterator(); t.hasNext();) {
                            var e = t.next();
                            Dr.computeNextCWEdges(e)
                        }
                    },
                    addEdge: function(t) {
                        if (t.isEmpty()) return null;
                        var e = X.removeRepeatedPoints(t.getCoordinates());
                        if (e.length < 2) return null;
                        var i = e[0],
                            n = e[e.length - 1],
                            r = this.getNode(i),
                            o = this.getNode(n),
                            s = new Rr(r, o, e[1], !0),
                            a = new Rr(o, r, e[e.length - 2], !1),
                            h = new _r(t);
                        h.setDirectedEdges(s, a), this.add(h)
                    },
                    deleteCutEdges: function() {
                        this.computeNextCWEdges(), Dr.findLabeledEdgeRings(this.dirEdges);
                        for (var t = new x, e = this.dirEdges.iterator(); e.hasNext();) {
                            var i = e.next();
                            if (!i.isMarked()) {
                                var n = i.getSym();
                                if (i.getLabel() === n.getLabel()) {
                                    i.setMarked(!0), n.setMarked(!0);
                                    var r = i.getEdge();
                                    t.add(r.getLine())
                                }
                            }
                        }
                        return t
                    },
                    getEdgeRings: function() {
                        this.computeNextCWEdges(), Dr.label(this.dirEdges, -1);
                        var t = Dr.findLabeledEdgeRings(this.dirEdges);
                        this.convertMaximalToMinimalEdgeRings(t);
                        for (var e = new x, i = this.dirEdges.iterator(); i.hasNext();) {
                            var n = i.next();
                            if (!n.isMarked() && !n.isInRing()) {
                                var r = this.findEdgeRing(n);
                                e.add(r)
                            }
                        }
                        return e
                    },
                    getNode: function(t) { var e = this.findNode(t); return null === e && (e = new Cr(t), this.add(e)), e },
                    convertMaximalToMinimalEdgeRings: function(t) {
                        for (var e = t.iterator(); e.hasNext();) {
                            var i = e.next(),
                                n = i.getLabel(),
                                r = Dr.findIntersectionNodes(i, n);
                            if (null !== r)
                                for (var o = r.iterator(); o.hasNext();) {
                                    var s = o.next();
                                    Dr.computeNextCCWEdges(s, n)
                                }
                        }
                    },
                    deleteDangles: function() {
                        for (var t = this.findNodesOfDegree(1), e = new J, i = new de, n = t.iterator(); n.hasNext();) i.push(n.next());
                        for (; !i.isEmpty();) {
                            var r = i.pop();
                            Dr.deleteAllEdges(r);
                            for (var o = r.getOutEdges().getEdges(), n = o.iterator(); n.hasNext();) {
                                var s = n.next();
                                s.setMarked(!0);
                                var a = s.getSym();
                                null !== a && a.setMarked(!0);
                                var h = s.getEdge();
                                e.add(h.getLine());
                                var l = s.getToNode();
                                1 === Dr.getDegreeNonDeleted(l) && i.push(l)
                            }
                        }
                        return e
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Dr }
                }), Dr.findLabeledEdgeRings = function(t) {
                    for (var e = new x, i = 1, n = t.iterator(); n.hasNext();) {
                        var r = n.next();
                        if (!(r.isMarked() || r.getLabel() >= 0)) {
                            e.add(r);
                            var o = Pr.findDirEdgesInRing(r);
                            Dr.label(o, i), i++
                        }
                    }
                    return e
                }, Dr.getDegreeNonDeleted = function(t) {
                    for (var e = t.getOutEdges().getEdges(), i = 0, n = e.iterator(); n.hasNext();) {
                        var r = n.next();
                        r.isMarked() || i++
                    }
                    return i
                }, Dr.deleteAllEdges = function(t) {
                    for (var e = t.getOutEdges().getEdges(), i = e.iterator(); i.hasNext();) {
                        var n = i.next();
                        n.setMarked(!0);
                        var r = n.getSym();
                        null !== r && r.setMarked(!0)
                    }
                }, Dr.label = function(t, e) {
                    for (var i = t.iterator(); i.hasNext();) {
                        var n = i.next();
                        n.setLabel(e)
                    }
                }, Dr.computeNextCWEdges = function(t) {
                    for (var e = t.getOutEdges(), i = null, n = null, r = e.getEdges().iterator(); r.hasNext();) {
                        var o = r.next();
                        if (!o.isMarked()) {
                            if (null === i && (i = o), null !== n) {
                                var s = n.getSym();
                                s.setNext(o)
                            }
                            n = o
                        }
                    }
                    if (null !== n) {
                        var s = n.getSym();
                        s.setNext(i)
                    }
                }, Dr.computeNextCCWEdges = function(t, e) {
                    for (var i = t.getOutEdges(), n = null, r = null, o = i.getEdges(), s = o.size() - 1; s >= 0; s--) {
                        var a = o.get(s),
                            h = a.getSym(),
                            l = null;
                        a.getLabel() === e && (l = a);
                        var u = null;
                        h.getLabel() === e && (u = h), null === l && null === u || (null !== u && (r = u), null !== l && (null !== r && (r.setNext(l), r = null), null === n && (n = l)))
                    }
                    null !== r && (c.isTrue(null !== n), r.setNext(n))
                }, Dr.getDegree = function(t, e) {
                    for (var i = t.getOutEdges().getEdges(), n = 0, r = i.iterator(); r.hasNext();) {
                        var o = r.next();
                        o.getLabel() === e && n++
                    }
                    return n
                }, Dr.findIntersectionNodes = function(t, e) {
                    var i = t,
                        n = null;
                    do {
                        var r = i.getFromNode();
                        Dr.getDegree(r, e) > 1 && (null === n && (n = new x), n.add(r)), i = i.getNext(), c.isTrue(null !== i, "found null DE in ring"), c.isTrue(i === t || !i.isInRing(), "found DE already in ring")
                    } while (i !== t);
                    return n
                }, e(Fr.prototype, {
                    getGeometry: function() { return null === this.geomFactory && (this.geomFactory = new ne), this.polygonize(), this.extractOnlyPolygonal ? this.geomFactory.buildGeometry(this.polyList) : this.geomFactory.createGeometryCollection(ne.toGeometryArray(this.polyList)) },
                    getInvalidRingLines: function() { return this.polygonize(), this.invalidRingLines },
                    findValidRings: function(t, e, i) {
                        for (var n = t.iterator(); n.hasNext();) {
                            var r = n.next();
                            r.isValid() ? e.add(r) : i.add(r.getLineString())
                        }
                    },
                    polygonize: function() {
                        if (null !== this.polyList) return null;
                        if (this.polyList = new x, null === this.graph) return null;
                        this.dangles = this.graph.deleteDangles(), this.cutEdges = this.graph.deleteCutEdges();
                        var t = this.graph.getEdgeRings(),
                            e = new x;
                        this.invalidRingLines = new x, this.isCheckingRingsValid ? this.findValidRings(t, e, this.invalidRingLines) : e = t, this.findShellsAndHoles(e), Fr.assignHolesToShells(this.holeList, this.shellList), ps.sort(this.shellList, new Pr.EnvelopeComparator);
                        var i = !0;
                        this.extractOnlyPolygonal && (Fr.findDisjointShells(this.shellList), i = !1), this.polyList = Fr.extractPolygons(this.shellList, i)
                    },
                    getDangles: function() { return this.polygonize(), this.dangles },
                    getCutEdges: function() { return this.polygonize(), this.cutEdges },
                    getPolygons: function() { return this.polygonize(), this.polyList },
                    add: function() {
                        if (M(arguments[0], y))
                            for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
                                var i = e.next();
                                this.add(i)
                            } else if (arguments[0] instanceof Nt) {
                                var n = arguments[0];
                                this.geomFactory = n.getFactory(), null === this.graph && (this.graph = new Dr(this.geomFactory)), this.graph.addEdge(n)
                            } else if (arguments[0] instanceof B) {
                            var r = arguments[0];
                            r.apply(this.lineStringAdder)
                        }
                    },
                    setCheckRingsValid: function(t) { this.isCheckingRingsValid = t },
                    findShellsAndHoles: function(t) {
                        this.holeList = new x, this.shellList = new x;
                        for (var e = t.iterator(); e.hasNext();) {
                            var i = e.next();
                            i.computeHole(), i.isHole() ? this.holeList.add(i) : this.shellList.add(i)
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Fr }
                }), Fr.findOuterShells = function(t) {
                    for (var e = t.iterator(); e.hasNext();) {
                        var i = e.next(),
                            n = i.getOuterHole();
                        null === n || n.isProcessed() || (i.setIncluded(!0), n.setProcessed(!0))
                    }
                }, Fr.extractPolygons = function(t, e) {
                    for (var i = new x, n = t.iterator(); n.hasNext();) {
                        var r = n.next();
                        (e || r.isIncluded()) && i.add(r.getPolygon())
                    }
                    return i
                }, Fr.assignHolesToShells = function(t, e) {
                    for (var i = t.iterator(); i.hasNext();) {
                        var n = i.next();
                        Fr.assignHoleToShell(n, e)
                    }
                }, Fr.assignHoleToShell = function(t, e) {
                    var i = Pr.findEdgeRingContaining(t, e);
                    null !== i && i.addHole(t)
                }, Fr.findDisjointShells = function(t) {
                    Fr.findOuterShells(t);
                    var e = null;
                    do {
                        e = !1;
                        for (var i = t.iterator(); i.hasNext();) {
                            var n = i.next();
                            n.isIncludedSet() || (n.updateIncluded(), n.isIncludedSet() || (e = !0))
                        }
                    } while (e)
                }, e(Ur.prototype, { filter: function(t) { t instanceof Nt && this.p.add(t) }, interfaces_: function() { return [U] }, getClass: function() { return Ur } }), Fr.LineStringAdder = Ur;
                var Is = Object.freeze({ Polygonizer: Fr });
                e(Br.prototype, {
                    createEdgeEndForNext: function(t, e, i, n) {
                        var r = i.segmentIndex + 1;
                        if (r >= t.getNumPoints() && null === n) return null;
                        var o = t.getCoordinate(r);
                        null !== n && n.segmentIndex === i.segmentIndex && (o = n.coord);
                        var s = new bi(t, i.coord, o, new ci(t.getLabel()));
                        e.add(s)
                    },
                    createEdgeEndForPrev: function(t, e, i, n) {
                        var r = i.segmentIndex;
                        if (0 === i.dist) {
                            if (0 === r) return null;
                            r--
                        }
                        var o = t.getCoordinate(r);
                        null !== n && n.segmentIndex >= r && (o = n.coord);
                        var s = new ci(t.getLabel());
                        s.flip();
                        var a = new bi(t, i.coord, o, s);
                        e.add(a)
                    },
                    computeEdgeEnds: function() {
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = new x, i = t; i.hasNext();) {
                                var n = i.next();
                                this.computeEdgeEnds(n, e)
                            }
                            return e
                        }
                        if (2 === arguments.length) {
                            var r = arguments[0],
                                o = arguments[1],
                                s = r.getEdgeIntersectionList();
                            s.addEndpoints();
                            var a = s.iterator(),
                                h = null,
                                l = null;
                            if (!a.hasNext()) return null;
                            var u = a.next();
                            do h = l, l = u, u = null, a.hasNext() && (u = a.next()), null !== l && (this.createEdgeEndForPrev(r, o, l, h), this.createEdgeEndForNext(r, o, l, u)); while (null !== l)
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Br }
                }), u(jr, bi), e(jr.prototype, {
                    insert: function(t) { this.edgeEnds.add(t) },
                    print: function(t) {
                        t.println("EdgeEndBundle--> Label: " + this.label);
                        for (var e = this.iterator(); e.hasNext();) {
                            var i = e.next();
                            i.print(t), t.println()
                        }
                    },
                    iterator: function() { return this.edgeEnds.iterator() },
                    getEdgeEnds: function() { return this.edgeEnds },
                    computeLabelOn: function(t, e) {
                        for (var i = 0, n = !1, r = this.iterator(); r.hasNext();) {
                            var o = r.next(),
                                s = o.getLabel().getLocation(t);
                            s === C.BOUNDARY && i++, s === C.INTERIOR && (n = !0)
                        }
                        var s = C.NONE;
                        n && (s = C.INTERIOR), i > 0 && (s = Ji.determineBoundary(e, i)), this.label.setLocation(t, s)
                    },
                    computeLabelSide: function(t, e) {
                        for (var i = this.iterator(); i.hasNext();) {
                            var n = i.next();
                            if (n.getLabel().isArea()) {
                                var r = n.getLabel().getLocation(t, e);
                                if (r === C.INTERIOR) return this.label.setLocation(t, e, C.INTERIOR), null;
                                r === C.EXTERIOR && this.label.setLocation(t, e, C.EXTERIOR)
                            }
                        }
                    },
                    getLabel: function() { return this.label },
                    computeLabelSides: function(t) { this.computeLabelSide(t, ui.LEFT), this.computeLabelSide(t, ui.RIGHT) },
                    updateIM: function(t) { Zi.updateIM(this.label, t) },
                    computeLabel: function(t) {
                        for (var e = !1, i = this.iterator(); i.hasNext();) {
                            var n = i.next();
                            n.getLabel().isArea() && (e = !0)
                        }
                        e ? this.label = new ci(C.NONE, C.NONE, C.NONE) : this.label = new ci(C.NONE);
                        for (var r = 0; 2 > r; r++) this.computeLabelOn(r, t), e && this.computeLabelSides(r)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return jr }
                }), u(zr, Ii), e(zr.prototype, {
                    updateIM: function(t) {
                        for (var e = this.iterator(); e.hasNext();) {
                            var i = e.next();
                            i.updateIM(t)
                        }
                    },
                    insert: function(t) {
                        var e = this.edgeMap.get(t);
                        null === e ? (e = new jr(t), this.insertEdgeEnd(t, e)) : e.insert(t)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return zr }
                }), u(Gr, mi), e(Gr.prototype, { updateIMFromEdges: function(t) { this.edges.updateIM(t) }, computeIM: function(t) { t.setAtLeastIfValid(this.label.getLocation(0), this.label.getLocation(1), 0) }, interfaces_: function() { return [] }, getClass: function() { return Gr } }), u(qr, xi), e(qr.prototype, { createNode: function(t) { return new Gr(t, new zr) }, interfaces_: function() { return [] }, getClass: function() { return qr } }), e(Vr.prototype, {
                    insertEdgeEnds: function(t) {
                        for (var e = t.iterator(); e.hasNext();) {
                            var i = e.next();
                            this.nodes.add(i)
                        }
                    },
                    computeProperIntersectionIM: function(t, e) {
                        var i = this.arg[0].getGeometry().getDimension(),
                            n = this.arg[1].getGeometry().getDimension(),
                            r = t.hasProperIntersection(),
                            o = t.hasProperInteriorIntersection();
                        2 === i && 2 === n ? r && e.setAtLeast("212101212") : 2 === i && 1 === n ? (r && e.setAtLeast("FFF0FFFF2"), o && e.setAtLeast("1FFFFF1FF")) : 1 === i && 2 === n ? (r && e.setAtLeast("F0FFFFFF2"), o && e.setAtLeast("1F1FFFFFF")) : 1 === i && 1 === n && o && e.setAtLeast("0FFFFFFFF")
                    },
                    labelIsolatedEdges: function(t, e) {
                        for (var i = this.arg[t].getEdgeIterator(); i.hasNext();) {
                            var n = i.next();
                            n.isIsolated() && (this.labelIsolatedEdge(n, e, this.arg[e].getGeometry()), this.isolatedEdges.add(n))
                        }
                    },
                    labelIsolatedEdge: function(t, e, i) {
                        if (i.getDimension() > 0) {
                            var n = this.ptLocator.locate(t.getCoordinate(), i);
                            t.getLabel().setAllLocations(e, n)
                        } else t.getLabel().setAllLocations(e, C.EXTERIOR)
                    },
                    computeIM: function() {
                        var t = new ce;
                        if (t.set(C.EXTERIOR, C.EXTERIOR, 2), !this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal())) return this.computeDisjointIM(t), t;
                        this.arg[0].computeSelfNodes(this.li, !1), this.arg[1].computeSelfNodes(this.li, !1);
                        var e = this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !1);
                        this.computeIntersectionNodes(0), this.computeIntersectionNodes(1), this.copyNodesAndLabels(0), this.copyNodesAndLabels(1), this.labelIsolatedNodes(), this.computeProperIntersectionIM(e, t);
                        var i = new Br,
                            n = i.computeEdgeEnds(this.arg[0].getEdgeIterator());
                        this.insertEdgeEnds(n);
                        var r = i.computeEdgeEnds(this.arg[1].getEdgeIterator());
                        return this.insertEdgeEnds(r), this.labelNodeEdges(), this.labelIsolatedEdges(0, 1), this.labelIsolatedEdges(1, 0), this.updateIM(t), t
                    },
                    labelNodeEdges: function() {
                        for (var t = this.nodes.iterator(); t.hasNext();) {
                            var e = t.next();
                            e.getEdges().computeLabelling(this.arg)
                        }
                    },
                    copyNodesAndLabels: function(t) {
                        for (var e = this.arg[t].getNodeIterator(); e.hasNext();) {
                            var i = e.next(),
                                n = this.nodes.addNode(i.getCoordinate());
                            n.setLabel(t, i.getLabel().getLocation(t))
                        }
                    },
                    labelIntersectionNodes: function(t) {
                        for (var e = this.arg[t].getEdgeIterator(); e.hasNext();)
                            for (var i = e.next(), n = i.getLabel().getLocation(t), r = i.getEdgeIntersectionList().iterator(); r.hasNext();) {
                                var o = r.next(),
                                    s = this.nodes.find(o.coord);
                                s.getLabel().isNull(t) && (n === C.BOUNDARY ? s.setLabelBoundary(t) : s.setLabel(t, C.INTERIOR))
                            }
                    },
                    labelIsolatedNode: function(t, e) {
                        var i = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());
                        t.getLabel().setAllLocations(e, i)
                    },
                    computeIntersectionNodes: function(t) {
                        for (var e = this.arg[t].getEdgeIterator(); e.hasNext();)
                            for (var i = e.next(), n = i.getLabel().getLocation(t), r = i.getEdgeIntersectionList().iterator(); r.hasNext();) {
                                var o = r.next(),
                                    s = this.nodes.addNode(o.coord);
                                n === C.BOUNDARY ? s.setLabelBoundary(t) : s.getLabel().isNull(t) && s.setLabel(t, C.INTERIOR)
                            }
                    },
                    labelIsolatedNodes: function() {
                        for (var t = this.nodes.iterator(); t.hasNext();) {
                            var e = t.next(),
                                i = e.getLabel();
                            c.isTrue(i.getGeometryCount() > 0, "node with empty label found"), e.isIsolated() && (i.isNull(0) ? this.labelIsolatedNode(e, 0) : this.labelIsolatedNode(e, 1))
                        }
                    },
                    updateIM: function(t) {
                        for (var e = this.isolatedEdges.iterator(); e.hasNext();) {
                            var i = e.next();
                            i.updateIM(t)
                        }
                        for (var n = this.nodes.iterator(); n.hasNext();) {
                            var r = n.next();
                            r.updateIM(t), r.updateIMFromEdges(t)
                        }
                    },
                    computeDisjointIM: function(t) {
                        var e = this.arg[0].getGeometry();
                        e.isEmpty() || (t.set(C.INTERIOR, C.EXTERIOR, e.getDimension()), t.set(C.BOUNDARY, C.EXTERIOR, e.getBoundaryDimension()));
                        var i = this.arg[1].getGeometry();
                        i.isEmpty() || (t.set(C.EXTERIOR, C.INTERIOR, i.getDimension()), t.set(C.EXTERIOR, C.BOUNDARY, i.getBoundaryDimension()))
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Vr }
                }), e(Wr.prototype, {
                    isContainedInBoundary: function(t) { if (t instanceof It) return !1; if (t instanceof Ct) return this.isPointContainedInBoundary(t); if (t instanceof Nt) return this.isLineStringContainedInBoundary(t); for (var e = 0; e < t.getNumGeometries(); e++) { var i = t.getGeometryN(e); if (!this.isContainedInBoundary(i)) return !1 } return !0 },
                    isLineSegmentContainedInBoundary: function(t, e) { if (t.equals(e)) return this.isPointContainedInBoundary(t); if (t.x === e.x) { if (t.x === this.rectEnv.getMinX() || t.x === this.rectEnv.getMaxX()) return !0 } else if (t.y === e.y && (t.y === this.rectEnv.getMinY() || t.y === this.rectEnv.getMaxY())) return !0; return !1 },
                    isLineStringContainedInBoundary: function(t) {
                        for (var e = t.getCoordinateSequence(), i = new f, n = new f, r = 0; r < e.size() - 1; r++)
                            if (e.getCoordinate(r, i), e.getCoordinate(r + 1, n), !this.isLineSegmentContainedInBoundary(i, n)) return !1;
                        return !0
                    },
                    isPointContainedInBoundary: function() { if (arguments[0] instanceof Ct) { var t = arguments[0]; return this.isPointContainedInBoundary(t.getCoordinate()) } if (arguments[0] instanceof f) { var e = arguments[0]; return e.x === this.rectEnv.getMinX() || e.x === this.rectEnv.getMaxX() || e.y === this.rectEnv.getMinY() || e.y === this.rectEnv.getMaxY() } },
                    contains: function(t) { return !!this.rectEnv.contains(t.getEnvelopeInternal()) && !this.isContainedInBoundary(t) },
                    interfaces_: function() { return [] },
                    getClass: function() { return Wr }
                }), Wr.contains = function(t, e) { var i = new Wr(t); return i.contains(e) }, e(Xr.prototype, {
                    intersects: function(t, e) {
                        var i = new S(t, e);
                        if (!this.rectEnv.intersects(i)) return !1;
                        if (this.rectEnv.intersects(t)) return !0;
                        if (this.rectEnv.intersects(e)) return !0;
                        if (t.compareTo(e) > 0) {
                            var n = t;
                            t = e, e = n
                        }
                        var r = !1;
                        return e.y > t.y && (r = !0), r ? this.li.computeIntersection(t, e, this.diagDown0, this.diagDown1) : this.li.computeIntersection(t, e, this.diagUp0, this.diagUp1), !!this.li.hasIntersection()
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Xr }
                }), e(Hr.prototype, {
                    applyTo: function(t) {
                        for (var e = 0; e < t.getNumGeometries() && !this._isDone; e++) {
                            var i = t.getGeometryN(e);
                            if (i instanceof ct) this.applyTo(i);
                            else if (this.visit(i), this.isDone()) return this._isDone = !0, null
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Hr }
                }), e(Yr.prototype, { intersects: function(t) { if (!this.rectEnv.intersects(t.getEnvelopeInternal())) return !1; var e = new Kr(this.rectEnv); if (e.applyTo(t), e.intersects()) return !0; var i = new $r(this.rectangle); if (i.applyTo(t), i.containsPoint()) return !0; var n = new Zr(this.rectangle); return n.applyTo(t), !!n.intersects() }, interfaces_: function() { return [] }, getClass: function() { return Yr } }), Yr.intersects = function(t, e) { var i = new Yr(t); return i.intersects(e) }, u(Kr, Hr), e(Kr.prototype, { isDone: function() { return this._intersects === !0 }, visit: function(t) { var e = t.getEnvelopeInternal(); return this.rectEnv.intersects(e) ? this.rectEnv.contains(e) ? (this._intersects = !0, null) : e.getMinX() >= this.rectEnv.getMinX() && e.getMaxX() <= this.rectEnv.getMaxX() ? (this._intersects = !0, null) : e.getMinY() >= this.rectEnv.getMinY() && e.getMaxY() <= this.rectEnv.getMaxY() ? (this._intersects = !0, null) : void 0 : null }, intersects: function() { return this._intersects }, interfaces_: function() { return [] }, getClass: function() { return Kr } }), u($r, Hr), e($r.prototype, {
                    isDone: function() { return this._containsPoint === !0 },
                    visit: function(t) {
                        if (!(t instanceof It)) return null;
                        var e = t.getEnvelopeInternal();
                        if (!this.rectEnv.intersects(e)) return null;
                        for (var i = new f, n = 0; 4 > n; n++)
                            if (this.rectSeq.getCoordinate(n, i), e.contains(i) && Mi.containsPointInPolygon(i, t)) return this._containsPoint = !0, null
                    },
                    containsPoint: function() { return this._containsPoint },
                    interfaces_: function() { return [] },
                    getClass: function() { return $r }
                }), u(Zr, Hr), e(Zr.prototype, {
                    intersects: function() { return this.hasIntersection },
                    isDone: function() { return this.hasIntersection === !0 },
                    visit: function(t) {
                        var e = t.getEnvelopeInternal();
                        if (!this.rectEnv.intersects(e)) return null;
                        var i = zi.getLines(t);
                        this.checkIntersectionWithLineStrings(i)
                    },
                    checkIntersectionWithLineStrings: function(t) { for (var e = t.iterator(); e.hasNext();) { var i = e.next(); if (this.checkIntersectionWithSegments(i), this.hasIntersection) return null } },
                    checkIntersectionWithSegments: function(t) {
                        for (var e = t.getCoordinateSequence(), i = 1; i < e.size(); i++)
                            if (e.getCoordinate(i - 1, this.p0), e.getCoordinate(i, this.p1), this.rectIntersector.intersects(this.p0, this.p1)) return this.hasIntersection = !0, null
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Zr }
                }), u(Jr, Qi), e(Jr.prototype, { getIntersectionMatrix: function() { return this._relate.computeIM() }, interfaces_: function() { return [] }, getClass: function() { return Jr } }), Jr.covers = function(t, e) { return !!t.getEnvelopeInternal().covers(e.getEnvelopeInternal()) && (!!t.isRectangle() || Jr.relate(t, e).isCovers()) }, Jr.intersects = function(t, e) { return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && (t.isRectangle() ? Yr.intersects(t, e) : e.isRectangle() ? Yr.intersects(e, t) : Jr.relate(t, e).isIntersects()) }, Jr.touches = function(t, e) { return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && Jr.relate(t, e).isTouches(t.getDimension(), e.getDimension()) }, Jr.within = function(t, e) { return e.contains(t) }, Jr.coveredBy = function(t, e) { return Jr.covers(e, t) }, Jr.relate = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            i = new Jr(t, e),
                            n = i.getIntersectionMatrix();
                        return n
                    }
                    if (3 === arguments.length) {
                        if ("string" == typeof arguments[2] && arguments[0] instanceof B && arguments[1] instanceof B) {
                            var r = arguments[0],
                                o = arguments[1],
                                s = arguments[2];
                            return Jr.relateWithCheck(r, o).matches(s)
                        }
                        if (M(arguments[2], z) && arguments[0] instanceof B && arguments[1] instanceof B) {
                            var a = arguments[0],
                                h = arguments[1],
                                l = arguments[2],
                                i = new Jr(a, h, l),
                                n = i.getIntersectionMatrix();
                            return n
                        }
                    }
                }, Jr.overlaps = function(t, e) { return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && Jr.relate(t, e).isOverlaps(t.getDimension(), e.getDimension()) }, Jr.disjoint = function(t, e) { return !t.intersects(e) }, Jr.relateWithCheck = function(t, e) { return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), Jr.relate(t, e) }, Jr.crosses = function(t, e) { return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && Jr.relate(t, e).isCrosses(t.getDimension(), e.getDimension()) }, Jr.contains = function(t, e) { return !!t.getEnvelopeInternal().contains(e.getEnvelopeInternal()) && (t.isRectangle() ? Wr.contains(t, e) : Jr.relate(t, e).isContains()) };
                var ks = Object.freeze({ RelateOp: Jr });
                e(Qr.prototype, {
                    extractElements: function(t, e) {
                        if (null === t) return null;
                        for (var i = 0; i < t.getNumGeometries(); i++) {
                            var n = t.getGeometryN(i);
                            this.skipEmpty && n.isEmpty() || e.add(n)
                        }
                    },
                    combine: function() {
                        for (var t = new x, e = this.inputGeoms.iterator(); e.hasNext();) {
                            var i = e.next();
                            this.extractElements(i, t)
                        }
                        return 0 === t.size() ? null !== this.geomFactory ? this.geomFactory.createGeometryCollection(null) : null : this.geomFactory.buildGeometry(t)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Qr }
                }), Qr.combine = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = new Qr(t);
                        return e.combine()
                    }
                    if (2 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            e = new Qr(Qr.createList(i, n));
                        return e.combine()
                    }
                    if (3 === arguments.length) {
                        var r = arguments[0],
                            o = arguments[1],
                            s = arguments[2],
                            e = new Qr(Qr.createList(r, o, s));
                        return e.combine()
                    }
                }, Qr.extractFactory = function(t) { return t.isEmpty() ? null : t.iterator().next().getFactory() }, Qr.createList = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            i = new x;
                        return i.add(t), i.add(e), i
                    }
                    if (3 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1],
                            o = arguments[2],
                            i = new x;
                        return i.add(n), i.add(r), i.add(o), i
                    }
                }, e(to.prototype, {
                    union: function() {
                        for (var t = new Ie, e = new at, i = 0; i < this.pointGeom.getNumGeometries(); i++) {
                            var n = this.pointGeom.getGeometryN(i),
                                r = n.getCoordinate(),
                                o = t.locate(r, this.otherGeom);
                            o === C.EXTERIOR && e.add(r)
                        }
                        if (0 === e.size()) return this.otherGeom;
                        var s = null,
                            a = X.toCoordinateArray(e);
                        return s = 1 === a.length ? this.geomFact.createPoint(a[0]) : this.geomFact.createMultiPointFromCoords(a), Qr.combine(s, this.otherGeom)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return to }
                }), to.union = function(t, e) { var i = new to(t, e); return i.union() }, e(eo.prototype, { filter: function(t) {-1 !== this.sortIndex && t.getSortIndex() !== this.sortIndex || this.comps.add(t) }, interfaces_: function() { return [ut] }, getClass: function() { return eo } }), eo.extract = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        return eo.extract(t, e, new x)
                    }
                    if (3 === arguments.length) {
                        var i = arguments[0],
                            n = arguments[1],
                            r = arguments[2];
                        return i.getSortIndex() === n ? r.add(i) : i instanceof ct && i.apply(new eo(n, r)), r
                    }
                }, e(io.prototype, {
                    reduceToGeometries: function(t) {
                        for (var e = new x, i = t.iterator(); i.hasNext();) {
                            var n = i.next(),
                                r = null;
                            M(n, v) ? r = this.unionTree(n) : n instanceof B && (r = n), e.add(r)
                        }
                        return e
                    },
                    extractByEnvelope: function(t, e, i) {
                        for (var n = new x, r = 0; r < e.getNumGeometries(); r++) {
                            var o = e.getGeometryN(r);
                            o.getEnvelopeInternal().intersects(t) ? n.add(o) : i.add(o)
                        }
                        return this.geomFactory.buildGeometry(n)
                    },
                    unionOptimized: function(t, e) {
                        var i = t.getEnvelopeInternal(),
                            n = e.getEnvelopeInternal();
                        if (!i.intersects(n)) { var r = Qr.combine(t, e); return r }
                        if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1) return this.unionActual(t, e);
                        var o = i.intersection(n);
                        return this.unionUsingEnvelopeIntersection(t, e, o)
                    },
                    union: function() {
                        if (null === this.inputPolys) throw new IllegalStateException("union() method cannot be called twice");
                        if (this.inputPolys.isEmpty()) return null;
                        this.geomFactory = this.inputPolys.iterator().next().getFactory();
                        for (var t = new Ge(io.STRTREE_NODE_CAPACITY), e = this.inputPolys.iterator(); e.hasNext();) {
                            var i = e.next();
                            t.insert(i.getEnvelopeInternal(), i)
                        }
                        this.inputPolys = null;
                        var n = t.itemsTree(),
                            r = this.unionTree(n);
                        return r
                    },
                    binaryUnion: function() {
                        if (1 === arguments.length) { var t = arguments[0]; return this.binaryUnion(t, 0, t.size()) }
                        if (3 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1],
                                n = arguments[2];
                            if (1 >= n - i) { var r = io.getGeometry(e, i); return this.unionSafe(r, null) }
                            if (n - i === 2) return this.unionSafe(io.getGeometry(e, i), io.getGeometry(e, i + 1));
                            var o = Math.trunc((n + i) / 2),
                                r = this.binaryUnion(e, i, o),
                                s = this.binaryUnion(e, o, n);
                            return this.unionSafe(r, s)
                        }
                    },
                    repeatedUnion: function(t) {
                        for (var e = null, i = t.iterator(); i.hasNext();) {
                            var n = i.next();
                            e = null === e ? n.copy() : e.union(n)
                        }
                        return e
                    },
                    unionSafe: function(t, e) { return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionOptimized(t, e) },
                    unionActual: function(t, e) { return io.restrictToPolygons(t.union(e)) },
                    unionTree: function(t) {
                        var e = this.reduceToGeometries(t),
                            i = this.binaryUnion(e);
                        return i
                    },
                    unionUsingEnvelopeIntersection: function(t, e, i) {
                        var n = new x,
                            r = this.extractByEnvelope(i, t, n),
                            o = this.extractByEnvelope(i, e, n),
                            s = this.unionActual(r, o);
                        n.add(s);
                        var a = Qr.combine(n);
                        return a
                    },
                    bufferUnion: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0],
                                e = t.get(0).getFactory(),
                                i = e.buildGeometry(t),
                                n = i.buffer(0);
                            return n
                        }
                        if (2 === arguments.length) {
                            var r = arguments[0],
                                o = arguments[1],
                                e = r.getFactory(),
                                i = e.createGeometryCollection([r, o]),
                                n = i.buffer(0);
                            return n
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return io }
                }), io.restrictToPolygons = function(t) { if (M(t, Mt)) return t; var e = dr.getPolygons(t); return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(ne.toPolygonArray(e)) }, io.getGeometry = function(t, e) { return e >= t.size() ? null : t.get(e) }, io.union = function(t) { var e = new io(t); return e.union() }, io.STRTREE_NODE_CAPACITY = 4, e(no.prototype, {
                    unionNoOpt: function(t) { var e = this.geomFact.createPoint(); return on.overlayOp(t, e, nn.UNION) },
                    unionWithNull: function(t, e) { return null === t && null === e ? null : null === e ? t : null === t ? e : t.union(e) },
                    extract: function() {
                        if (M(arguments[0], y))
                            for (var t = arguments[0], e = t.iterator(); e.hasNext();) {
                                var i = e.next();
                                this.extract(i)
                            } else if (arguments[0] instanceof B) {
                                var n = arguments[0];
                                null === this.geomFact && (this.geomFact = n.getFactory()), eo.extract(n, B.SORTINDEX_POLYGON, this.polygons), eo.extract(n, B.SORTINDEX_LINESTRING, this.lines), eo.extract(n, B.SORTINDEX_POINT, this.points)
                            }
                    },
                    union: function t() {
                        if (null === this.geomFact) return null;
                        var e = null;
                        if (this.points.size() > 0) {
                            var i = this.geomFact.buildGeometry(this.points);
                            e = this.unionNoOpt(i)
                        }
                        var n = null;
                        if (this.lines.size() > 0) {
                            var r = this.geomFact.buildGeometry(this.lines);
                            n = this.unionNoOpt(r)
                        }
                        var o = null;
                        this.polygons.size() > 0 && (o = io.union(this.polygons));
                        var s = this.unionWithNull(n, o),
                            t = null;
                        return t = null === e ? s : null === s ? e : to.union(e, s), null === t ? this.geomFact.createGeometryCollection() : t
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return no }
                }), no.union = function() {
                    if (1 === arguments.length) {
                        if (M(arguments[0], y)) {
                            var t = arguments[0],
                                e = new no(t);
                            return e.union()
                        }
                        if (arguments[0] instanceof B) {
                            var i = arguments[0],
                                e = new no(i);
                            return e.union()
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1],
                            e = new no(n, r);
                        return e.union()
                    }
                };
                var Ts = Object.freeze({ UnaryUnionOp: no });
                e(ro.prototype, {
                    visitInteriorRing: function(t, e) {
                        var i = t.getCoordinates(),
                            n = i[0],
                            r = ro.findDifferentPoint(i, n),
                            o = e.findEdgeInSameDirection(n, r),
                            s = e.findEdgeEnd(o),
                            a = null;
                        s.getLabel().getLocation(0, ui.RIGHT) === C.INTERIOR ? a = s : s.getSym().getLabel().getLocation(0, ui.RIGHT) === C.INTERIOR && (a = s.getSym()), c.isTrue(null !== a, "unable to find dirEdge with Interior on RHS"), this.visitLinkedDirectedEdges(a)
                    },
                    visitShellInteriors: function(t, e) {
                        if (t instanceof It) {
                            var i = t;
                            this.visitInteriorRing(i.getExteriorRing(), e)
                        }
                        if (t instanceof At)
                            for (var n = t, r = 0; r < n.getNumGeometries(); r++) {
                                var i = n.getGeometryN(r);
                                this.visitInteriorRing(i.getExteriorRing(), e)
                            }
                    },
                    getCoordinate: function() { return this.disconnectedRingcoord },
                    setInteriorEdgesInResult: function(t) {
                        for (var e = t.getEdgeEnds().iterator(); e.hasNext();) {
                            var i = e.next();
                            i.getLabel().getLocation(0, ui.RIGHT) === C.INTERIOR && i.setInResult(!0)
                        }
                    },
                    visitLinkedDirectedEdges: function(t) {
                        var e = t,
                            i = t;
                        do c.isTrue(null !== i, "found null Directed Edge"), i.setVisited(!0), i = i.getNext(); while (i !== e)
                    },
                    buildEdgeRings: function(t) {
                        for (var e = new x, i = t.iterator(); i.hasNext();) {
                            var n = i.next();
                            if (n.isInResult() && null === n.getEdgeRing()) {
                                var r = new di(n, this.geometryFactory);
                                r.linkDirectedEdgesForMinimalEdgeRings();
                                var o = r.buildMinimalRings();
                                e.addAll(o)
                            }
                        }
                        return e
                    },
                    hasUnvisitedShellEdge: function(t) {
                        for (var e = 0; e < t.size(); e++) {
                            var i = t.get(e);
                            if (!i.isHole()) {
                                var n = i.getEdges(),
                                    r = n.get(0);
                                if (r.getLabel().getLocation(0, ui.RIGHT) === C.INTERIOR)
                                    for (var o = 0; o < n.size(); o++)
                                        if (r = n.get(o), !r.isVisited()) return this.disconnectedRingcoord = r.getCoordinate(), !0
                            }
                        }
                        return !1
                    },
                    isInteriorsConnected: function() {
                        var t = new x;
                        this.geomGraph.computeSplitEdges(t);
                        var e = new Ei(new Ti);
                        e.addEdges(t), this.setInteriorEdgesInResult(e), e.linkResultDirectedEdges();
                        var i = this.buildEdgeRings(e.getEdgeEnds());
                        return this.visitShellInteriors(this.geomGraph.getGeometry(), e), !this.hasUnvisitedShellEdge(i)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return ro }
                }), ro.findDifferentPoint = function(t, e) {
                    for (var i = 0; i < t.length; i++)
                        if (!t[i].equals(e)) return t[i];
                    return null
                }, e(oo.prototype, {
                    insertEdgeEnds: function(t) {
                        for (var e = t.iterator(); e.hasNext();) {
                            var i = e.next();
                            this.nodes.add(i)
                        }
                    },
                    getNodeIterator: function() { return this.nodes.iterator() },
                    copyNodesAndLabels: function(t, e) {
                        for (var i = t.getNodeIterator(); i.hasNext();) {
                            var n = i.next(),
                                r = this.nodes.addNode(n.getCoordinate());
                            r.setLabel(e, n.getLabel().getLocation(e))
                        }
                    },
                    build: function(t) {
                        this.computeIntersectionNodes(t, 0), this.copyNodesAndLabels(t, 0);
                        var e = new Br,
                            i = e.computeEdgeEnds(t.getEdgeIterator());
                        this.insertEdgeEnds(i)
                    },
                    computeIntersectionNodes: function(t, e) {
                        for (var i = t.getEdgeIterator(); i.hasNext();)
                            for (var n = i.next(), r = n.getLabel().getLocation(e), o = n.getEdgeIntersectionList().iterator(); o.hasNext();) {
                                var s = o.next(),
                                    a = this.nodes.addNode(s.coord);
                                r === C.BOUNDARY ? a.setLabelBoundary(e) : a.getLabel().isNull(e) && a.setLabel(e, C.INTERIOR)
                            }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return oo }
                }), e(so.prototype, {
                    isNodeEdgeAreaLabelsConsistent: function() { for (var t = this.nodeGraph.getNodeIterator(); t.hasNext();) { var e = t.next(); if (!e.getEdges().isAreaLabelsConsistent(this.geomGraph)) return this.invalidPoint = e.getCoordinate().copy(), !1 } return !0 },
                    getInvalidPoint: function() { return this.invalidPoint },
                    hasDuplicateRings: function() {
                        for (var t = this.nodeGraph.getNodeIterator(); t.hasNext();)
                            for (var e = t.next(), i = e.getEdges().iterator(); i.hasNext();) { var n = i.next(); if (n.getEdgeEnds().size() > 1) return this.invalidPoint = n.getEdge().getCoordinate(0), !0 }
                        return !1
                    },
                    isNodeConsistentArea: function() { var t = this.geomGraph.computeSelfNodes(this.li, !0, !0); return t.hasProperIntersection() ? (this.invalidPoint = t.getProperIntersectionPoint(), !1) : (this.nodeGraph.build(this.geomGraph), this.isNodeEdgeAreaLabelsConsistent()) },
                    interfaces_: function() { return [] },
                    getClass: function() { return so }
                }), e(ao.prototype, {
                    buildIndex: function() {
                        this.index = new Ge;
                        for (var t = 0; t < this.rings.size(); t++) {
                            var e = this.rings.get(t),
                                i = e.getEnvelopeInternal();
                            this.index.insert(i, e)
                        }
                    },
                    getNestedPoint: function() { return this.nestedPt },
                    isNonNested: function() {
                        this.buildIndex();
                        for (var t = 0; t < this.rings.size(); t++)
                            for (var e = this.rings.get(t), i = e.getCoordinates(), n = this.index.query(e.getEnvelopeInternal()), r = 0; r < n.size(); r++) {
                                var o = n.get(r),
                                    s = o.getCoordinates();
                                if (e !== o && e.getEnvelopeInternal().intersects(o.getEnvelopeInternal())) { var a = lo.findPtNotNode(i, o, this.graph); if (null !== a) { var h = ue.isPointInRing(a, s); if (h) return this.nestedPt = a, !1 } }
                            }
                        return !0
                    },
                    add: function(t) { this.rings.add(t), this.totalEnv.expandToInclude(t.getEnvelopeInternal()) },
                    interfaces_: function() { return [] },
                    getClass: function() { return ao }
                }), e(ho.prototype, { getErrorType: function() { return this.errorType }, getMessage: function() { return ho.errMsg[this.errorType] }, getCoordinate: function() { return this.pt }, toString: function() { var t = ""; return null !== this.pt && (t = " at or near point " + this.pt), this.getMessage() + t }, interfaces_: function() { return [] }, getClass: function() { return ho } }), ho.ERROR = 0, ho.REPEATED_POINT = 1, ho.HOLE_OUTSIDE_SHELL = 2, ho.NESTED_HOLES = 3, ho.DISCONNECTED_INTERIOR = 4, ho.SELF_INTERSECTION = 5, ho.RING_SELF_INTERSECTION = 6, ho.NESTED_SHELLS = 7, ho.DUPLICATE_RINGS = 8, ho.TOO_FEW_POINTS = 9, ho.INVALID_COORDINATE = 10, ho.RING_NOT_CLOSED = 11, ho.errMsg = ["Topology Validation Error", "Repeated Point", "Hole lies outside shell", "Holes are nested", "Interior is disconnected", "Self-intersection", "Ring Self-intersection", "Nested shells", "Duplicate Rings", "Too few distinct points in geometry component", "Invalid Coordinate", "Ring is not closed"], e(lo.prototype, {
                    checkInvalidCoordinates: function() {
                        if (arguments[0] instanceof Array) {
                            for (var t = arguments[0], e = 0; e < t.length; e++)
                                if (!lo.isValid(t[e])) return this.validErr = new ho(ho.INVALID_COORDINATE, t[e]), null
                        } else if (arguments[0] instanceof It) {
                            var i = arguments[0];
                            if (this.checkInvalidCoordinates(i.getExteriorRing().getCoordinates()), null !== this.validErr) return null;
                            for (var e = 0; e < i.getNumInteriorRing(); e++)
                                if (this.checkInvalidCoordinates(i.getInteriorRingN(e).getCoordinates()), null !== this.validErr) return null
                        }
                    },
                    checkHolesNotNested: function(t, e) {
                        for (var i = new ao(e), n = 0; n < t.getNumInteriorRing(); n++) {
                            var r = t.getInteriorRingN(n);
                            i.add(r)
                        }
                        var o = i.isNonNested();
                        o || (this.validErr = new ho(ho.NESTED_HOLES, i.getNestedPoint()))
                    },
                    checkConsistentArea: function(t) {
                        var e = new so(t),
                            i = e.isNodeConsistentArea();
                        return i ? void(e.hasDuplicateRings() && (this.validErr = new ho(ho.DUPLICATE_RINGS, e.getInvalidPoint()))) : (this.validErr = new ho(ho.SELF_INTERSECTION, e.getInvalidPoint()), null)
                    },
                    isValid: function() { return this.checkValid(this.parentGeometry), null === this.validErr },
                    checkShellInsideHole: function(t, e, i) {
                        var n = t.getCoordinates(),
                            r = e.getCoordinates(),
                            o = lo.findPtNotNode(n, e, i);
                        if (null !== o) { var s = ue.isPointInRing(o, r); if (!s) return o }
                        var a = lo.findPtNotNode(r, t, i);
                        if (null !== a) { var h = ue.isPointInRing(a, n); return h ? a : null }
                        return c.shouldNeverReachHere("points in shell and hole appear to be equal"), null
                    },
                    checkNoSelfIntersectingRings: function(t) { for (var e = t.getEdgeIterator(); e.hasNext();) { var i = e.next(); if (this.checkNoSelfIntersectingRing(i.getEdgeIntersectionList()), null !== this.validErr) return null } },
                    checkConnectedInteriors: function(t) {
                        var e = new ro(t);
                        e.isInteriorsConnected() || (this.validErr = new ho(ho.DISCONNECTED_INTERIOR, e.getCoordinate()))
                    },
                    checkNoSelfIntersectingRing: function(t) {
                        for (var e = new at, i = !0, n = t.iterator(); n.hasNext();) {
                            var r = n.next();
                            if (i) i = !1;
                            else {
                                if (e.contains(r.coord)) return this.validErr = new ho(ho.RING_SELF_INTERSECTION, r.coord), null;
                                e.add(r.coord)
                            }
                        }
                    },
                    checkHolesInShell: function(t, e) {
                        for (var i = t.getExteriorRing(), n = new xn(i), r = 0; r < t.getNumInteriorRing(); r++) {
                            var o = t.getInteriorRingN(r),
                                s = lo.findPtNotNode(o.getCoordinates(), i, e);
                            if (null === s) return null;
                            var a = !n.isInside(s);
                            if (a) return this.validErr = new ho(ho.HOLE_OUTSIDE_SHELL, s), null
                        }
                    },
                    checkTooFewPoints: function(t) { return t.hasTooFewPoints() ? (this.validErr = new ho(ho.TOO_FEW_POINTS, t.getInvalidPoint()), null) : void 0 },
                    getValidationError: function() { return this.checkValid(this.parentGeometry), this.validErr },
                    checkValid: function() {
                        if (arguments[0] instanceof Ct) {
                            var t = arguments[0];
                            this.checkInvalidCoordinates(t.getCoordinates())
                        } else if (arguments[0] instanceof kt) {
                            var e = arguments[0];
                            this.checkInvalidCoordinates(e.getCoordinates())
                        } else if (arguments[0] instanceof Tt) {
                            var i = arguments[0];
                            if (this.checkInvalidCoordinates(i.getCoordinates()), null !== this.validErr) return null;
                            if (this.checkClosedRing(i), null !== this.validErr) return null;
                            var n = new Ji(0, i);
                            if (this.checkTooFewPoints(n), null !== this.validErr) return null;
                            var r = new ae;
                            n.computeSelfNodes(r, !0, !0), this.checkNoSelfIntersectingRings(n)
                        } else if (arguments[0] instanceof Nt) {
                            var o = arguments[0];
                            if (this.checkInvalidCoordinates(o.getCoordinates()), null !== this.validErr) return null;
                            var n = new Ji(0, o);
                            this.checkTooFewPoints(n)
                        } else if (arguments[0] instanceof It) {
                            var s = arguments[0];
                            if (this.checkInvalidCoordinates(s), null !== this.validErr) return null;
                            if (this.checkClosedRings(s), null !== this.validErr) return null;
                            var n = new Ji(0, s);
                            if (this.checkTooFewPoints(n), null !== this.validErr) return null;
                            if (this.checkConsistentArea(n), null !== this.validErr) return null;
                            if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(n), null !== this.validErr)) return null;
                            if (this.checkHolesInShell(s, n), null !== this.validErr) return null;
                            if (this.checkHolesNotNested(s, n), null !== this.validErr) return null;
                            this.checkConnectedInteriors(n)
                        } else if (arguments[0] instanceof At) {
                            for (var a = arguments[0], h = 0; h < a.getNumGeometries(); h++) { var l = a.getGeometryN(h); if (this.checkInvalidCoordinates(l), null !== this.validErr) return null; if (this.checkClosedRings(l), null !== this.validErr) return null }
                            var n = new Ji(0, a);
                            if (this.checkTooFewPoints(n), null !== this.validErr) return null;
                            if (this.checkConsistentArea(n), null !== this.validErr) return null;
                            if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(n), null !== this.validErr)) return null;
                            for (var h = 0; h < a.getNumGeometries(); h++) { var l = a.getGeometryN(h); if (this.checkHolesInShell(l, n), null !== this.validErr) return null }
                            for (var h = 0; h < a.getNumGeometries(); h++) { var l = a.getGeometryN(h); if (this.checkHolesNotNested(l, n), null !== this.validErr) return null }
                            if (this.checkShellsNotNested(a, n), null !== this.validErr) return null;
                            this.checkConnectedInteriors(n)
                        } else if (arguments[0] instanceof ct)
                            for (var u = arguments[0], h = 0; h < u.getNumGeometries(); h++) { var p = u.getGeometryN(h); if (this.checkValid(p), null !== this.validErr) return null } else if (arguments[0] instanceof B) {
                                var c = arguments[0];
                                if (this.validErr = null, c.isEmpty()) return null;
                                if (c instanceof Ct) this.checkValid(c);
                                else if (c instanceof kt) this.checkValid(c);
                                else if (c instanceof Tt) this.checkValid(c);
                                else if (c instanceof Nt) this.checkValid(c);
                                else if (c instanceof It) this.checkValid(c);
                                else if (c instanceof At) this.checkValid(c);
                                else {
                                    if (!(c instanceof ct)) throw new UnsupportedOperationException(c.getClass().getName());
                                    this.checkValid(c)
                                }
                            }
                    },
                    setSelfTouchingRingFormingHoleValid: function(t) { this.isSelfTouchingRingFormingHoleValid = t },
                    checkShellNotNested: function(t, e, i) {
                        var n = t.getCoordinates(),
                            r = e.getExteriorRing(),
                            o = r.getCoordinates(),
                            s = lo.findPtNotNode(n, r, i);
                        if (null === s) return null;
                        var a = ue.isPointInRing(s, o);
                        if (!a) return null;
                        if (e.getNumInteriorRing() <= 0) return this.validErr = new ho(ho.NESTED_SHELLS, s), null;
                        for (var h = null, l = 0; l < e.getNumInteriorRing(); l++) { var u = e.getInteriorRingN(l); if (h = this.checkShellInsideHole(t, u, i), null === h) return null }
                        this.validErr = new ho(ho.NESTED_SHELLS, h)
                    },
                    checkClosedRings: function(t) {
                        if (this.checkClosedRing(t.getExteriorRing()), null !== this.validErr) return null;
                        for (var e = 0; e < t.getNumInteriorRing(); e++)
                            if (this.checkClosedRing(t.getInteriorRingN(e)), null !== this.validErr) return null
                    },
                    checkClosedRing: function(t) {
                        if (!t.isClosed()) {
                            var e = null;
                            t.getNumPoints() >= 1 && (e = t.getCoordinateN(0)), this.validErr = new ho(ho.RING_NOT_CLOSED, e)
                        }
                    },
                    checkShellsNotNested: function(t, e) {
                        for (var i = 0; i < t.getNumGeometries(); i++)
                            for (var n = t.getGeometryN(i), r = n.getExteriorRing(), o = 0; o < t.getNumGeometries(); o++)
                                if (i !== o) { var s = t.getGeometryN(o); if (this.checkShellNotNested(r, s, e), null !== this.validErr) return null }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return lo }
                }), lo.findPtNotNode = function(t, e, i) { for (var n = i.findEdge(e), r = n.getEdgeIntersectionList(), o = 0; o < t.length; o++) { var s = t[o]; if (!r.isIntersection(s)) return s } return null }, lo.isValid = function() {
                    if (arguments[0] instanceof B) {
                        var t = arguments[0],
                            e = new lo(t);
                        return e.isValid()
                    }
                    if (arguments[0] instanceof f) { var i = arguments[0]; return !r.isNaN(i.x) && (!r.isInfinite(i.x) && (!r.isNaN(i.y) && !r.isInfinite(i.y))) }
                };
                var As = Object.freeze({ IsValidOp: lo, ConsistentAreaTester: so }),
                    Rs = Object.freeze({ BoundaryOp: gt, IsSimpleOp: Hn, buffer: Ns, distance: Ls, linemerge: Cs, overlay: Ms, polygonize: Is, relate: ks, union: Ts, valid: As });
                u(uo, Rt.CoordinateOperation), e(uo.prototype, {
                    editCoordinates: function(t, e) {
                        if (0 === t.length) return null;
                        for (var i = new Array(t.length).fill(null), n = 0; n < t.length; n++) {
                            var r = new f(t[n]);
                            this.targetPM.makePrecise(r), i[n] = r
                        }
                        var o = new E(i, !1),
                            s = o.toCoordinateArray(),
                            a = 0;
                        e instanceof Nt && (a = 2), e instanceof Tt && (a = 4);
                        var h = i;
                        return this.removeCollapsed && (h = null), s.length < a ? h : s
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return uo }
                }), e(po.prototype, {
                    fixPolygonalTopology: function(t) {
                        var e = t;
                        this.changePrecisionModel || (e = this.changePM(t, this.targetPM));
                        var i = e.buffer(0),
                            n = i;
                        return this.changePrecisionModel || (n = t.getFactory().createGeometry(i)), n
                    },
                    reducePointwise: function(t) {
                        var e = null;
                        if (this.changePrecisionModel) {
                            var i = this.createFactory(t.getFactory(), this.targetPM);
                            e = new Rt(i)
                        } else e = new Rt;
                        var n = this.removeCollapsed;
                        t.getDimension() >= 2 && (n = !0);
                        var r = e.edit(t, new uo(this.targetPM, n));
                        return r
                    },
                    changePM: function(t, e) { var i = this.createEditor(t.getFactory(), e); return i.edit(t, new Rt.NoOpGeometryOperation) },
                    setRemoveCollapsedComponents: function(t) { this.removeCollapsed = t },
                    createFactory: function(t, e) { var i = new ne(e, t.getSRID(), t.getCoordinateSequenceFactory()); return i },
                    setChangePrecisionModel: function(t) { this.changePrecisionModel = t },
                    reduce: function(t) { var e = this.reducePointwise(t); return this.isPointwise ? e : M(e, Mt) ? e.isValid() ? e : this.fixPolygonalTopology(e) : e },
                    setPointwise: function(t) { this.isPointwise = t },
                    createEditor: function(t, e) {
                        if (t.getPrecisionModel() === e) return new Rt;
                        var i = this.createFactory(t, e),
                            n = new Rt(i);
                        return n
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return po }
                }), po.reduce = function(t, e) { var i = new po(e); return i.reduce(t) }, po.reducePointwise = function(t, e) { var i = new po(e); return i.setPointwise(!0), i.reduce(t) };
                var _s = Object.freeze({ GeometryPrecisionReducer: po });
                e(co.prototype, {
                    simplifySection: function(t, e) {
                        if (t + 1 === e) return null;
                        this.seg.p0 = this.pts[t], this.seg.p1 = this.pts[e];
                        for (var i = -1, n = t, r = t + 1; e > r; r++) {
                            var o = this.seg.distance(this.pts[r]);
                            o > i && (i = o, n = r)
                        }
                        if (i <= this.distanceTolerance)
                            for (var r = t + 1; e > r; r++) this.usePt[r] = !1;
                        else this.simplifySection(t, n), this.simplifySection(n, e)
                    },
                    setDistanceTolerance: function(t) { this.distanceTolerance = t },
                    simplify: function() {
                        this.usePt = new Array(this.pts.length).fill(null);
                        for (var t = 0; t < this.pts.length; t++) this.usePt[t] = !0;
                        this.simplifySection(0, this.pts.length - 1);
                        for (var e = new E, t = 0; t < this.pts.length; t++) this.usePt[t] && e.add(new f(this.pts[t]));
                        return e.toCoordinateArray()
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return co }
                }), co.simplify = function(t, e) { var i = new co(t); return i.setDistanceTolerance(e), i.simplify() }, e(fo.prototype, {
                    setEnsureValid: function(t) { this.isEnsureValidTopology = t },
                    getResultGeometry: function() { return this.inputGeom.isEmpty() ? this.inputGeom.copy() : new go(this.isEnsureValidTopology, this.distanceTolerance).transform(this.inputGeom) },
                    setDistanceTolerance: function(t) {
                        if (0 > t) throw new n("Tolerance must be non-negative");
                        this.distanceTolerance = t
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return fo }
                }), fo.simplify = function(t, e) { var i = new fo(t); return i.setDistanceTolerance(e), i.getResultGeometry() }, u(go, be), e(go.prototype, {
                    transformPolygon: function(t, e) { if (t.isEmpty()) return null; var i = be.prototype.transformPolygon.call(this, t, e); return e instanceof At ? i : this.createValidArea(i) },
                    createValidArea: function(t) { return this.isEnsureValidTopology ? t.buffer(0) : t },
                    transformCoordinates: function(t, e) {
                        var i = t.toCoordinateArray(),
                            n = null;
                        return n = 0 === i.length ? new Array(0).fill(null) : co.simplify(i, this.distanceTolerance), this.factory.getCoordinateSequenceFactory().create(n)
                    },
                    transformMultiPolygon: function(t, e) { var i = be.prototype.transformMultiPolygon.call(this, t, e); return this.createValidArea(i) },
                    transformLinearRing: function(t, e) {
                        var i = e instanceof It,
                            n = be.prototype.transformLinearRing.call(this, t, e);
                        return !i || n instanceof Tt ? n : null
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return go }
                }), fo.DPTransformer = go, u(yo, pe), e(yo.prototype, { getIndex: function() { return this.index }, getParent: function() { return this.parent }, interfaces_: function() { return [] }, getClass: function() { return yo } }), e(mo.prototype, {
                    addToResult: function(t) { this.resultSegs.add(t) },
                    asLineString: function() { return this.parentLine.getFactory().createLineString(mo.extractCoordinates(this.resultSegs)) },
                    getResultSize: function() { var t = this.resultSegs.size(); return 0 === t ? 0 : t + 1 },
                    getParent: function() { return this.parentLine },
                    getSegment: function(t) { return this.segs[t] },
                    getParentCoordinates: function() { return this.parentLine.getCoordinates() },
                    getMinimumSize: function() { return this.minimumSize },
                    asLinearRing: function() { return this.parentLine.getFactory().createLinearRing(mo.extractCoordinates(this.resultSegs)) },
                    getSegments: function() { return this.segs },
                    init: function() {
                        var t = this.parentLine.getCoordinates();
                        this.segs = new Array(t.length - 1).fill(null);
                        for (var e = 0; e < t.length - 1; e++) {
                            var i = new yo(t[e], t[e + 1], this.parentLine, e);
                            this.segs[e] = i
                        }
                    },
                    getResultCoordinates: function() { return mo.extractCoordinates(this.resultSegs) },
                    interfaces_: function() { return [] },
                    getClass: function() { return mo }
                }), mo.extractCoordinates = function(t) { for (var e = new Array(t.size() + 1).fill(null), i = null, n = 0; n < t.size(); n++) i = t.get(n), e[n] = i.p0; return e[e.length - 1] = i.p1, e }, e(vo.prototype, {
                    remove: function(t) { this.index.remove(new S(t.p0, t.p1), t) },
                    add: function() {
                        if (arguments[0] instanceof mo)
                            for (var t = arguments[0], e = t.getSegments(), i = 0; i < e.length; i++) {
                                var n = e[i];
                                this.add(n)
                            } else if (arguments[0] instanceof pe) {
                                var r = arguments[0];
                                this.index.insert(new S(r.p0, r.p1), r)
                            }
                    },
                    query: function(t) {
                        var e = new S(t.p0, t.p1),
                            i = new bo(t);
                        this.index.query(e, i);
                        var n = i.getItems();
                        return n
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return vo }
                }), e(bo.prototype, {
                    visitItem: function(t) {
                        var e = t;
                        S.intersects(e.p0, e.p1, this.querySeg.p0, this.querySeg.p1) && this.items.add(t)
                    },
                    getItems: function() { return this.items },
                    interfaces_: function() { return [Oe] },
                    getClass: function() { return bo }
                }), e(wo.prototype, {
                    flatten: function(t, e) {
                        var i = this.linePts[t],
                            n = this.linePts[e],
                            r = new pe(i, n);
                        return this.remove(this.line, t, e), this.outputIndex.add(r), r
                    },
                    hasBadIntersection: function(t, e, i) { return !!this.hasBadOutputIntersection(i) || !!this.hasBadInputIntersection(t, e, i) },
                    setDistanceTolerance: function(t) { this.distanceTolerance = t },
                    simplifySection: function(t, e, i) {
                        i += 1;
                        var n = new Array(2).fill(null);
                        if (t + 1 === e) { var r = this.line.getSegment(t); return this.line.addToResult(r), null }
                        var o = !0;
                        if (this.line.getResultSize() < this.line.getMinimumSize()) {
                            var s = i + 1;
                            s < this.line.getMinimumSize() && (o = !1)
                        }
                        var a = new Array(1).fill(null),
                            h = this.findFurthestPoint(this.linePts, t, e, a);
                        a[0] > this.distanceTolerance && (o = !1);
                        var l = new pe;
                        if (l.p0 = this.linePts[t], l.p1 = this.linePts[e], n[0] = t, n[1] = e, this.hasBadIntersection(this.line, n, l) && (o = !1), o) { var r = this.flatten(t, e); return this.line.addToResult(r), null }
                        this.simplifySection(t, h, i), this.simplifySection(h, e, i)
                    },
                    hasBadOutputIntersection: function(t) { for (var e = this.outputIndex.query(t), i = e.iterator(); i.hasNext();) { var n = i.next(); if (this.hasInteriorIntersection(n, t)) return !0 } return !1 },
                    findFurthestPoint: function(t, e, i, n) {
                        var r = new pe;
                        r.p0 = t[e], r.p1 = t[i];
                        for (var o = -1, s = e, a = e + 1; i > a; a++) {
                            var h = t[a],
                                l = r.distance(h);
                            l > o && (o = l, s = a)
                        }
                        return n[0] = o, s
                    },
                    simplify: function(t) { this.line = t, this.linePts = t.getParentCoordinates(), this.simplifySection(0, this.linePts.length - 1, 0) },
                    remove: function(t, e, i) {
                        for (var n = e; i > n; n++) {
                            var r = t.getSegment(n);
                            this.inputIndex.remove(r)
                        }
                    },
                    hasInteriorIntersection: function(t, e) { return this.li.computeIntersection(t.p0, t.p1, e.p0, e.p1), this.li.isInteriorIntersection() },
                    hasBadInputIntersection: function(t, e, i) { for (var n = this.inputIndex.query(i), r = n.iterator(); r.hasNext();) { var o = r.next(); if (this.hasInteriorIntersection(o, i)) { if (wo.isInLineSection(t, e, o)) continue; return !0 } } return !1 },
                    interfaces_: function() { return [] },
                    getClass: function() { return wo }
                }), wo.isInLineSection = function(t, e, i) { if (i.getParent() !== t.getParent()) return !1; var n = i.getIndex(); return n >= e[0] && n < e[1] }, e(xo.prototype, {
                    setDistanceTolerance: function(t) { this.distanceTolerance = t },
                    simplify: function(t) {
                        for (var e = t.iterator(); e.hasNext();) this.inputIndex.add(e.next());
                        for (var e = t.iterator(); e.hasNext();) {
                            var i = new wo(this.inputIndex, this.outputIndex);
                            i.setDistanceTolerance(this.distanceTolerance), i.simplify(e.next())
                        }
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return xo }
                }), e(Eo.prototype, {
                    getResultGeometry: function() {
                        if (this.inputGeom.isEmpty()) return this.inputGeom.copy();
                        this.linestringMap = new te, this.inputGeom.apply(new No(this)), this.lineSimplifier.simplify(this.linestringMap.values());
                        var t = new So(this.linestringMap).transform(this.inputGeom);
                        return t
                    },
                    setDistanceTolerance: function(t) {
                        if (0 > t) throw new n("Tolerance must be non-negative");
                        this.lineSimplifier.setDistanceTolerance(t)
                    },
                    interfaces_: function() { return [] },
                    getClass: function() { return Eo }
                }), Eo.simplify = function(t, e) { var i = new Eo(t); return i.setDistanceTolerance(e), i.getResultGeometry() }, u(So, be), e(So.prototype, { transformCoordinates: function(t, e) { if (0 === t.size()) return null; if (e instanceof Nt) { var i = this.linestringMap.get(e); return this.createCoordinateSequence(i.getResultCoordinates()) } return be.prototype.transformCoordinates.call(this, t, e) }, interfaces_: function() { return [] }, getClass: function() { return So } }), e(No.prototype, {
                    filter: function(t) {
                        if (t instanceof Nt) {
                            var e = t;
                            if (e.isEmpty()) return null;
                            var i = e.isClosed() ? 4 : 2,
                                n = new mo(e, i);
                            this.tps.linestringMap.put(e, n)
                        }
                    },
                    interfaces_: function() { return [U] },
                    getClass: function() { return No }
                }), Eo.LineStringTransformer = So, Eo.LineStringMapBuilderFilter = No;
                var Ps = Object.freeze({ DouglasPeuckerSimplifier: fo, TopologyPreservingSimplifier: Eo });
                e(Lo.prototype, {
                        splitAt: function() {
                            if (1 === arguments.length) {
                                var t = arguments[0],
                                    e = this.minimumLen / this.segLen;
                                if (t.distance(this.seg.p0) < this.minimumLen) return this.splitPt = this.seg.pointAlong(e), null;
                                if (t.distance(this.seg.p1) < this.minimumLen) return this.splitPt = Lo.pointAlongReverse(this.seg, e), null;
                                this.splitPt = t
                            } else if (2 === arguments.length) {
                                var i = arguments[0],
                                    n = arguments[1],
                                    r = this.getConstrainedLength(i),
                                    o = r / this.segLen;
                                n.equals2D(this.seg.p0) ? this.splitPt = this.seg.pointAlong(o) : this.splitPt = Lo.pointAlongReverse(this.seg, o)
                            }
                        },
                        setMinimumLength: function(t) { this.minimumLen = t },
                        getConstrainedLength: function(t) { return t < this.minimumLen ? this.minimumLen : t },
                        getSplitPoint: function() { return this.splitPt },
                        interfaces_: function() { return [] },
                        getClass: function() { return Lo }
                    }), Lo.pointAlongReverse = function(t, e) { var i = new f; return i.x = t.p1.x - e * (t.p1.x - t.p0.x), i.y = t.p1.y - e * (t.p1.y - t.p0.y), i }, e(Co.prototype, { findSplitPoint: function(t, e) {}, interfaces_: function() { return [] }, getClass: function() { return Co } }), e(Mo.prototype, {
                        findSplitPoint: function(t, e) {
                            var i = t.getLineSegment(),
                                n = i.getLength(),
                                r = n / 2,
                                o = new Lo(i),
                                s = Mo.projectedSplitPoint(t, e),
                                a = 2 * s.distance(e) * .8,
                                h = a;
                            return h > r && (h = r), o.setMinimumLength(h), o.splitAt(s), o.getSplitPoint()
                        },
                        interfaces_: function() { return [Co] },
                        getClass: function() { return Mo }
                    }), Mo.projectedSplitPoint = function(t, e) {
                        var i = t.getLineSegment(),
                            n = i.project(e);
                        return n
                    }, e(Io.prototype, { interfaces_: function() { return [] }, getClass: function() { return Io } }), Io.triArea = function(t, e, i) { return (e.x - t.x) * (i.y - t.y) - (e.y - t.y) * (i.x - t.x) }, Io.isInCircleDDNormalized = function(t, e, i, n) {
                        var r = R.valueOf(t.x).selfSubtract(n.x),
                            o = R.valueOf(t.y).selfSubtract(n.y),
                            s = R.valueOf(e.x).selfSubtract(n.x),
                            a = R.valueOf(e.y).selfSubtract(n.y),
                            h = R.valueOf(i.x).selfSubtract(n.x),
                            l = R.valueOf(i.y).selfSubtract(n.y),
                            u = r.multiply(a).selfSubtract(s.multiply(o)),
                            p = s.multiply(l).selfSubtract(h.multiply(a)),
                            c = h.multiply(o).selfSubtract(r.multiply(l)),
                            f = r.multiply(r).selfAdd(o.multiply(o)),
                            g = s.multiply(s).selfAdd(a.multiply(a)),
                            d = h.multiply(h).selfAdd(l.multiply(l)),
                            y = f.selfMultiply(p).selfAdd(g.selfMultiply(c)).selfAdd(d.selfMultiply(u)),
                            m = y.doubleValue() > 0;
                        return m
                    }, Io.checkRobustInCircle = function(t, e, i, n) {
                        var r = Io.isInCircleNonRobust(t, e, i, n),
                            o = Io.isInCircleDDSlow(t, e, i, n),
                            s = Io.isInCircleCC(t, e, i, n),
                            a = Nn.circumcentre(t, e, i);
                        O.out.println("p radius diff a = " + Math.abs(n.distance(a) - t.distance(a)) / t.distance(a)), r === o && r === s || (O.out.println("inCircle robustness failure (double result = " + r + ", DD result = " + o + ", CC result = " + s + ")"), O.out.println(oe.toLineString(new Ft([t, e, i, n]))), O.out.println("Circumcentre = " + oe.toPoint(a) + " radius = " + t.distance(a)), O.out.println("p radius diff a = " + Math.abs(n.distance(a) / t.distance(a) - 1)), O.out.println("p radius diff b = " + Math.abs(n.distance(a) / e.distance(a) - 1)), O.out.println("p radius diff c = " + Math.abs(n.distance(a) / i.distance(a) - 1)), O.out.println())
                    }, Io.isInCircleDDFast = function(t, e, i, n) {
                        var r = R.sqr(t.x).selfAdd(R.sqr(t.y)).selfMultiply(Io.triAreaDDFast(e, i, n)),
                            o = R.sqr(e.x).selfAdd(R.sqr(e.y)).selfMultiply(Io.triAreaDDFast(t, i, n)),
                            s = R.sqr(i.x).selfAdd(R.sqr(i.y)).selfMultiply(Io.triAreaDDFast(t, e, n)),
                            a = R.sqr(n.x).selfAdd(R.sqr(n.y)).selfMultiply(Io.triAreaDDFast(t, e, i)),
                            h = r.selfSubtract(o).selfAdd(s).selfSubtract(a),
                            l = h.doubleValue() > 0;
                        return l
                    }, Io.isInCircleCC = function(t, e, i, n) {
                        var r = Nn.circumcentre(t, e, i),
                            o = t.distance(r),
                            s = n.distance(r) - o;
                        return 0 >= s
                    }, Io.isInCircleNormalized = function(t, e, i, n) {
                        var r = t.x - n.x,
                            o = t.y - n.y,
                            s = e.x - n.x,
                            a = e.y - n.y,
                            h = i.x - n.x,
                            l = i.y - n.y,
                            u = r * a - s * o,
                            p = s * l - h * a,
                            c = h * o - r * l,
                            f = r * r + o * o,
                            g = s * s + a * a,
                            d = h * h + l * l,
                            y = f * p + g * c + d * u;
                        return y > 0
                    }, Io.isInCircleDDSlow = function(t, e, i, n) {
                        var r = R.valueOf(n.x),
                            o = R.valueOf(n.y),
                            s = R.valueOf(t.x),
                            a = R.valueOf(t.y),
                            h = R.valueOf(e.x),
                            l = R.valueOf(e.y),
                            u = R.valueOf(i.x),
                            p = R.valueOf(i.y),
                            c = s.multiply(s).add(a.multiply(a)).multiply(Io.triAreaDDSlow(h, l, u, p, r, o)),
                            f = h.multiply(h).add(l.multiply(l)).multiply(Io.triAreaDDSlow(s, a, u, p, r, o)),
                            g = u.multiply(u).add(p.multiply(p)).multiply(Io.triAreaDDSlow(s, a, h, l, r, o)),
                            d = r.multiply(r).add(o.multiply(o)).multiply(Io.triAreaDDSlow(s, a, h, l, u, p)),
                            y = c.subtract(f).add(g).subtract(d),
                            m = y.doubleValue() > 0;
                        return m
                    }, Io.isInCircleNonRobust = function(t, e, i, n) { var r = (t.x * t.x + t.y * t.y) * Io.triArea(e, i, n) - (e.x * e.x + e.y * e.y) * Io.triArea(t, i, n) + (i.x * i.x + i.y * i.y) * Io.triArea(t, e, n) - (n.x * n.x + n.y * n.y) * Io.triArea(t, e, i) > 0; return r }, Io.isInCircleRobust = function(t, e, i, n) { return Io.isInCircleNormalized(t, e, i, n) }, Io.triAreaDDSlow = function(t, e, i, n, r, o) { return i.subtract(t).multiply(o.subtract(e)).subtract(n.subtract(e).multiply(r.subtract(t))) }, Io.triAreaDDFast = function(t, e, i) {
                        var n = R.valueOf(e.x).selfSubtract(t.x).selfMultiply(R.valueOf(i.y).selfSubtract(t.y)),
                            r = R.valueOf(e.y).selfSubtract(t.y).selfMultiply(R.valueOf(i.x).selfSubtract(t.x));
                        return n.selfSubtract(r)
                    }, e(ko.prototype, {
                        circleCenter: function(t, e) {
                            var i = new ko(this.getX(), this.getY()),
                                n = this.bisector(i, t),
                                r = this.bisector(t, e),
                                o = new D(n, r),
                                s = null;
                            try { s = new ko(o.getX(), o.getY()) } catch (n) {
                                if (!(n instanceof L)) throw n;
                                O.err.println("a: " + i + "  b: " + t + "  c: " + e), O.err.println(n)
                            } finally {}
                            return s
                        },
                        dot: function(t) { return this.p.x * t.getX() + this.p.y * t.getY() },
                        magn: function() { return Math.sqrt(this.p.x * this.p.x + this.p.y * this.p.y) },
                        getZ: function() { return this.p.z },
                        bisector: function(t, e) {
                            var i = e.getX() - t.getX(),
                                n = e.getY() - t.getY(),
                                r = new D(t.getX() + i / 2, t.getY() + n / 2, 1),
                                o = new D(t.getX() - n + i / 2, t.getY() + i + n / 2, 1);
                            return new D(r, o)
                        },
                        equals: function() {
                            if (1 === arguments.length) { var t = arguments[0]; return this.p.x === t.getX() && this.p.y === t.getY() }
                            if (2 === arguments.length) {
                                var e = arguments[0],
                                    i = arguments[1];
                                return this.p.distance(e.getCoordinate()) < i
                            }
                        },
                        getCoordinate: function() { return this.p },
                        isInCircle: function(t, e, i) { return Io.isInCircleRobust(t.p, e.p, i.p, this.p) },
                        interpolateZValue: function(t, e, i) {
                            var n = t.getX(),
                                r = t.getY(),
                                o = e.getX() - n,
                                s = i.getX() - n,
                                a = e.getY() - r,
                                h = i.getY() - r,
                                l = o * h - s * a,
                                u = this.getX() - n,
                                p = this.getY() - r,
                                c = (h * u - s * p) / l,
                                f = (-a * u + o * p) / l,
                                g = t.getZ() + c * (e.getZ() - t.getZ()) + f * (i.getZ() - t.getZ());
                            return g
                        },
                        midPoint: function(t) {
                            var e = (this.p.x + t.getX()) / 2,
                                i = (this.p.y + t.getY()) / 2,
                                n = (this.p.z + t.getZ()) / 2;
                            return new ko(e, i, n)
                        },
                        rightOf: function(t) { return this.isCCW(t.dest(), t.orig()) },
                        isCCW: function(t, e) { return (t.p.x - this.p.x) * (e.p.y - this.p.y) - (t.p.y - this.p.y) * (e.p.x - this.p.x) > 0 },
                        getX: function() { return this.p.x },
                        crossProduct: function(t) { return this.p.x * t.getY() - this.p.y * t.getX() },
                        setZ: function(t) { this.p.z = t },
                        times: function(t) { return new ko(t * this.p.x, t * this.p.y) },
                        cross: function() { return new ko(this.p.y, -this.p.x) },
                        leftOf: function(t) { return this.isCCW(t.orig(), t.dest()) },
                        toString: function() { return "POINT (" + this.p.x + " " + this.p.y + ")" },
                        sub: function(t) { return new ko(this.p.x - t.getX(), this.p.y - t.getY()) },
                        getY: function() { return this.p.y },
                        classify: function(t, e) {
                            var i = this,
                                n = e.sub(t),
                                r = i.sub(t),
                                o = n.crossProduct(r);
                            return o > 0 ? ko.LEFT : 0 > o ? ko.RIGHT : n.getX() * r.getX() < 0 || n.getY() * r.getY() < 0 ? ko.BEHIND : n.magn() < r.magn() ? ko.BEYOND : t.equals(i) ? ko.ORIGIN : e.equals(i) ? ko.DESTINATION : ko.BETWEEN
                        },
                        sum: function(t) { return new ko(this.p.x + t.getX(), this.p.y + t.getY()) },
                        distance: function(t, e) { return Math.sqrt(Math.pow(e.getX() - t.getX(), 2) + Math.pow(e.getY() - t.getY(), 2)) },
                        circumRadiusRatio: function(t, e) {
                            var i = this.circleCenter(t, e),
                                n = this.distance(i, t),
                                r = this.distance(this, t),
                                o = this.distance(t, e);
                            return r > o && (r = o), o = this.distance(e, this), r > o && (r = o), n / r
                        },
                        interfaces_: function() { return [] },
                        getClass: function() { return ko }
                    }), ko.interpolateZ = function() {
                        if (3 === arguments.length) {
                            var t = arguments[0],
                                e = arguments[1],
                                i = arguments[2],
                                n = e.distance(i),
                                r = t.distance(e),
                                o = i.z - e.z,
                                s = e.z + o * (r / n);
                            return s
                        }
                        if (4 === arguments.length) {
                            var a = arguments[0],
                                h = arguments[1],
                                l = arguments[2],
                                u = arguments[3],
                                p = h.x,
                                c = h.y,
                                f = l.x - p,
                                g = u.x - p,
                                d = l.y - c,
                                y = u.y - c,
                                m = f * y - g * d,
                                v = a.x - p,
                                b = a.y - c,
                                w = (y * v - g * b) / m,
                                x = (-d * v + f * b) / m,
                                E = h.z + w * (l.z - h.z) + x * (u.z - h.z);
                            return E
                        }
                    }, ko.LEFT = 0, ko.RIGHT = 1, ko.BEYOND = 2, ko.BEHIND = 3, ko.BETWEEN = 4, ko.ORIGIN = 5, ko.DESTINATION = 6, u(To, ko),
                    e(To.prototype, { getConstraint: function() { return this.constraint }, setOnConstraint: function(t) { this._isOnConstraint = t }, merge: function(t) { t._isOnConstraint && (this._isOnConstraint = !0, this.constraint = t.constraint) }, isOnConstraint: function() { return this._isOnConstraint }, setConstraint: function(t) { this._isOnConstraint = !0, this.constraint = t }, interfaces_: function() { return [] }, getClass: function() { return To } }), e(Ao.prototype, {
                        equalsNonOriented: function(t) { return !!this.equalsOriented(t) || !!this.equalsOriented(t.sym()) },
                        toLineSegment: function() { return new pe(this.vertex.getCoordinate(), this.dest().getCoordinate()) },
                        dest: function() { return this.sym().orig() },
                        oNext: function() { return this.next },
                        equalsOriented: function(t) { return !(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate()) || !this.dest().getCoordinate().equals2D(t.dest().getCoordinate())) },
                        dNext: function() { return this.sym().oNext().sym() },
                        lPrev: function() { return this.next.sym() },
                        rPrev: function() { return this.sym().oNext() },
                        rot: function() { return this._rot },
                        oPrev: function() { return this._rot.next._rot },
                        sym: function() { return this._rot._rot },
                        setOrig: function(t) { this.vertex = t },
                        lNext: function() { return this.invRot().oNext().rot() },
                        getLength: function() { return this.orig().getCoordinate().distance(this.dest().getCoordinate()) },
                        invRot: function() { return this._rot.sym() },
                        setDest: function(t) { this.sym().setOrig(t) },
                        setData: function(t) { this.data = t },
                        getData: function() { return this.data },
                        delete: function() { this._rot = null },
                        orig: function() { return this.vertex },
                        rNext: function() { return this._rot.next.invRot() },
                        toString: function() {
                            var t = this.vertex.getCoordinate(),
                                e = this.dest().getCoordinate();
                            return oe.toLineString(t, e)
                        },
                        isLive: function() { return null !== this._rot },
                        getPrimary: function() { return this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0 ? this : this.sym() },
                        dPrev: function() { return this.invRot().oNext().invRot() },
                        setNext: function(t) { this.next = t },
                        interfaces_: function() { return [] },
                        getClass: function() { return Ao }
                    }), Ao.makeEdge = function(t, e) {
                        var i = new Ao,
                            n = new Ao,
                            r = new Ao,
                            o = new Ao;
                        i._rot = n, n._rot = r, r._rot = o, o._rot = i, i.setNext(i), n.setNext(o), r.setNext(r), o.setNext(n);
                        var s = i;
                        return s.setOrig(t), s.setDest(e), s
                    }, Ao.swap = function(t) {
                        var e = t.oPrev(),
                            i = t.sym().oPrev();
                        Ao.splice(t, e), Ao.splice(t.sym(), i), Ao.splice(t, e.lNext()), Ao.splice(t.sym(), i.lNext()), t.setOrig(e.dest()), t.setDest(i.dest())
                    }, Ao.splice = function(t, e) {
                        var i = t.oNext().rot(),
                            n = e.oNext().rot(),
                            r = e.oNext(),
                            o = t.oNext(),
                            s = n.oNext(),
                            a = i.oNext();
                        t.setNext(r), e.setNext(o), i.setNext(s), n.setNext(a)
                    }, Ao.connect = function(t, e) { var i = Ao.makeEdge(t.dest(), e.orig()); return Ao.splice(i, t.lNext()), Ao.splice(i.sym(), e), i }, e(Ro.prototype, {
                        insertSite: function(t) {
                            var e = this.subdiv.locate(t);
                            if (this.subdiv.isVertexOfEdge(e, t)) return e;
                            this.subdiv.isOnEdge(e, t.getCoordinate()) && (e = e.oPrev(), this.subdiv.delete(e.oNext()));
                            var i = this.subdiv.makeEdge(e.orig(), t);
                            Ao.splice(i, e);
                            var n = i;
                            do i = this.subdiv.connect(e, i.sym()), e = i.oPrev(); while (e.lNext() !== n);
                            for (;;) {
                                var r = e.oPrev();
                                if (r.dest().rightOf(e) && t.isInCircle(e.orig(), r.dest(), e.dest())) Ao.swap(e), e = e.oPrev();
                                else {
                                    if (e.oNext() === n) return i;
                                    e = e.oNext().lPrev()
                                }
                            }
                        },
                        insertSites: function(t) {
                            for (var e = t.iterator(); e.hasNext();) {
                                var i = e.next();
                                this.insertSite(i)
                            }
                        },
                        interfaces_: function() { return [] },
                        getClass: function() { return Ro }
                    }), e(_o.prototype, { locate: function(t) {}, interfaces_: function() { return [] }, getClass: function() { return _o } }), e(Po.prototype, { init: function() { this.lastEdge = this.findEdge() }, locate: function(t) { this.lastEdge.isLive() || this.init(); var e = this.subdiv.locateFromEdge(t, this.lastEdge); return this.lastEdge = e, e }, findEdge: function() { var t = this.subdiv.getEdges(); return t.iterator().next() }, interfaces_: function() { return [_o] }, getClass: function() { return Po } }), u(Oo, l), e(Oo.prototype, { getSegment: function() { return this.seg }, interfaces_: function() { return [] }, getClass: function() { return Oo } }), Oo.msgWithSpatial = function(t, e) { return null !== e ? t + " [ " + e + " ]" : t }, e(Do.prototype, { visit: function(t) {}, interfaces_: function() { return [] }, getClass: function() { return Do } }), e(Fo.prototype, {
                        getTriangleVertices: function(t) { var e = new jo; return this.visitTriangles(e, t), e.getTriangleVertices() },
                        isFrameVertex: function(t) { return !!t.equals(this.frameVertex[0]) || (!!t.equals(this.frameVertex[1]) || !!t.equals(this.frameVertex[2])) },
                        isVertexOfEdge: function(t, e) { return !(!e.equals(t.orig(), this.tolerance) && !e.equals(t.dest(), this.tolerance)) },
                        connect: function(t, e) { var i = Ao.connect(t, e); return this.quadEdges.add(i), i },
                        getVoronoiCellPolygon: function(t, e) {
                            var i = new x,
                                n = t;
                            do {
                                var r = t.rot().orig().getCoordinate();
                                i.add(r), t = t.oPrev()
                            } while (t !== n);
                            var o = new E;
                            o.addAll(i, !1), o.closeRing(), o.size() < 4 && (O.out.println(o), o.add(o.get(o.size() - 1), !0));
                            var s = o.toCoordinateArray(),
                                a = e.createPolygon(e.createLinearRing(s), null),
                                h = n.orig();
                            return a.setUserData(h.getCoordinate()), a
                        },
                        setLocator: function(t) { this.locator = t },
                        initSubdiv: function() {
                            var t = this.makeEdge(this.frameVertex[0], this.frameVertex[1]),
                                e = this.makeEdge(this.frameVertex[1], this.frameVertex[2]);
                            Ao.splice(t.sym(), e);
                            var i = this.makeEdge(this.frameVertex[2], this.frameVertex[0]);
                            return Ao.splice(e.sym(), i), Ao.splice(i.sym(), t), t
                        },
                        isFrameBorderEdge: function(t) {
                            var e = new Array(3).fill(null);
                            Fo.getTriangleEdges(t, e);
                            var i = new Array(3).fill(null);
                            Fo.getTriangleEdges(t.sym(), i);
                            var n = t.lNext().dest();
                            if (this.isFrameVertex(n)) return !0;
                            var r = t.sym().lNext().dest();
                            return !!this.isFrameVertex(r)
                        },
                        makeEdge: function(t, e) { var i = Ao.makeEdge(t, e); return this.quadEdges.add(i), i },
                        visitTriangles: function(t, e) {
                            this.visitedKey++;
                            var i = new de;
                            i.push(this.startingEdge);
                            for (var n = new J; !i.empty();) {
                                var r = i.pop();
                                if (!n.contains(r)) {
                                    var o = this.fetchTriangleToVisit(r, i, e, n);
                                    null !== o && t.visit(o)
                                }
                            }
                        },
                        isFrameEdge: function(t) { return !(!this.isFrameVertex(t.orig()) && !this.isFrameVertex(t.dest())) },
                        isOnEdge: function(t, e) { this.seg.setCoordinates(t.orig().getCoordinate(), t.dest().getCoordinate()); var i = this.seg.distance(e); return i < this.edgeCoincidenceTolerance },
                        getEnvelope: function() { return new S(this.frameEnv) },
                        createFrame: function(t) {
                            var e = t.getWidth(),
                                i = t.getHeight(),
                                n = 0;
                            n = e > i ? 10 * e : 10 * i, this.frameVertex[0] = new ko((t.getMaxX() + t.getMinX()) / 2, t.getMaxY() + n), this.frameVertex[1] = new ko(t.getMinX() - n, t.getMinY() - n), this.frameVertex[2] = new ko(t.getMaxX() + n, t.getMinY() - n), this.frameEnv = new S(this.frameVertex[0].getCoordinate(), this.frameVertex[1].getCoordinate()), this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate())
                        },
                        getTriangleCoordinates: function(t) { var e = new zo; return this.visitTriangles(e, t), e.getTriangles() },
                        getVertices: function(t) {
                            for (var e = new J, i = this.quadEdges.iterator(); i.hasNext();) {
                                var n = i.next(),
                                    r = n.orig();
                                !t && this.isFrameVertex(r) || e.add(r);
                                var o = n.dest();
                                !t && this.isFrameVertex(o) || e.add(o)
                            }
                            return e
                        },
                        fetchTriangleToVisit: function(t, e, i, n) {
                            var r = t,
                                o = 0,
                                s = !1;
                            do {
                                this.triEdges[o] = r, this.isFrameEdge(r) && (s = !0);
                                var a = r.sym();
                                n.contains(a) || e.push(a), n.add(r), o++, r = r.lNext()
                            } while (r !== t);
                            return s && !i ? null : this.triEdges
                        },
                        getEdges: function() {
                            if (0 === arguments.length) return this.quadEdges;
                            if (1 === arguments.length) {
                                for (var t = arguments[0], e = this.getPrimaryEdges(!1), i = new Array(e.size()).fill(null), n = 0, r = e.iterator(); r.hasNext();) {
                                    var o = r.next();
                                    i[n++] = t.createLineString([o.orig().getCoordinate(), o.dest().getCoordinate()])
                                }
                                return t.createMultiLineString(i)
                            }
                        },
                        getVertexUniqueEdges: function(t) {
                            for (var e = new x, i = new J, n = this.quadEdges.iterator(); n.hasNext();) {
                                var r = n.next(),
                                    o = r.orig();
                                i.contains(o) || (i.add(o), !t && this.isFrameVertex(o) || e.add(r));
                                var s = r.sym(),
                                    a = s.orig();
                                i.contains(a) || (i.add(a), !t && this.isFrameVertex(a) || e.add(s))
                            }
                            return e
                        },
                        getTriangleEdges: function(t) { var e = new Bo; return this.visitTriangles(e, t), e.getTriangleEdges() },
                        getPrimaryEdges: function(t) {
                            this.visitedKey++;
                            var e = new x,
                                i = new de;
                            i.push(this.startingEdge);
                            for (var n = new J; !i.empty();) { var r = i.pop(); if (!n.contains(r)) { var o = r.getPrimary();!t && this.isFrameEdge(o) || e.add(o), i.push(r.oNext()), i.push(r.sym().oNext()), n.add(r), n.add(r.sym()) } }
                            return e
                        },
                        delete: function(t) {
                            Ao.splice(t, t.oPrev()), Ao.splice(t.sym(), t.sym().oPrev());
                            var e = t.sym(),
                                i = t.rot(),
                                n = t.rot().sym();
                            this.quadEdges.remove(t), this.quadEdges.remove(e), this.quadEdges.remove(i), this.quadEdges.remove(n), t.delete(), e.delete(), i.delete(), n.delete()
                        },
                        locateFromEdge: function(t, e) {
                            for (var i = 0, n = this.quadEdges.size(), r = e;;) {
                                if (i++, i > n) throw new Oo(r.toLineSegment());
                                if (t.equals(r.orig()) || t.equals(r.dest())) break;
                                if (t.rightOf(r)) r = r.sym();
                                else if (t.rightOf(r.oNext())) {
                                    if (t.rightOf(r.dPrev())) break;
                                    r = r.dPrev()
                                } else r = r.oNext()
                            }
                            return r
                        },
                        getTolerance: function() { return this.tolerance },
                        getVoronoiCellPolygons: function(t) {
                            this.visitTriangles(new Uo, !0);
                            for (var e = new x, i = this.getVertexUniqueEdges(!1), n = i.iterator(); n.hasNext();) {
                                var r = n.next();
                                e.add(this.getVoronoiCellPolygon(r, t))
                            }
                            return e
                        },
                        getVoronoiDiagram: function(t) { var e = this.getVoronoiCellPolygons(t); return t.createGeometryCollection(ne.toGeometryArray(e)) },
                        getTriangles: function(t) {
                            for (var e = this.getTriangleCoordinates(!1), i = new Array(e.size()).fill(null), n = 0, r = e.iterator(); r.hasNext();) {
                                var o = r.next();
                                i[n++] = t.createPolygon(t.createLinearRing(o), null)
                            }
                            return t.createGeometryCollection(i)
                        },
                        insertSite: function(t) {
                            var e = this.locate(t);
                            if (t.equals(e.orig(), this.tolerance) || t.equals(e.dest(), this.tolerance)) return e;
                            var i = this.makeEdge(e.orig(), t);
                            Ao.splice(i, e);
                            var n = i;
                            do i = this.connect(e, i.sym()), e = i.oPrev(); while (e.lNext() !== n);
                            return n
                        },
                        locate: function() {
                            if (1 === arguments.length) { if (arguments[0] instanceof ko) { var t = arguments[0]; return this.locator.locate(t) } if (arguments[0] instanceof f) { var e = arguments[0]; return this.locator.locate(new ko(e)) } } else if (2 === arguments.length) {
                                var i = arguments[0],
                                    n = arguments[1],
                                    r = this.locator.locate(new ko(i));
                                if (null === r) return null;
                                var o = r;
                                r.dest().getCoordinate().equals2D(i) && (o = r.sym());
                                var s = o;
                                do {
                                    if (s.dest().getCoordinate().equals2D(n)) return s;
                                    s = s.oNext()
                                } while (s !== o);
                                return null
                            }
                        },
                        interfaces_: function() { return [] },
                        getClass: function() { return Fo }
                    }), Fo.getTriangleEdges = function(t, e) { if (e[0] = t, e[1] = e[0].lNext(), e[2] = e[1].lNext(), e[2].lNext() !== e[0]) throw new n("Edges do not form a triangle") }, e(Uo.prototype, { visit: function(t) { for (var e = t[0].orig().getCoordinate(), i = t[1].orig().getCoordinate(), n = t[2].orig().getCoordinate(), r = Nn.circumcentre(e, i, n), o = new ko(r), s = 0; 3 > s; s++) t[s].rot().setOrig(o) }, interfaces_: function() { return [Do] }, getClass: function() { return Uo } }), e(Bo.prototype, { getTriangleEdges: function() { return this.triList }, visit: function(t) { this.triList.add(t.clone()) }, interfaces_: function() { return [Do] }, getClass: function() { return Bo } }), e(jo.prototype, { visit: function(t) { this.triList.add([t[0].orig(), t[1].orig(), t[2].orig()]) }, getTriangleVertices: function() { return this.triList }, interfaces_: function() { return [Do] }, getClass: function() { return jo } }), e(zo.prototype, {
                        checkTriangleSize: function(t) {
                            var e = "";
                            t.length >= 2 ? e = oe.toLineString(t[0], t[1]) : t.length >= 1 && (e = oe.toPoint(t[0]))
                        },
                        visit: function(t) {
                            this.coordList.clear();
                            for (var e = 0; 3 > e; e++) {
                                var i = t[e].orig();
                                this.coordList.add(i.getCoordinate())
                            }
                            if (this.coordList.size() > 0) {
                                this.coordList.closeRing();
                                var n = this.coordList.toCoordinateArray();
                                if (4 !== n.length) return null;
                                this.triCoords.add(n)
                            }
                        },
                        getTriangles: function() { return this.triCoords },
                        interfaces_: function() { return [Do] },
                        getClass: function() { return zo }
                    }), Fo.TriangleCircumcentreVisitor = Uo, Fo.TriangleEdgesListVisitor = Bo, Fo.TriangleVertexListVisitor = jo, Fo.TriangleCoordinatesVisitor = zo, Fo.EDGE_COINCIDENCE_TOL_FACTOR = 1e3, e(Go.prototype, { getLineSegment: function() { return this.ls }, getEndZ: function() { var t = this.ls.getCoordinate(1); return t.z }, getStartZ: function() { var t = this.ls.getCoordinate(0); return t.z }, intersection: function(t) { return this.ls.intersection(t.getLineSegment()) }, getStart: function() { return this.ls.getCoordinate(0) }, getEnd: function() { return this.ls.getCoordinate(1) }, getEndY: function() { var t = this.ls.getCoordinate(1); return t.y }, getStartX: function() { var t = this.ls.getCoordinate(0); return t.x }, equalsTopo: function(t) { return this.ls.equalsTopo(t.getLineSegment()) }, getStartY: function() { var t = this.ls.getCoordinate(0); return t.y }, setData: function(t) { this.data = t }, getData: function() { return this.data }, getEndX: function() { var t = this.ls.getCoordinate(1); return t.x }, toString: function() { return this.ls.toString() }, interfaces_: function() { return [] }, getClass: function() { return Go } }), e(qo.prototype, { visit: function(t) {}, interfaces_: function() { return [] }, getClass: function() { return qo } }), e(Vo.prototype, { isRepeated: function() { return this.count > 1 }, getRight: function() { return this.right }, getCoordinate: function() { return this.p }, setLeft: function(t) { this.left = t }, getX: function() { return this.p.x }, getData: function() { return this.data }, getCount: function() { return this.count }, getLeft: function() { return this.left }, getY: function() { return this.p.y }, increment: function() { this.count = this.count + 1 }, setRight: function(t) { this.right = t }, interfaces_: function() { return [] }, getClass: function() { return Vo } }), e(Wo.prototype, {
                        insert: function() {
                            if (1 === arguments.length) { var t = arguments[0]; return this.insert(t, null) }
                            if (2 === arguments.length) {
                                var e = arguments[0],
                                    i = arguments[1];
                                if (null === this.root) return this.root = new Vo(e, i), this.root;
                                if (this.tolerance > 0) { var n = this.findBestMatchNode(e); if (null !== n) return n.increment(), n }
                                return this.insertExact(e, i)
                            }
                        },
                        query: function() {
                            var t = arguments,
                                e = this;
                            if (1 === arguments.length) {
                                var i = arguments[0],
                                    n = new x;
                                return this.query(i, n), n
                            }
                            if (2 === arguments.length)
                                if (arguments[0] instanceof S && M(arguments[1], v)) ! function() {
                                    var i = t[0],
                                        n = t[1];
                                    e.queryNode(e.root, i, !0, { interfaces_: function() { return [qo] }, visit: function(t) { n.add(t) } })
                                }();
                                else if (arguments[0] instanceof S && M(arguments[1], qo)) {
                                var r = arguments[0],
                                    o = arguments[1];
                                this.queryNode(this.root, r, !0, o)
                            }
                        },
                        queryNode: function(t, e, i, n) {
                            if (null === t) return null;
                            var r = null,
                                o = null,
                                s = null;
                            i ? (r = e.getMinX(), o = e.getMaxX(), s = t.getX()) : (r = e.getMinY(), o = e.getMaxY(), s = t.getY());
                            var a = s > r,
                                h = o >= s;
                            a && this.queryNode(t.getLeft(), e, !i, n), e.contains(t.getCoordinate()) && n.visit(t), h && this.queryNode(t.getRight(), e, !i, n)
                        },
                        findBestMatchNode: function(t) { var e = new Xo(t, this.tolerance); return this.query(e.queryEnvelope(), e), e.getNode() },
                        isEmpty: function() { return null === this.root },
                        insertExact: function(t, e) {
                            for (var i = this.root, n = this.root, r = !0, o = !0; null !== i;) {
                                if (null !== i) { var s = t.distance(i.getCoordinate()) <= this.tolerance; if (s) return i.increment(), i }
                                o = r ? t.x < i.getX() : t.y < i.getY(), n = i, i = o ? i.getLeft() : i.getRight(), r = !r
                            }
                            this.numberOfNodes = this.numberOfNodes + 1;
                            var a = new Vo(t, e);
                            return o ? n.setLeft(a) : n.setRight(a), a
                        },
                        interfaces_: function() { return [] },
                        getClass: function() { return Wo }
                    }), Wo.toCoordinates = function() {
                        if (1 === arguments.length) { var t = arguments[0]; return Wo.toCoordinates(t, !1) }
                        if (2 === arguments.length) {
                            for (var e = arguments[0], i = arguments[1], n = new E, r = e.iterator(); r.hasNext();)
                                for (var o = r.next(), s = i ? o.getCount() : 1, a = 0; s > a; a++) n.add(o.getCoordinate(), !0);
                            return n.toCoordinateArray()
                        }
                    }, e(Xo.prototype, {
                        visit: function(t) {
                            var e = this.p.distance(t.getCoordinate()),
                                i = e <= this.tolerance;
                            if (!i) return null;
                            var n = !1;
                            (null === this.matchNode || e < this.matchDist || null !== this.matchNode && e === this.matchDist && t.getCoordinate().compareTo(this.matchNode.getCoordinate()) < 1) && (n = !0), n && (this.matchNode = t, this.matchDist = e)
                        },
                        queryEnvelope: function() { var t = new S(this.p); return t.expandBy(this.tolerance), t },
                        getNode: function() { return this.matchNode },
                        interfaces_: function() { return [qo] },
                        getClass: function() { return Xo }
                    }), Wo.BestMatchVisitor = Xo, e(Ho.prototype, {
                        getInitialVertices: function() { return this.initialVertices },
                        getKDT: function() { return this.kdt },
                        enforceConstraints: function() {
                            this.addConstraintVertices();
                            var t = 0,
                                e = 0;
                            do e = this.enforceGabriel(this.segments), t++; while (e > 0 && t < Ho.MAX_SPLIT_ITER)
                        },
                        insertSites: function(t) {
                            for (var e = t.iterator(); e.hasNext();) {
                                var i = e.next();
                                this.insertSite(i)
                            }
                        },
                        getVertexFactory: function() { return this.vertexFactory },
                        getPointArray: function() {
                            for (var t = new Array(this.initialVertices.size() + this.segVertices.size()).fill(null), e = 0, i = this.initialVertices.iterator(); i.hasNext();) {
                                var n = i.next();
                                t[e++] = n.getCoordinate()
                            }
                            for (var r = this.segVertices.iterator(); r.hasNext();) {
                                var n = r.next();
                                t[e++] = n.getCoordinate()
                            }
                            return t
                        },
                        setConstraints: function(t, e) { this.segments = t, this.segVertices = e },
                        computeConvexHull: function() {
                            var t = new ne,
                                e = this.getPointArray(),
                                i = new me(e, t);
                            this.convexHull = i.getConvexHull()
                        },
                        addConstraintVertices: function() { this.computeConvexHull(), this.insertSites(this.segVertices) },
                        findNonGabrielPoint: function(t) {
                            var e = t.getStart(),
                                i = t.getEnd(),
                                n = new f((e.x + i.x) / 2, (e.y + i.y) / 2),
                                o = e.distance(n),
                                s = new S(n);
                            s.expandBy(o);
                            for (var a = this.kdt.query(s), h = null, l = r.MAX_VALUE, u = a.iterator(); u.hasNext();) {
                                var p = u.next(),
                                    c = p.getCoordinate();
                                if (!c.equals2D(e) && !c.equals2D(i)) {
                                    var g = n.distance(c);
                                    if (o > g) {
                                        var d = g;
                                        (null === h || l > d) && (h = c, l = d)
                                    }
                                }
                            }
                            return h
                        },
                        getConstraintSegments: function() { return this.segments },
                        setSplitPointFinder: function(t) { this.splitFinder = t },
                        getConvexHull: function() { return this.convexHull },
                        getTolerance: function() { return this.tolerance },
                        enforceGabriel: function(t) {
                            for (var e = new x, i = 0, n = new x, r = t.iterator(); r.hasNext();) {
                                var o = r.next(),
                                    s = this.findNonGabrielPoint(o);
                                if (null !== s) {
                                    this.splitPt = this.splitFinder.findSplitPoint(o, s);
                                    var a = this.createVertex(this.splitPt, o),
                                        h = (this.insertSite(a), new Go(o.getStartX(), o.getStartY(), o.getStartZ(), a.getX(), a.getY(), a.getZ(), o.getData())),
                                        l = new Go(a.getX(), a.getY(), a.getZ(), o.getEndX(), o.getEndY(), o.getEndZ(), o.getData());
                                    e.add(h), e.add(l), n.add(o), i += 1
                                }
                            }
                            return t.removeAll(n), t.addAll(e), i
                        },
                        createVertex: function() {
                            if (1 === arguments.length) {
                                var t = arguments[0],
                                    e = null;
                                return e = null !== this.vertexFactory ? this.vertexFactory.createVertex(t, null) : new To(t)
                            }
                            if (2 === arguments.length) {
                                var i = arguments[0],
                                    n = arguments[1],
                                    e = null;
                                return e = null !== this.vertexFactory ? this.vertexFactory.createVertex(i, n) : new To(i), e.setOnConstraint(!0), e
                            }
                        },
                        getSubdivision: function() { return this.subdiv },
                        computeBoundingBox: function() {
                            var t = Ho.computeVertexEnvelope(this.initialVertices),
                                e = Ho.computeVertexEnvelope(this.segVertices),
                                i = new S(t);
                            i.expandToInclude(e);
                            var n = .2 * i.getWidth(),
                                r = .2 * i.getHeight(),
                                o = Math.max(n, r);
                            this.computeAreaEnv = new S(i), this.computeAreaEnv.expandBy(o)
                        },
                        setVertexFactory: function(t) { this.vertexFactory = t },
                        formInitialDelaunay: function() { this.computeBoundingBox(), this.subdiv = new Fo(this.computeAreaEnv, this.tolerance), this.subdiv.setLocator(new Po(this.subdiv)), this.incDel = new Ro(this.subdiv), this.insertSites(this.initialVertices) },
                        insertSite: function() {
                            if (arguments[0] instanceof To) {
                                var t = arguments[0],
                                    e = this.kdt.insert(t.getCoordinate(), t);
                                if (e.isRepeated()) { var i = e.getData(); return i.merge(t), i }
                                return this.incDel.insertSite(t), t
                            }
                            if (arguments[0] instanceof f) {
                                var n = arguments[0];
                                this.insertSite(this.createVertex(n))
                            }
                        },
                        interfaces_: function() { return [] },
                        getClass: function() { return Ho }
                    }), Ho.computeVertexEnvelope = function(t) {
                        for (var e = new S, i = t.iterator(); i.hasNext();) {
                            var n = i.next();
                            e.expandToInclude(n.getCoordinate())
                        }
                        return e
                    }, Ho.MAX_SPLIT_ITER = 99, e(Yo.prototype, {
                        create: function() {
                            if (null !== this.subdiv) return null;
                            var t = Yo.envelope(this.siteCoords),
                                e = Yo.toVertices(this.siteCoords);
                            this.subdiv = new Fo(t, this.tolerance);
                            var i = new Ro(this.subdiv);
                            i.insertSites(e)
                        },
                        setTolerance: function(t) { this.tolerance = t },
                        setSites: function() {
                            if (arguments[0] instanceof B) {
                                var t = arguments[0];
                                this.siteCoords = Yo.extractUniqueCoordinates(t)
                            } else if (M(arguments[0], y)) {
                                var e = arguments[0];
                                this.siteCoords = Yo.unique(X.toCoordinateArray(e))
                            }
                        },
                        getEdges: function(t) { return this.create(), this.subdiv.getEdges(t) },
                        getSubdivision: function() { return this.create(), this.subdiv },
                        getTriangles: function(t) { return this.create(), this.subdiv.getTriangles(t) },
                        interfaces_: function() { return [] },
                        getClass: function() { return Yo }
                    }), Yo.extractUniqueCoordinates = function(t) { if (null === t) return new E; var e = t.getCoordinates(); return Yo.unique(e) }, Yo.envelope = function(t) {
                        for (var e = new S, i = t.iterator(); i.hasNext();) {
                            var n = i.next();
                            e.expandToInclude(n)
                        }
                        return e
                    }, Yo.unique = function(t) {
                        var e = X.copyDeep(t);
                        ht.sort(e);
                        var i = new E(e, !1);
                        return i
                    }, Yo.toVertices = function(t) {
                        for (var e = new x, i = t.iterator(); i.hasNext();) {
                            var n = i.next();
                            e.add(new ko(n))
                        }
                        return e
                    }, e(Ko.prototype, {
                        createSiteVertices: function(t) {
                            for (var e = new x, i = t.iterator(); i.hasNext();) {
                                var n = i.next();
                                this.constraintVertexMap.containsKey(n) || e.add(new To(n))
                            }
                            return e
                        },
                        create: function() {
                            if (null !== this.subdiv) return null;
                            var t = Yo.envelope(this.siteCoords),
                                e = new x;
                            null !== this.constraintLines && (t.expandToInclude(this.constraintLines.getEnvelopeInternal()), this.createVertices(this.constraintLines), e = Ko.createConstraintSegments(this.constraintLines));
                            var i = this.createSiteVertices(this.siteCoords),
                                n = new Ho(i, this.tolerance);
                            n.setConstraints(e, new x(this.constraintVertexMap.values())), n.formInitialDelaunay(), n.enforceConstraints(), this.subdiv = n.getSubdivision()
                        },
                        setTolerance: function(t) { this.tolerance = t },
                        setConstraints: function(t) { this.constraintLines = t },
                        setSites: function(t) { this.siteCoords = Yo.extractUniqueCoordinates(t) },
                        getEdges: function(t) { return this.create(), this.subdiv.getEdges(t) },
                        getSubdivision: function() { return this.create(), this.subdiv },
                        getTriangles: function(t) { return this.create(), this.subdiv.getTriangles(t) },
                        createVertices: function(t) {
                            for (var e = t.getCoordinates(), i = 0; i < e.length; i++) {
                                var n = new To(e[i]);
                                this.constraintVertexMap.put(e[i], n)
                            }
                        },
                        interfaces_: function() { return [] },
                        getClass: function() { return Ko }
                    }), Ko.createConstraintSegments = function() {
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = zi.getLines(t), i = new x, n = e.iterator(); n.hasNext();) {
                                var r = n.next();
                                Ko.createConstraintSegments(r, i)
                            }
                            return i
                        }
                        if (2 === arguments.length)
                            for (var o = arguments[0], s = arguments[1], a = o.getCoordinates(), n = 1; n < a.length; n++) s.add(new Go(a[n - 1], a[n]))
                    }, e($o.prototype, {
                        create: function() {
                            if (null !== this.subdiv) return null;
                            var t = Yo.envelope(this.siteCoords);
                            this.diagramEnv = t;
                            var e = Math.max(this.diagramEnv.getWidth(), this.diagramEnv.getHeight());
                            this.diagramEnv.expandBy(e), null !== this.clipEnv && this.diagramEnv.expandToInclude(this.clipEnv);
                            var i = Yo.toVertices(this.siteCoords);
                            this.subdiv = new Fo(t, this.tolerance);
                            var n = new Ro(this.subdiv);
                            n.insertSites(i)
                        },
                        getDiagram: function(t) { this.create(); var e = this.subdiv.getVoronoiDiagram(t); return $o.clipGeometryCollection(e, this.diagramEnv) },
                        setTolerance: function(t) { this.tolerance = t },
                        setSites: function() {
                            if (arguments[0] instanceof B) {
                                var t = arguments[0];
                                this.siteCoords = Yo.extractUniqueCoordinates(t)
                            } else if (M(arguments[0], y)) {
                                var e = arguments[0];
                                this.siteCoords = Yo.unique(X.toCoordinateArray(e))
                            }
                        },
                        setClipEnvelope: function(t) { this.clipEnv = t },
                        getSubdivision: function() { return this.create(), this.subdiv },
                        interfaces_: function() { return [] },
                        getClass: function() { return $o }
                    }), $o.clipGeometryCollection = function(t, e) {
                        for (var i = t.getFactory().toGeometry(e), n = new x, r = 0; r < t.getNumGeometries(); r++) {
                            var o = t.getGeometryN(r),
                                s = null;
                            e.contains(o.getEnvelopeInternal()) ? s = o : e.intersects(o.getEnvelopeInternal()) && (s = i.intersection(o), s.setUserData(o.getUserData())), null === s || s.isEmpty() || n.add(s)
                        }
                        return t.getFactory().createGeometryCollection(ne.toGeometryArray(n))
                    };
                var Os = Object.freeze({ ConformingDelaunayTriangulationBuilder: Ko, DelaunayTriangulationBuilder: Yo, VoronoiDiagramBuilder: $o });
                e(Zo.prototype, { interfaces_: function() { return [] }, getClass: function() { return Zo } }), Zo.union = function(t, e) { if (t.isEmpty() || e.isEmpty()) { if (t.isEmpty() && e.isEmpty()) return nn.createEmptyResult(nn.UNION, t, e, t.getFactory()); if (t.isEmpty()) return e.copy(); if (e.isEmpty()) return t.copy() } return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), on.overlayOp(t, e, nn.UNION) }, e(B.prototype, {
                    equalsTopo: function(t) { return !!this.getEnvelopeInternal().equals(t.getEnvelopeInternal()) && Jr.relate(this, t).isEquals(this.getDimension(), t.getDimension()) },
                    union: function() { if (0 === arguments.length) return no.union(this); if (1 === arguments.length) { var t = arguments[0]; return Zo.union(this, t) } },
                    isValid: function() { return lo.isValid(this) },
                    intersection: function(t) { if (this.isEmpty() || t.isEmpty()) return nn.createEmptyResult(nn.INTERSECTION, this, t, this.factory); if (this.isGeometryCollection()) { var e = t; return li.map(this, { interfaces_: function() { return [MapOp] }, map: function(t) { return t.intersection(e) } }) } return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), on.overlayOp(this, t, nn.INTERSECTION) },
                    covers: function(t) { return Jr.covers(this, t) },
                    coveredBy: function(t) { return Jr.coveredBy(this, t) },
                    touches: function(t) { return Jr.touches(this, t) },
                    intersects: function(t) { return Jr.intersects(this, t) },
                    within: function(t) { return Jr.within(this, t) },
                    overlaps: function(t) { return Jr.overlaps(this, t) },
                    disjoint: function(t) { return Jr.disjoint(this, t) },
                    crosses: function(t) { return Jr.crosses(this, t) },
                    buffer: function() {
                        if (1 === arguments.length) { var t = arguments[0]; return gr.bufferOp(this, t) }
                        if (2 === arguments.length) {
                            var e = arguments[0],
                                i = arguments[1];
                            return gr.bufferOp(this, e, i)
                        }
                        if (3 === arguments.length) {
                            var n = arguments[0],
                                r = arguments[1],
                                o = arguments[2];
                            return gr.bufferOp(this, n, r, o)
                        }
                    },
                    convexHull: function() { return new me(this).getConvexHull() },
                    relate: function() { for (var t = arguments.length, e = Array(t), i = 0; t > i; i++) e[i] = arguments[i]; return Jr.relate.apply(Jr, [this].concat(e)) },
                    getCentroid: function() { if (this.isEmpty()) return this.factory.createPoint(); var t = fe.getCentroid(this); return this.createPointFromInternalCoord(t, this) },
                    getInteriorPoint: function() {
                        if (this.isEmpty()) return this.factory.createPoint();
                        var t = null,
                            e = this.getDimension();
                        if (0 === e) {
                            var i = new ln(this);
                            t = i.getInteriorPoint()
                        } else if (1 === e) {
                            var i = new hn(this);
                            t = i.getInteriorPoint()
                        } else {
                            var i = new sn(this);
                            t = i.getInteriorPoint()
                        }
                        return this.createPointFromInternalCoord(t, this)
                    },
                    symDifference: function(t) { if (this.isEmpty() || t.isEmpty()) { if (this.isEmpty() && t.isEmpty()) return nn.createEmptyResult(nn.SYMDIFFERENCE, this, t, this.factory); if (this.isEmpty()) return t.copy(); if (t.isEmpty()) return this.copy() } return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), on.overlayOp(this, t, nn.SYMDIFFERENCE) },
                    createPointFromInternalCoord: function(t, e) { return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t) },
                    toText: function() { var t = new oe; return t.write(this) },
                    toString: function() { this.toText() },
                    contains: function(t) { return Jr.contains(this, t) },
                    difference: function(t) { return this.isEmpty() ? nn.createEmptyResult(nn.DIFFERENCE, this, t, this.factory) : t.isEmpty() ? this.copy() : (this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), on.overlayOp(this, t, nn.DIFFERENCE)) },
                    isSimple: function() { var t = new Hn(this); return t.isSimple() },
                    isWithinDistance: function(t, e) { var i = this.getEnvelopeInternal().distance(t.getEnvelopeInternal()); return !(i > e) && br.isWithinDistance(this, t, e) },
                    distance: function(t) { return br.distance(this, t) },
                    isEquivalentClass: function(t) { return this.getClass() === t.getClass() }
                });
                var Ds = "1.2.0 (d405c89)";
                t.version = Ds, t.algorithm = cs, t.densify = fs, t.dissolve = gs, t.geom = us, t.geomgraph = ds, t.index = vs, t.io = Es, t.noding = Ss, t.operation = Rs, t.precision = _s, t.simplify = Ps, t.triangulate = Os
            })
        }, {}],
        22: [function(t, e, i) {
            function n(t) {
                if ("Feature" === t.type && "Polygon" === t.geometry.type) {
                    var i = [];
                    r(t, function(t) { i.push(t) });
                    var n, l, u, p, c, f, g, d, y = o(t),
                        m = y.geometry.coordinates,
                        v = 0,
                        b = 0,
                        w = 0,
                        x = i.map(function(t) { return [t[0] - m[0], t[1] - m[1]] });
                    for (n = 0; n < i.length - 1; n++) l = x[n], p = l[0], f = l[1], u = x[n + 1], c = u[0], g = u[1], d = p * g - c * f, w += d, v += (p + c) * d, b += (f + g) * d;
                    if (0 === w) return y;
                    var E = .5 * w,
                        S = 1 / (6 * E);
                    return h([m[0] + S * v, m[1] + S * b])
                }
                var N = s(a(t));
                return N ? e.exports(N) : o(t)
            }
            var r = t("@turf/meta").coordEach,
                o = t("@turf/centroid"),
                s = t("@turf/convex"),
                a = t("@turf/explode"),
                h = t("@turf/helpers").point;
            e.exports = n
        }, { "@turf/centroid": 23, "@turf/convex": 24, "@turf/explode": 25, "@turf/helpers": 26, "@turf/meta": 27 }],
        23: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-centroid") }, { "/Users/tmcw/src/turf/packages/turf-centroid": 31 }],
        24: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-convex") }, { "/Users/tmcw/src/turf/packages/turf-convex": 45 }],
        25: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-explode") }, { "/Users/tmcw/src/turf/packages/turf-explode": 75 }],
        26: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        27: [function(t, e, i) { arguments[4][12][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-meta": 113, dup: 12 }],
        28: [function(t, e, i) {
            var n = t("@turf/bbox"),
                r = t("@turf/helpers").point;
            e.exports = function(t) {
                var e = n(t),
                    i = (e[0] + e[2]) / 2,
                    o = (e[1] + e[3]) / 2;
                return r([i, o])
            }
        }, { "@turf/bbox": 29, "@turf/helpers": 30 }],
        29: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-bbox") }, { "/Users/tmcw/src/turf/packages/turf-bbox": 11 }],
        30: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        31: [function(t, e, i) {
            var n = t("@turf/meta").coordEach,
                r = t("@turf/helpers").point;
            e.exports = function(t) {
                var e = 0,
                    i = 0,
                    o = 0;
                return n(t, function(t) { e += t[0], i += t[1], o++ }, !0), r([e / o, i / o])
            }
        }, { "@turf/helpers": 32, "@turf/meta": 33 }],
        32: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        33: [function(t, e, i) { arguments[4][12][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-meta": 113, dup: 12 }],
        34: [function(t, e, i) {
            var n = t("@turf/destination"),
                r = t("@turf/helpers"),
                o = r.polygon;
            e.exports = function(t, e, i, r) { i = i || 64; for (var s = [], a = 0; a < i; a++) s.push(n(t, e, 360 * a / i, r).geometry.coordinates); return s.push(s[0]), o([s]) }
        }, { "@turf/destination": 35, "@turf/helpers": 36 }],
        35: [function(t, e, i) { arguments[4][3][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-destination": 64, dup: 3 }],
        36: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        37: [function(t, e, i) {
            var n = t("@turf/inside");
            e.exports = function(t, e, i, r) {
                return t.features.forEach(function(t) {
                    var o = e.features.filter(function(e) { return n(e, t) }).map(function(t) { return t.properties[i] });
                    t.properties || (t.properties = {}), t.properties[r] = o
                }), t
            }
        }, { "@turf/inside": 38 }],
        38: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-inside") }, { "/Users/tmcw/src/turf/packages/turf-inside": 84 }],
        39: [function(t, e, i) {
            var n = t("@turf/meta");
            e.exports = function(t) {
                function e(t, e, n) { n ? i[e].coordinates = i[e].coordinates.concat(t.geometry.coordinates) : i[e].coordinates.push(t.geometry.coordinates), i[e].properties.push(t.properties) }
                var i = { MultiPoint: { coordinates: [], properties: [] }, MultiLineString: { coordinates: [], properties: [] }, MultiPolygon: { coordinates: [], properties: [] } },
                    r = Object.keys(i).reduce(function(t, e) { return t[e.replace("Multi", "")] = e, t }, {});
                return n.featureEach(t, function(t) { t.geometry && (i[t.geometry.type] ? e(t, t.geometry.type, !0) : r[t.geometry.type] && e(t, r[t.geometry.type], !1)) }), { type: "FeatureCollection", features: Object.keys(i).filter(function(t) { return i[t].coordinates.length }).sort().map(function(t) { return { type: "Feature", properties: { collectedProperties: i[t].properties }, geometry: { type: t, coordinates: i[t].coordinates } } }) }
            }
        }, { "@turf/meta": 40 }],
        40: [function(t, e, i) { arguments[4][12][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-meta": 113, dup: 12 }],
        41: [function(t, e, i) {
            function n(t, e, i) {
                function n(t) {
                    var n = t.geometry.coordinates[0][0],
                        r = t.geometry.coordinates[0][1],
                        o = t.geometry.coordinates[0][2],
                        s = a(n, r, i),
                        h = a(r, o, i),
                        l = a(n, o, i);
                    return s <= e && h <= e && l <= e
                }
                if ("number" != typeof e) throw new Error("maxEdge parameter is required");
                if ("string" != typeof i) throw new Error("units parameter is required");
                var s = o(t),
                    h = s.features.filter(n);
                return s.features = h, r(s)
            }

            function r(t) {
                for (var e = JSON.parse(JSON.stringify(t.features[0])), i = t.features, n = 0, r = i.length; n < r; n++) {
                    var o = i[n];
                    o.geometry && (e = s(e, o))
                }
                return e
            }
            var o = t("@turf/tin"),
                s = t("@turf/union"),
                a = t("@turf/distance");
            e.exports = n
        }, { "@turf/distance": 42, "@turf/tin": 43, "@turf/union": 44 }],
        42: [function(t, e, i) { arguments[4][4][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-distance": 69, dup: 4 }],
        43: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-tin") }, { "/Users/tmcw/src/turf/packages/turf-tin": 151 }],
        44: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-union") }, { "/Users/tmcw/src/turf/packages/turf-union": 156 }],
        45: [function(t, e, i) {
            var n = t("@turf/meta").coordEach,
                r = t("convex-hull"),
                o = t("@turf/helpers").polygon;
            e.exports = function(t) {
                var e = [];
                n(t, function(t) { e.push([t[0], t[1]]) });
                var i = r(e);
                if (i.length >= 3) { for (var s = [], a = 0; a < i.length; a++) s.push(e[i[a][0]]); return s.push(e[i[i.length - 1][1]]), o([s]) }
            }
        }, { "@turf/helpers": 46, "@turf/meta": 47, "convex-hull": 50 }],
        46: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        47: [function(t, e, i) { arguments[4][12][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-meta": 113, dup: 12 }],
        48: [function(t, e, i) {
            "use strict";

            function n(t, e) {
                for (var i = new Array(e + 1), n = 0; n < t.length; ++n) i[n] = t[n];
                for (var n = 0; n <= t.length; ++n) {
                    for (var r = t.length; r <= e; ++r) {
                        for (var s = new Array(e), a = 0; a < e; ++a) s[a] = Math.pow(r + 1 - n, a);
                        i[r] = s
                    }
                    var h = o.apply(void 0, i);
                    if (h) return !0
                }
                return !1
            }

            function r(t) {
                var e = t.length;
                if (0 === e) return [];
                if (1 === e) return [0];
                for (var i = t[0].length, r = [t[0]], o = [0], s = 1; s < e; ++s)
                    if (r.push(t[s]), n(r, i)) { if (o.push(s), o.length === i + 1) return o } else r.pop();
                return o
            }
            e.exports = r;
            var o = t("robust-orientation")
        }, { "robust-orientation": 56 }],
        49: [function(t, e, i) {
            "use strict";
            "use restrict";

            function n(t) { var e = 32; return t &= -t, t && e--, 65535 & t && (e -= 16), 16711935 & t && (e -= 8), 252645135 & t && (e -= 4), 858993459 & t && (e -= 2), 1431655765 & t && (e -= 1), e }
            var r = 32;
            i.INT_BITS = r, i.INT_MAX = 2147483647, i.INT_MIN = -1 << r - 1, i.sign = function(t) { return (t > 0) - (t < 0) }, i.abs = function(t) { var e = t >> r - 1; return (t ^ e) - e }, i.min = function(t, e) { return e ^ (t ^ e) & -(t < e) }, i.max = function(t, e) { return t ^ (t ^ e) & -(t < e) }, i.isPow2 = function(t) { return !(t & t - 1 || !t) }, i.log2 = function(t) { var e, i; return e = (t > 65535) << 4, t >>>= e, i = (t > 255) << 3, t >>>= i, e |= i, i = (t > 15) << 2, t >>>= i, e |= i, i = (t > 3) << 1, t >>>= i, e |= i, e | t >> 1 }, i.log10 = function(t) { return t >= 1e9 ? 9 : t >= 1e8 ? 8 : t >= 1e7 ? 7 : t >= 1e6 ? 6 : t >= 1e5 ? 5 : t >= 1e4 ? 4 : t >= 1e3 ? 3 : t >= 100 ? 2 : t >= 10 ? 1 : 0 }, i.popCount = function(t) { return t -= t >>> 1 & 1431655765, t = (858993459 & t) + (t >>> 2 & 858993459), 16843009 * (t + (t >>> 4) & 252645135) >>> 24 }, i.countTrailingZeros = n, i.nextPow2 = function(t) { return t += 0 === t, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t + 1 }, i.prevPow2 = function(t) { return t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t - (t >>> 1) }, i.parity = function(t) { return t ^= t >>> 16, t ^= t >>> 8, t ^= t >>> 4, t &= 15, 27030 >>> t & 1 };
            var o = new Array(256);
            ! function(t) {
                for (var e = 0; e < 256; ++e) {
                    var i = e,
                        n = e,
                        r = 7;
                    for (i >>>= 1; i; i >>>= 1) n <<= 1, n |= 1 & i, --r;
                    t[e] = n << r & 255
                }
            }(o), i.reverse = function(t) { return o[255 & t] << 24 | o[t >>> 8 & 255] << 16 | o[t >>> 16 & 255] << 8 | o[t >>> 24 & 255] }, i.interleave2 = function(t, e) { return t &= 65535, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e &= 65535, e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t | e << 1 }, i.deinterleave2 = function(t, e) { return t = t >>> e & 1431655765, t = 858993459 & (t | t >>> 1), t = 252645135 & (t | t >>> 2), t = 16711935 & (t | t >>> 4), t = 65535 & (t | t >>> 16), t << 16 >> 16 }, i.interleave3 = function(t, e, i) { return t &= 1023, t = 4278190335 & (t | t << 16), t = 251719695 & (t | t << 8), t = 3272356035 & (t | t << 4), t = 1227133513 & (t | t << 2), e &= 1023, e = 4278190335 & (e | e << 16), e = 251719695 & (e | e << 8), e = 3272356035 & (e | e << 4), e = 1227133513 & (e | e << 2), t |= e << 1, i &= 1023, i = 4278190335 & (i | i << 16), i = 251719695 & (i | i << 8), i = 3272356035 & (i | i << 4), i = 1227133513 & (i | i << 2), t | i << 2 }, i.deinterleave3 = function(t, e) { return t = t >>> e & 1227133513, t = 3272356035 & (t | t >>> 2), t = 251719695 & (t | t >>> 4), t = 4278190335 & (t | t >>> 8), t = 1023 & (t | t >>> 16), t << 22 >> 22 }, i.nextCombination = function(t) { var e = t | t - 1; return e + 1 | (~e & -~e) - 1 >>> n(t) + 1 }
        }, {}],
        50: [function(t, e, i) {
            "use strict";

            function n(t) {
                var e = t.length;
                if (0 === e) return [];
                if (1 === e) return [
                    [0]
                ];
                var i = t[0].length;
                return 0 === i ? [] : 1 === i ? r(t) : 2 === i ? o(t) : s(t, i)
            }
            var r = t("./lib/ch1d"),
                o = t("./lib/ch2d"),
                s = t("./lib/chnd");
            e.exports = n
        }, { "./lib/ch1d": 51, "./lib/ch2d": 52, "./lib/chnd": 53 }],
        51: [function(t, e, i) {
            "use strict";

            function n(t) {
                for (var e = 0, i = 0, n = 1; n < t.length; ++n) t[n][0] < t[e][0] && (e = n), t[n][0] > t[i][0] && (i = n);
                return e < i ? [
                    [e],
                    [i]
                ] : e > i ? [
                    [i],
                    [e]
                ] : [
                    [e]
                ]
            }
            e.exports = n
        }, {}],
        52: [function(t, e, i) {
            "use strict";

            function n(t) {
                var e = r(t),
                    i = e.length;
                if (i <= 2) return [];
                for (var n = new Array(i), o = e[i - 1], s = 0; s < i; ++s) {
                    var a = e[s];
                    n[s] = [o, a], o = a
                }
                return n
            }
            e.exports = n;
            var r = t("monotone-convex-hull-2d")
        }, { "monotone-convex-hull-2d": 55 }],
        53: [function(t, e, i) {
            "use strict";

            function n(t, e) { for (var i = t.length, n = new Array(i), r = 0; r < e.length; ++r) n[r] = t[e[r]]; for (var o = e.length, r = 0; r < i; ++r) e.indexOf(r) < 0 && (n[o++] = t[r]); return n }

            function r(t, e) {
                for (var i = t.length, n = e.length, r = 0; r < i; ++r)
                    for (var o = t[r], s = 0; s < o.length; ++s) {
                        var a = o[s];
                        if (a < n) o[s] = e[a];
                        else {
                            a -= n;
                            for (var h = 0; h < n; ++h) a >= e[h] && (a += 1);
                            o[s] = a
                        }
                    }
                return t
            }

            function o(t, e) {
                try { return s(t, !0) } catch (l) {
                    var i = a(t);
                    if (i.length <= e) return [];
                    var o = n(t, i),
                        h = s(o, !0);
                    return r(h, i)
                }
            }
            e.exports = o;
            var s = t("incremental-convex-hull"),
                a = t("affine-hull")
        }, { "affine-hull": 48, "incremental-convex-hull": 54 }],
        54: [function(t, e, i) {
            "use strict";

            function n(t, e, i) { this.vertices = t, this.adjacent = e, this.boundary = i, this.lastVisited = -1 }

            function r(t, e, i) { this.vertices = t, this.cell = e, this.index = i }

            function o(t, e) { return u(t.vertices, e.vertices) }

            function s(t) {
                for (var e = ["function orient(){var tuple=this.tuple;return test("], i = 0; i <= t; ++i) i > 0 && e.push(","), e.push("tuple[", i, "]");
                e.push(")}return orient");
                var n = new Function("test", e.join("")),
                    r = l[t + 1];
                return r || (r = l), n(r)
            }

            function a(t, e, i) {
                this.dimension = t, this.vertices = e, this.simplices = i, this.interior = i.filter(function(t) { return !t.boundary }), this.tuple = new Array(t + 1);
                for (var n = 0; n <= t; ++n) this.tuple[n] = this.vertices[n];
                var r = p[t];
                r || (r = p[t] = s(t)), this.orient = r
            }

            function h(t, e) {
                var i = t.length;
                if (0 === i) throw new Error("Must have at least d+1 points");
                var r = t[0].length;
                if (i <= r) throw new Error("Must input at least d+1 points");
                var o = t.slice(0, r + 1),
                    s = l.apply(void 0, o);
                if (0 === s) throw new Error("Input not in general position");
                for (var h = new Array(r + 1), u = 0; u <= r; ++u) h[u] = u;
                s < 0 && (h[0] = 1, h[1] = 0);
                for (var p = new n(h, new Array(r + 1), !1), c = p.adjacent, f = new Array(r + 2), u = 0; u <= r; ++u) {
                    for (var g = h.slice(), d = 0; d <= r; ++d) d === u && (g[d] = -1);
                    var y = g[0];
                    g[0] = g[1], g[1] = y;
                    var m = new n(g, new Array(r + 1), !0);
                    c[u] = m, f[u] = m
                }
                f[r + 1] = p;
                for (var u = 0; u <= r; ++u)
                    for (var g = c[u].vertices, v = c[u].adjacent, d = 0; d <= r; ++d) {
                        var b = g[d];
                        if (b < 0) v[d] = p;
                        else
                            for (var w = 0; w <= r; ++w) c[w].vertices.indexOf(b) < 0 && (v[d] = c[w])
                    }
                for (var x = new a(r, o, f), E = !!e, u = r + 1; u < i; ++u) x.insert(t[u], E);
                return x.boundary()
            }
            e.exports = h;
            var l = t("robust-orientation"),
                u = t("simplicial-complex").compareCells;
            n.prototype.flip = function() {
                var t = this.vertices[0];
                this.vertices[0] = this.vertices[1], this.vertices[1] = t;
                var e = this.adjacent[0];
                this.adjacent[0] = this.adjacent[1], this.adjacent[1] = e
            };
            var p = [],
                c = a.prototype;
            c.handleBoundaryDegeneracy = function(t, e) {
                var i = this.dimension,
                    n = this.vertices.length - 1,
                    r = this.tuple,
                    o = this.vertices,
                    s = [t];
                for (t.lastVisited = -n; s.length > 0;) {
                    t = s.pop();
                    for (var a = (t.vertices, t.adjacent), h = 0; h <= i; ++h) {
                        var l = a[h];
                        if (l.boundary && !(l.lastVisited <= -n)) {
                            for (var u = l.vertices, p = 0; p <= i; ++p) {
                                var c = u[p];
                                c < 0 ? r[p] = e : r[p] = o[c]
                            }
                            var f = this.orient();
                            if (f > 0) return l;
                            l.lastVisited = -n, 0 === f && s.push(l)
                        }
                    }
                }
                return null
            }, c.walk = function(t, e) {
                var i = this.vertices.length - 1,
                    n = this.dimension,
                    r = this.vertices,
                    o = this.tuple,
                    s = e ? this.interior.length * Math.random() | 0 : this.interior.length - 1,
                    a = this.interior[s];
                t: for (; !a.boundary;) {
                    for (var h = a.vertices, l = a.adjacent, u = 0; u <= n; ++u) o[u] = r[h[u]];
                    a.lastVisited = i;
                    for (var u = 0; u <= n; ++u) {
                        var p = l[u];
                        if (!(p.lastVisited >= i)) {
                            var c = o[u];
                            o[u] = t;
                            var f = this.orient();
                            if (o[u] = c, f < 0) { a = p; continue t }
                            p.boundary ? p.lastVisited = -i : p.lastVisited = i
                        }
                    }
                    return
                }
                return a
            }, c.addPeaks = function(t, e) {
                var i = this.vertices.length - 1,
                    s = this.dimension,
                    a = this.vertices,
                    h = this.tuple,
                    l = this.interior,
                    u = this.simplices,
                    p = [e];
                e.lastVisited = i, e.vertices[e.vertices.indexOf(-1)] = i, e.boundary = !1, l.push(e);
                for (var c = []; p.length > 0;) {
                    var e = p.pop(),
                        f = e.vertices,
                        g = e.adjacent,
                        d = f.indexOf(i);
                    if (!(d < 0))
                        for (var y = 0; y <= s; ++y)
                            if (y !== d) {
                                var m = g[y];
                                if (m.boundary && !(m.lastVisited >= i)) {
                                    var v = m.vertices;
                                    if (m.lastVisited !== -i) {
                                        for (var b = 0, w = 0; w <= s; ++w) v[w] < 0 ? (b = w, h[w] = t) : h[w] = a[v[w]];
                                        var x = this.orient();
                                        if (x > 0) { v[b] = i, m.boundary = !1, l.push(m), p.push(m), m.lastVisited = i; continue }
                                        m.lastVisited = -i
                                    }
                                    var E = m.adjacent,
                                        S = f.slice(),
                                        N = g.slice(),
                                        L = new n(S, N, !0);
                                    u.push(L);
                                    var C = E.indexOf(e);
                                    if (!(C < 0)) {
                                        E[C] = L, N[d] = m, S[y] = -1, N[y] = e, g[y] = L, L.flip();
                                        for (var w = 0; w <= s; ++w) {
                                            var M = S[w];
                                            if (!(M < 0 || M === i)) {
                                                for (var I = new Array(s - 1), k = 0, T = 0; T <= s; ++T) {
                                                    var A = S[T];
                                                    A < 0 || T === w || (I[k++] = A)
                                                }
                                                c.push(new r(I, L, w))
                                            }
                                        }
                                    }
                                }
                            }
                }
                c.sort(o);
                for (var y = 0; y + 1 < c.length; y += 2) {
                    var R = c[y],
                        _ = c[y + 1],
                        P = R.index,
                        O = _.index;
                    P < 0 || O < 0 || (R.cell.adjacent[R.index] = _.cell, _.cell.adjacent[_.index] = R.cell)
                }
            }, c.insert = function(t, e) {
                var i = this.vertices;
                i.push(t);
                var n = this.walk(t, e);
                if (n) {
                    for (var r = this.dimension, o = this.tuple, s = 0; s <= r; ++s) {
                        var a = n.vertices[s];
                        a < 0 ? o[s] = t : o[s] = i[a]
                    }
                    var h = this.orient(o);
                    h < 0 || (0 !== h || (n = this.handleBoundaryDegeneracy(n, t))) && this.addPeaks(t, n)
                }
            }, c.boundary = function() {
                for (var t = this.dimension, e = [], i = this.simplices, n = i.length, r = 0; r < n; ++r) {
                    var o = i[r];
                    if (o.boundary) {
                        for (var s = new Array(t), a = o.vertices, h = 0, l = 0, u = 0; u <= t; ++u) a[u] >= 0 ? s[h++] = a[u] : l = 1 & u;
                        if (l === (1 & t)) {
                            var p = s[0];
                            s[0] = s[1], s[1] = p
                        }
                        e.push(s)
                    }
                }
                return e
            }
        }, { "robust-orientation": 56, "simplicial-complex": 60 }],
        55: [function(t, e, i) {
            "use strict";

            function n(t) {
                var e = t.length;
                if (e < 3) { for (var i = new Array(e), n = 0; n < e; ++n) i[n] = n; return 2 === e && t[0][0] === t[1][0] && t[0][1] === t[1][1] ? [0] : i }
                for (var o = new Array(e), n = 0; n < e; ++n) o[n] = n;
                o.sort(function(e, i) { var n = t[e][0] - t[i][0]; return n ? n : t[e][1] - t[i][1] });
                for (var s = [o[0], o[1]], a = [o[0], o[1]], n = 2; n < e; ++n) {
                    for (var h = o[n], l = t[h], u = s.length; u > 1 && r(t[s[u - 2]], t[s[u - 1]], l) <= 0;) u -= 1, s.pop();
                    for (s.push(h), u = a.length; u > 1 && r(t[a[u - 2]], t[a[u - 1]], l) >= 0;) u -= 1, a.pop();
                    a.push(h)
                }
                for (var i = new Array(a.length + s.length - 2), p = 0, n = 0, c = s.length; n < c; ++n) i[p++] = s[n];
                for (var f = a.length - 2; f > 0; --f) i[p++] = a[f];
                return i
            }
            e.exports = n;
            var r = t("robust-orientation")[3]
        }, { "robust-orientation": 56 }],
        56: [function(t, e, i) {
            "use strict";

            function n(t, e) {
                for (var i = new Array(t.length - 1), n = 1; n < t.length; ++n)
                    for (var r = i[n - 1] = new Array(t.length - 1), o = 0, s = 0; o < t.length; ++o) o !== e && (r[s++] = t[n][o]);
                return i
            }

            function r(t) { for (var e = new Array(t), i = 0; i < t; ++i) { e[i] = new Array(t); for (var n = 0; n < t; ++n) e[i][n] = ["m", n, "[", t - i - 1, "]"].join("") } return e }

            function o(t) { return 1 & t ? "-" : "" }

            function s(t) { if (1 === t.length) return t[0]; if (2 === t.length) return ["sum(", t[0], ",", t[1], ")"].join(""); var e = t.length >> 1; return ["sum(", s(t.slice(0, e)), ",", s(t.slice(e)), ")"].join("") }

            function a(t) {
                if (2 === t.length) return [
                    ["sum(prod(", t[0][0], ",", t[1][1], "),prod(-", t[0][1], ",", t[1][0], "))"].join("")
                ];
                for (var e = [], i = 0; i < t.length; ++i) e.push(["scale(", s(a(n(t, i))), ",", o(i), t[0][i], ")"].join(""));
                return e
            }

            function h(t) {
                for (var e = [], i = [], o = r(t), h = [], l = 0; l < t; ++l) 0 === (1 & l) ? e.push.apply(e, a(n(o, l))) : i.push.apply(i, a(n(o, l))), h.push("m" + l);
                var u = s(e),
                    d = s(i),
                    y = "orientation" + t + "Exact",
                    m = ["function ", y, "(", h.join(), "){var p=", u, ",n=", d, ",d=sub(p,n);return d[d.length-1];};return ", y].join(""),
                    v = new Function("sum", "prod", "scale", "sub", m);
                return v(c, p, f, g)
            }

            function l(t) { var e = x[t.length]; return e || (e = x[t.length] = h(t.length)), e.apply(void 0, t) }

            function u() {
                for (; x.length <= d;) x.push(h(x.length));
                for (var t = [], i = ["slow"], n = 0; n <= d; ++n) t.push("a" + n), i.push("o" + n);
                for (var r = ["function getOrientation(", t.join(), "){switch(arguments.length){case 0:case 1:return 0;"], n = 2; n <= d; ++n) r.push("case ", n, ":return o", n, "(", t.slice(0, n).join(), ");");
                r.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation"), i.push(r.join(""));
                var o = Function.apply(void 0, i);
                e.exports = o.apply(void 0, [l].concat(x));
                for (var n = 0; n <= d; ++n) e.exports[n] = x[n]
            }
            var p = t("two-product"),
                c = t("robust-sum"),
                f = t("robust-scale"),
                g = t("robust-subtract"),
                d = 5,
                y = 1.1102230246251565e-16,
                m = (3 + 16 * y) * y,
                v = (7 + 56 * y) * y,
                b = h(3),
                w = h(4),
                x = [function() { return 0 }, function() { return 0 }, function(t, e) { return e[0] - t[0] }, function(t, e, i) {
                    var n, r = (t[1] - i[1]) * (e[0] - i[0]),
                        o = (t[0] - i[0]) * (e[1] - i[1]),
                        s = r - o;
                    if (r > 0) {
                        if (o <= 0) return s;
                        n = r + o
                    } else {
                        if (!(r < 0)) return s;
                        if (o >= 0) return s;
                        n = -(r + o)
                    }
                    var a = m * n;
                    return s >= a || s <= -a ? s : b(t, e, i)
                }, function(t, e, i, n) {
                    var r = t[0] - n[0],
                        o = e[0] - n[0],
                        s = i[0] - n[0],
                        a = t[1] - n[1],
                        h = e[1] - n[1],
                        l = i[1] - n[1],
                        u = t[2] - n[2],
                        p = e[2] - n[2],
                        c = i[2] - n[2],
                        f = o * l,
                        g = s * h,
                        d = s * a,
                        y = r * l,
                        m = r * h,
                        b = o * a,
                        x = u * (f - g) + p * (d - y) + c * (m - b),
                        E = (Math.abs(f) + Math.abs(g)) * Math.abs(u) + (Math.abs(d) + Math.abs(y)) * Math.abs(p) + (Math.abs(m) + Math.abs(b)) * Math.abs(c),
                        S = v * E;
                    return x > S || -x > S ? x : w(t, e, i, n)
                }];
            u()
        }, { "robust-scale": 57, "robust-subtract": 58, "robust-sum": 59, "two-product": 61 }],
        57: [function(t, e, i) {
            "use strict";

            function n(t, e) {
                var i = t.length;
                if (1 === i) { var n = r(t[0], e); return n[0] ? n : [n[1]] }
                var s = new Array(2 * i),
                    a = [.1, .1],
                    h = [.1, .1],
                    l = 0;
                r(t[0], e, a), a[0] && (s[l++] = a[0]);
                for (var u = 1; u < i; ++u) {
                    r(t[u], e, h);
                    var p = a[1];
                    o(p, h[0], a), a[0] && (s[l++] = a[0]);
                    var c = h[1],
                        f = a[1],
                        g = c + f,
                        d = g - c,
                        y = f - d;
                    a[1] = g, y && (s[l++] = y)
                }
                return a[1] && (s[l++] = a[1]), 0 === l && (s[l++] = 0), s.length = l, s
            }
            var r = t("two-product"),
                o = t("two-sum");
            e.exports = n
        }, { "two-product": 61, "two-sum": 62 }],
        58: [function(t, e, i) {
            "use strict";

            function n(t, e) {
                var i = t + e,
                    n = i - t,
                    r = i - n,
                    o = e - n,
                    s = t - r,
                    a = s + o;
                return a ? [a, i] : [i]
            }

            function r(t, e) {
                var i = 0 | t.length,
                    r = 0 | e.length;
                if (1 === i && 1 === r) return n(t[0], -e[0]);
                var o, s, a = i + r,
                    h = new Array(a),
                    l = 0,
                    u = 0,
                    p = 0,
                    c = Math.abs,
                    f = t[u],
                    g = c(f),
                    d = -e[p],
                    y = c(d);
                g < y ? (s = f, u += 1, u < i && (f = t[u], g = c(f))) : (s = d, p += 1, p < r && (d = -e[p], y = c(d))), u < i && g < y || p >= r ? (o = f, u += 1, u < i && (f = t[u], g = c(f))) : (o = d, p += 1, p < r && (d = -e[p], y = c(d)));
                for (var m, v, b, w, x, E = o + s, S = E - o, N = s - S, L = N, C = E; u < i && p < r;) g < y ? (o = f, u += 1, u < i && (f = t[u], g = c(f))) : (o = d, p += 1, p < r && (d = -e[p], y = c(d))), s = L, E = o + s, S = E - o, N = s - S, N && (h[l++] = N), m = C + E, v = m - C, b = m - v, w = E - v, x = C - b, L = x + w, C = m;
                for (; u < i;) o = f, s = L, E = o + s, S = E - o, N = s - S, N && (h[l++] = N), m = C + E, v = m - C, b = m - v, w = E - v, x = C - b, L = x + w, C = m, u += 1, u < i && (f = t[u]);
                for (; p < r;) o = d, s = L, E = o + s, S = E - o, N = s - S, N && (h[l++] = N), m = C + E, v = m - C, b = m - v, w = E - v, x = C - b, L = x + w, C = m, p += 1, p < r && (d = -e[p]);
                return L && (h[l++] = L), C && (h[l++] = C), l || (h[l++] = 0), h.length = l, h
            }
            e.exports = r
        }, {}],
        59: [function(t, e, i) {
            "use strict";

            function n(t, e) {
                var i = t + e,
                    n = i - t,
                    r = i - n,
                    o = e - n,
                    s = t - r,
                    a = s + o;
                return a ? [a, i] : [i]
            }

            function r(t, e) {
                var i = 0 | t.length,
                    r = 0 | e.length;
                if (1 === i && 1 === r) return n(t[0], e[0]);
                var o, s, a = i + r,
                    h = new Array(a),
                    l = 0,
                    u = 0,
                    p = 0,
                    c = Math.abs,
                    f = t[u],
                    g = c(f),
                    d = e[p],
                    y = c(d);
                g < y ? (s = f, u += 1, u < i && (f = t[u], g = c(f))) : (s = d, p += 1, p < r && (d = e[p], y = c(d))), u < i && g < y || p >= r ? (o = f, u += 1, u < i && (f = t[u], g = c(f))) : (o = d, p += 1, p < r && (d = e[p], y = c(d)));
                for (var m, v, b, w, x, E = o + s, S = E - o, N = s - S, L = N, C = E; u < i && p < r;) g < y ? (o = f, u += 1, u < i && (f = t[u], g = c(f))) : (o = d, p += 1, p < r && (d = e[p], y = c(d))), s = L, E = o + s, S = E - o, N = s - S, N && (h[l++] = N), m = C + E, v = m - C, b = m - v, w = E - v, x = C - b, L = x + w, C = m;
                for (; u < i;) o = f, s = L, E = o + s, S = E - o, N = s - S, N && (h[l++] = N), m = C + E, v = m - C, b = m - v, w = E - v, x = C - b, L = x + w, C = m, u += 1, u < i && (f = t[u]);
                for (; p < r;) o = d, s = L, E = o + s, S = E - o, N = s - S, N && (h[l++] = N), m = C + E, v = m - C, b = m - v, w = E - v, x = C - b, L = x + w, C = m, p += 1, p < r && (d = e[p]);
                return L && (h[l++] = L), C && (h[l++] = C), l || (h[l++] = 0), h.length = l, h
            }
            e.exports = r
        }, {}],
        60: [function(t, e, i) {
            "use strict";
            "use restrict";

            function n(t) { for (var e = 0, i = Math.max, n = 0, r = t.length; n < r; ++n) e = i(e, t[n].length); return e - 1 }

            function r(t) {
                for (var e = -1, i = Math.max, n = 0, r = t.length; n < r; ++n)
                    for (var o = t[n], s = 0, a = o.length; s < a; ++s) e = i(e, o[s]);
                return e + 1
            }

            function o(t) { for (var e = new Array(t.length), i = 0, n = t.length; i < n; ++i) e[i] = t[i].slice(0); return e }

            function s(t, e) {
                var i = t.length,
                    n = t.length - e.length,
                    r = Math.min;
                if (n) return n;
                switch (i) {
                    case 0:
                        return 0;
                    case 1:
                        return t[0] - e[0];
                    case 2:
                        var o = t[0] + t[1] - e[0] - e[1];
                        return o ? o : r(t[0], t[1]) - r(e[0], e[1]);
                    case 3:
                        var s = t[0] + t[1],
                            a = e[0] + e[1];
                        if (o = s + t[2] - (a + e[2])) return o;
                        var h = r(t[0], t[1]),
                            l = r(e[0], e[1]),
                            o = r(h, t[2]) - r(l, e[2]);
                        return o ? o : r(h + t[2], s) - r(l + e[2], a);
                    default:
                        var u = t.slice(0);
                        u.sort();
                        var p = e.slice(0);
                        p.sort();
                        for (var c = 0; c < i; ++c)
                            if (n = u[c] - p[c]) return n;
                        return 0
                }
            }

            function a(t, e) { return s(t[0], e[0]) }

            function h(t, e) {
                if (e) {
                    for (var i = t.length, n = new Array(i), r = 0; r < i; ++r) n[r] = [t[r], e[r]];
                    n.sort(a);
                    for (var r = 0; r < i; ++r) t[r] = n[r][0], e[r] = n[r][1];
                    return t
                }
                return t.sort(s), t
            }

            function l(t) {
                if (0 === t.length) return [];
                for (var e = 1, i = t.length, n = 1; n < i; ++n) {
                    var r = t[n];
                    if (s(r, t[n - 1])) {
                        if (n === e) { e++; continue }
                        t[e++] = r
                    }
                }
                return t.length = e, t
            }

            function u(t, e) {
                for (var i = 0, n = t.length - 1, r = -1; i <= n;) {
                    var o = i + n >> 1,
                        a = s(t[o], e);
                    a <= 0 ? (0 === a && (r = o), i = o + 1) : a > 0 && (n = o - 1)
                }
                return r
            }

            function p(t, e) {
                for (var i = new Array(t.length), n = 0, r = i.length; n < r; ++n) i[n] = [];
                for (var o = [], n = 0, a = e.length; n < a; ++n)
                    for (var h = e[n], l = h.length, p = 1, c = 1 << l; p < c; ++p) {
                        o.length = b.popCount(p);
                        for (var f = 0, g = 0; g < l; ++g) p & 1 << g && (o[f++] = h[g]);
                        var d = u(t, o);
                        if (!(d < 0))
                            for (;;)
                                if (i[d++].push(n), d >= t.length || 0 !== s(t[d], o)) break
                    }
                return i
            }

            function c(t, e) {
                if (!e) return p(l(g(t, 0)), t, 0);
                for (var i = new Array(e), n = 0; n < e; ++n) i[n] = [];
                for (var n = 0, r = t.length; n < r; ++n)
                    for (var o = t[n], s = 0, a = o.length; s < a; ++s) i[o[s]].push(n);
                return i
            }

            function f(t) {
                for (var e = [], i = 0, n = t.length; i < n; ++i)
                    for (var r = t[i], o = 0 | r.length, s = 1, a = 1 << o; s < a; ++s) {
                        for (var l = [], u = 0; u < o; ++u) s >>> u & 1 && l.push(r[u]);
                        e.push(l)
                    }
                return h(e)
            }

            function g(t, e) {
                if (e < 0) return [];
                for (var i = [], n = (1 << e + 1) - 1, r = 0; r < t.length; ++r)
                    for (var o = t[r], s = n; s < 1 << o.length; s = b.nextCombination(s)) {
                        for (var a = new Array(e + 1), l = 0, u = 0; u < o.length; ++u) s & 1 << u && (a[l++] = o[u]);
                        i.push(a)
                    }
                return h(i)
            }

            function d(t) {
                for (var e = [], i = 0, n = t.length; i < n; ++i)
                    for (var r = t[i], o = 0, s = r.length; o < s; ++o) {
                        for (var a = new Array(r.length - 1), l = 0, u = 0; l < s; ++l) l !== o && (a[u++] = r[l]);
                        e.push(a)
                    }
                return h(e)
            }

            function y(t, e) {
                for (var i = new w(e), n = 0; n < t.length; ++n)
                    for (var r = t[n], o = 0; o < r.length; ++o)
                        for (var s = o + 1; s < r.length; ++s) i.link(r[o], r[s]);
                for (var a = [], h = i.ranks, n = 0; n < h.length; ++n) h[n] = -1;
                for (var n = 0; n < t.length; ++n) {
                    var l = i.find(t[n][0]);
                    h[l] < 0 ? (h[l] = a.length, a.push([t[n].slice(0)])) : a[h[l]].push(t[n].slice(0))
                }
                return a
            }

            function m(t) {
                for (var e = l(h(g(t, 0))), i = new w(e.length), n = 0; n < t.length; ++n)
                    for (var r = t[n], o = 0; o < r.length; ++o)
                        for (var s = u(e, [r[o]]), a = o + 1; a < r.length; ++a) i.link(s, u(e, [r[a]]));
                for (var p = [], c = i.ranks, n = 0; n < c.length; ++n) c[n] = -1;
                for (var n = 0; n < t.length; ++n) {
                    var f = i.find(u(e, [t[n][0]]));
                    c[f] < 0 ? (c[f] = p.length, p.push([t[n].slice(0)])) : p[c[f]].push(t[n].slice(0))
                }
                return p
            }

            function v(t, e) { return e ? y(t, e) : m(t) }
            var b = t("bit-twiddle"),
                w = t("union-find");
            i.dimension = n, i.countVertices = r, i.cloneCells = o, i.compareCells = s, i.normalize = h, i.unique = l, i.findCell = u, i.incidence = p, i.dual = c, i.explode = f, i.skeleton = g, i.boundary = d, i.connectedComponents = v
        }, { "bit-twiddle": 49, "union-find": 63 }],
        61: [function(t, e, i) {
            "use strict";

            function n(t, e, i) {
                var n = t * e,
                    o = r * t,
                    s = o - t,
                    a = o - s,
                    h = t - a,
                    l = r * e,
                    u = l - e,
                    p = l - u,
                    c = e - p,
                    f = n - a * p,
                    g = f - h * p,
                    d = g - a * c,
                    y = h * c - d;
                return i ? (i[0] = y, i[1] = n, i) : [y, n]
            }
            e.exports = n;
            var r = +(Math.pow(2, 27) + 1)
        }, {}],
        62: [function(t, e, i) {
            "use strict";

            function n(t, e, i) {
                var n = t + e,
                    r = n - t,
                    o = n - r,
                    s = e - r,
                    a = t - o;
                return i ? (i[0] = a + s, i[1] = n, i) : [a + s, n]
            }
            e.exports = n
        }, {}],
        63: [function(t, e, i) {
            "use strict";
            "use restrict";

            function n(t) { this.roots = new Array(t), this.ranks = new Array(t); for (var e = 0; e < t; ++e) this.roots[e] = e, this.ranks[e] = 0 }
            e.exports = n;
            var r = n.prototype;
            Object.defineProperty(r, "length", { get: function() { return this.roots.length } }), r.makeSet = function() { var t = this.roots.length; return this.roots.push(t), this.ranks.push(0), t }, r.find = function(t) {
                for (var e = t, i = this.roots; i[t] !== t;) t = i[t];
                for (; i[e] !== t;) {
                    var n = i[e];
                    i[e] = t, e = n
                }
                return t
            }, r.link = function(t, e) {
                var i = this.find(t),
                    n = this.find(e);
                if (i !== n) {
                    var r = this.ranks,
                        o = this.roots,
                        s = r[i],
                        a = r[n];
                    s < a ? o[i] = n : a < s ? o[n] = i : (o[n] = i, ++r[i])
                }
            }
        }, {}],
        64: [function(t, e, i) {
            var n = t("@turf/invariant").getCoord,
                r = t("@turf/helpers"),
                o = r.point,
                s = r.distanceToRadians;
            e.exports = function(t, e, i, r) {
                var a = Math.PI / 180,
                    h = 180 / Math.PI,
                    l = n(t),
                    u = a * l[0],
                    p = a * l[1],
                    c = a * i,
                    f = s(e, r),
                    g = Math.asin(Math.sin(p) * Math.cos(f) + Math.cos(p) * Math.sin(f) * Math.cos(c)),
                    d = u + Math.atan2(Math.sin(c) * Math.sin(f) * Math.cos(p), Math.cos(f) - Math.sin(p) * Math.sin(g));
                return o([h * d, h * g])
            }
        }, { "@turf/helpers": 65, "@turf/invariant": 66 }],
        65: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        66: [function(t, e, i) { arguments[4][14][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-invariant": 88, dup: 14 }],
        67: [function(t, e, i) {
            var n = t("jsts");
            e.exports = function(t, e) {
                var i = JSON.parse(JSON.stringify(t)),
                    r = JSON.parse(JSON.stringify(e));
                "Feature" !== i.type && (i = { type: "Feature", properties: {}, geometry: i }), "Feature" !== r.type && (r = { type: "Feature", properties: {}, geometry: r });
                var o = new n.io.GeoJSONReader,
                    s = o.read(JSON.stringify(i.geometry)),
                    a = o.read(JSON.stringify(r.geometry)),
                    h = s.difference(a);
                if (!h.isEmpty()) {
                    var l = new n.io.GeoJSONWriter,
                        u = l.write(h);
                    return i.geometry = h, { type: "Feature", properties: i.properties, geometry: u }
                }
            }
        }, { jsts: 68 }],
        68: [function(t, e, i) { arguments[4][21][0].apply(i, arguments) }, { dup: 21 }],
        69: [function(t, e, i) {
            var n = t("@turf/invariant").getCoord,
                r = t("@turf/helpers").radiansToDistance;
            e.exports = function(t, e, i) {
                var o = Math.PI / 180,
                    s = n(t),
                    a = n(e),
                    h = o * (a[1] - s[1]),
                    l = o * (a[0] - s[0]),
                    u = o * s[1],
                    p = o * a[1],
                    c = Math.pow(Math.sin(h / 2), 2) + Math.pow(Math.sin(l / 2), 2) * Math.cos(u) * Math.cos(p);
                return r(2 * Math.atan2(Math.sqrt(c), Math.sqrt(1 - c)), i)
            }
        }, { "@turf/helpers": 70, "@turf/invariant": 71 }],
        70: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        71: [function(t, e, i) { arguments[4][14][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-invariant": 88, dup: 14 }],
        72: [function(t, e, i) {
            var n = t("@turf/bbox"),
                r = t("@turf/bbox-polygon");
            e.exports = function(t) { return r(n(t)) }
        }, { "@turf/bbox": 74, "@turf/bbox-polygon": 73 }],
        73: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-bbox-polygon") }, { "/Users/tmcw/src/turf/packages/turf-bbox-polygon": 9 }],
        74: [function(t, e, i) { arguments[4][29][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-bbox": 11, dup: 29 }],
        75: [function(t, e, i) {
            var n = t("@turf/helpers").featureCollection,
                r = t("@turf/meta").coordEach,
                o = t("@turf/helpers").point;
            e.exports = function(t) { var e = []; return r(t, function(t) { e.push(o(t)) }), n(e) }
        }, { "@turf/helpers": 76, "@turf/meta": 77 }],
        76: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        77: [function(t, e, i) { arguments[4][12][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-meta": 113, dup: 12 }],
        78: [function(t, e, i) {
            var n = t("@turf/meta").coordEach;
            e.exports = function(t) { return t = JSON.parse(JSON.stringify(t)), n(t, function(t) { t.reverse() }), t }
        }, { "@turf/meta": 79 }],
        79: [function(t, e, i) { arguments[4][12][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-meta": 113, dup: 12 }],
        80: [function(t, e, i) {
            function n(t, e) { return { type: "Feature", properties: e || {}, geometry: t } }
            e.exports.feature = n, e.exports.point = function(t, e) { if (!Array.isArray(t)) throw new Error("Coordinates must be an array"); if (t.length < 2) throw new Error("Coordinates must be at least 2 numbers long"); return n({ type: "Point", coordinates: t.slice() }, e) }, e.exports.polygon = function(t, e) {
                if (!t) throw new Error("No coordinates passed");
                for (var i = 0; i < t.length; i++) {
                    var r = t[i];
                    if (r.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
                    for (var o = 0; o < r[r.length - 1].length; o++)
                        if (r[r.length - 1][o] !== r[0][o]) throw new Error("First and last Position are not equivalent.")
                }
                return n({ type: "Polygon", coordinates: t }, e)
            }, e.exports.lineString = function(t, e) { if (!t) throw new Error("No coordinates passed"); return n({ type: "LineString", coordinates: t }, e) }, e.exports.featureCollection = function(t) { return { type: "FeatureCollection", features: t } }, e.exports.multiLineString = function(t, e) { if (!t) throw new Error("No coordinates passed"); return n({ type: "MultiLineString", coordinates: t }, e) }, e.exports.multiPoint = function(t, e) { if (!t) throw new Error("No coordinates passed"); return n({ type: "MultiPoint", coordinates: t }, e) }, e.exports.multiPolygon = function(t, e) { if (!t) throw new Error("No coordinates passed"); return n({ type: "MultiPolygon", coordinates: t }, e) }, e.exports.geometryCollection = function(t, e) { return n({ type: "GeometryCollection", geometries: t }, e) };
            var r = { miles: 3960, nauticalmiles: 3441.145, degrees: 57.2957795, radians: 1, inches: 250905600, yards: 6969600, meters: 6373e3, metres: 6373e3, kilometers: 6373, kilometres: 6373 };
            e.exports.radiansToDistance = function(t, e) { var i = r[e || "kilometers"]; if (void 0 === i) throw new Error("Invalid unit"); return t * i }, e.exports.distanceToRadians = function(t, e) { var i = r[e || "kilometers"]; if (void 0 === i) throw new Error("Invalid unit"); return t / i }, e.exports.distanceToDegrees = function(t, e) { var i = r[e || "kilometers"]; if (void 0 === i) throw new Error("Invalid unit"); return t / i * 57.2958 }
        }, {}],
        81: [function(t, e, i) {
            function n(t, e, i) {
                for (var n = [], r = 0; r < 6; r++) {
                    var o = t[0] + e * l[r],
                        a = t[1] + i * u[r];
                    n.push([o, a])
                }
                return n.push(n[0]), s([n])
            }

            function r(t, e, i) {
                for (var n = [], r = 0; r < 6; r++) {
                    var o = [];
                    o.push(t), o.push([t[0] + e * l[r], t[1] + i * u[r]]), o.push([t[0] + e * l[(r + 1) % 6], t[1] + i * u[(r + 1) % 6]]), o.push(t), n.push(s([o]))
                }
                return n
            }
            for (var o = t("@turf/helpers").point, s = t("@turf/helpers").polygon, a = t("@turf/distance"), h = t("@turf/helpers").featureCollection, l = [], u = [], p = 0; p < 6; p++) {
                var c = 2 * Math.PI / 6 * p;
                l.push(Math.cos(c)), u.push(Math.sin(c))
            }
            e.exports = function(t, e, i, s) {
                var l = e / a(o([t[0], t[1]]), o([t[2], t[1]]), i),
                    u = l * (t[2] - t[0]),
                    p = e / a(o([t[0], t[1]]), o([t[0], t[3]]), i),
                    c = p * (t[3] - t[1]),
                    f = u / 2,
                    g = 2 * f,
                    d = Math.sqrt(3) / 2 * c,
                    y = t[2] - t[0],
                    m = t[3] - t[1],
                    v = .75 * g,
                    b = d,
                    w = y / (g - f / 2),
                    x = Math.ceil(w);
                Math.round(w) === x && x++;
                var E = (x * v - f / 2 - y) / 2 - f / 2,
                    S = Math.ceil(m / d),
                    N = (m - S * d) / 2,
                    L = S * d - m > d / 2;
                L && (N -= d / 4);
                for (var C = h([]), M = 0; M < x; M++)
                    for (var I = 0; I <= S; I++) {
                        var k = M % 2 === 1;
                        if (!(0 === I && k || 0 === I && L)) {
                            var T = M * v + t[0] - E,
                                A = I * b + t[1] + N;
                            k && (A -= d / 2), s ? C.features.push.apply(C.features, r([T, A], u / 2, c / 2)) : C.features.push(n([T, A], u / 2, c / 2))
                        }
                    }
                return C
            }
        }, { "@turf/distance": 82, "@turf/helpers": 83 }],
        82: [function(t, e, i) { arguments[4][4][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-distance": 69, dup: 4 }],
        83: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        84: [function(t, e, i) {
            function n(t, e) {
                for (var i = !1, n = 0, r = e.length - 1; n < e.length; r = n++) {
                    var o = e[n][0],
                        s = e[n][1],
                        a = e[r][0],
                        h = e[r][1],
                        l = s > t[1] != h > t[1] && t[0] < (a - o) * (t[1] - s) / (h - s) + o;
                    l && (i = !i)
                }
                return i
            }
            var r = t("@turf/invariant");
            e.exports = function(t, e) {
                var i = r.getCoord(t),
                    o = e.geometry.coordinates;
                "Polygon" === e.geometry.type && (o = [o]);
                for (var s = 0, a = !1; s < o.length && !a; s++)
                    if (n(i, o[s][0])) {
                        for (var h = !1, l = 1; l < o[s].length && !h;) n(i, o[s][l]) && (h = !0), l++;
                        h || (a = !0)
                    }
                return a
            }
        }, { "@turf/invariant": 85 }],
        85: [function(t, e, i) { arguments[4][14][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-invariant": 88, dup: 14 }],
        86: [function(t, e, i) {
            var n = t("jsts");
            e.exports = function(t, e) {
                var i, r;
                i = "Feature" === t.type ? t.geometry : t, r = "Feature" === e.type ? e.geometry : e;
                var o = new n.io.GeoJSONReader,
                    s = o.read(JSON.stringify(i)),
                    a = o.read(JSON.stringify(r)),
                    h = s.intersection(a);
                if (!h.isEmpty()) {
                    var l = new n.io.GeoJSONWriter,
                        u = l.write(h);
                    return { type: "Feature", properties: {}, geometry: u }
                }
            }
        }, { jsts: 87 }],
        87: [function(t, e, i) { arguments[4][21][0].apply(i, arguments) }, { dup: 21 }],
        88: [function(t, e, i) {
            function n(t) { if (Array.isArray(t) && "number" == typeof t[0] && "number" == typeof t[1]) return t; if (t) { if ("Feature" === t.type && t.geometry && "Point" === t.geometry.type && Array.isArray(t.geometry.coordinates)) return t.geometry.coordinates; if ("Point" === t.type && Array.isArray(t.coordinates)) return t.coordinates } throw new Error("A coordinate, feature, or point geometry is required") }

            function r(t, e, i) { if (!e || !i) throw new Error("type and name required"); if (!t || t.type !== e) throw new Error("Invalid input to " + i + ": must be a " + e + ", given " + t.type) }

            function o(t, e, i) { if (!i) throw new Error(".featureOf() requires a name"); if (!t || "Feature" !== t.type || !t.geometry) throw new Error("Invalid input to " + i + ", Feature with geometry required"); if (!t.geometry || t.geometry.type !== e) throw new Error("Invalid input to " + i + ": must be a " + e + ", given " + t.geometry.type) }

            function s(t, e, i) { if (!i) throw new Error(".collectionOf() requires a name"); if (!t || "FeatureCollection" !== t.type) throw new Error("Invalid input to " + i + ", FeatureCollection required"); for (var n = 0; n < t.features.length; n++) { var r = t.features[n]; if (!r || "Feature" !== r.type || !r.geometry) throw new Error("Invalid input to " + i + ", Feature with geometry required"); if (!r.geometry || r.geometry.type !== e) throw new Error("Invalid input to " + i + ": must be a " + e + ", given " + r.geometry.type) } }
            e.exports.geojsonType = r, e.exports.collectionOf = s, e.exports.featureOf = o, e.exports.getCoord = n
        }, {}],
        89: [function(t, e, i) {
            function n(t, e) {
                var i = t.x - e.x,
                    n = t.y - e.y;
                return i * i + n * n < a
            }

            function r(t) {
                for (var e = t.head; e;) {
                    var i = e.next;
                    e.next = e.prev, e.prev = i, e = i
                }
                var i = t.head;
                t.head = t.tail, t.tail = i
            }

            function o(t) { this.level = t, this.s = null, this.count = 0 }

            function s(t) {
                if (t) this.drawContour = t;
                else {
                    var e = this;
                    e.contours = {}, this.drawContour = function(t, i, n, r, s, a) {
                        var h = e.contours[a];
                        h || (h = e.contours[a] = new o(s)), h.addSegment({ x: t, y: i }, { x: n, y: r })
                    }, this.contourList = function() {
                        var t = [],
                            i = e.contours;
                        for (var n in i)
                            for (var r = i[n].s, o = i[n].level; r;) {
                                var s = r.head,
                                    a = [];
                                for (a.level = o, a.k = n; s && s.p;) a.push(s.p), s = s.next;
                                t.push(a), r = r.next
                            }
                        return t.sort(function(t, e) { return t.k - e.k }), t
                    }
                }
                this.h = new Array(5), this.sh = new Array(5), this.xh = new Array(5), this.yh = new Array(5)
            }
            e.exports = s;
            var a = 1e-10;
            o.prototype.remove_seq = function(t) { t.prev ? t.prev.next = t.next : this.s = t.next, t.next && (t.next.prev = t.prev), --this.count }, o.prototype.addSegment = function(t, e) {
                for (var i = this.s, o = null, s = null, a = !1, h = !1; i && (null == o && (n(t, i.head.p) ? (o = i, a = !0) : n(t, i.tail.p) && (o = i)), null == s && (n(e, i.head.p) ? (s = i, h = !0) : n(e, i.tail.p) && (s = i)), null == s || null == o);) i = i.next;
                var l = (null != o ? 1 : 0) | (null != s ? 2 : 0);
                switch (l) {
                    case 0:
                        var u = { p: t, prev: null },
                            p = { p: e, next: null };
                        u.next = p, p.prev = u, o = { head: u, tail: p, next: this.s, prev: null, closed: !1 }, this.s && (this.s.prev = o), this.s = o, ++this.count;
                        break;
                    case 1:
                        var c = { p: e };
                        a ? (c.next = o.head, c.prev = null, o.head.prev = c, o.head = c) : (c.next = null, c.prev = o.tail, o.tail.next = c, o.tail = c);
                        break;
                    case 2:
                        var c = { p: t };
                        h ? (c.next = s.head, c.prev = null, s.head.prev = c, s.head = c) : (c.next = null, c.prev = s.tail, s.tail.next = c, s.tail = c);
                        break;
                    case 3:
                        if (o === s) {
                            var c = { p: o.tail.p, next: o.head, prev: null };
                            o.head.prev = c, o.head = c, o.closed = !0;
                            break
                        }
                        switch ((a ? 1 : 0) | (h ? 2 : 0)) {
                            case 0:
                                r(o);
                            case 1:
                                s.tail.next = o.head, o.head.prev = s.tail, s.tail = o.tail, this.remove_seq(o);
                                break;
                            case 3:
                                r(o);
                            case 2:
                                o.tail.next = s.head, s.head.prev = o.tail, o.tail = s.tail, this.remove_seq(s)
                        }
                }
            }, s.prototype.contour = function(t, e, i, n, r, o, s, h, l) {
                var u = this.h,
                    p = this.sh,
                    c = this.xh,
                    f = this.yh,
                    g = this.drawContour;
                this.contours = {};
                for (var d, y, m, v, b, w, x = function(t, e) { return (u[e] * c[t] - u[t] * c[e]) / (u[e] - u[t]) }, E = function(t, e) { return (u[e] * f[t] - u[t] * f[e]) / (u[e] - u[t]) }, S = 0, N = 0, L = 0, C = 0, M = [0, 1, 1, 0], I = [0, 0, 1, 1], k = [
                        [
                            [0, 0, 8],
                            [0, 2, 5],
                            [7, 6, 9]
                        ],
                        [
                            [0, 3, 4],
                            [1, 3, 1],
                            [4, 3, 0]
                        ],
                        [
                            [9, 6, 7],
                            [5, 2, 0],
                            [8, 0, 0]
                        ]
                    ], T = r - 1; T >= n; T--)
                    for (var A = e; A <= i - 1; A++) {
                        var R, _;
                        if (R = Math.min(t[A][T], t[A][T + 1]), _ = Math.min(t[A + 1][T], t[A + 1][T + 1]), b = Math.min(R, _), R = Math.max(t[A][T], t[A][T + 1]), _ = Math.max(t[A + 1][T], t[A + 1][T + 1]), w = Math.max(R, _), w >= l[0] && b <= l[h - 1])
                            for (var P = 0; P < h; P++)
                                if (l[P] >= b && l[P] <= w) {
                                    for (var O = 4; O >= 0; O--) O > 0 ? (u[O] = t[A + M[O - 1]][T + I[O - 1]] - l[P], c[O] = o[A + M[O - 1]], f[O] = s[T + I[O - 1]]) : (u[0] = .25 * (u[1] + u[2] + u[3] + u[4]), c[0] = .5 * (o[A] + o[A + 1]), f[0] = .5 * (s[T] + s[T + 1])), u[O] > a ? p[O] = 1 : u[O] < -a ? p[O] = -1 : p[O] = 0;
                                    for (O = 1; O <= 4; O++)
                                        if (d = O, y = 0, m = 4 != O ? O + 1 : 1, v = k[p[d] + 1][p[y] + 1][p[m] + 1], 0 != v) {
                                            switch (v) {
                                                case 1:
                                                    S = c[d], L = f[d], N = c[y], C = f[y];
                                                    break;
                                                case 2:
                                                    S = c[y], L = f[y], N = c[m], C = f[m];
                                                    break;
                                                case 3:
                                                    S = c[m], L = f[m], N = c[d], C = f[d];
                                                    break;
                                                case 4:
                                                    S = c[d], L = f[d], N = x(y, m), C = E(y, m);
                                                    break;
                                                case 5:
                                                    S = c[y], L = f[y], N = x(m, d), C = E(m, d);
                                                    break;
                                                case 6:
                                                    S = c[m], L = f[m], N = x(d, y), C = E(d, y);
                                                    break;
                                                case 7:
                                                    S = x(d, y), L = E(d, y), N = x(y, m), C = E(y, m);
                                                    break;
                                                case 8:
                                                    S = x(y, m), L = E(y, m), N = x(m, d), C = E(m, d);
                                                    break;
                                                case 9:
                                                    S = x(m, d), L = E(m, d), N = x(d, y), C = E(d, y)
                                            }
                                            g(S, L, N, C, l[P], P)
                                        }
                                }
                    }
            }
        }, {}],
        90: [function(t, e, i) {
            var n = t("@turf/tin"),
                r = t("@turf/inside"),
                o = t("turf-grid"),
                s = t("@turf/bbox"),
                a = t("@turf/planepoint"),
                h = t("@turf/helpers").featureCollection,
                l = t("@turf/helpers").lineString,
                u = t("@turf/square"),
                p = t("./conrec");
            e.exports = function(t, e, i, c) {
                for (var f = n(t, e), g = s(t), d = u(g), y = o(d, i), m = [], v = 0; v < y.features.length; v++)
                    for (var b = y.features[v], w = 0; w < f.features.length; w++) {
                        var x = f.features[w];
                        r(b, x) && (b.properties = {}, b.properties[e] = a(b, x))
                    }
                for (var E = Math.sqrt(y.features.length), S = 0; S < E; S++) {
                    for (var N = y.features.slice(S * E, (S + 1) * E), L = [], C = 0; C < N.length; C++) N[C].properties ? L.push(N[C].properties[e]) : L.push(0);
                    m.push(L)
                }
                for (var M = (d[2] - d[0]) / E, I = [], k = [], T = 0; T < E; T++) I.push(T * M + d[0]), k.push(T * M + d[1]);
                var A = new p;
                A.contour(m, 0, i, 0, i, I, k, c.length, c);
                var R = A.contourList(),
                    _ = h([]);
                return R.forEach(function(t) {
                    if (t.length > 2) {
                        var i = [];
                        t.forEach(function(t) { i.push([t.x, t.y]) });
                        var n = l(i);
                        n.properties = {}, n.properties[e] = t.level, _.features.push(n)
                    }
                }), _
            }
        }, {
            "./conrec": 89,
            "@turf/bbox": 91,
            "@turf/helpers": 92,
            "@turf/inside": 93,
            "@turf/planepoint": 94,
            "@turf/square": 95,
            "@turf/tin": 96,
            "turf-grid": 97
        }],
        91: [function(t, e, i) { arguments[4][29][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-bbox": 11, dup: 29 }],
        92: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        93: [function(t, e, i) { arguments[4][38][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-inside": 84, dup: 38 }],
        94: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-planepoint") }, { "/Users/tmcw/src/turf/packages/turf-planepoint": 120 }],
        95: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-square") }, { "/Users/tmcw/src/turf/packages/turf-square": 144 }],
        96: [function(t, e, i) { arguments[4][43][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-tin": 151, dup: 43 }],
        97: [function(t, e, i) {
            var n = t("turf-point");
            e.exports = function(t, e) {
                for (var i = t[0], r = t[1], o = t[2], s = (t[3], (o - i) / e), a = { type: "FeatureCollection", features: [] }, h = 0; h <= e; h++)
                    for (var l = 0; l <= e; l++) a.features.push(n([h * s + i, l * s + r]));
                return a
            }
        }, { "turf-point": 98 }],
        98: [function(t, e, i) {
            var n = Array.isArray || function(t) { return "[object Array]" === Object.prototype.toString.call(t) };
            e.exports = function(t, e) { if (!n(t)) throw new Error("Coordinates must be an array"); if (t.length < 2) throw new Error("Coordinates must be at least 2 numbers long"); return { type: "Feature", geometry: { type: "Point", coordinates: t }, properties: e || {} } }
        }, {}],
        99: [function(t, e, i) {
            function n(t, e, i, n, r, o, s, a) { var h, l, u, p, c, f = { x: null, y: null, onLine1: !1, onLine2: !1 }; return h = (a - o) * (i - t) - (s - r) * (n - e), 0 === h ? null !== f.x && null !== f.y && f : (l = e - o, u = t - r, p = (s - r) * l - (a - o) * u, c = (i - t) * l - (n - e) * u, l = p / h, u = c / h, f.x = t + l * (i - t), f.y = e + l * (n - e), l >= 0 && l <= 1 && (f.onLine1 = !0), u >= 0 && u <= 1 && (f.onLine2 = !0), !(!f.onLine1 || !f.onLine2) && [f.x, f.y]) }
            var r = t("@turf/helpers").point;
            e.exports = function(t) {
                var e, i = { type: "FeatureCollection", features: [] };
                return e = "Feature" === t.type ? t.geometry : t, e.coordinates.forEach(function(t) {
                    e.coordinates.forEach(function(e) {
                        for (var o = 0; o < t.length - 1; o++)
                            for (var s = 0; s < e.length - 1; s++)
                                if (t !== e || 1 !== Math.abs(o - s) && Math.abs(o - s) !== t.length - 2) {
                                    var a = n(t[o][0], t[o][1], t[o + 1][0], t[o + 1][1], e[s][0], e[s][1], e[s + 1][0], e[s + 1][1]);
                                    a && i.features.push(r([a[0], a[1]]))
                                }
                    })
                }), i
            }
        }, { "@turf/helpers": 100 }],
        100: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        101: [function(t, e, i) {
            function n(t, e) { for (var i, n = 0, s = o(t[0]), a = o(t[0]), h = 1; h < t.length; h++) a.geometry.coordinates = t[h], n += r(s, a, e), i = s, s = a, a = i; return n }
            var r = t("@turf/distance"),
                o = t("@turf/helpers").point;
            e.exports = function t(e, i) {
                if ("FeatureCollection" === e.type) return e.features.reduce(function(e, n) { return e + t(n, i) }, 0);
                var r, o, s = "Feature" === e.type ? e.geometry : e;
                if ("LineString" === s.type) return n(s.coordinates, i);
                if ("Polygon" === s.type || "MultiLineString" === s.type) { for (r = 0, o = 0; o < s.coordinates.length; o++) r += n(s.coordinates[o], i); return r }
                if ("MultiPolygon" === e.type) {
                    for (r = 0, o = 0; o < s.coordinates.length; o++)
                        for (var a = 0; a < s.coordinates[o].length; a++) r += n(s.coordinates[o][a], i);
                    return r
                }
                throw new Error("input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry (or a FeatureCollection containing only those types)")
            }
        }, { "@turf/distance": 102, "@turf/helpers": 103 }],
        102: [function(t, e, i) { arguments[4][4][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-distance": 69, dup: 4 }],
        103: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        104: [function(t, e, i) {
            var n = t("turf-bearing"),
                r = t("turf-distance"),
                o = t("turf-destination"),
                s = t("turf-helpers").lineString;
            e.exports = function(t, e, i, a) {
                var h, l = [];
                if ("Feature" === t.type) h = t.geometry.coordinates;
                else {
                    if ("LineString" !== t.type) throw new Error("input must be a LineString Feature or Geometry");
                    h = t.coordinates
                }
                for (var u, p, c, f = 0, g = 0; g < h.length && !(e >= f && g === h.length - 1); g++) {
                    if (f > e && 0 === l.length) {
                        if (u = e - f, !u) return l.push(h[g]);
                        p = n(h[g], h[g - 1]) - 180, c = o(h[g], u, p, a), l.push(c.geometry.coordinates)
                    }
                    if (f >= i) return (u = i - f) ? (p = n(h[g], h[g - 1]) - 180, c = o(h[g], u, p, a), l.push(c.geometry.coordinates), s(l)) : l.push(h[g]);
                    f >= e && l.push(h[g]), f += r(h[g], h[g + 1], a)
                }
                return s(h[h.length - 1])
            }
        }, { "turf-bearing": 105, "turf-destination": 106, "turf-distance": 107, "turf-helpers": 108 }],
        105: [function(t, e, i) {
            var n = t("turf-invariant").getCoord;
            e.exports = function(t, e) {
                var i = Math.PI / 180,
                    r = 180 / Math.PI,
                    o = n(t),
                    s = n(e),
                    a = i * o[0],
                    h = i * s[0],
                    l = i * o[1],
                    u = i * s[1],
                    p = Math.sin(h - a) * Math.cos(u),
                    c = Math.cos(l) * Math.sin(u) - Math.sin(l) * Math.cos(u) * Math.cos(h - a),
                    f = r * Math.atan2(p, c);
                return f
            }
        }, { "turf-invariant": 109 }],
        106: [function(t, e, i) {
            var n = t("turf-invariant").getCoord,
                r = t("turf-helpers"),
                o = r.point,
                s = r.distanceToRadians;
            e.exports = function(t, e, i, r) {
                var a = Math.PI / 180,
                    h = 180 / Math.PI,
                    l = n(t),
                    u = a * l[0],
                    p = a * l[1],
                    c = a * i,
                    f = s(e, r),
                    g = Math.asin(Math.sin(p) * Math.cos(f) + Math.cos(p) * Math.sin(f) * Math.cos(c)),
                    d = u + Math.atan2(Math.sin(c) * Math.sin(f) * Math.cos(p), Math.cos(f) - Math.sin(p) * Math.sin(g));
                return o([h * d, h * g])
            }
        }, { "turf-helpers": 108, "turf-invariant": 109 }],
        107: [function(t, e, i) {
            var n = t("turf-invariant").getCoord,
                r = t("turf-helpers").radiansToDistance;
            e.exports = function(t, e, i) {
                var o = Math.PI / 180,
                    s = n(t),
                    a = n(e),
                    h = o * (a[1] - s[1]),
                    l = o * (a[0] - s[0]),
                    u = o * s[1],
                    p = o * a[1],
                    c = Math.pow(Math.sin(h / 2), 2) + Math.pow(Math.sin(l / 2), 2) * Math.cos(u) * Math.cos(p);
                return r(2 * Math.atan2(Math.sqrt(c), Math.sqrt(1 - c)), i)
            }
        }, { "turf-helpers": 108, "turf-invariant": 109 }],
        108: [function(t, e, i) { arguments[4][80][0].apply(i, arguments) }, { dup: 80 }],
        109: [function(t, e, i) { arguments[4][88][0].apply(i, arguments) }, { dup: 88 }],
        110: [function(t, e, i) {
            var n = t("@turf/helpers").lineString,
                r = t("@turf/point-on-line");
            e.exports = function(t, e, i) {
                var o;
                if ("Feature" === i.type) o = i.geometry.coordinates;
                else {
                    if ("LineString" !== i.type) throw new Error("input must be a LineString Feature or Geometry");
                    o = i.coordinates
                }
                var s, a = r(i, t),
                    h = r(i, e);
                s = a.properties.index <= h.properties.index ? [a, h] : [h, a];
                for (var l = n([s[0].geometry.coordinates], {}), u = s[0].properties.index + 1; u < s[1].properties.index + 1; u++) l.geometry.coordinates.push(o[u]);
                return l.geometry.coordinates.push(s[1].geometry.coordinates), l
            }
        }, { "@turf/helpers": 111, "@turf/point-on-line": 112 }],
        111: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        112: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-point-on-line") }, { "/Users/tmcw/src/turf/packages/turf-point-on-line": 124 }],
        113: [function(t, e, i) {
            function n(t, e, i) {
                var r, o, s, a, h, l, u, p, c, f, g = 0,
                    d = "FeatureCollection" === t.type,
                    y = "Feature" === t.type,
                    m = d ? t.features.length : 1;
                for (r = 0; r < m; r++)
                    for (c = d ? t.features[r].geometry : y ? t.geometry : t, f = "GeometryCollection" === c.type, u = f ? c.geometries.length : 1, a = 0; a < u; a++)
                        if (l = f ? c.geometries[a] : c, p = l.coordinates, g = !i || "Polygon" !== l.type && "MultiPolygon" !== l.type ? 0 : 1, "Point" === l.type) e(p);
                        else if ("LineString" === l.type || "MultiPoint" === l.type)
                    for (o = 0; o < p.length; o++) e(p[o]);
                else if ("Polygon" === l.type || "MultiLineString" === l.type)
                    for (o = 0; o < p.length; o++)
                        for (s = 0; s < p[o].length - g; s++) e(p[o][s]);
                else if ("MultiPolygon" === l.type)
                    for (o = 0; o < p.length; o++)
                        for (s = 0; s < p[o].length; s++)
                            for (h = 0; h < p[o][s].length - g; h++) e(p[o][s][h]);
                else { if ("GeometryCollection" !== l.type) throw new Error("Unknown Geometry Type"); for (o = 0; o < l.geometries.length; o++) n(l.geometries[o], e, i) }
            }

            function r(t, e, i, r) { return n(t, function(t) { i = e(i, t) }, r), i }

            function o(t, e) {
                var i;
                switch (t.type) {
                    case "FeatureCollection":
                        for (i = 0; i < t.features.length; i++) e(t.features[i].properties);
                        break;
                    case "Feature":
                        e(t.properties)
                }
            }

            function s(t, e, i) { return o(t, function(t) { i = e(i, t) }), i }

            function a(t, e) {
                if ("Feature" === t.type) e(t);
                else if ("FeatureCollection" === t.type)
                    for (var i = 0; i < t.features.length; i++) e(t.features[i])
            }

            function h(t) { var e = []; return n(t, function(t) { e.push(t) }), e }
            e.exports.coordEach = n, e.exports.coordReduce = r, e.exports.propEach = o, e.exports.propReduce = s, e.exports.featureEach = a, e.exports.coordAll = h
        }, {}],
        114: [function(t, e, i) {
            var n = t("@turf/bearing"),
                r = t("@turf/destination"),
                o = t("@turf/distance");
            e.exports = function(t, e) {
                var i = o(t, e, "miles"),
                    s = n(t, e),
                    a = r(t, i / 2, s, "miles");
                return a
            }
        }, { "@turf/bearing": 115, "@turf/destination": 116, "@turf/distance": 117 }],
        115: [function(t, e, i) { arguments[4][2][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-bearing": 13, dup: 2 }],
        116: [function(t, e, i) { arguments[4][3][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-destination": 64, dup: 3 }],
        117: [function(t, e, i) { arguments[4][4][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-distance": 69, dup: 4 }],
        118: [function(t, e, i) {
            var n = t("@turf/distance");
            e.exports = function(t, e) {
                for (var i, r = 1 / 0, o = 0; o < e.features.length; o++) {
                    var s = n(t, e.features[o], "miles");
                    s < r && (i = e.features[o], r = s)
                }
                return i
            }
        }, { "@turf/distance": 119 }],
        119: [function(t, e, i) { arguments[4][4][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-distance": 69, dup: 4 }],
        120: [function(t, e, i) {
            e.exports = function(t, e) {
                var i = t.geometry.coordinates[0],
                    n = t.geometry.coordinates[1],
                    r = e.geometry.coordinates[0][0][0],
                    o = e.geometry.coordinates[0][0][1],
                    s = e.properties.a,
                    a = e.geometry.coordinates[0][1][0],
                    h = e.geometry.coordinates[0][1][1],
                    l = e.properties.b,
                    u = e.geometry.coordinates[0][2][0],
                    p = e.geometry.coordinates[0][2][1],
                    c = e.properties.c,
                    f = (c * (i - r) * (n - h) + s * (i - a) * (n - p) + l * (i - u) * (n - o) - l * (i - r) * (n - p) - c * (i - a) * (n - o) - s * (i - u) * (n - h)) / ((i - r) * (n - h) + (i - a) * (n - p) + (i - u) * (n - o) - (i - r) * (n - p) - (i - a) * (n - o) - (i - u) * (n - h));
                return f
            }
        }, {}],
        121: [function(t, e, i) {
            var n = t("@turf/helpers").point,
                r = t("@turf/helpers").featureCollection,
                o = t("@turf/distance");
            e.exports = function(t, e, i) {
                for (var s = r([]), a = e / o(n([t[0], t[1]]), n([t[2], t[1]]), i), h = a * (t[2] - t[0]), l = e / o(n([t[0], t[1]]), n([t[0], t[3]]), i), u = l * (t[3] - t[1]), p = t[0]; p <= t[2];) {
                    for (var c = t[1]; c <= t[3];) s.features.push(n([p, c])), c += u;
                    p += h
                }
                return s
            }
        }, { "@turf/distance": 122, "@turf/helpers": 123 }],
        122: [function(t, e, i) { arguments[4][4][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-distance": 69, dup: 4 }],
        123: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        124: [function(t, e, i) {
            function n(t, e, i) {
                for (var n = s([1 / 0, 1 / 0], { dist: 1 / 0 }), l = 0; l < e.length - 1; l++) {
                    var u = s(e[l]),
                        p = s(e[l + 1]);
                    u.properties.dist = o(t, u, i), p.properties.dist = o(t, p, i);
                    var c, f = Math.max(u.properties.dist, p.properties.dist),
                        g = a(u, p),
                        d = h(t, f, g + 90, i),
                        y = h(t, f, g - 90, i),
                        m = r(d.geometry.coordinates[0], d.geometry.coordinates[1], y.geometry.coordinates[0], y.geometry.coordinates[1], u.geometry.coordinates[0], u.geometry.coordinates[1], p.geometry.coordinates[0], p.geometry.coordinates[1]);
                    m && (c = s(m), c.properties.dist = o(t, c, i)), u.properties.dist < n.properties.dist && (n = u, n.properties.index = l), p.properties.dist < n.properties.dist && (n = p, n.properties.index = l), c && c.properties.dist < n.properties.dist && (n = c, n.properties.index = l)
                }
                return n
            }

            function r(t, e, i, n, r, o, s, a) { var h, l, u, p, c, f = { x: null, y: null, onLine1: !1, onLine2: !1 }; return h = (a - o) * (i - t) - (s - r) * (n - e), 0 === h ? null !== f.x && null !== f.y && f : (l = e - o, u = t - r, p = (s - r) * l - (a - o) * u, c = (i - t) * l - (n - e) * u, l = p / h, u = c / h, f.x = t + l * (i - t), f.y = e + l * (n - e), l > 0 && l < 1 && (f.onLine1 = !0), u > 0 && u < 1 && (f.onLine2 = !0), !(!f.onLine1 || !f.onLine2) && [f.x, f.y]) }
            var o = t("@turf/distance"),
                s = t("@turf/helpers").point,
                a = t("@turf/bearing"),
                h = t("@turf/destination");
            e.exports = function(t, e, i) {
                var r;
                if ("Feature" === t.type) r = t.geometry.coordinates;
                else {
                    if ("LineString" !== t.type) throw new Error("input must be a LineString Feature or Geometry");
                    r = t.coordinates
                }
                return n(e, r, i || "miles")
            }
        }, { "@turf/bearing": 125, "@turf/destination": 126, "@turf/distance": 127, "@turf/helpers": 128 }],
        125: [function(t, e, i) { arguments[4][2][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-bearing": 13, dup: 2 }],
        126: [function(t, e, i) { arguments[4][3][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-destination": 64, dup: 3 }],
        127: [function(t, e, i) { arguments[4][4][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-distance": 69, dup: 4 }],
        128: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        129: [function(t, e, i) {
            function n(t) {
                "FeatureCollection" !== t.type && ("Feature" !== t.type && (t = { type: "Feature", geometry: t, properties: {} }), t = o([t]));
                for (var e = s(t), i = !1, n = 0; !i && n < t.features.length;) {
                    var u, p, c, f, g, d, y, m = t.features[n].geometry,
                        v = !1;
                    if ("Point" === m.type) e.geometry.coordinates[0] === m.coordinates[0] && e.geometry.coordinates[1] === m.coordinates[1] && (i = !0);
                    else if ("MultiPoint" === m.type) { var b = !1; for (y = 0; !b && y < m.coordinates.length;) e.geometry.coordinates[0] === m.coordinates[y][0] && e.geometry.coordinates[1] === m.coordinates[y][1] && (i = !0, b = !0), y++ } else if ("LineString" === m.type)
                        for (y = 0; !v && y < m.coordinates.length - 1;) u = e.geometry.coordinates[0], p = e.geometry.coordinates[1], c = m.coordinates[y][0], f = m.coordinates[y][1], g = m.coordinates[y + 1][0], d = m.coordinates[y + 1][1], r(u, p, c, f, g, d) && (v = !0, i = !0), y++;
                    else if ("MultiLineString" === m.type)
                        for (var w = 0; w < m.coordinates.length;) {
                            v = !1, y = 0;
                            for (var x = m.coordinates[w]; !v && y < x.length - 1;) u = e.geometry.coordinates[0], p = e.geometry.coordinates[1], c = x[y][0], f = x[y][1], g = x[y + 1][0], d = x[y + 1][1], r(u, p, c, f, g, d) && (v = !0, i = !0), y++;
                            w++
                        } else if ("Polygon" === m.type || "MultiPolygon" === m.type) {
                            var E = { type: "Feature", geometry: m, properties: {} };
                            h(e, E) && (i = !0)
                        }
                    n++
                }
                if (i) return e;
                var S = o([]);
                for (n = 0; n < t.features.length; n++) S.features = S.features.concat(l(t.features[n]).features);
                var N, L = 1 / 0;
                for (n = 0; n < S.features.length; n++) {
                    var C = a(e, S.features[n], "miles");
                    C < L && (L = C, N = S.features[n])
                }
                return N
            }

            function r(t, e, i, n, r, o) {
                var s = Math.sqrt((r - i) * (r - i) + (o - n) * (o - n)),
                    a = Math.sqrt((t - i) * (t - i) + (e - n) * (e - n)),
                    h = Math.sqrt((r - t) * (r - t) + (o - e) * (o - e));
                if (s === a + h) return !0
            }
            var o = t("@turf/helpers").featureCollection,
                s = t("@turf/center"),
                a = t("@turf/distance"),
                h = t("@turf/inside"),
                l = t("@turf/explode");
            e.exports = n
        }, { "@turf/center": 130, "@turf/distance": 131, "@turf/explode": 132, "@turf/helpers": 133, "@turf/inside": 134 }],
        130: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-center") }, { "/Users/tmcw/src/turf/packages/turf-center": 28 }],
        131: [function(t, e, i) { arguments[4][4][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-distance": 69, dup: 4 }],
        132: [function(t, e, i) { arguments[4][25][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-explode": 75, dup: 25 }],
        133: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        134: [function(t, e, i) { arguments[4][38][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-inside": 84, dup: 38 }],
        135: [function(t, e, i) {
            var n = t("geojson-random");
            e.exports = function(t, e, i) {
                switch (i = i || {}, e = e || 1, t) {
                    case "point":
                    case "points":
                    case void 0:
                        return n.point(e, i.bbox);
                    case "polygon":
                    case "polygons":
                        return n.polygon(e, i.num_vertices, i.max_radial_length, i.bbox);
                    default:
                        throw new Error("Unknown type given: valid options are points and polygons")
                }
            }
        }, { "geojson-random": 136 }],
        136: [function(t, e, n) {
            function r(t) { return t ? u(t) : [a(), h()] }

            function o(t) { return function(e, i) { return [e[0] + t[0], e[1] + t[1]] } }

            function s() { return Math.random() - .5 }

            function a() { return 360 * s() }

            function h() { return 180 * s() }

            function l(t) { return { type: "Point", coordinates: t || [a(), h()] } }

            function u(t) { return [Math.random() * (t[2] - t[0]) + t[0], Math.random() * (t[3] - t[1]) + t[1]] }

            function p(t) { return { type: "Polygon", coordinates: t } }

            function c(t) { return { type: "Feature", geometry: t, properties: {} } }

            function f(t) { return { type: "FeatureCollection", features: t } }
            e.exports = function() { throw new Error("call .point() or .polygon() instead") }, e.exports.position = r, e.exports.point = function(t, e) { var n = []; for (i = 0; i < t; i++) n.push(c(e ? l(r(e)) : l())); return f(n) }, e.exports.polygon = function(t, e, n, s) {
                function a(t, e, i) { i[e] = e > 0 ? t + i[e - 1] : t }

                function h(t, e) {
                    t = 2 * t * Math.PI / g[g.length - 1];
                    var i = Math.random();
                    u.push([i * n * Math.sin(t), i * n * Math.cos(t)])
                }
                "number" != typeof e && (e = 10), "number" != typeof n && (n = 10);
                var l = [];
                for (i = 0; i < t; i++) {
                    var u = [],
                        g = Array.apply(null, new Array(e + 1)).map(Math.random);
                    g.forEach(a), g.forEach(h), u[u.length - 1] = u[0], u = u.map(o(r(s))), l.push(c(p([u])))
                }
                return f(l)
            }
        }, {}],
        137: [function(t, e, i) {
            function n(t, e) { for (var i, n, r = t.slice(0), o = t.length, s = o - e; o-- > s;) n = Math.floor((o + 1) * Math.random()), i = r[n], r[n] = r[o], r[o] = i; return r.slice(s) }
            var r = t("@turf/helpers").featureCollection;
            e.exports = function(t, e) { var i = r(n(t.features, e)); return i }
        }, { "@turf/helpers": 138 }],
        138: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        139: [function(t, e, i) {
            function n(t, e, i) { return "LineString" === t.geometry.type ? { type: "LineString", coordinates: s(t.geometry.coordinates, e, i) } : "MultiLineString" === t.geometry.type ? { type: "MultiLineString", coordinates: t.geometry.coordinates.map(function(t) { return s(t, e, i) }) } : "Polygon" === t.geometry.type ? { type: "Polygon", coordinates: a(t.geometry.coordinates, e, i) } : "MultiPolygon" === t.geometry.type ? { type: "MultiPolygon", coordinates: t.geometry.coordinates.map(function(t) { return a(t, e, i) }) } : t }

            function r(t) { return !(t.length < 3) && (3 !== t.length || t[2][0] !== t[0][0] || t[2][1] !== t[0][1]) }

            function o(t, e) { return { type: "Feature", geometry: t, properties: e } }

            function s(t, e, i) { return h(t.map(function(t) { return { x: t[0], y: t[1] } }), e, i).map(function(t) { return [t.x, t.y] }) }

            function a(t, e, i) { return t.map(function(t) { var n = t.map(function(t) { return { x: t[0], y: t[1] } }); if (n.length < 4) throw new Error("Invalid polygon"); for (var o = h(n, e, i).map(function(t) { return [t.x, t.y] }); !r(o);) e -= .01 * e, o = h(n, e, i).map(function(t) { return [t.x, t.y] }); return o[o.length - 1][0] === o[0][0] && o[o.length - 1][1] === o[0][1] || o.push(o[0]), o }) }
            var h = t("simplify-js"),
                l = ["LineString", "MultiLineString", "Polygon", "MultiPolygon"];
            e.exports = function(t, e, i) { return "Feature" === t.type ? o(n(t, e, i), t.properties) : "FeatureCollection" === t.type ? { type: "FeatureCollection", features: t.features.map(function(t) { var r = n(t, e, i); return l.indexOf(r.type) > -1 ? o(r, t.properties) : r }) } : "GeometryCollection" === t.type ? { type: "GeometryCollection", geometries: t.geometries.map(function(t) { return l.indexOf(t.type) > -1 ? n({ type: "Feature", geometry: t }, e, i) : t }) } : t }
        }, { "simplify-js": 140 }],
        140: [function(e, i, n) {
            ! function() {
                "use strict";

                function e(t, e) {
                    var i = t.x - e.x,
                        n = t.y - e.y;
                    return i * i + n * n
                }

                function n(t, e, i) {
                    var n = e.x,
                        r = e.y,
                        o = i.x - n,
                        s = i.y - r;
                    if (0 !== o || 0 !== s) {
                        var a = ((t.x - n) * o + (t.y - r) * s) / (o * o + s * s);
                        a > 1 ? (n = i.x, r = i.y) : a > 0 && (n += o * a, r += s * a)
                    }
                    return o = t.x - n, s = t.y - r, o * o + s * s
                }

                function r(t, i) { for (var n, r = t[0], o = [r], s = 1, a = t.length; s < a; s++) n = t[s], e(n, r) > i && (o.push(n), r = n); return r !== n && o.push(n), o }

                function o(t, e) {
                    var i, r, o, s, a = t.length,
                        h = "undefined" != typeof Uint8Array ? Uint8Array : Array,
                        l = new h(a),
                        u = 0,
                        p = a - 1,
                        c = [],
                        f = [];
                    for (l[u] = l[p] = 1; p;) {
                        for (r = 0, i = u + 1; i < p; i++) o = n(t[i], t[u], t[p]), o > r && (s = i, r = o);
                        r > e && (l[s] = 1, c.push(u, s, s, p)), p = c.pop(), u = c.pop()
                    }
                    for (i = 0; i < a; i++) l[i] && f.push(t[i]);
                    return f
                }

                function s(t, e, i) { var n = void 0 !== e ? e * e : 1; return t = i ? t : r(t, n), t = o(t, n) }
                "function" == typeof t && t.amd ? t(function() { return s }) : "undefined" != typeof i ? i.exports = s : "undefined" != typeof self ? self.simplify = s : window.simplify = s
            }()
        }, {}],
        141: [function(t, e, i) {
            var n = t("@turf/helpers").featureCollection,
                r = t("@turf/helpers").point,
                o = t("@turf/helpers").polygon,
                s = t("@turf/distance");
            e.exports = function(t, e, i) {
                for (var a = n([]), h = e / s(r([t[0], t[1]]), r([t[2], t[1]]), i), l = h * (t[2] - t[0]), u = e / s(r([t[0], t[1]]), r([t[0], t[3]]), i), p = u * (t[3] - t[1]), c = t[0]; c <= t[2];) {
                    for (var f = t[1]; f <= t[3];) {
                        var g = o([
                            [
                                [c, f],
                                [c, f + p],
                                [c + l, f + p],
                                [c + l, f],
                                [c, f]
                            ]
                        ]);
                        a.features.push(g), f += p
                    }
                    c += l
                }
                return a
            }
        }, { "@turf/distance": 142, "@turf/helpers": 143 }],
        142: [function(t, e, i) { arguments[4][4][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-distance": 69, dup: 4 }],
        143: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        144: [function(t, e, i) {
            var n = t("@turf/distance");
            e.exports = function(t) {
                var e = n(t.slice(0, 2), [t[2], t[1]], "miles"),
                    i = n(t.slice(0, 2), [t[0], t[3]], "miles");
                if (e >= i) { var r = (t[1] + t[3]) / 2; return [t[0], r - (t[2] - t[0]) / 2, t[2], r + (t[2] - t[0]) / 2] }
                var o = (t[0] + t[2]) / 2;
                return [o - (t[3] - t[1]) / 2, t[1], o + (t[3] - t[1]) / 2, t[3]]
            }
        }, { "@turf/distance": 145 }],
        145: [function(t, e, i) { arguments[4][4][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-distance": 69, dup: 4 }],
        146: [function(t, e, i) {
            var n = t("@turf/inside");
            e.exports = function(t, e, i, r) {
                return t = JSON.parse(JSON.stringify(t)), e = JSON.parse(JSON.stringify(e)), t.features.forEach(function(t) {
                    t.properties || (t.properties = {}), e.features.forEach(function(e) {
                        if (void 0 === t.properties[r]) {
                            var o = n(t, e);
                            o && (t.properties[r] = e.properties[i])
                        }
                    })
                }), t
            }
        }, { "@turf/inside": 147 }],
        147: [function(t, e, i) { arguments[4][38][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-inside": 84, dup: 38 }],
        148: [function(t, e, i) {
            function n(t) {
                var e = r(t),
                    i = 2,
                    n = s(e.vertices, e.holes, i),
                    a = [],
                    h = [];
                n.forEach(function(t, r) {
                    var o = n[r];
                    h.push([e.vertices[o * i], e.vertices[o * i + 1]])
                });
                for (var l = 0; l < h.length; l += 3) {
                    var u = h.slice(l, l + 3);
                    u.push(h[l]), a.push(o([u]))
                }
                return a
            }

            function r(t) {
                for (var e = t[0][0].length, i = { vertices: [], holes: [], dimensions: e }, n = 0, r = 0; r < t.length; r++) {
                    for (var o = 0; o < t[r].length; o++)
                        for (var s = 0; s < e; s++) i.vertices.push(t[r][o][s]);
                    r > 0 && (n += t[r - 1].length, i.holes.push(n))
                }
                return i
            }
            var o = t("@turf/helpers").polygon,
                s = t("earcut");
            e.exports = function(t) { if (!t.geometry || "Polygon" !== t.geometry.type && "MultiPolygon" !== t.geometry.type) throw new Error("input must be a Polygon or MultiPolygon"); var e = { type: "FeatureCollection", features: [] }; return "Polygon" === t.geometry.type ? e.features = n(t.geometry.coordinates) : t.geometry.coordinates.forEach(function(t) { e.features = e.features.concat(n(t)) }), e }
        }, { "@turf/helpers": 149, earcut: 150 }],
        149: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        150: [function(t, e, i) {
            "use strict";

            function n(t, e, i) {
                i = i || 2;
                var n = e && e.length,
                    o = n ? e[0] * i : t.length,
                    a = r(t, 0, o, i, !0),
                    h = [];
                if (!a) return h;
                var l, u, c, f, g, d, y;
                if (n && (a = p(t, e, a, i)), t.length > 80 * i) {
                    l = c = t[0], u = f = t[1];
                    for (var m = i; m < o; m += i) g = t[m], d = t[m + 1], g < l && (l = g), d < u && (u = d), g > c && (c = g), d > f && (f = d);
                    y = Math.max(c - l, f - u)
                }
                return s(a, h, i, l, u, y), h
            }

            function r(t, e, i, n, r) {
                var o, s;
                if (r === A(t, e, i, n) > 0)
                    for (o = e; o < i; o += n) s = I(o, t[o], t[o + 1], s);
                else
                    for (o = i - n; o >= e; o -= n) s = I(o, t[o], t[o + 1], s);
                return s && E(s, s.next) && (k(s), s = s.next), s
            }

            function o(t, e) {
                if (!t) return t;
                e || (e = t);
                var i, n = t;
                do
                    if (i = !1, n.steiner || !E(n, n.next) && 0 !== x(n.prev, n, n.next)) n = n.next;
                    else {
                        if (k(n), n = e = n.prev, n === n.next) return null;
                        i = !0
                    }
                while (i || n !== e);
                return e
            }

            function s(t, e, i, n, r, p, c) {
                if (t) {
                    !c && p && d(t, n, r, p);
                    for (var f, g, y = t; t.prev !== t.next;)
                        if (f = t.prev, g = t.next, p ? h(t, n, r, p) : a(t)) e.push(f.i / i), e.push(t.i / i), e.push(g.i / i), k(t), t = g.next, y = g.next;
                        else if (t = g, t === y) { c ? 1 === c ? (t = l(t, e, i), s(t, e, i, n, r, p, 2)) : 2 === c && u(t, e, i, n, r, p) : s(o(t), e, i, n, r, p, 1); break }
                }
            }

            function a(t) {
                var e = t.prev,
                    i = t,
                    n = t.next;
                if (x(e, i, n) >= 0) return !1;
                for (var r = t.next.next; r !== t.prev;) {
                    if (b(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && x(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function h(t, e, i, n) {
                var r = t.prev,
                    o = t,
                    s = t.next;
                if (x(r, o, s) >= 0) return !1;
                for (var a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x, h = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y, l = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x, u = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y, p = m(a, h, e, i, n), c = m(l, u, e, i, n), f = t.nextZ; f && f.z <= c;) {
                    if (f !== t.prev && f !== t.next && b(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && x(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                for (f = t.prevZ; f && f.z >= p;) {
                    if (f !== t.prev && f !== t.next && b(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && x(f.prev, f, f.next) >= 0) return !1;
                    f = f.prevZ
                }
                return !0
            }

            function l(t, e, i) {
                var n = t;
                do {
                    var r = n.prev,
                        o = n.next.next;
                    !E(r, o) && S(r, n, n.next, o) && L(r, o) && L(o, r) && (e.push(r.i / i), e.push(n.i / i), e.push(o.i / i), k(n), k(n.next), n = t = o), n = n.next
                } while (n !== t);
                return n
            }

            function u(t, e, i, n, r, a) {
                var h = t;
                do {
                    for (var l = h.next.next; l !== h.prev;) {
                        if (h.i !== l.i && w(h, l)) { var u = M(h, l); return h = o(h, h.next), u = o(u, u.next), s(h, e, i, n, r, a), void s(u, e, i, n, r, a) }
                        l = l.next
                    }
                    h = h.next
                } while (h !== t)
            }

            function p(t, e, i, n) { var s, a, h, l, u, p = []; for (s = 0, a = e.length; s < a; s++) h = e[s] * n, l = s < a - 1 ? e[s + 1] * n : t.length, u = r(t, h, l, n, !1), u === u.next && (u.steiner = !0), p.push(v(u)); for (p.sort(c), s = 0; s < p.length; s++) f(p[s], i), i = o(i, i.next); return i }

            function c(t, e) { return t.x - e.x }

            function f(t, e) {
                if (e = g(t, e)) {
                    var i = M(e, t);
                    o(i, i.next)
                }
            }

            function g(t, e) {
                var i, n = e,
                    r = t.x,
                    o = t.y,
                    s = -(1 / 0);
                do {
                    if (o <= n.y && o >= n.next.y) {
                        var a = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (a <= r && a > s) {
                            if (s = a, a === r) { if (o === n.y) return n; if (o === n.next.y) return n.next }
                            i = n.x < n.next.x ? n : n.next
                        }
                    }
                    n = n.next
                } while (n !== e);
                if (!i) return null;
                if (r === s) return i.prev;
                var h, l = i,
                    u = i.x,
                    p = i.y,
                    c = 1 / 0;
                for (n = i.next; n !== l;) r >= n.x && n.x >= u && b(o < p ? r : s, o, u, p, o < p ? s : r, o, n.x, n.y) && (h = Math.abs(o - n.y) / (r - n.x), (h < c || h === c && n.x > i.x) && L(n, t) && (i = n, c = h)), n = n.next;
                return i
            }

            function d(t, e, i, n) {
                var r = t;
                do null === r.z && (r.z = m(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== t);
                r.prevZ.nextZ = null, r.prevZ = null, y(r)
            }

            function y(t) {
                var e, i, n, r, o, s, a, h, l = 1;
                do {
                    for (i = t, t = null, o = null, s = 0; i;) {
                        for (s++, n = i, a = 0, e = 0; e < l && (a++, n = n.nextZ, n); e++);
                        for (h = l; a > 0 || h > 0 && n;) 0 === a ? (r = n, n = n.nextZ, h--) : 0 !== h && n ? i.z <= n.z ? (r = i, i = i.nextZ, a--) : (r = n, n = n.nextZ, h--) : (r = i, i = i.nextZ, a--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
                        i = n
                    }
                    o.nextZ = null, l *= 2
                } while (s > 1);
                return t
            }

            function m(t, e, i, n, r) { return t = 32767 * (t - i) / r, e = 32767 * (e - n) / r, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t | e << 1 }

            function v(t) {
                var e = t,
                    i = t;
                do e.x < i.x && (i = e), e = e.next; while (e !== t);
                return i
            }

            function b(t, e, i, n, r, o, s, a) { return (r - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (n - a) - (i - s) * (e - a) >= 0 && (i - s) * (o - a) - (r - s) * (n - a) >= 0 }

            function w(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !N(t, e) && L(t, e) && L(e, t) && C(t, e) }

            function x(t, e, i) { return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y) }

            function E(t, e) { return t.x === e.x && t.y === e.y }

            function S(t, e, i, n) { return !!(E(t, e) && E(i, n) || E(t, n) && E(i, e)) || x(t, e, i) > 0 != x(t, e, n) > 0 && x(i, n, t) > 0 != x(i, n, e) > 0 }

            function N(t, e) {
                var i = t;
                do {
                    if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && S(i, i.next, t, e)) return !0;
                    i = i.next
                } while (i !== t);
                return !1
            }

            function L(t, e) { return x(t.prev, t, t.next) < 0 ? x(t, e, t.next) >= 0 && x(t, t.prev, e) >= 0 : x(t, e, t.prev) < 0 || x(t, t.next, e) < 0 }

            function C(t, e) {
                var i = t,
                    n = !1,
                    r = (t.x + e.x) / 2,
                    o = (t.y + e.y) / 2;
                do i.y > o != i.next.y > o && r < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next; while (i !== t);
                return n
            }

            function M(t, e) {
                var i = new T(t.i, t.x, t.y),
                    n = new T(e.i, e.x, e.y),
                    r = t.next,
                    o = e.prev;
                return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n
            }

            function I(t, e, i, n) { var r = new T(t, e, i); return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r }

            function k(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) }

            function T(t, e, i) { this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 }

            function A(t, e, i, n) { for (var r = 0, o = e, s = i - n; o < i; o += n) r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o; return r }
            e.exports = n, n.deviation = function(t, e, i, n) {
                var r = e && e.length,
                    o = r ? e[0] * i : t.length,
                    s = Math.abs(A(t, 0, o, i));
                if (r)
                    for (var a = 0, h = e.length; a < h; a++) {
                        var l = e[a] * i,
                            u = a < h - 1 ? e[a + 1] * i : t.length;
                        s -= Math.abs(A(t, l, u, i))
                    }
                var p = 0;
                for (a = 0; a < n.length; a += 3) {
                    var c = n[a] * i,
                        f = n[a + 1] * i,
                        g = n[a + 2] * i;
                    p += Math.abs((t[c] - t[g]) * (t[f + 1] - t[c + 1]) - (t[c] - t[f]) * (t[g + 1] - t[c + 1]))
                }
                return 0 === s && 0 === p ? 0 : Math.abs((p - s) / s)
            }, n.flatten = function(t) {
                for (var e = t[0][0].length, i = { vertices: [], holes: [], dimensions: e }, n = 0, r = 0; r < t.length; r++) {
                    for (var o = 0; o < t[r].length; o++)
                        for (var s = 0; s < e; s++) i.vertices.push(t[r][o][s]);
                    r > 0 && (n += t[r - 1].length, i.holes.push(n))
                }
                return i
            }
        }, {}],
        151: [function(t, e, i) {
            function n(t, e, i) {
                this.a = t, this.b = e, this.c = i;
                var n, r, o, s, a = e.x - t.x,
                    h = e.y - t.y,
                    l = i.x - t.x,
                    u = i.y - t.y,
                    p = a * (t.x + e.x) + h * (t.y + e.y),
                    c = l * (t.x + i.x) + u * (t.y + i.y),
                    f = 2 * (a * (i.y - e.y) - h * (i.x - e.x));
                Math.abs(f) < 1e-6 ? (n = Math.min(t.x, e.x, i.x), r = Math.min(t.y, e.y, i.y), o = .5 * (Math.max(t.x, e.x, i.x) - n), s = .5 * (Math.max(t.y, e.y, i.y) - r), this.x = n + o, this.y = r + s, this.r = o * o + s * s) : (this.x = (u * p - h * c) / f, this.y = (a * c - l * p) / f, o = this.x - t.x, s = this.y - t.y, this.r = o * o + s * s)
            }

            function r(t, e) { return e.x - t.x }

            function o(t) {
                var e, i, n, r, o, s = t.length;
                t: for (; s;)
                    for (i = t[--s], e = t[--s], n = s; n;)
                        if (o = t[--n], r = t[--n], e === r && i === o || e === o && i === r) { t.splice(s, 2), t.splice(n, 2), s -= 2; continue t }
            }

            function s(t) {
                if (t.length < 3) return [];
                t.sort(r);
                for (var e = t.length - 1, i = t[e].x, s = t[0].x, a = t[e].y, h = a; e--;) t[e].y < a && (a = t[e].y), t[e].y > h && (h = t[e].y);
                var l, u, p, c = s - i,
                    f = h - a,
                    g = c > f ? c : f,
                    d = .5 * (s + i),
                    y = .5 * (h + a),
                    m = [new n({ x: d - 20 * g, y: y - g, __sentinel: !0 }, { x: d, y: y + 20 * g, __sentinel: !0 }, { x: d + 20 * g, y: y - g, __sentinel: !0 })],
                    v = [],
                    b = [];
                for (e = t.length; e--;) { for (b.length = 0, l = m.length; l--;) c = t[e].x - m[l].x, c > 0 && c * c > m[l].r ? (v.push(m[l]), m.splice(l, 1)) : (f = t[e].y - m[l].y, c * c + f * f > m[l].r || (b.push(m[l].a, m[l].b, m[l].b, m[l].c, m[l].c, m[l].a), m.splice(l, 1))); for (o(b), l = b.length; l;) p = b[--l], u = b[--l], m.push(new n(u, p, t[e])) }
                for (Array.prototype.push.apply(v, m), e = v.length; e--;)(v[e].a.__sentinel || v[e].b.__sentinel || v[e].c.__sentinel) && v.splice(e, 1);
                return v
            }
            var a = t("@turf/helpers").polygon,
                h = t("@turf/helpers").featureCollection;
            e.exports = function(t, e) {
                return h(s(t.features.map(function(t) { var i = { x: t.geometry.coordinates[0], y: t.geometry.coordinates[1] }; return e && (i.z = t.properties[e]), i })).map(function(t) {
                    return a([
                        [
                            [t.a.x, t.a.y],
                            [t.b.x, t.b.y],
                            [t.c.x, t.c.y],
                            [t.a.x, t.a.y]
                        ]
                    ], { a: t.a.z, b: t.b.z, c: t.c.z })
                }))
            }
        }, { "@turf/helpers": 152 }],
        152: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        153: [function(t, e, i) {
            var n = t("@turf/helpers").featureCollection,
                r = t("@turf/helpers").polygon,
                o = t("@turf/distance");
            e.exports = function(t, e, i) {
                for (var s = n([]), a = e / o([t[0], t[1]], [t[2], t[1]], i), h = a * (t[2] - t[0]), l = e / o([t[0], t[1]], [t[0], t[3]], i), u = l * (t[3] - t[1]), p = 0, c = t[0]; c <= t[2];) {
                    for (var f = 0, g = t[1]; g <= t[3];) p % 2 === 0 && f % 2 === 0 ? s.features.push(r([
                        [
                            [c, g],
                            [c, g + u],
                            [c + h, g],
                            [c, g]
                        ]
                    ]), r([
                        [
                            [c, g + u],
                            [c + h, g + u],
                            [c + h, g],
                            [c, g + u]
                        ]
                    ])) : p % 2 === 0 && f % 2 === 1 ? s.features.push(r([
                        [
                            [c, g],
                            [c + h, g + u],
                            [c + h, g],
                            [c, g]
                        ]
                    ]), r([
                        [
                            [c, g],
                            [c, g + u],
                            [c + h, g + u],
                            [c, g]
                        ]
                    ])) : f % 2 === 0 && p % 2 === 1 ? s.features.push(r([
                        [
                            [c, g],
                            [c, g + u],
                            [c + h, g + u],
                            [c, g]
                        ]
                    ]), r([
                        [
                            [c, g],
                            [c + h, g + u],
                            [c + h, g],
                            [c, g]
                        ]
                    ])) : f % 2 === 1 && p % 2 === 1 && s.features.push(r([
                        [
                            [c, g],
                            [c, g + u],
                            [c + h, g],
                            [c, g]
                        ]
                    ]), r([
                        [
                            [c, g + u],
                            [c + h, g + u],
                            [c + h, g],
                            [c, g + u]
                        ]
                    ])), g += u, f++;
                    p++, c += h
                }
                return s
            }
        }, { "@turf/distance": 154, "@turf/helpers": 155 }],
        154: [function(t, e, i) { arguments[4][4][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-distance": 69, dup: 4 }],
        155: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        156: [function(t, e, i) {
            var n = t("jsts");
            e.exports = function() { for (var t = new n.io.GeoJSONReader, e = t.read(JSON.stringify(arguments[0].geometry)), i = 1; i < arguments.length; i++) e = e.union(t.read(JSON.stringify(arguments[i].geometry))); var r = new n.io.GeoJSONWriter; return e = r.write(e), { type: "Feature", geometry: e, properties: arguments[0].properties } }
        }, { jsts: 157 }],
        157: [function(t, e, i) { arguments[4][21][0].apply(i, arguments) }, { dup: 21 }],
        158: [function(t, e, i) {
            var n = t("@turf/inside"),
                r = t("@turf/helpers").featureCollection;
            e.exports = function(t, e) {
                for (var i = r([]), o = 0; o < e.features.length; o++)
                    for (var s = 0; s < t.features.length; s++) {
                        var a = n(t.features[s], e.features[o]);
                        a && i.features.push(t.features[s])
                    }
                return i
            }
        }, { "@turf/helpers": 159, "@turf/inside": 160 }],
        159: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        160: [function(t, e, i) { arguments[4][38][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-inside": 84, dup: 38 }],
        161: [function(t, e, i) {
            var n = t("@turf/helpers");
            e.exports = {
                isolines: t("@turf/isolines"),
                convex: t("@turf/convex"),
                within: t("@turf/within"),
                concave: t("@turf/concave"),
                difference: t("@turf/difference"),
                collect: t("@turf/collect"),
                flip: t("@turf/flip"),
                simplify: t("@turf/simplify"),
                bezier: t("@turf/bezier"),
                tag: t("@turf/tag"),
                sample: t("@turf/sample"),
                envelope: t("@turf/envelope"),
                square: t("@turf/square"),
                circle: t("@turf/circle"),
                midpoint: t("@turf/midpoint"),
                buffer: t("@turf/buffer"),
                center: t("@turf/center"),
                centerOfMass: t("@turf/center-of-mass"),
                centroid: t("@turf/centroid"),
                combine: t("@turf/combine"),
                distance: t("@turf/distance"),
                explode: t("@turf/explode"),
                bbox: t("@turf/bbox"),
                tesselate: t("@turf/tesselate"),
                bboxPolygon: t("@turf/bbox-polygon"),
                inside: t("@turf/inside"),
                intersect: t("@turf/intersect"),
                nearest: t("@turf/nearest"),
                planepoint: t("@turf/planepoint"),
                random: t("@turf/random"),
                tin: t("@turf/tin"),
                union: t("@turf/union"),
                bearing: t("@turf/bearing"),
                destination: t("@turf/destination"),
                kinks: t("@turf/kinks"),
                pointOnSurface: t("@turf/point-on-surface"),
                area: t("@turf/area"),
                along: t("@turf/along"),
                lineDistance: t("@turf/line-distance"),
                lineSlice: t("@turf/line-slice"),
                lineSliceAlong: t("@turf/line-slice-along"),
                pointOnLine: t("@turf/point-on-line"),
                pointGrid: t("@turf/point-grid"),
                squareGrid: t("@turf/square-grid"),
                triangleGrid: t("@turf/triangle-grid"),
                hexGrid: t("@turf/hex-grid"),
                idw: t("@turf/idw"),
                point: n.point,
                polygon: n.polygon,
                lineString: n.lineString,
                multiPoint: n.multiPoint,
                multiPolygon: n.multiPolygon,
                multiLineString: n.multiLineString,
                feature: n.feature,
                featureCollection: n.featureCollection,
                geometryCollection: n.geometryCollection
            }
        }, { "@turf/along": 162, "@turf/area": 163, "@turf/bbox": 165, "@turf/bbox-polygon": 164, "@turf/bearing": 166, "@turf/bezier": 167, "@turf/buffer": 168, "@turf/center": 170, "@turf/center-of-mass": 169, "@turf/centroid": 171, "@turf/circle": 172, "@turf/collect": 173, "@turf/combine": 174, "@turf/concave": 175, "@turf/convex": 176, "@turf/destination": 177, "@turf/difference": 178, "@turf/distance": 179, "@turf/envelope": 180, "@turf/explode": 181, "@turf/flip": 182, "@turf/helpers": 183, "@turf/hex-grid": 184, "@turf/idw": 185, "@turf/inside": 186, "@turf/intersect": 187, "@turf/isolines": 188, "@turf/kinks": 189, "@turf/line-distance": 190, "@turf/line-slice": 192, "@turf/line-slice-along": 191, "@turf/midpoint": 193, "@turf/nearest": 194, "@turf/planepoint": 195, "@turf/point-grid": 196, "@turf/point-on-line": 197, "@turf/point-on-surface": 198, "@turf/random": 199, "@turf/sample": 200, "@turf/simplify": 201, "@turf/square": 203, "@turf/square-grid": 202, "@turf/tag": 204, "@turf/tesselate": 205, "@turf/tin": 206, "@turf/triangle-grid": 207, "@turf/union": 208, "@turf/within": 209 }],
        162: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-along") }, { "/Users/tmcw/src/turf/packages/turf-along": 1 }],
        163: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-area") }, { "/Users/tmcw/src/turf/packages/turf-area": 6 }],
        164: [function(t, e, i) { arguments[4][73][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-bbox-polygon": 9, dup: 73 }],
        165: [function(t, e, i) { arguments[4][29][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-bbox": 11, dup: 29 }],
        166: [function(t, e, i) { arguments[4][2][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-bearing": 13, dup: 2 }],
        167: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-bezier") }, { "/Users/tmcw/src/turf/packages/turf-bezier": 15 }],
        168: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-buffer") }, { "/Users/tmcw/src/turf/packages/turf-buffer": 18 }],
        169: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-center-of-mass") }, { "/Users/tmcw/src/turf/packages/turf-center-of-mass": 22 }],
        170: [function(t, e, i) { arguments[4][130][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-center": 28, dup: 130 }],
        171: [function(t, e, i) { arguments[4][23][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-centroid": 31, dup: 23 }],
        172: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-circle") }, { "/Users/tmcw/src/turf/packages/turf-circle": 34 }],
        173: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-collect") }, { "/Users/tmcw/src/turf/packages/turf-collect": 37 }],
        174: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-combine") }, { "/Users/tmcw/src/turf/packages/turf-combine": 39 }],
        175: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-concave") }, { "/Users/tmcw/src/turf/packages/turf-concave": 41 }],
        176: [function(t, e, i) { arguments[4][24][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-convex": 45, dup: 24 }],
        177: [function(t, e, i) { arguments[4][3][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-destination": 64, dup: 3 }],
        178: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-difference") }, { "/Users/tmcw/src/turf/packages/turf-difference": 67 }],
        179: [function(t, e, i) { arguments[4][4][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-distance": 69, dup: 4 }],
        180: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-envelope") }, { "/Users/tmcw/src/turf/packages/turf-envelope": 72 }],
        181: [function(t, e, i) { arguments[4][25][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-explode": 75, dup: 25 }],
        182: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-flip") }, { "/Users/tmcw/src/turf/packages/turf-flip": 78 }],
        183: [function(t, e, i) { arguments[4][5][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-helpers": 80, dup: 5 }],
        184: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-hex-grid") }, { "/Users/tmcw/src/turf/packages/turf-hex-grid": 81 }],
        185: [function(t, e, i) {
            var n = t("@turf/distance"),
                r = t("@turf/square-grid"),
                o = t("@turf/centroid"),
                s = t("@turf/bbox");
            e.exports = function(t, e, i, a, h) {
                var l = t.features.filter(function(t) { return t.properties && t.properties.hasOwnProperty(e) });
                if (0 !== l.length) {
                    for (var u = r(s(t), a, h), p = u.features.length, c = 0; c < p; c++) {
                        for (var f = 0, g = 0, d = 0; d < t.length; d++) {
                            var y = n(o(u.features[d]), t[d], h);
                            0 === y && (f = t[d].properties[e]);
                            var m = 1 / Math.pow(y, i);
                            g += m, f += m * t[d].properties[e]
                        }
                        u.features[c].properties.z = f / g
                    }
                    return u
                }
                console.log("Specified Data Field is Missing")
            }
        }, { "@turf/bbox": 165, "@turf/centroid": 171, "@turf/distance": 179, "@turf/square-grid": 202 }],
        186: [function(t, e, i) { arguments[4][38][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-inside": 84, dup: 38 }],
        187: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-intersect") }, { "/Users/tmcw/src/turf/packages/turf-intersect": 86 }],
        188: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-isolines") }, { "/Users/tmcw/src/turf/packages/turf-isolines": 90 }],
        189: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-kinks") }, { "/Users/tmcw/src/turf/packages/turf-kinks": 99 }],
        190: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-line-distance") }, { "/Users/tmcw/src/turf/packages/turf-line-distance": 101 }],
        191: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-line-slice-along") }, { "/Users/tmcw/src/turf/packages/turf-line-slice-along": 104 }],
        192: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-line-slice") }, { "/Users/tmcw/src/turf/packages/turf-line-slice": 110 }],
        193: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-midpoint") }, { "/Users/tmcw/src/turf/packages/turf-midpoint": 114 }],
        194: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-nearest") }, { "/Users/tmcw/src/turf/packages/turf-nearest": 118 }],
        195: [function(t, e, i) { arguments[4][94][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-planepoint": 120, dup: 94 }],
        196: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-point-grid") }, { "/Users/tmcw/src/turf/packages/turf-point-grid": 121 }],
        197: [function(t, e, i) { arguments[4][112][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-point-on-line": 124, dup: 112 }],
        198: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-point-on-surface") }, { "/Users/tmcw/src/turf/packages/turf-point-on-surface": 129 }],
        199: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-random") }, { "/Users/tmcw/src/turf/packages/turf-random": 135 }],
        200: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-sample") }, { "/Users/tmcw/src/turf/packages/turf-sample": 137 }],
        201: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-simplify") }, { "/Users/tmcw/src/turf/packages/turf-simplify": 139 }],
        202: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-square-grid") }, { "/Users/tmcw/src/turf/packages/turf-square-grid": 141 }],
        203: [function(t, e, i) { arguments[4][95][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-square": 144, dup: 95 }],
        204: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-tag") }, { "/Users/tmcw/src/turf/packages/turf-tag": 146 }],
        205: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-tesselate") }, { "/Users/tmcw/src/turf/packages/turf-tesselate": 148 }],
        206: [function(t, e, i) { arguments[4][43][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-tin": 151, dup: 43 }],
        207: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-triangle-grid") }, { "/Users/tmcw/src/turf/packages/turf-triangle-grid": 153 }],
        208: [function(t, e, i) { arguments[4][44][0].apply(i, arguments) }, { "/Users/tmcw/src/turf/packages/turf-union": 156, dup: 44 }],
        209: [function(t, e, i) { e.exports = t("/Users/tmcw/src/turf/packages/turf-within") }, { "/Users/tmcw/src/turf/packages/turf-within": 158 }]
    }, {}, [161])(161)
}), proj4.defs("EPSG:2056", "+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs"), proj4.defs("EPSG:21781", "+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs");
var saveAs = saveAs || function(t) {
    "use strict";
    if (!("undefined" == typeof t || "undefined" != typeof navigator && /MSIE [1-9]\./.test(navigator.userAgent))) {
        var e = t.document,
            i = function() { return t.URL || t.webkitURL || t },
            n = e.createElementNS("http://www.w3.org/1999/xhtml", "a"),
            r = "download" in n,
            o = function(t) {
                var e = new MouseEvent("click");
                t.dispatchEvent(e)
            },
            s = /constructor/i.test(t.HTMLElement) || t.safari,
            a = /CriOS\/[\d]+/.test(navigator.userAgent),
            h = function(e) {
                (t.setImmediate || t.setTimeout)(function() { throw e }, 0)
            },
            l = "application/octet-stream",
            u = 4e4,
            p = function(t) {
                var e = function() { "string" == typeof t ? i().revokeObjectURL(t) : t.remove() };
                setTimeout(e, u)
            },
            c = function(t, e, i) { e = [].concat(e); for (var n = e.length; n--;) { var r = t["on" + e[n]]; if ("function" == typeof r) try { r.call(t, i || t) } catch (t) { h(t) } } },
            f = function(t) { return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t], { type: t.type }) : t },
            g = function(e, h, u) {
                u || (e = f(e));
                var g, d = this,
                    y = e.type,
                    m = y === l,
                    v = function() { c(d, "writestart progress write writeend".split(" ")) },
                    b = function() {
                        if ((a || m && s) && t.FileReader) {
                            var n = new FileReader;
                            return n.onloadend = function() {
                                var e = a ? n.result : n.result.replace(/^data:[^;]*;/, "data:attachment/file;"),
                                    i = t.open(e, "_blank");
                                i || (t.location.href = e), e = void 0, d.readyState = d.DONE, v()
                            }, n.readAsDataURL(e), void(d.readyState = d.INIT)
                        }
                        if (g || (g = i().createObjectURL(e)), m) t.location.href = g;
                        else {
                            var r = t.open(g, "_blank");
                            r || (t.location.href = g)
                        }
                        d.readyState = d.DONE, v(), p(g)
                    };
                return d.readyState = d.INIT, r ? (g = i().createObjectURL(e), void setTimeout(function() { n.href = g, n.download = h, o(n), v(), p(g), d.readyState = d.DONE })) : void b()
            },
            d = g.prototype,
            y = function(t, e, i) { return new g(t, e || t.name || "download", i) };
        return "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function(t, e, i) { return e = e || t.name || "download", i || (t = f(t)), navigator.msSaveOrOpenBlob(t, e) } : (d.abort = function() {}, d.readyState = d.INIT = 0, d.WRITING = 1, d.DONE = 2, d.error = d.onwritestart = d.onprogress = d.onwrite = d.onabort = d.onerror = d.onwriteend = null, y)
    }
}("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);
if ("undefined" != typeof module && module.exports ? module.exports.saveAs = saveAs : "undefined" != typeof define && null !== define && null !== define.amd && define("FileSaver.js", function() { return saveAs }), function() {
        function t(t) {
            function e(e, i, n, r, o, s) {
                for (; o >= 0 && o < s; o += t) {
                    var a = r ? r[o] : o;
                    n = i(n, e[a], a, e)
                }
                return n
            }
            return function(i, n, r, o) {
                n = b(n, o, 4);
                var s = !C(i) && v.keys(i),
                    a = (s || i).length,
                    h = t > 0 ? 0 : a - 1;
                return arguments.length < 3 && (r = i[s ? s[h] : h], h += t), e(i, n, r, s, h, a)
            }
        }

        function e(t) {
            return function(e, i, n) {
                i = w(i, n);
                for (var r = L(e), o = t > 0 ? 0 : r - 1; o >= 0 && o < r; o += t)
                    if (i(e[o], o, e)) return o;
                return -1
            }
        }

        function i(t, e, i) {
            return function(n, r, o) {
                var s = 0,
                    a = L(n);
                if ("number" == typeof o) t > 0 ? s = o >= 0 ? o : Math.max(o + a, s) : a = o >= 0 ? Math.min(o + 1, a) : o + a + 1;
                else if (i && o && a) return o = i(n, r), n[o] === r ? o : -1;
                if (r !== r) return o = e(u.call(n, s, a), v.isNaN), o >= 0 ? o + s : -1;
                for (o = t > 0 ? s : a - 1; o >= 0 && o < a; o += t)
                    if (n[o] === r) return o;
                return -1
            }
        }

        function n(t, e) {
            var i = A.length,
                n = t.constructor,
                r = v.isFunction(n) && n.prototype || a,
                o = "constructor";
            for (v.has(t, o) && !v.contains(e, o) && e.push(o); i--;) o = A[i], o in t && t[o] !== r[o] && !v.contains(e, o) && e.push(o)
        }
        var r = this,
            o = r._,
            s = Array.prototype,
            a = Object.prototype,
            h = Function.prototype,
            l = s.push,
            u = s.slice,
            p = a.toString,
            c = a.hasOwnProperty,
            f = Array.isArray,
            g = Object.keys,
            d = h.bind,
            y = Object.create,
            m = function() {},
            v = function(t) { return t instanceof v ? t : this instanceof v ? void(this._wrapped = t) : new v(t) };
        "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = v), exports._ = v) : r._ = v, v.VERSION = "1.8.3";
        var b = function(t, e, i) {
                if (void 0 === e) return t;
                switch (null == i ? 3 : i) {
                    case 1:
                        return function(i) { return t.call(e, i) };
                    case 2:
                        return function(i, n) { return t.call(e, i, n) };
                    case 3:
                        return function(i, n, r) { return t.call(e, i, n, r) };
                    case 4:
                        return function(i, n, r, o) { return t.call(e, i, n, r, o) }
                }
                return function() { return t.apply(e, arguments) }
            },
            w = function(t, e, i) { return null == t ? v.identity : v.isFunction(t) ? b(t, e, i) : v.isObject(t) ? v.matcher(t) : v.property(t) };
        v.iteratee = function(t, e) { return w(t, e, 1 / 0) };
        var x = function(t, e) {
                return function(i) {
                    var n = arguments.length;
                    if (n < 2 || null == i) return i;
                    for (var r = 1; r < n; r++)
                        for (var o = arguments[r], s = t(o), a = s.length, h = 0; h < a; h++) {
                            var l = s[h];
                            e && void 0 !== i[l] || (i[l] = o[l])
                        }
                    return i
                }
            },
            E = function(t) {
                if (!v.isObject(t)) return {};
                if (y) return y(t);
                m.prototype = t;
                var e = new m;
                return m.prototype = null, e
            },
            S = function(t) { return function(e) { return null == e ? void 0 : e[t] } },
            N = Math.pow(2, 53) - 1,
            L = S("length"),
            C = function(t) { var e = L(t); return "number" == typeof e && e >= 0 && e <= N };
        v.each = v.forEach = function(t, e, i) {
            e = b(e, i);
            var n, r;
            if (C(t))
                for (n = 0, r = t.length; n < r; n++) e(t[n], n, t);
            else { var o = v.keys(t); for (n = 0, r = o.length; n < r; n++) e(t[o[n]], o[n], t) }
            return t
        }, v.map = v.collect = function(t, e, i) {
            e = w(e, i);
            for (var n = !C(t) && v.keys(t), r = (n || t).length, o = Array(r), s = 0; s < r; s++) {
                var a = n ? n[s] : s;
                o[s] = e(t[a], a, t)
            }
            return o
        }, v.reduce = v.foldl = v.inject = t(1), v.reduceRight = v.foldr = t(-1), v.find = v.detect = function(t, e, i) { var n; if (n = C(t) ? v.findIndex(t, e, i) : v.findKey(t, e, i), void 0 !== n && n !== -1) return t[n] }, v.filter = v.select = function(t, e, i) { var n = []; return e = w(e, i), v.each(t, function(t, i, r) { e(t, i, r) && n.push(t) }), n }, v.reject = function(t, e, i) { return v.filter(t, v.negate(w(e)), i) }, v.every = v.all = function(t, e, i) { e = w(e, i); for (var n = !C(t) && v.keys(t), r = (n || t).length, o = 0; o < r; o++) { var s = n ? n[o] : o; if (!e(t[s], s, t)) return !1 } return !0 }, v.some = v.any = function(t, e, i) { e = w(e, i); for (var n = !C(t) && v.keys(t), r = (n || t).length, o = 0; o < r; o++) { var s = n ? n[o] : o; if (e(t[s], s, t)) return !0 } return !1 }, v.contains = v.includes = v.include = function(t, e, i, n) { return C(t) || (t = v.values(t)), ("number" != typeof i || n) && (i = 0), v.indexOf(t, e, i) >= 0 }, v.invoke = function(t, e) {
            var i = u.call(arguments, 2),
                n = v.isFunction(e);
            return v.map(t, function(t) { var r = n ? e : t[e]; return null == r ? r : r.apply(t, i) })
        }, v.pluck = function(t, e) { return v.map(t, v.property(e)) }, v.where = function(t, e) { return v.filter(t, v.matcher(e)) }, v.findWhere = function(t, e) { return v.find(t, v.matcher(e)) }, v.max = function(t, e, i) {
            var n, r, o = -(1 / 0),
                s = -(1 / 0);
            if (null == e && null != t) { t = C(t) ? t : v.values(t); for (var a = 0, h = t.length; a < h; a++) n = t[a], n > o && (o = n) } else e = w(e, i), v.each(t, function(t, i, n) { r = e(t, i, n), (r > s || r === -(1 / 0) && o === -(1 / 0)) && (o = t, s = r) });
            return o
        }, v.min = function(t, e, i) {
            var n, r, o = 1 / 0,
                s = 1 / 0;
            if (null == e && null != t) { t = C(t) ? t : v.values(t); for (var a = 0, h = t.length; a < h; a++) n = t[a], n < o && (o = n) } else e = w(e, i), v.each(t, function(t, i, n) { r = e(t, i, n), (r < s || r === 1 / 0 && o === 1 / 0) && (o = t, s = r) });
            return o
        }, v.shuffle = function(t) { for (var e, i = C(t) ? t : v.values(t), n = i.length, r = Array(n), o = 0; o < n; o++) e = v.random(0, o), e !== o && (r[o] = r[e]), r[e] = i[o]; return r }, v.sample = function(t, e, i) { return null == e || i ? (C(t) || (t = v.values(t)), t[v.random(t.length - 1)]) : v.shuffle(t).slice(0, Math.max(0, e)) }, v.sortBy = function(t, e, i) {
            return e = w(e, i), v.pluck(v.map(t, function(t, i, n) { return { value: t, index: i, criteria: e(t, i, n) } }).sort(function(t, e) {
                var i = t.criteria,
                    n = e.criteria;
                if (i !== n) { if (i > n || void 0 === i) return 1; if (i < n || void 0 === n) return -1 }
                return t.index - e.index
            }), "value")
        };
        var M = function(t) {
            return function(e, i, n) {
                var r = {};
                return i = w(i, n), v.each(e, function(n, o) {
                    var s = i(n, o, e);
                    t(r, n, s)
                }), r
            }
        };
        v.groupBy = M(function(t, e, i) { v.has(t, i) ? t[i].push(e) : t[i] = [e] }), v.indexBy = M(function(t, e, i) { t[i] = e }), v.countBy = M(function(t, e, i) { v.has(t, i) ? t[i]++ : t[i] = 1 }), v.toArray = function(t) { return t ? v.isArray(t) ? u.call(t) : C(t) ? v.map(t, v.identity) : v.values(t) : [] }, v.size = function(t) { return null == t ? 0 : C(t) ? t.length : v.keys(t).length }, v.partition = function(t, e, i) {
            e = w(e, i);
            var n = [],
                r = [];
            return v.each(t, function(t, i, o) {
                (e(t, i, o) ? n : r).push(t)
            }), [n, r]
        }, v.first = v.head = v.take = function(t, e, i) { if (null != t) return null == e || i ? t[0] : v.initial(t, t.length - e) }, v.initial = function(t, e, i) { return u.call(t, 0, Math.max(0, t.length - (null == e || i ? 1 : e))) }, v.last = function(t, e, i) { if (null != t) return null == e || i ? t[t.length - 1] : v.rest(t, Math.max(0, t.length - e)) }, v.rest = v.tail = v.drop = function(t, e, i) { return u.call(t, null == e || i ? 1 : e) }, v.compact = function(t) { return v.filter(t, v.identity) };
        var I = function(t, e, i, n) {
            for (var r = [], o = 0, s = n || 0, a = L(t); s < a; s++) {
                var h = t[s];
                if (C(h) && (v.isArray(h) || v.isArguments(h))) {
                    e || (h = I(h, e, i));
                    var l = 0,
                        u = h.length;
                    for (r.length += u; l < u;) r[o++] = h[l++]
                } else i || (r[o++] = h)
            }
            return r
        };
        v.flatten = function(t, e) { return I(t, e, !1) }, v.without = function(t) { return v.difference(t, u.call(arguments, 1)) }, v.uniq = v.unique = function(t, e, i, n) {
            v.isBoolean(e) || (n = i, i = e, e = !1), null != i && (i = w(i, n));
            for (var r = [], o = [], s = 0, a = L(t); s < a; s++) {
                var h = t[s],
                    l = i ? i(h, s, t) : h;
                e ? (s && o === l || r.push(h), o = l) : i ? v.contains(o, l) || (o.push(l), r.push(h)) : v.contains(r, h) || r.push(h)
            }
            return r
        }, v.union = function() { return v.uniq(I(arguments, !0, !0)) }, v.intersection = function(t) {
            for (var e = [], i = arguments.length, n = 0, r = L(t); n < r; n++) {
                var o = t[n];
                if (!v.contains(e, o)) {
                    for (var s = 1; s < i && v.contains(arguments[s], o); s++);
                    s === i && e.push(o)
                }
            }
            return e
        }, v.difference = function(t) { var e = I(arguments, !0, !0, 1); return v.filter(t, function(t) { return !v.contains(e, t) }) }, v.zip = function() { return v.unzip(arguments) }, v.unzip = function(t) { for (var e = t && v.max(t, L).length || 0, i = Array(e), n = 0; n < e; n++) i[n] = v.pluck(t, n); return i }, v.object = function(t, e) { for (var i = {}, n = 0, r = L(t); n < r; n++) e ? i[t[n]] = e[n] : i[t[n][0]] = t[n][1]; return i }, v.findIndex = e(1), v.findLastIndex = e(-1), v.sortedIndex = function(t, e, i, n) {
            i = w(i, n, 1);
            for (var r = i(e), o = 0, s = L(t); o < s;) {
                var a = Math.floor((o + s) / 2);
                i(t[a]) < r ? o = a + 1 : s = a
            }
            return o
        }, v.indexOf = i(1, v.findIndex, v.sortedIndex), v.lastIndexOf = i(-1, v.findLastIndex), v.range = function(t, e, i) { null == e && (e = t || 0, t = 0), i = i || 1; for (var n = Math.max(Math.ceil((e - t) / i), 0), r = Array(n), o = 0; o < n; o++, t += i) r[o] = t; return r };
        var k = function(t, e, i, n, r) {
            if (!(n instanceof e)) return t.apply(i, r);
            var o = E(t.prototype),
                s = t.apply(o, r);
            return v.isObject(s) ? s : o
        };
        v.bind = function(t, e) {
            if (d && t.bind === d) return d.apply(t, u.call(arguments, 1));
            if (!v.isFunction(t)) throw new TypeError("Bind must be called on a function");
            var i = u.call(arguments, 2),
                n = function() { return k(t, n, e, this, i.concat(u.call(arguments))) };
            return n
        }, v.partial = function(t) {
            var e = u.call(arguments, 1),
                i = function() { for (var n = 0, r = e.length, o = Array(r), s = 0; s < r; s++) o[s] = e[s] === v ? arguments[n++] : e[s]; for (; n < arguments.length;) o.push(arguments[n++]); return k(t, i, this, this, o) };
            return i
        }, v.bindAll = function(t) { var e, i, n = arguments.length; if (n <= 1) throw new Error("bindAll must be passed function names"); for (e = 1; e < n; e++) i = arguments[e], t[i] = v.bind(t[i], t); return t }, v.memoize = function(t, e) {
            var i = function(n) {
                var r = i.cache,
                    o = "" + (e ? e.apply(this, arguments) : n);
                return v.has(r, o) || (r[o] = t.apply(this, arguments)), r[o]
            };
            return i.cache = {}, i
        }, v.delay = function(t, e) { var i = u.call(arguments, 2); return setTimeout(function() { return t.apply(null, i) }, e) }, v.defer = v.partial(v.delay, v, 1), v.throttle = function(t, e, i) {
            var n, r, o, s = null,
                a = 0;
            i || (i = {});
            var h = function() { a = i.leading === !1 ? 0 : v.now(), s = null, o = t.apply(n, r), s || (n = r = null) };
            return function() {
                var l = v.now();
                a || i.leading !== !1 || (a = l);
                var u = e - (l - a);
                return n = this, r = arguments, u <= 0 || u > e ? (s && (clearTimeout(s), s = null), a = l, o = t.apply(n, r), s || (n = r = null)) : s || i.trailing === !1 || (s = setTimeout(h, u)), o
            }
        }, v.debounce = function(t, e, i) {
            var n, r, o, s, a, h = function() {
                var l = v.now() - s;
                l < e && l >= 0 ? n = setTimeout(h, e - l) : (n = null, i || (a = t.apply(o, r), n || (o = r = null)))
            };
            return function() { o = this, r = arguments, s = v.now(); var l = i && !n; return n || (n = setTimeout(h, e)), l && (a = t.apply(o, r), o = r = null), a }
        }, v.wrap = function(t, e) { return v.partial(e, t) }, v.negate = function(t) { return function() { return !t.apply(this, arguments) } }, v.compose = function() {
            var t = arguments,
                e = t.length - 1;
            return function() { for (var i = e, n = t[e].apply(this, arguments); i--;) n = t[i].call(this, n); return n }
        }, v.after = function(t, e) { return function() { if (--t < 1) return e.apply(this, arguments) } }, v.before = function(t, e) { var i; return function() { return --t > 0 && (i = e.apply(this, arguments)), t <= 1 && (e = null), i } }, v.once = v.partial(v.before, 2);
        var T = !{ toString: null }.propertyIsEnumerable("toString"),
            A = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
        v.keys = function(t) { if (!v.isObject(t)) return []; if (g) return g(t); var e = []; for (var i in t) v.has(t, i) && e.push(i); return T && n(t, e), e }, v.allKeys = function(t) { if (!v.isObject(t)) return []; var e = []; for (var i in t) e.push(i); return T && n(t, e), e }, v.values = function(t) { for (var e = v.keys(t), i = e.length, n = Array(i), r = 0; r < i; r++) n[r] = t[e[r]]; return n }, v.mapObject = function(t, e, i) { e = w(e, i); for (var n, r = v.keys(t), o = r.length, s = {}, a = 0; a < o; a++) n = r[a], s[n] = e(t[n], n, t); return s }, v.pairs = function(t) { for (var e = v.keys(t), i = e.length, n = Array(i), r = 0; r < i; r++) n[r] = [e[r], t[e[r]]]; return n }, v.invert = function(t) { for (var e = {}, i = v.keys(t), n = 0, r = i.length; n < r; n++) e[t[i[n]]] = i[n]; return e }, v.functions = v.methods = function(t) { var e = []; for (var i in t) v.isFunction(t[i]) && e.push(i); return e.sort() }, v.extend = x(v.allKeys), v.extendOwn = v.assign = x(v.keys), v.findKey = function(t, e, i) {
            e = w(e, i);
            for (var n, r = v.keys(t), o = 0, s = r.length; o < s; o++)
                if (n = r[o], e(t[n], n, t)) return n
        }, v.pick = function(t, e, i) {
            var n, r, o = {},
                s = t;
            if (null == s) return o;
            v.isFunction(e) ? (r = v.allKeys(s), n = b(e, i)) : (r = I(arguments, !1, !1, 1), n = function(t, e, i) { return e in i }, s = Object(s));
            for (var a = 0, h = r.length; a < h; a++) {
                var l = r[a],
                    u = s[l];
                n(u, l, s) && (o[l] = u)
            }
            return o
        }, v.omit = function(t, e, i) {
            if (v.isFunction(e)) e = v.negate(e);
            else {
                var n = v.map(I(arguments, !1, !1, 1), String);
                e = function(t, e) { return !v.contains(n, e) }
            }
            return v.pick(t, e, i)
        }, v.defaults = x(v.allKeys, !0), v.create = function(t, e) { var i = E(t); return e && v.extendOwn(i, e), i }, v.clone = function(t) { return v.isObject(t) ? v.isArray(t) ? t.slice() : v.extend({}, t) : t }, v.tap = function(t, e) { return e(t), t }, v.isMatch = function(t, e) {
            var i = v.keys(e),
                n = i.length;
            if (null == t) return !n;
            for (var r = Object(t), o = 0; o < n; o++) { var s = i[o]; if (e[s] !== r[s] || !(s in r)) return !1 }
            return !0
        };
        var R = function(t, e, i, n) {
            if (t === e) return 0 !== t || 1 / t === 1 / e;
            if (null == t || null == e) return t === e;
            t instanceof v && (t = t._wrapped), e instanceof v && (e = e._wrapped);
            var r = p.call(t);
            if (r !== p.call(e)) return !1;
            switch (r) {
                case "[object RegExp]":
                case "[object String]":
                    return "" + t == "" + e;
                case "[object Number]":
                    return +t !== +t ? +e !== +e : 0 === +t ? 1 / +t === 1 / e : +t === +e;
                case "[object Date]":
                case "[object Boolean]":
                    return +t === +e
            }
            var o = "[object Array]" === r;
            if (!o) {
                if ("object" != typeof t || "object" != typeof e) return !1;
                var s = t.constructor,
                    a = e.constructor;
                if (s !== a && !(v.isFunction(s) && s instanceof s && v.isFunction(a) && a instanceof a) && "constructor" in t && "constructor" in e) return !1
            }
            i = i || [], n = n || [];
            for (var h = i.length; h--;)
                if (i[h] === t) return n[h] === e;
            if (i.push(t), n.push(e), o) {
                if (h = t.length, h !== e.length) return !1;
                for (; h--;)
                    if (!R(t[h], e[h], i, n)) return !1
            } else {
                var l, u = v.keys(t);
                if (h = u.length, v.keys(e).length !== h) return !1;
                for (; h--;)
                    if (l = u[h], !v.has(e, l) || !R(t[l], e[l], i, n)) return !1
            }
            return i.pop(), n.pop(), !0
        };
        v.isEqual = function(t, e) { return R(t, e) }, v.isEmpty = function(t) { return null == t || (C(t) && (v.isArray(t) || v.isString(t) || v.isArguments(t)) ? 0 === t.length : 0 === v.keys(t).length) }, v.isElement = function(t) { return !(!t || 1 !== t.nodeType) }, v.isArray = f || function(t) { return "[object Array]" === p.call(t) }, v.isObject = function(t) { var e = typeof t; return "function" === e || "object" === e && !!t }, v.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error"], function(t) { v["is" + t] = function(e) { return p.call(e) === "[object " + t + "]" } }), v.isArguments(arguments) || (v.isArguments = function(t) { return v.has(t, "callee") }), "function" != typeof /./ && "object" != typeof Int8Array && (v.isFunction = function(t) { return "function" == typeof t || !1 }), v.isFinite = function(t) { return isFinite(t) && !isNaN(parseFloat(t)) }, v.isNaN = function(t) { return v.isNumber(t) && t !== +t }, v.isBoolean = function(t) { return t === !0 || t === !1 || "[object Boolean]" === p.call(t) }, v.isNull = function(t) { return null === t }, v.isUndefined = function(t) { return void 0 === t }, v.has = function(t, e) { return null != t && c.call(t, e) }, v.noConflict = function() { return r._ = o, this }, v.identity = function(t) { return t }, v.constant = function(t) { return function() { return t } }, v.noop = function() {}, v.property = S, v.propertyOf = function(t) { return null == t ? function() {} : function(e) { return t[e] } }, v.matcher = v.matches = function(t) {
            return t = v.extendOwn({}, t),
                function(e) { return v.isMatch(e, t) }
        }, v.times = function(t, e, i) {
            var n = Array(Math.max(0, t));
            e = b(e, i, 1);
            for (var r = 0; r < t; r++) n[r] = e(r);
            return n
        }, v.random = function(t, e) { return null == e && (e = t, t = 0), t + Math.floor(Math.random() * (e - t + 1)) }, v.now = Date.now || function() { return (new Date).getTime() };
        var _ = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" },
            P = v.invert(_),
            O = function(t) {
                var e = function(e) { return t[e] },
                    i = "(?:" + v.keys(t).join("|") + ")",
                    n = RegExp(i),
                    r = RegExp(i, "g");
                return function(t) { return t = null == t ? "" : "" + t, n.test(t) ? t.replace(r, e) : t }
            };
        v.escape = O(_), v.unescape = O(P), v.result = function(t, e, i) { var n = null == t ? void 0 : t[e]; return void 0 === n && (n = i), v.isFunction(n) ? n.call(t) : n };
        var D = 0;
        v.uniqueId = function(t) { var e = ++D + ""; return t ? t + e : e }, v.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g };
        var F = /(.)^/,
            U = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "\u2028": "u2028", "\u2029": "u2029" },
            B = /\\|'|\r|\n|\u2028|\u2029/g,
            j = function(t) { return "\\" + U[t] };
        v.template = function(t, e, i) {
            !e && i && (e = i), e = v.defaults({}, e, v.templateSettings);
            var n = RegExp([(e.escape || F).source, (e.interpolate || F).source, (e.evaluate || F).source].join("|") + "|$", "g"),
                r = 0,
                o = "__p+='";
            t.replace(n, function(e, i, n, s, a) { return o += t.slice(r, a).replace(B, j), r = a + e.length, i ? o += "'+\n((__t=(" + i + "))==null?'':_.escape(__t))+\n'" : n ? o += "'+\n((__t=(" + n + "))==null?'':__t)+\n'" : s && (o += "';\n" + s + "\n__p+='"), e }), o += "';\n", e.variable || (o = "with(obj||{}){\n" + o + "}\n"), o = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + o + "return __p;\n";
            try { var s = new Function(e.variable || "obj", "_", o) } catch (t) { throw t.source = o, t }
            var a = function(t) { return s.call(this, t, v) },
                h = e.variable || "obj";
            return a.source = "function(" + h + "){\n" + o + "}", a
        }, v.chain = function(t) { var e = v(t); return e._chain = !0, e };
        var z = function(t, e) { return t._chain ? v(e).chain() : e };
        v.mixin = function(t) {
            v.each(v.functions(t), function(e) {
                var i = v[e] = t[e];
                v.prototype[e] = function() { var t = [this._wrapped]; return l.apply(t, arguments), z(this, i.apply(v, t)) }
            })
        }, v.mixin(v), v.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(t) {
            var e = s[t];
            v.prototype[t] = function() { var i = this._wrapped; return e.apply(i, arguments), "shift" !== t && "splice" !== t || 0 !== i.length || delete i[0], z(this, i) }
        }), v.each(["concat", "join", "slice"], function(t) {
            var e = s[t];
            v.prototype[t] = function() { return z(this, e.apply(this._wrapped, arguments)) }
        }), v.prototype.value = function() { return this._wrapped }, v.prototype.valueOf = v.prototype.toJSON = v.prototype.value, v.prototype.toString = function() { return "" + this._wrapped }, "function" == typeof define && define.amd && define("underscore", [], function() { return v })
    }.call(this), "undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery"); + function(t) { "use strict"; var e = t.fn.jquery.split(" ")[0].split("."); if (e[0] < 2 && e[1] < 9 || 1 == e[0] && 9 == e[1] && e[2] < 1 || e[0] > 3) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4") }(jQuery), + function(t) {
    "use strict";

    function e() {
        var t = document.createElement("bootstrap"),
            e = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" };
        for (var i in e)
            if (void 0 !== t.style[i]) return { end: e[i] };
        return !1
    }
    t.fn.emulateTransitionEnd = function(e) {
        var i = !1,
            n = this;
        t(this).one("bsTransitionEnd", function() { i = !0 });
        var r = function() { i || t(n).trigger(t.support.transition.end) };
        return setTimeout(r, e), this
    }, t(function() { t.support.transition = e(), t.support.transition && (t.event.special.bsTransitionEnd = { bindType: t.support.transition.end, delegateType: t.support.transition.end, handle: function(e) { if (t(e.target).is(this)) return e.handleObj.handler.apply(this, arguments) } }) })
}(jQuery), + function(t) {
    "use strict";

    function e(e) {
        return this.each(function() {
            var i = t(this),
                r = i.data("bs.alert");
            r || i.data("bs.alert", r = new n(this)), "string" == typeof e && r[e].call(i)
        })
    }
    var i = '[data-dismiss="alert"]',
        n = function(e) { t(e).on("click", i, this.close) };
    n.VERSION = "3.3.7", n.TRANSITION_DURATION = 150, n.prototype.close = function(e) {
        function i() { s.detach().trigger("closed.bs.alert").remove() }
        var r = t(this),
            o = r.attr("data-target");
        o || (o = r.attr("href"), o = o && o.replace(/.*(?=#[^\s]*$)/, ""));
        var s = t("#" === o ? [] : o);
        e && e.preventDefault(), s.length || (s = r.closest(".alert")), s.trigger(e = t.Event("close.bs.alert")), e.isDefaultPrevented() || (s.removeClass("in"), t.support.transition && s.hasClass("fade") ? s.one("bsTransitionEnd", i).emulateTransitionEnd(n.TRANSITION_DURATION) : i())
    };
    var r = t.fn.alert;
    t.fn.alert = e, t.fn.alert.Constructor = n, t.fn.alert.noConflict = function() { return t.fn.alert = r, this }, t(document).on("click.bs.alert.data-api", i, n.prototype.close)
}(jQuery), + function(t) {
    "use strict";

    function e(e) {
        return this.each(function() {
            var n = t(this),
                r = n.data("bs.button"),
                o = "object" == typeof e && e;
            r || n.data("bs.button", r = new i(this, o)), "toggle" == e ? r.toggle() : e && r.setState(e)
        })
    }
    var i = function(e, n) { this.$element = t(e), this.options = t.extend({}, i.DEFAULTS, n), this.isLoading = !1 };
    i.VERSION = "3.3.7", i.DEFAULTS = { loadingText: "loading..." }, i.prototype.setState = function(e) {
        var i = "disabled",
            n = this.$element,
            r = n.is("input") ? "val" : "html",
            o = n.data();
        e += "Text", null == o.resetText && n.data("resetText", n[r]()), setTimeout(t.proxy(function() { n[r](null == o[e] ? this.options[e] : o[e]), "loadingText" == e ? (this.isLoading = !0, n.addClass(i).attr(i, i).prop(i, !0)) : this.isLoading && (this.isLoading = !1, n.removeClass(i).removeAttr(i).prop(i, !1)) }, this), 0)
    }, i.prototype.toggle = function() {
        var t = !0,
            e = this.$element.closest('[data-toggle="buttons"]');
        if (e.length) { var i = this.$element.find("input"); "radio" == i.prop("type") ? (i.prop("checked") && (t = !1), e.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == i.prop("type") && (i.prop("checked") !== this.$element.hasClass("active") && (t = !1), this.$element.toggleClass("active")), i.prop("checked", this.$element.hasClass("active")), t && i.trigger("change") } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active")
    };
    var n = t.fn.button;
    t.fn.button = e, t.fn.button.Constructor = i, t.fn.button.noConflict = function() { return t.fn.button = n, this }, t(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(i) {
        var n = t(i.target).closest(".btn");
        e.call(n, "toggle"), t(i.target).is('input[type="radio"], input[type="checkbox"]') || (i.preventDefault(), n.is("input,button") ? n.trigger("focus") : n.find("input:visible,button:visible").first().trigger("focus"))
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(e) { t(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type)) })
}(jQuery), + function(t) {
    "use strict";

    function e(e) {
        return this.each(function() {
            var n = t(this),
                r = n.data("bs.carousel"),
                o = t.extend({}, i.DEFAULTS, n.data(), "object" == typeof e && e),
                s = "string" == typeof e ? e : o.slide;
            r || n.data("bs.carousel", r = new i(this, o)), "number" == typeof e ? r.to(e) : s ? r[s]() : o.interval && r.pause().cycle()
        })
    }
    var i = function(e, i) { this.$element = t(e), this.$indicators = this.$element.find(".carousel-indicators"), this.options = i, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", t.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", t.proxy(this.pause, this)).on("mouseleave.bs.carousel", t.proxy(this.cycle, this)) };
    i.VERSION = "3.3.7", i.TRANSITION_DURATION = 600, i.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0,
        keyboard: !0
    }, i.prototype.keydown = function(t) {
        if (!/input|textarea/i.test(t.target.tagName)) {
            switch (t.which) {
                case 37:
                    this.prev();
                    break;
                case 39:
                    this.next();
                    break;
                default:
                    return
            }
            t.preventDefault()
        }
    }, i.prototype.cycle = function(e) { return e || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(t.proxy(this.next, this), this.options.interval)), this }, i.prototype.getItemIndex = function(t) { return this.$items = t.parent().children(".item"), this.$items.index(t || this.$active) }, i.prototype.getItemForDirection = function(t, e) {
        var i = this.getItemIndex(e),
            n = "prev" == t && 0 === i || "next" == t && i == this.$items.length - 1;
        if (n && !this.options.wrap) return e;
        var r = "prev" == t ? -1 : 1,
            o = (i + r) % this.$items.length;
        return this.$items.eq(o)
    }, i.prototype.to = function(t) {
        var e = this,
            i = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        if (!(t > this.$items.length - 1 || t < 0)) return this.sliding ? this.$element.one("slid.bs.carousel", function() { e.to(t) }) : i == t ? this.pause().cycle() : this.slide(t > i ? "next" : "prev", this.$items.eq(t))
    }, i.prototype.pause = function(e) { return e || (this.paused = !0), this.$element.find(".next, .prev").length && t.support.transition && (this.$element.trigger(t.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this }, i.prototype.next = function() { if (!this.sliding) return this.slide("next") }, i.prototype.prev = function() { if (!this.sliding) return this.slide("prev") }, i.prototype.slide = function(e, n) {
        var r = this.$element.find(".item.active"),
            o = n || this.getItemForDirection(e, r),
            s = this.interval,
            a = "next" == e ? "left" : "right",
            h = this;
        if (o.hasClass("active")) return this.sliding = !1;
        var l = o[0],
            u = t.Event("slide.bs.carousel", { relatedTarget: l, direction: a });
        if (this.$element.trigger(u), !u.isDefaultPrevented()) {
            if (this.sliding = !0, s && this.pause(), this.$indicators.length) {
                this.$indicators.find(".active").removeClass("active");
                var p = t(this.$indicators.children()[this.getItemIndex(o)]);
                p && p.addClass("active")
            }
            var c = t.Event("slid.bs.carousel", { relatedTarget: l, direction: a });
            return t.support.transition && this.$element.hasClass("slide") ? (o.addClass(e), o[0].offsetWidth, r.addClass(a), o.addClass(a), r.one("bsTransitionEnd", function() { o.removeClass([e, a].join(" ")).addClass("active"), r.removeClass(["active", a].join(" ")), h.sliding = !1, setTimeout(function() { h.$element.trigger(c) }, 0) }).emulateTransitionEnd(i.TRANSITION_DURATION)) : (r.removeClass("active"), o.addClass("active"), this.sliding = !1, this.$element.trigger(c)), s && this.cycle(), this
        }
    };
    var n = t.fn.carousel;
    t.fn.carousel = e, t.fn.carousel.Constructor = i, t.fn.carousel.noConflict = function() { return t.fn.carousel = n, this };
    var r = function(i) {
        var n, r = t(this),
            o = t(r.attr("data-target") || (n = r.attr("href")) && n.replace(/.*(?=#[^\s]+$)/, ""));
        if (o.hasClass("carousel")) {
            var s = t.extend({}, o.data(), r.data()),
                a = r.attr("data-slide-to");
            a && (s.interval = !1), e.call(o, s), a && o.data("bs.carousel").to(a), i.preventDefault()
        }
    };
    t(document).on("click.bs.carousel.data-api", "[data-slide]", r).on("click.bs.carousel.data-api", "[data-slide-to]", r), t(window).on("load", function() {
        t('[data-ride="carousel"]').each(function() {
            var i = t(this);
            e.call(i, i.data())
        })
    })
}(jQuery), + function(t) {
    "use strict";

    function e(e) { var i, n = e.attr("data-target") || (i = e.attr("href")) && i.replace(/.*(?=#[^\s]+$)/, ""); return t(n) }

    function i(e) {
        return this.each(function() {
            var i = t(this),
                r = i.data("bs.collapse"),
                o = t.extend({}, n.DEFAULTS, i.data(), "object" == typeof e && e);
            !r && o.toggle && /show|hide/.test(e) && (o.toggle = !1), r || i.data("bs.collapse", r = new n(this, o)), "string" == typeof e && r[e]()
        })
    }
    var n = function(e, i) { this.$element = t(e), this.options = t.extend({}, n.DEFAULTS, i), this.$trigger = t('[data-toggle="collapse"][href="#' + e.id + '"],[data-toggle="collapse"][data-target="#' + e.id + '"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle() };
    n.VERSION = "3.3.7", n.TRANSITION_DURATION = 350, n.DEFAULTS = { toggle: !0 }, n.prototype.dimension = function() { var t = this.$element.hasClass("width"); return t ? "width" : "height" }, n.prototype.show = function() {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var e, r = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
            if (!(r && r.length && (e = r.data("bs.collapse"), e && e.transitioning))) {
                var o = t.Event("show.bs.collapse");
                if (this.$element.trigger(o), !o.isDefaultPrevented()) {
                    r && r.length && (i.call(r, "hide"), e || r.data("bs.collapse", null));
                    var s = this.dimension();
                    this.$element.removeClass("collapse").addClass("collapsing")[s](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;
                    var a = function() { this.$element.removeClass("collapsing").addClass("collapse in")[s](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse") };
                    if (!t.support.transition) return a.call(this);
                    var h = t.camelCase(["scroll", s].join("-"));
                    this.$element.one("bsTransitionEnd", t.proxy(a, this)).emulateTransitionEnd(n.TRANSITION_DURATION)[s](this.$element[0][h])
                }
            }
        }
    }, n.prototype.hide = function() {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var e = t.Event("hide.bs.collapse");
            if (this.$element.trigger(e), !e.isDefaultPrevented()) {
                var i = this.dimension();
                this.$element[i](this.$element[i]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;
                var r = function() { this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse") };
                return t.support.transition ? void this.$element[i](0).one("bsTransitionEnd", t.proxy(r, this)).emulateTransitionEnd(n.TRANSITION_DURATION) : r.call(this)
            }
        }
    }, n.prototype.toggle = function() { this[this.$element.hasClass("in") ? "hide" : "show"]() }, n.prototype.getParent = function() {
        return t(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each(t.proxy(function(i, n) {
            var r = t(n);
            this.addAriaAndCollapsedClass(e(r), r)
        }, this)).end()
    }, n.prototype.addAriaAndCollapsedClass = function(t, e) {
        var i = t.hasClass("in");
        t.attr("aria-expanded", i), e.toggleClass("collapsed", !i).attr("aria-expanded", i)
    };
    var r = t.fn.collapse;
    t.fn.collapse = i, t.fn.collapse.Constructor = n, t.fn.collapse.noConflict = function() { return t.fn.collapse = r, this }, t(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function(n) {
        var r = t(this);
        r.attr("data-target") || n.preventDefault();
        var o = e(r),
            s = o.data("bs.collapse"),
            a = s ? "toggle" : r.data();
        i.call(o, a)
    })
}(jQuery), + function(t) {
    "use strict";

    function e(e) {
        var i = e.attr("data-target");
        i || (i = e.attr("href"), i = i && /#[A-Za-z]/.test(i) && i.replace(/.*(?=#[^\s]*$)/, ""));
        var n = i && t(i);
        return n && n.length ? n : e.parent()
    }

    function i(i) {
        i && 3 === i.which || (t(r).remove(), t(o).each(function() {
            var n = t(this),
                r = e(n),
                o = { relatedTarget: this };
            r.hasClass("open") && (i && "click" == i.type && /input|textarea/i.test(i.target.tagName) && t.contains(r[0], i.target) || (r.trigger(i = t.Event("hide.bs.dropdown", o)), i.isDefaultPrevented() || (n.attr("aria-expanded", "false"), r.removeClass("open").trigger(t.Event("hidden.bs.dropdown", o)))))
        }))
    }

    function n(e) {
        return this.each(function() {
            var i = t(this),
                n = i.data("bs.dropdown");
            n || i.data("bs.dropdown", n = new s(this)), "string" == typeof e && n[e].call(i)
        })
    }
    var r = ".dropdown-backdrop",
        o = '[data-toggle="dropdown"]',
        s = function(e) { t(e).on("click.bs.dropdown", this.toggle) };
    s.VERSION = "3.3.7", s.prototype.toggle = function(n) {
        var r = t(this);
        if (!r.is(".disabled, :disabled")) {
            var o = e(r),
                s = o.hasClass("open");
            if (i(), !s) {
                "ontouchstart" in document.documentElement && !o.closest(".navbar-nav").length && t(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(t(this)).on("click", i);
                var a = { relatedTarget: this };
                if (o.trigger(n = t.Event("show.bs.dropdown", a)), n.isDefaultPrevented()) return;
                r.trigger("focus").attr("aria-expanded", "true"), o.toggleClass("open").trigger(t.Event("shown.bs.dropdown", a))
            }
            return !1
        }
    }, s.prototype.keydown = function(i) {
        if (/(38|40|27|32)/.test(i.which) && !/input|textarea/i.test(i.target.tagName)) {
            var n = t(this);
            if (i.preventDefault(), i.stopPropagation(), !n.is(".disabled, :disabled")) {
                var r = e(n),
                    s = r.hasClass("open");
                if (!s && 27 != i.which || s && 27 == i.which) return 27 == i.which && r.find(o).trigger("focus"), n.trigger("click");
                var a = " li:not(.disabled):visible a",
                    h = r.find(".dropdown-menu" + a);
                if (h.length) {
                    var l = h.index(i.target);
                    38 == i.which && l > 0 && l--, 40 == i.which && l < h.length - 1 && l++, ~l || (l = 0), h.eq(l).trigger("focus")
                }
            }
        }
    };
    var a = t.fn.dropdown;
    t.fn.dropdown = n, t.fn.dropdown.Constructor = s, t.fn.dropdown.noConflict = function() { return t.fn.dropdown = a, this }, t(document).on("click.bs.dropdown.data-api", i).on("click.bs.dropdown.data-api", ".dropdown form", function(t) { t.stopPropagation() }).on("click.bs.dropdown.data-api", o, s.prototype.toggle).on("keydown.bs.dropdown.data-api", o, s.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", s.prototype.keydown)
}(jQuery), + function(t) {
    "use strict";

    function e(e, n) {
        return this.each(function() {
            var r = t(this),
                o = r.data("bs.modal"),
                s = t.extend({}, i.DEFAULTS, r.data(), "object" == typeof e && e);
            o || r.data("bs.modal", o = new i(this, s)), "string" == typeof e ? o[e](n) : s.show && o.show(n)
        })
    }
    var i = function(e, i) { this.options = i, this.$body = t(document.body), this.$element = t(e), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, t.proxy(function() { this.$element.trigger("loaded.bs.modal") }, this)) };
    i.VERSION = "3.3.7", i.TRANSITION_DURATION = 300, i.BACKDROP_TRANSITION_DURATION = 150, i.DEFAULTS = { backdrop: !0, keyboard: !0, show: !0 }, i.prototype.toggle = function(t) { return this.isShown ? this.hide() : this.show(t) }, i.prototype.show = function(e) {
        var n = this,
            r = t.Event("show.bs.modal", { relatedTarget: e });
        this.$element.trigger(r), this.isShown || r.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', t.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function() { n.$element.one("mouseup.dismiss.bs.modal", function(e) { t(e.target).is(n.$element) && (n.ignoreBackdropClick = !0) }) }), this.backdrop(function() {
            var r = t.support.transition && n.$element.hasClass("fade");
            n.$element.parent().length || n.$element.appendTo(n.$body), n.$element.show().scrollTop(0), n.adjustDialog(), r && n.$element[0].offsetWidth, n.$element.addClass("in"), n.enforceFocus();
            var o = t.Event("shown.bs.modal", { relatedTarget: e });
            r ? n.$dialog.one("bsTransitionEnd", function() { n.$element.trigger("focus").trigger(o) }).emulateTransitionEnd(i.TRANSITION_DURATION) : n.$element.trigger("focus").trigger(o)
        }))
    }, i.prototype.hide = function(e) { e && e.preventDefault(), e = t.Event("hide.bs.modal"), this.$element.trigger(e), this.isShown && !e.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), t(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), t.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", t.proxy(this.hideModal, this)).emulateTransitionEnd(i.TRANSITION_DURATION) : this.hideModal()) }, i.prototype.enforceFocus = function() { t(document).off("focusin.bs.modal").on("focusin.bs.modal", t.proxy(function(t) { document === t.target || this.$element[0] === t.target || this.$element.has(t.target).length || this.$element.trigger("focus") }, this)) }, i.prototype.escape = function() { this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", t.proxy(function(t) { 27 == t.which && this.hide() }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal") }, i.prototype.resize = function() { this.isShown ? t(window).on("resize.bs.modal", t.proxy(this.handleUpdate, this)) : t(window).off("resize.bs.modal") }, i.prototype.hideModal = function() {
        var t = this;
        this.$element.hide(), this.backdrop(function() { t.$body.removeClass("modal-open"), t.resetAdjustments(), t.resetScrollbar(), t.$element.trigger("hidden.bs.modal") })
    }, i.prototype.removeBackdrop = function() { this.$backdrop && this.$backdrop.remove(), this.$backdrop = null }, i.prototype.backdrop = function(e) {
        var n = this,
            r = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var o = t.support.transition && r;
            if (this.$backdrop = t(document.createElement("div")).addClass("modal-backdrop " + r).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", t.proxy(function(t) { return this.ignoreBackdropClick ? void(this.ignoreBackdropClick = !1) : void(t.target === t.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide())) }, this)), o && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !e) return;
            o ? this.$backdrop.one("bsTransitionEnd", e).emulateTransitionEnd(i.BACKDROP_TRANSITION_DURATION) : e()
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var s = function() { n.removeBackdrop(), e && e() };
            t.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", s).emulateTransitionEnd(i.BACKDROP_TRANSITION_DURATION) : s()
        } else e && e()
    }, i.prototype.handleUpdate = function() { this.adjustDialog() }, i.prototype.adjustDialog = function() {
        var t = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({ paddingLeft: !this.bodyIsOverflowing && t ? this.scrollbarWidth : "", paddingRight: this.bodyIsOverflowing && !t ? this.scrollbarWidth : "" })
    }, i.prototype.resetAdjustments = function() { this.$element.css({ paddingLeft: "", paddingRight: "" }) }, i.prototype.checkScrollbar = function() {
        var t = window.innerWidth;
        if (!t) {
            var e = document.documentElement.getBoundingClientRect();
            t = e.right - Math.abs(e.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < t, this.scrollbarWidth = this.measureScrollbar()
    }, i.prototype.setScrollbar = function() {
        var t = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", t + this.scrollbarWidth)
    }, i.prototype.resetScrollbar = function() { this.$body.css("padding-right", this.originalBodyPad) }, i.prototype.measureScrollbar = function() {
        var t = document.createElement("div");
        t.className = "modal-scrollbar-measure", this.$body.append(t);
        var e = t.offsetWidth - t.clientWidth;
        return this.$body[0].removeChild(t), e
    };
    var n = t.fn.modal;
    t.fn.modal = e, t.fn.modal.Constructor = i, t.fn.modal.noConflict = function() { return t.fn.modal = n, this }, t(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(i) {
        var n = t(this),
            r = n.attr("href"),
            o = t(n.attr("data-target") || r && r.replace(/.*(?=#[^\s]+$)/, "")),
            s = o.data("bs.modal") ? "toggle" : t.extend({ remote: !/#/.test(r) && r }, o.data(), n.data());
        n.is("a") && i.preventDefault(), o.one("show.bs.modal", function(t) { t.isDefaultPrevented() || o.one("hidden.bs.modal", function() { n.is(":visible") && n.trigger("focus") }) }), e.call(o, s, this)
    })
}(jQuery), + function(t) {
    "use strict";

    function e(e) {
        return this.each(function() {
            var n = t(this),
                r = n.data("bs.tooltip"),
                o = "object" == typeof e && e;
            !r && /destroy|hide/.test(e) || (r || n.data("bs.tooltip", r = new i(this, o)), "string" == typeof e && r[e]())
        })
    }
    var i = function(t, e) { this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", t, e) };
    i.VERSION = "3.3.7", i.TRANSITION_DURATION = 150, i.DEFAULTS = { animation: !0, placement: "top", selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: !1, container: !1, viewport: { selector: "body", padding: 0 } }, i.prototype.init = function(e, i, n) {
        if (this.enabled = !0, this.type = e, this.$element = t(i), this.options = this.getOptions(n), this.$viewport = this.options.viewport && t(t.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = { click: !1, hover: !1, focus: !1 }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        for (var r = this.options.trigger.split(" "), o = r.length; o--;) {
            var s = r[o];
            if ("click" == s) this.$element.on("click." + this.type, this.options.selector, t.proxy(this.toggle, this));
            else if ("manual" != s) {
                var a = "hover" == s ? "mouseenter" : "focusin",
                    h = "hover" == s ? "mouseleave" : "focusout";
                this.$element.on(a + "." + this.type, this.options.selector, t.proxy(this.enter, this)), this.$element.on(h + "." + this.type, this.options.selector, t.proxy(this.leave, this))
            }
        }
        this.options.selector ? this._options = t.extend({}, this.options, { trigger: "manual", selector: "" }) : this.fixTitle()
    }, i.prototype.getDefaults = function() { return i.DEFAULTS }, i.prototype.getOptions = function(e) { return e = t.extend({}, this.getDefaults(), this.$element.data(), e), e.delay && "number" == typeof e.delay && (e.delay = { show: e.delay, hide: e.delay }), e }, i.prototype.getDelegateOptions = function() {
        var e = {},
            i = this.getDefaults();
        return this._options && t.each(this._options, function(t, n) { i[t] != n && (e[t] = n) }), e
    }, i.prototype.enter = function(e) { var i = e instanceof this.constructor ? e : t(e.currentTarget).data("bs." + this.type); return i || (i = new this.constructor(e.currentTarget, this.getDelegateOptions()), t(e.currentTarget).data("bs." + this.type, i)), e instanceof t.Event && (i.inState["focusin" == e.type ? "focus" : "hover"] = !0), i.tip().hasClass("in") || "in" == i.hoverState ? void(i.hoverState = "in") : (clearTimeout(i.timeout), i.hoverState = "in", i.options.delay && i.options.delay.show ? void(i.timeout = setTimeout(function() { "in" == i.hoverState && i.show() }, i.options.delay.show)) : i.show()) }, i.prototype.isInStateTrue = function() {
        for (var t in this.inState)
            if (this.inState[t]) return !0;
        return !1
    }, i.prototype.leave = function(e) { var i = e instanceof this.constructor ? e : t(e.currentTarget).data("bs." + this.type); if (i || (i = new this.constructor(e.currentTarget, this.getDelegateOptions()), t(e.currentTarget).data("bs." + this.type, i)), e instanceof t.Event && (i.inState["focusout" == e.type ? "focus" : "hover"] = !1), !i.isInStateTrue()) return clearTimeout(i.timeout), i.hoverState = "out", i.options.delay && i.options.delay.hide ? void(i.timeout = setTimeout(function() { "out" == i.hoverState && i.hide() }, i.options.delay.hide)) : i.hide() }, i.prototype.show = function() {
        var e = t.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e);
            var n = t.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (e.isDefaultPrevented() || !n) return;
            var r = this,
                o = this.tip(),
                s = this.getUID(this.type);
            this.setContent(), o.attr("id", s), this.$element.attr("aria-describedby", s), this.options.animation && o.addClass("fade");
            var a = "function" == typeof this.options.placement ? this.options.placement.call(this, o[0], this.$element[0]) : this.options.placement,
                h = /\s?auto?\s?/i,
                l = h.test(a);
            l && (a = a.replace(h, "") || "top"), o.detach().css({ top: 0, left: 0, display: "block" }).addClass(a).data("bs." + this.type, this), this.options.container ? o.appendTo(this.options.container) : o.insertAfter(this.$element), this.$element.trigger("inserted.bs." + this.type);
            var u = this.getPosition(),
                p = o[0].offsetWidth,
                c = o[0].offsetHeight;
            if (l) {
                var f = a,
                    g = this.getPosition(this.$viewport);
                a = "bottom" == a && u.bottom + c > g.bottom ? "top" : "top" == a && u.top - c < g.top ? "bottom" : "right" == a && u.right + p > g.width ? "left" : "left" == a && u.left - p < g.left ? "right" : a, o.removeClass(f).addClass(a)
            }
            var d = this.getCalculatedOffset(a, u, p, c);
            this.applyPlacement(d, a);
            var y = function() {
                var t = r.hoverState;
                r.$element.trigger("shown.bs." + r.type), r.hoverState = null, "out" == t && r.leave(r)
            };
            t.support.transition && this.$tip.hasClass("fade") ? o.one("bsTransitionEnd", y).emulateTransitionEnd(i.TRANSITION_DURATION) : y()
        }
    }, i.prototype.applyPlacement = function(e, i) {
        var n = this.tip(),
            r = n[0].offsetWidth,
            o = n[0].offsetHeight,
            s = parseInt(n.css("margin-top"), 10),
            a = parseInt(n.css("margin-left"), 10);
        isNaN(s) && (s = 0), isNaN(a) && (a = 0), e.top += s, e.left += a, t.offset.setOffset(n[0], t.extend({ using: function(t) { n.css({ top: Math.round(t.top), left: Math.round(t.left) }) } }, e), 0), n.addClass("in");
        var h = n[0].offsetWidth,
            l = n[0].offsetHeight;
        "top" == i && l != o && (e.top = e.top + o - l);
        var u = this.getViewportAdjustedDelta(i, e, h, l);
        u.left ? e.left += u.left : e.top += u.top;
        var p = /top|bottom/.test(i),
            c = p ? 2 * u.left - r + h : 2 * u.top - o + l,
            f = p ? "offsetWidth" : "offsetHeight";
        n.offset(e), this.replaceArrow(c, n[0][f], p)
    }, i.prototype.replaceArrow = function(t, e, i) { this.arrow().css(i ? "left" : "top", 50 * (1 - t / e) + "%").css(i ? "top" : "left", "") }, i.prototype.setContent = function() {
        var t = this.tip(),
            e = this.getTitle();
        t.find(".tooltip-inner")[this.options.html ? "html" : "text"](e), t.removeClass("fade in top bottom left right")
    }, i.prototype.hide = function(e) {
        function n() { "in" != r.hoverState && o.detach(), r.$element && r.$element.removeAttr("aria-describedby").trigger("hidden.bs." + r.type), e && e() }
        var r = this,
            o = t(this.$tip),
            s = t.Event("hide.bs." + this.type);
        if (this.$element.trigger(s), !s.isDefaultPrevented()) return o.removeClass("in"), t.support.transition && o.hasClass("fade") ? o.one("bsTransitionEnd", n).emulateTransitionEnd(i.TRANSITION_DURATION) : n(), this.hoverState = null, this
    }, i.prototype.fixTitle = function() {
        var t = this.$element;
        (t.attr("title") || "string" != typeof t.attr("data-original-title")) && t.attr("data-original-title", t.attr("title") || "").attr("title", "")
    }, i.prototype.hasContent = function() { return this.getTitle() }, i.prototype.getPosition = function(e) {
        e = e || this.$element;
        var i = e[0],
            n = "BODY" == i.tagName,
            r = i.getBoundingClientRect();
        null == r.width && (r = t.extend({}, r, { width: r.right - r.left, height: r.bottom - r.top }));
        var o = window.SVGElement && i instanceof window.SVGElement,
            s = n ? { top: 0, left: 0 } : o ? null : e.offset(),
            a = { scroll: n ? document.documentElement.scrollTop || document.body.scrollTop : e.scrollTop() },
            h = n ? { width: t(window).width(), height: t(window).height() } : null;
        return t.extend({}, r, a, h, s)
    }, i.prototype.getCalculatedOffset = function(t, e, i, n) { return "bottom" == t ? { top: e.top + e.height, left: e.left + e.width / 2 - i / 2 } : "top" == t ? { top: e.top - n, left: e.left + e.width / 2 - i / 2 } : "left" == t ? { top: e.top + e.height / 2 - n / 2, left: e.left - i } : { top: e.top + e.height / 2 - n / 2, left: e.left + e.width } }, i.prototype.getViewportAdjustedDelta = function(t, e, i, n) {
        var r = { top: 0, left: 0 };
        if (!this.$viewport) return r;
        var o = this.options.viewport && this.options.viewport.padding || 0,
            s = this.getPosition(this.$viewport);
        if (/right|left/.test(t)) {
            var a = e.top - o - s.scroll,
                h = e.top + o - s.scroll + n;
            a < s.top ? r.top = s.top - a : h > s.top + s.height && (r.top = s.top + s.height - h)
        } else {
            var l = e.left - o,
                u = e.left + o + i;
            l < s.left ? r.left = s.left - l : u > s.right && (r.left = s.left + s.width - u)
        }
        return r
    }, i.prototype.getTitle = function() {
        var t, e = this.$element,
            i = this.options;
        return t = e.attr("data-original-title") || ("function" == typeof i.title ? i.title.call(e[0]) : i.title)
    }, i.prototype.getUID = function(t) { do t += ~~(1e6 * Math.random()); while (document.getElementById(t)); return t }, i.prototype.tip = function() { if (!this.$tip && (this.$tip = t(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!"); return this.$tip }, i.prototype.arrow = function() { return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow") }, i.prototype.enable = function() { this.enabled = !0 }, i.prototype.disable = function() { this.enabled = !1 }, i.prototype.toggleEnabled = function() { this.enabled = !this.enabled }, i.prototype.toggle = function(e) {
        var i = this;
        e && (i = t(e.currentTarget).data("bs." + this.type), i || (i = new this.constructor(e.currentTarget, this.getDelegateOptions()), t(e.currentTarget).data("bs." + this.type, i))), e ? (i.inState.click = !i.inState.click, i.isInStateTrue() ? i.enter(i) : i.leave(i)) : i.tip().hasClass("in") ? i.leave(i) : i.enter(i)
    }, i.prototype.destroy = function() {
        var t = this;
        clearTimeout(this.timeout), this.hide(function() { t.$element.off("." + t.type).removeData("bs." + t.type), t.$tip && t.$tip.detach(), t.$tip = null, t.$arrow = null, t.$viewport = null, t.$element = null })
    };
    var n = t.fn.tooltip;
    t.fn.tooltip = e, t.fn.tooltip.Constructor = i, t.fn.tooltip.noConflict = function() { return t.fn.tooltip = n, this }
}(jQuery), + function(t) {
    "use strict";

    function e(e) {
        return this.each(function() {
            var n = t(this),
                r = n.data("bs.popover"),
                o = "object" == typeof e && e;
            !r && /destroy|hide/.test(e) || (r || n.data("bs.popover", r = new i(this, o)), "string" == typeof e && r[e]())
        })
    }
    var i = function(t, e) { this.init("popover", t, e) };
    if (!t.fn.tooltip) throw new Error("Popover requires tooltip.js");
    i.VERSION = "3.3.7", i.DEFAULTS = t.extend({}, t.fn.tooltip.Constructor.DEFAULTS, { placement: "right", trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>' }), i.prototype = t.extend({}, t.fn.tooltip.Constructor.prototype), i.prototype.constructor = i, i.prototype.getDefaults = function() { return i.DEFAULTS }, i.prototype.setContent = function() {
        var t = this.tip(),
            e = this.getTitle(),
            i = this.getContent();
        t.find(".popover-title")[this.options.html ? "html" : "text"](e), t.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof i ? "html" : "append" : "text"](i), t.removeClass("fade top bottom left right in"), t.find(".popover-title").html() || t.find(".popover-title").hide()
    }, i.prototype.hasContent = function() { return this.getTitle() || this.getContent() }, i.prototype.getContent = function() {
        var t = this.$element,
            e = this.options;
        return t.attr("data-content") || ("function" == typeof e.content ? e.content.call(t[0]) : e.content)
    }, i.prototype.arrow = function() { return this.$arrow = this.$arrow || this.tip().find(".arrow") };
    var n = t.fn.popover;
    t.fn.popover = e, t.fn.popover.Constructor = i, t.fn.popover.noConflict = function() { return t.fn.popover = n, this }
}(jQuery), + function(t) {
    "use strict";

    function e(i, n) { this.$body = t(document.body), this.$scrollElement = t(t(i).is(document.body) ? window : i), this.options = t.extend({}, e.DEFAULTS, n), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", t.proxy(this.process, this)), this.refresh(), this.process() }

    function i(i) {
        return this.each(function() {
            var n = t(this),
                r = n.data("bs.scrollspy"),
                o = "object" == typeof i && i;
            r || n.data("bs.scrollspy", r = new e(this, o)), "string" == typeof i && r[i]()
        })
    }
    e.VERSION = "3.3.7", e.DEFAULTS = { offset: 10 }, e.prototype.getScrollHeight = function() { return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight) }, e.prototype.refresh = function() {
        var e = this,
            i = "offset",
            n = 0;
        this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), t.isWindow(this.$scrollElement[0]) || (i = "position", n = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function() {
            var e = t(this),
                r = e.data("target") || e.attr("href"),
                o = /^#./.test(r) && t(r);
            return o && o.length && o.is(":visible") && [
                [o[i]().top + n, r]
            ] || null
        }).sort(function(t, e) { return t[0] - e[0] }).each(function() { e.offsets.push(this[0]), e.targets.push(this[1]) })
    }, e.prototype.process = function() {
        var t, e = this.$scrollElement.scrollTop() + this.options.offset,
            i = this.getScrollHeight(),
            n = this.options.offset + i - this.$scrollElement.height(),
            r = this.offsets,
            o = this.targets,
            s = this.activeTarget;
        if (this.scrollHeight != i && this.refresh(), e >= n) return s != (t = o[o.length - 1]) && this.activate(t);
        if (s && e < r[0]) return this.activeTarget = null, this.clear();
        for (t = r.length; t--;) s != o[t] && e >= r[t] && (void 0 === r[t + 1] || e < r[t + 1]) && this.activate(o[t])
    }, e.prototype.activate = function(e) {
        this.activeTarget = e, this.clear();
        var i = this.selector + '[data-target="' + e + '"],' + this.selector + '[href="' + e + '"]',
            n = t(i).parents("li").addClass("active");
        n.parent(".dropdown-menu").length && (n = n.closest("li.dropdown").addClass("active")), n.trigger("activate.bs.scrollspy")
    }, e.prototype.clear = function() { t(this.selector).parentsUntil(this.options.target, ".active").removeClass("active") };
    var n = t.fn.scrollspy;
    t.fn.scrollspy = i, t.fn.scrollspy.Constructor = e, t.fn.scrollspy.noConflict = function() { return t.fn.scrollspy = n, this }, t(window).on("load.bs.scrollspy.data-api", function() {
        t('[data-spy="scroll"]').each(function() {
            var e = t(this);
            i.call(e, e.data())
        })
    })
}(jQuery), + function(t) {
    "use strict";

    function e(e) {
        return this.each(function() {
            var n = t(this),
                r = n.data("bs.tab");
            r || n.data("bs.tab", r = new i(this)), "string" == typeof e && r[e]()
        })
    }
    var i = function(e) { this.element = t(e) };
    i.VERSION = "3.3.7", i.TRANSITION_DURATION = 150, i.prototype.show = function() {
        var e = this.element,
            i = e.closest("ul:not(.dropdown-menu)"),
            n = e.data("target");
        if (n || (n = e.attr("href"), n = n && n.replace(/.*(?=#[^\s]*$)/, "")), !e.parent("li").hasClass("active")) {
            var r = i.find(".active:last a"),
                o = t.Event("hide.bs.tab", { relatedTarget: e[0] }),
                s = t.Event("show.bs.tab", { relatedTarget: r[0] });
            if (r.trigger(o), e.trigger(s), !s.isDefaultPrevented() && !o.isDefaultPrevented()) {
                var a = t(n);
                this.activate(e.closest("li"), i), this.activate(a, a.parent(), function() { r.trigger({ type: "hidden.bs.tab", relatedTarget: e[0] }), e.trigger({ type: "shown.bs.tab", relatedTarget: r[0] }) })
            }
        }
    }, i.prototype.activate = function(e, n, r) {
        function o() { s.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), e.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), a ? (e[0].offsetWidth, e.addClass("in")) : e.removeClass("fade"), e.parent(".dropdown-menu").length && e.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), r && r() }
        var s = n.find("> .active"),
            a = r && t.support.transition && (s.length && s.hasClass("fade") || !!n.find("> .fade").length);
        s.length && a ? s.one("bsTransitionEnd", o).emulateTransitionEnd(i.TRANSITION_DURATION) : o(), s.removeClass("in")
    };
    var n = t.fn.tab;
    t.fn.tab = e, t.fn.tab.Constructor = i, t.fn.tab.noConflict = function() { return t.fn.tab = n, this };
    var r = function(i) { i.preventDefault(), e.call(t(this), "show") };
    t(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', r).on("click.bs.tab.data-api", '[data-toggle="pill"]', r)
}(jQuery), + function(t) {
    "use strict";

    function e(e) {
        return this.each(function() {
            var n = t(this),
                r = n.data("bs.affix"),
                o = "object" == typeof e && e;
            r || n.data("bs.affix", r = new i(this, o)), "string" == typeof e && r[e]()
        })
    }
    var i = function(e, n) { this.options = t.extend({}, i.DEFAULTS, n), this.$target = t(this.options.target).on("scroll.bs.affix.data-api", t.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", t.proxy(this.checkPositionWithEventLoop, this)), this.$element = t(e), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition() };
    i.VERSION = "3.3.7", i.RESET = "affix affix-top affix-bottom", i.DEFAULTS = { offset: 0, target: window }, i.prototype.getState = function(t, e, i, n) {
        var r = this.$target.scrollTop(),
            o = this.$element.offset(),
            s = this.$target.height();
        if (null != i && "top" == this.affixed) return r < i && "top";
        if ("bottom" == this.affixed) return null != i ? !(r + this.unpin <= o.top) && "bottom" : !(r + s <= t - n) && "bottom";
        var a = null == this.affixed,
            h = a ? r : o.top,
            l = a ? s : e;
        return null != i && r <= i ? "top" : null != n && h + l >= t - n && "bottom"
    }, i.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(i.RESET).addClass("affix");
        var t = this.$target.scrollTop(),
            e = this.$element.offset();
        return this.pinnedOffset = e.top - t
    }, i.prototype.checkPositionWithEventLoop = function() { setTimeout(t.proxy(this.checkPosition, this), 1) }, i.prototype.checkPosition = function() {
        if (this.$element.is(":visible")) {
            var e = this.$element.height(),
                n = this.options.offset,
                r = n.top,
                o = n.bottom,
                s = Math.max(t(document).height(), t(document.body).height());
            "object" != typeof n && (o = r = n), "function" == typeof r && (r = n.top(this.$element)), "function" == typeof o && (o = n.bottom(this.$element));
            var a = this.getState(s, e, r, o);
            if (this.affixed != a) {
                null != this.unpin && this.$element.css("top", "");
                var h = "affix" + (a ? "-" + a : ""),
                    l = t.Event(h + ".bs.affix");
                if (this.$element.trigger(l), l.isDefaultPrevented()) return;
                this.affixed = a, this.unpin = "bottom" == a ? this.getPinnedOffset() : null, this.$element.removeClass(i.RESET).addClass(h).trigger(h.replace("affix", "affixed") + ".bs.affix")
            }
            "bottom" == a && this.$element.offset({ top: s - e - o })
        }
    };
    var n = t.fn.affix;
    t.fn.affix = e, t.fn.affix.Constructor = i, t.fn.affix.noConflict = function() { return t.fn.affix = n, this }, t(window).on("load", function() {
        t('[data-spy="affix"]').each(function() {
            var i = t(this),
                n = i.data();
            n.offset = n.offset || {}, null != n.offsetBottom && (n.offset.bottom = n.offsetBottom), null != n.offsetTop && (n.offset.top = n.offsetTop),
                e.call(i, n)
        })
    })
}(jQuery),
function() {
    function t(t) { return void 0 !== t }

    function e() {}

    function i(t) { t.Ec = function() { return t.mj ? t.mj : t.mj = new t } }

    function n(t) { var e = typeof t; if ("object" == e) { if (!t) return "null"; if (t instanceof Array) return "array"; if (t instanceof Object) return e; var i = Object.prototype.toString.call(t); if ("[object Window]" == i) return "object"; if ("[object Array]" == i || "number" == typeof t.length && "undefined" != typeof t.splice && "undefined" != typeof t.propertyIsEnumerable && !t.propertyIsEnumerable("splice")) return "array"; if ("[object Function]" == i || "undefined" != typeof t.call && "undefined" != typeof t.propertyIsEnumerable && !t.propertyIsEnumerable("call")) return "function" } else if ("function" == e && "undefined" == typeof t.call) return "object"; return e }

    function r(t) { return "array" == n(t) }

    function o(t) { var e = n(t); return "array" == e || "object" == e && "number" == typeof t.length }

    function s(t) { return "string" == typeof t }

    function a(t) { return "number" == typeof t }

    function h(t) { return "function" == n(t) }

    function l(t) { var e = typeof t; return "object" == e && null != t || "function" == e }

    function u(t) { return t[hb] || (t[hb] = ++lb) }

    function p(t, e, i) { return t.call.apply(t.bind, arguments) }

    function c(t, e, i) { if (!t) throw Error(); if (2 < arguments.length) { var n = Array.prototype.slice.call(arguments, 2); return function() { var i = Array.prototype.slice.call(arguments); return Array.prototype.unshift.apply(i, n), t.apply(e, i) } } return function() { return t.apply(e, arguments) } }

    function f(t, e, i) { return f = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? p : c, f.apply(null, arguments) }

    function g(t, e) { var i = Array.prototype.slice.call(arguments, 1); return function() { var e = i.slice(); return e.push.apply(e, arguments), t.apply(this, e) } }

    function d(e, i) {
        var n = e.split("."),
            r = ab;
        n[0] in r || !r.execScript || r.execScript("var " + n[0]);
        for (var o; n.length && (o = n.shift());) !n.length && t(i) ? r[o] = i : r = r[o] ? r[o] : r[o] = {}
    }

    function y(t, e) {
        function i() {}
        i.prototype = e.prototype, t.ga = e.prototype, t.prototype = new i, t.prototype.constructor = t, t.Ps = function(t, i, n) { for (var r = Array(arguments.length - 2), o = 2; o < arguments.length; o++) r[o - 2] = arguments[o]; return e.prototype[i].apply(t, r) }
    }

    function m(t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t }

    function v() {}

    function b(t) { return t.Wq || (t.Wq = ++fb) }

    function w(t) { this.message = "Assertion failed. See /doc/errors/#" + t + " for details.", this.code = t, this.name = "AssertionError" }

    function x(t, e) { if (!t) throw new w(e) }

    function E(t) { for (var e = T(), i = 0, n = t.length; i < n; ++i) D(e, t[i]); return e }

    function S(t, e, i) { return i ? (i[0] = t[0] - e, i[1] = t[1] - e, i[2] = t[2] + e, i[3] = t[3] + e, i) : [t[0] - e, t[1] - e, t[2] + e, t[3] + e] }

    function N(t, e) { return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t.slice() }

    function L(t, e, i) { return e = e < t[0] ? t[0] - e : t[2] < e ? e - t[2] : 0, t = i < t[1] ? t[1] - i : t[3] < i ? i - t[3] : 0, e * e + t * t }

    function C(t, e) { return I(t, e[0], e[1]) }

    function M(t, e) { return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3] }

    function I(t, e, i) { return t[0] <= e && e <= t[2] && t[1] <= i && i <= t[3] }

    function k(t, e) {
        var i = t[1],
            n = t[2],
            r = t[3],
            o = e[0],
            s = e[1],
            a = 0;
        return o < t[0] ? a |= 16 : o > n && (a |= 4), s < i ? a |= 8 : s > r && (a |= 2), 0 === a && (a = 1), a
    }

    function T() { return [1 / 0, 1 / 0, -(1 / 0), -(1 / 0)] }

    function A(t, e, i, n, r) { return r ? (r[0] = t, r[1] = e, r[2] = i, r[3] = n, r) : [t, e, i, n] }

    function R(t, e) {
        var i = t[0],
            n = t[1];
        return A(i, n, i, n, e)
    }

    function _(t, e, i, n, r) { return r = A(1 / 0, 1 / 0, -(1 / 0), -(1 / 0), r), F(r, t, e, i, n) }

    function P(t, e) { return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3] }

    function O(t, e) { return e[0] < t[0] && (t[0] = e[0]), e[2] > t[2] && (t[2] = e[2]), e[1] < t[1] && (t[1] = e[1]), e[3] > t[3] && (t[3] = e[3]), t }

    function D(t, e) { e[0] < t[0] && (t[0] = e[0]), e[0] > t[2] && (t[2] = e[0]), e[1] < t[1] && (t[1] = e[1]), e[1] > t[3] && (t[3] = e[1]) }

    function F(t, e, i, n, r) {
        for (; i < n; i += r) {
            var o = t,
                s = e[i],
                a = e[i + 1];
            o[0] = Math.min(o[0], s), o[1] = Math.min(o[1], a), o[2] = Math.max(o[2], s), o[3] = Math.max(o[3], a)
        }
        return t
    }

    function U(t, e, i) { var n; return (n = e.call(i, j(t))) || (n = e.call(i, z(t))) || (n = e.call(i, H(t))) ? n : !!(n = e.call(i, X(t))) && n }

    function B(t) { var e = 0; return $(t) || (e = Y(t) * V(t)), e }

    function j(t) { return [t[0], t[1]] }

    function z(t) { return [t[2], t[1]] }

    function G(t) { return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2] }

    function q(t, e, i, n, r) {
        var o = e * n[0] / 2;
        n = e * n[1] / 2, e = Math.cos(i);
        var s = Math.sin(i);
        i = o * e, o *= s, e *= n;
        var a = n * s,
            h = t[0],
            l = t[1];
        t = h - i + a, n = h - i - a, s = h + i - a, i = h + i + a;
        var a = l - o - e,
            h = l - o + e,
            u = l + o + e,
            o = l + o - e;
        return A(Math.min(t, n, s, i), Math.min(a, h, u, o), Math.max(t, n, s, i), Math.max(a, h, u, o), r)
    }

    function V(t) { return t[3] - t[1] }

    function W(t, e, i) { return i = i ? i : T(), K(t, e) && (i[0] = t[0] > e[0] ? t[0] : e[0], i[1] = t[1] > e[1] ? t[1] : e[1], i[2] = t[2] < e[2] ? t[2] : e[2], i[3] = t[3] < e[3] ? t[3] : e[3]), i }

    function X(t) { return [t[0], t[3]] }

    function H(t) { return [t[2], t[3]] }

    function Y(t) { return t[2] - t[0] }

    function K(t, e) { return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1] }

    function $(t) { return t[2] < t[0] || t[3] < t[1] }

    function Z(t, e) {
        var i = (t[2] - t[0]) / 2 * (e - 1),
            n = (t[3] - t[1]) / 2 * (e - 1);
        t[0] -= i, t[2] += i, t[1] -= n, t[3] += n
    }

    function J(t, e, i) {
        t = [t[0], t[1], t[0], t[3], t[2], t[1], t[2], t[3]], e(t, t, 2);
        var n = [t[0], t[2], t[4], t[6]],
            r = [t[1], t[3], t[5], t[7]];
        return e = Math.min.apply(null, n), t = Math.min.apply(null, r), n = Math.max.apply(null, n), r = Math.max.apply(null, r), A(e, t, n, r, i)
    }

    function Q() { return !0 }

    function tt() { return !1 }

    function et(t) { for (var e in t) delete t[e] }

    function it(t) { var e, i = []; for (e in t) i.push(t[e]); return i }

    function nt(t) { for (var e in t) return !1; return !e }

    function rt(t) {
        function e(e) {
            var i = t.listener,
                n = t.ri || t.target;
            return t.dd && ct(t), i.call(n, e)
        }
        return t.si = e
    }

    function ot(t, e, i, n) {
        for (var r, o = 0, s = t.length; o < s; ++o)
            if (r = t[o], r.listener === e && r.ri === i) return n && (r.deleteIndex = o), r
    }

    function st(t, e) { var i = t.vb; return i ? i[e] : void 0 }

    function at(t) { var e = t.vb; return e || (e = t.vb = {}), e }

    function ht(t, e) {
        var i = st(t, e);
        if (i) {
            for (var n = 0, r = i.length; n < r; ++n) t.removeEventListener(e, i[n].si), et(i[n]);
            i.length = 0, (i = t.vb) && (delete i[e], 0 === Object.keys(i).length && delete t.vb)
        }
    }

    function lt(t, e, i, n, r) {
        var o = at(t),
            s = o[e];
        return s || (s = o[e] = []), (o = ot(s, i, n, !1)) ? r || (o.dd = !1) : (o = { ri: n, dd: !!r, listener: i, target: t, type: e }, t.addEventListener(e, rt(o)), s.push(o)), o
    }

    function ut(t, e, i, n) { return lt(t, e, i, n, !0) }

    function pt(t, e, i, n) {
        (t = st(t, e)) && (i = ot(t, i, n, !0)) && ct(i)
    }

    function ct(t) {
        if (t && t.target) {
            t.target.removeEventListener(t.type, t.si);
            var e = st(t.target, t.type);
            if (e) { var i = "deleteIndex" in t ? t.deleteIndex : e.indexOf(t); - 1 !== i && e.splice(i, 1), 0 === e.length && ht(t.target, t.type) }
            et(t)
        }
    }

    function ft(t) { var e, i = at(t); for (e in i) ht(t, e) }

    function gt() {}

    function dt(t) { this.type = t, this.target = null }

    function yt(t) { t.stopPropagation() }

    function mt(t) { t.preventDefault() }

    function vt() { this.Xa = {}, this.za = {}, this.sa = {} }

    function bt(t, e) { return e ? e in t.sa : 0 < Object.keys(t.sa).length }

    function wt() { vt.call(this), this.g = 0 }

    function xt(t) {
        if (Array.isArray(t))
            for (var e = 0, i = t.length; e < i; ++e) ct(t[e]);
        else ct(t)
    }

    function Et(t, e, i) { dt.call(this, t), this.key = e, this.oldValue = i }

    function St(t) { wt.call(this), b(this), this.T = {}, void 0 !== t && this.G(t) }

    function Nt(t) { return yb.hasOwnProperty(t) ? yb[t] : yb[t] = "change:" + t }

    function Lt(t, e, i) {
        var n;
        n = Nt(e), t.b(new Et(n, e, i)), t.b(new Et("propertychange", e, i))
    }

    function Ct(t, e, i) { return Math.min(Math.max(t, e), i) }

    function Mt(t) { return x(0 < t, 29), Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }

    function It(t, e, i, n, r, o) {
        var s = r - i,
            a = o - n;
        if (0 !== s || 0 !== a) {
            var h = ((t - i) * s + (e - n) * a) / (s * s + a * a);
            1 < h ? (i = r, n = o) : 0 < h && (i += s * h, n += a * h)
        }
        return kt(t, e, i, n)
    }

    function kt(t, e, i, n) { return t = i - t, e = n - e, t * t + e * e }

    function Tt(t) { return t * Math.PI / 180 }

    function At(t, e) { var i = t % e; return 0 > i * e ? i + e : i }

    function Rt(t, e, i) { return t + i * (e - t) }

    function _t(t) { this.radius = t }

    function Pt(t) {
        this.be = t.code, this.c = t.units, this.f = void 0 !== t.extent ? t.extent : null, this.i = void 0 !== t.worldExtent ? t.worldExtent : null, this.b = void 0 !== t.axisOrientation ? t.axisOrientation : "enu", this.g = void 0 !== t.global && t.global, this.a = !(!this.g || !this.f), this.j = void 0 !== t.getPointResolution ? t.getPointResolution : this.Wm, this.l = null, this.o = t.metersPerUnit;
        var e = wb,
            i = t.code,
            n = Eb || gb.proj4;
        if ("function" == typeof n && void 0 === e[i]) { var r = n.defs(i); if (void 0 !== r) { void 0 !== r.axis && void 0 === t.axisOrientation && (this.b = r.axis), void 0 === t.metersPerUnit && (this.o = r.to_meter), void 0 === t.units && (this.c = r.units); for (var o in e) e = n.defs(o), void 0 !== e && (t = qt(o), e === r ? Ot([t, this]) : (e = n(o, i), zt(t, this, e.forward, e.inverse))) } }
    }

    function Ot(t) { Ut(t), t.forEach(function(e) { t.forEach(function(t) { e !== t && jt(e, t, Yt) }) }) }

    function Dt() {
        var t = ME,
            e = Kp,
            i = $p;
        AE.forEach(function(n) { t.forEach(function(t) { jt(n, t, e), jt(t, n, i) }) })
    }

    function Ft(t) { wb[t.Ya()] = t, jt(t, t, Yt) }

    function Ut(t) {
        var e = [];
        t.forEach(function(t) { e.push(Ft(t)) })
    }

    function Bt(t) { return t ? "string" == typeof t ? qt(t) : t : qt("EPSG:3857") }

    function jt(t, e, i) { t = t.Ya(), e = e.Ya(), t in xb || (xb[t] = {}), xb[t][e] = i }

    function zt(t, e, i, n) { t = qt(t), e = qt(e), jt(t, e, Gt(i)), jt(e, t, Gt(n)) }

    function Gt(t) {
        return function(e, i, n) {
            var r = e.length;
            n = void 0 !== n ? n : 2, i = void 0 !== i ? i : Array(r);
            var o, s;
            for (s = 0; s < r; s += n)
                for (o = t([e[s], e[s + 1]]), i[s] = o[0], i[s + 1] = o[1], o = n - 1; 2 <= o; --o) i[s + o] = e[s + o];
            return i
        }
    }

    function qt(t) {
        var e;
        if (t instanceof Pt) e = t;
        else if ("string" == typeof t) {
            e = wb[t];
            var i = Eb || gb.proj4;
            void 0 === e && "function" == typeof i && void 0 !== i.defs(t) && (e = new Pt({ code: t }), Ft(e))
        }
        return e || null
    }

    function Vt(t, e) { if (t === e) return !0; var i = t.Ub() === e.Ub(); return t.Ya() === e.Ya() ? i : Xt(t, e) === Yt && i }

    function Wt(t, e) {
        var i = qt(t),
            n = qt(e);
        return Xt(i, n)
    }

    function Xt(t, e) {
        var i, n = t.Ya(),
            r = e.Ya();
        return n in xb && r in xb[n] && (i = xb[n][r]), void 0 === i && (i = Ht), i
    }

    function Ht(t, e) {
        if (void 0 !== e && t !== e) {
            for (var i = 0, n = t.length; i < n; ++i) e[i] = t[i];
            t = e
        }
        return t
    }

    function Yt(t, e) {
        var i;
        if (void 0 !== e) {
            i = 0;
            for (var n = t.length; i < n; ++i) e[i] = t[i];
            i = e
        } else i = t.slice();
        return i
    }

    function Kt(t, e, i) { return Wt(e, i)(t, void 0, t.length) }

    function $t(t, e, i) { return e = Wt(e, i), J(t, e) }

    function Zt() { St.call(this), this.s = T(), this.A = -1, this.i = {}, this.o = this.l = 0 }

    function Jt(t, e, i, n, r, o) {
        for (var s = o ? o : [], a = 0; e < i; e += n) {
            var h = t[e],
                l = t[e + 1];
            s[a++] = r[0] * h + r[2] * l + r[4], s[a++] = r[1] * h + r[3] * l + r[5]
        }
        return o && s.length != a && (s.length = a), s
    }

    function Qt() { Zt.call(this), this.ma = "XY", this.a = 2, this.B = null }

    function te(t) { var e; return "XY" == t ? e = 2 : "XYZ" == t || "XYM" == t ? e = 3 : "XYZM" == t && (e = 4), e }

    function ee(t, e, i) { t.a = te(e), t.ma = e, t.B = i }

    function ie(t, e, i, n) {
        if (e) i = te(e);
        else {
            for (e = 0; e < n; ++e) {
                if (0 === i.length) return t.ma = "XY", void(t.a = 2);
                i = i[0]
            }
            i = i.length;
            var r;
            2 == i ? r = "XY" : 3 == i ? r = "XYZ" : 4 == i && (r = "XYZM"), e = r
        }
        t.ma = e, t.a = i
    }

    function ne(t, e) { var i, n, r = 0; for (i = 0, n = e.length; i < n; ++i) t[r++] = e[i]; return r }

    function re(t, e, i, n) { var r, o; for (r = 0, o = i.length; r < o; ++r) { var s, a = i[r]; for (s = 0; s < n; ++s) t[e++] = a[s] } return e }

    function oe(t, e, i, n, r) { r = r ? r : []; var o, s, a = 0; for (o = 0, s = i.length; o < s; ++o) e = re(t, e, i[o], n), r[a++] = e; return r.length = a, r }

    function se(t, e) { Qt.call(this), this.wa(t, e) }

    function ae(t, e) { return t > e ? 1 : t < e ? -1 : 0 }

    function he(t, e) { return 0 <= t.indexOf(e) }

    function le(t, e, i) {
        var n = t.length;
        if (t[0] <= e) return 0;
        if (!(e <= t[n - 1]))
            if (0 < i) {
                for (i = 1; i < n; ++i)
                    if (t[i] < e) return i - 1
            } else if (0 > i) {
            for (i = 1; i < n; ++i)
                if (t[i] <= e) return i
        } else
            for (i = 1; i < n; ++i) { if (t[i] == e) return i; if (t[i] < e) return t[i - 1] - e < e - t[i] ? i - 1 : i }
        return n - 1
    }

    function ue(t) { return t.reduce(function(t, e) { return Array.isArray(e) ? t.concat(ue(e)) : t.concat(e) }, []) }

    function pe(t, e) {
        var i, n = Array.isArray(e) ? e : [e],
            r = n.length;
        for (i = 0; i < r; i++) t[t.length] = n[i]
    }

    function ce(t, e) {
        var i = t.indexOf(e),
            n = -1 < i;
        return n && t.splice(i, 1), n
    }

    function fe(t, e) {
        for (var i, n = t.length >>> 0, r = 0; r < n; r++)
            if (i = t[r], e(i, r, t)) return i;
        return null
    }

    function ge(t, e) {
        var i = t.length;
        if (i !== e.length) return !1;
        for (var n = 0; n < i; n++)
            if (t[n] !== e[n]) return !1;
        return !0
    }

    function de(t) {
        var e, i = tu,
            n = t.length,
            r = Array(t.length);
        for (e = 0; e < n; e++) r[e] = { index: e, value: t[e] };
        for (r.sort(function(t, e) { return i(t.value, e.value) || t.index - e.index }), e = 0; e < t.length; e++) t[e] = r[e].value
    }

    function ye(t, e) { var i; return t.every(function(n, r) { return i = r, !e(n, r, t) }) ? -1 : i }

    function me(t, e) { var i = e || ae; return t.every(function(e, n) { if (0 === n) return !0; var r = i(t[n - 1], e); return !(0 < r || 0 === r) }) }

    function ve(t, e, i, n, r) { r = void 0 !== r ? r : []; for (var o = 0; e < i; e += n) r[o++] = t.slice(e, e + n); return r.length = o, r }

    function be(t, e, i, n, r) {
        r = void 0 !== r ? r : [];
        var o, s, a = 0;
        for (o = 0, s = i.length; o < s; ++o) {
            var h = i[o];
            r[a++] = ve(t, e, h, n, r[a]), e = h
        }
        return r.length = a, r
    }

    function we(t, e) { Qt.call(this), this.wa(t, e) }

    function xe(t, e, i, n, r, o, s) {
        var a = t[e],
            h = t[e + 1],
            l = t[i] - a,
            u = t[i + 1] - h;
        if (0 !== l || 0 !== u)
            if (o = ((r - a) * l + (o - h) * u) / (l * l + u * u), 1 < o) e = i;
            else if (0 < o) { for (r = 0; r < n; ++r) s[r] = Rt(t[e + r], t[i + r], o); return void(s.length = n) }
        for (r = 0; r < n; ++r) s[r] = t[e + r];
        s.length = n
    }

    function Ee(t, e, i, n, r) {
        var o = t[e],
            s = t[e + 1];
        for (e += n; e < i; e += n) {
            var a = t[e],
                h = t[e + 1],
                o = kt(o, s, a, h);
            o > r && (r = o), o = a, s = h
        }
        return r
    }

    function Se(t, e, i, n, r) {
        var o, s;
        for (o = 0, s = i.length; o < s; ++o) {
            var a = i[o];
            r = Ee(t, e, a, n, r), e = a
        }
        return r
    }

    function Ne(t, e, i, n, r, o, s, a, h, l, u) {
        if (e == i) return l;
        var p;
        if (0 === r) { if (p = kt(s, a, t[e], t[e + 1]), p < l) { for (u = 0; u < n; ++u) h[u] = t[e + u]; return h.length = n, p } return l }
        for (var c = u ? u : [NaN, NaN], f = e + n; f < i;)
            if (xe(t, f - n, f, n, s, a, c), p = kt(s, a, c[0], c[1]), p < l) {
                for (l = p, u = 0; u < n; ++u) h[u] = c[u];
                h.length = n, f += n
            } else f += n * Math.max((Math.sqrt(p) - Math.sqrt(l)) / r | 0, 1);
        if (o && (xe(t, i - n, e, n, s, a, c), p = kt(s, a, c[0], c[1]), p < l)) {
            for (l = p, u = 0; u < n; ++u) h[u] = c[u];
            h.length = n
        }
        return l
    }

    function Le(t, e, i, n, r, o, s, a, h, l, u) {
        u = u ? u : [NaN, NaN];
        var p, c;
        for (p = 0, c = i.length; p < c; ++p) {
            var f = i[p];
            l = Ne(t, e, f, n, r, o, s, a, h, l, u), e = f
        }
        return l
    }

    function Ce(t, e, i, n, r, o) {
        var s = NaN,
            a = NaN,
            h = (i - e) / n;
        if (0 !== h)
            if (1 == h) s = t[e], a = t[e + 1];
            else if (2 == h) s = (1 - r) * t[e] + r * t[e + n], a = (1 - r) * t[e + 1] + r * t[e + n + 1];
        else {
            var l, a = t[e],
                h = t[e + 1],
                u = 0,
                s = [0];
            for (l = e + n; l < i; l += n) {
                var p = t[l],
                    c = t[l + 1],
                    u = u + Math.sqrt((p - a) * (p - a) + (c - h) * (c - h));
                s.push(u), a = p, h = c
            }
            for (i = r * u, h = 0, u = s.length, l = !1; h < u;) r = h + (u - h >> 1), a = +ae(s[r], i), 0 > a ? h = r + 1 : (u = r, l = !a);
            r = l ? h : ~h, 0 > r ? (i = (i - s[-r - 2]) / (s[-r - 1] - s[-r - 2]), e += (-r - 2) * n, s = Rt(t[e], t[e + n], i), a = Rt(t[e + 1], t[e + n + 1], i)) : (s = t[e + r * n], a = t[e + r * n + 1])
        }
        return o ? (o[0] = s, o[1] = a, o) : [s, a]
    }

    function Me(t, e, i, n, r, o) {
        if (i == e) return null;
        if (r < t[e + n - 1]) return o ? (i = t.slice(e, e + n), i[n - 1] = r, i) : null;
        if (t[i - 1] < r) return o ? (i = t.slice(i - n, i), i[n - 1] = r, i) : null;
        if (r == t[e + n - 1]) return t.slice(e, e + n);
        for (e /= n, i /= n; e < i;) o = e + i >> 1, r < t[(o + 1) * n - 1] ? i = o : e = o + 1;
        if (i = t[e * n - 1], r == i) return t.slice((e - 1) * n, (e - 1) * n + n);
        o = (r - i) / (t[(e + 1) * n - 1] - i), i = [];
        var s;
        for (s = 0; s < n - 1; ++s) i.push(Rt(t[(e - 1) * n + s], t[e * n + s], o));
        return i.push(r), i
    }

    function Ie(t, e, i, n, r, o) {
        var s = 0;
        if (o) return Me(t, s, e[e.length - 1], i, n, r);
        if (n < t[i - 1]) return r ? (t = t.slice(0, i), t[i - 1] = n, t) : null;
        if (t[t.length - 1] < n) return r ? (t = t.slice(t.length - i), t[i - 1] = n, t) : null;
        for (r = 0, o = e.length; r < o; ++r) {
            var a = e[r];
            if (s != a) {
                if (n < t[s + i - 1]) break;
                if (n <= t[a - 1]) return Me(t, s, a, i, n, !1);
                s = a
            }
        }
        return null
    }

    function ke(t, e, i, n, r) { return !U(r, function(r) { return !Te(t, e, i, n, r[0], r[1]) }) }

    function Te(t, e, i, n, r, o) {
        for (var s = !1, a = t[i - n], h = t[i - n + 1]; e < i; e += n) {
            var l = t[e],
                u = t[e + 1];
            h > o != u > o && r < (l - a) * (o - h) / (u - h) + a && (s = !s), a = l, h = u
        }
        return s
    }

    function Ae(t, e, i, n, r, o) {
        if (0 === i.length || !Te(t, e, i[0], n, r, o)) return !1;
        var s;
        for (e = 1, s = i.length; e < s; ++e)
            if (Te(t, i[e - 1], i[e], n, r, o)) return !1;
        return !0
    }

    function Re(t, e, i, n, r, o) {
        for (var s, a = [t[e], t[e + 1]], h = []; e + n < i; e += n) {
            if (h[0] = t[e + n], h[1] = t[e + n + 1], s = r.call(o, a, h)) return s;
            a[0] = h[0], a[1] = h[1]
        }
        return !1
    }

    function _e(t, e, i, n, r) {
        var o = F(T(), t, e, i, n);
        return !!K(r, o) && (!!(M(r, o) || o[0] >= r[0] && o[2] <= r[2] || o[1] >= r[1] && o[3] <= r[3]) || Re(t, e, i, n, function(t, e) {
            var i = !1,
                n = k(r, t),
                o = k(r, e);
            if (1 === n || 1 === o) i = !0;
            else {
                var s = r[0],
                    a = r[1],
                    h = r[2],
                    l = r[3],
                    u = e[0],
                    p = e[1],
                    c = (p - t[1]) / (u - t[0]);
                2 & o && !(2 & n) && (i = u - (p - l) / c, i = i >= s && i <= h), i || !(4 & o) || 4 & n || (i = p - (u - h) * c, i = i >= a && i <= l), i || !(8 & o) || 8 & n || (i = u - (p - a) / c, i = i >= s && i <= h), i || !(16 & o) || 16 & n || (i = p - (u - s) * c, i = i >= a && i <= l)
            }
            return i
        }))
    }

    function Pe(t, e, i, n, r) {
        var o = i[0];
        if (!(_e(t, e, o, n, r) || Te(t, e, o, n, r[0], r[1]) || Te(t, e, o, n, r[0], r[3]) || Te(t, e, o, n, r[2], r[1]) || Te(t, e, o, n, r[2], r[3]))) return !1;
        if (1 === i.length) return !0;
        for (e = 1, o = i.length; e < o; ++e)
            if (ke(t, i[e - 1], i[e], n, r)) return !1;
        return !0
    }

    function Oe(t, e, i, n, r, o, s) {
        var a = (i - e) / n;
        if (3 > a) { for (; e < i; e += n) o[s++] = t[e], o[s++] = t[e + 1]; return s }
        var h = Array(a);
        h[0] = 1, h[a - 1] = 1, i = [e, i - n];
        for (var l, u = 0; 0 < i.length;) {
            var p = i.pop(),
                c = i.pop(),
                f = 0,
                g = t[c],
                d = t[c + 1],
                y = t[p],
                m = t[p + 1];
            for (l = c + n; l < p; l += n) {
                var v = It(t[l], t[l + 1], g, d, y, m);
                v > f && (u = l, f = v)
            }
            f > r && (h[(u - e) / n] = 1, c + n < u && i.push(c, u), u + n < p && i.push(u, p))
        }
        for (l = 0; l < a; ++l) h[l] && (o[s++] = t[e + l * n], o[s++] = t[e + l * n + 1]);
        return s
    }

    function De(t, e, i, n, r, o, s, a) {
        var h, l;
        for (h = 0, l = i.length; h < l; ++h) {
            var u = i[h];
            t: {
                var p = t,
                    c = u,
                    f = n,
                    g = r,
                    d = o;
                if (e != c) {
                    var y = g * Math.round(p[e] / g),
                        m = g * Math.round(p[e + 1] / g);
                    e += f, d[s++] = y, d[s++] = m;
                    var v, b;
                    do
                        if (v = g * Math.round(p[e] / g), b = g * Math.round(p[e + 1] / g), e += f, e == c) { d[s++] = v, d[s++] = b; break t }
                    while (v == y && b == m);
                    for (; e < c;) {
                        var w, x;
                        if (w = g * Math.round(p[e] / g), x = g * Math.round(p[e + 1] / g), e += f, w != v || x != b) {
                            var E = v - y,
                                S = b - m,
                                N = w - y,
                                L = x - m;
                            E * L == S * N && (0 > E && N < E || E == N || 0 < E && N > E) && (0 > S && L < S || S == L || 0 < S && L > S) || (d[s++] = v, d[s++] = b, y = v, m = b), v = w, b = x
                        }
                    }
                    d[s++] = v, d[s++] = b
                }
            }
            a.push(s), e = u
        }
        return s
    }

    function Fe(t, e) { Qt.call(this), this.c = null, this.v = this.C = this.j = -1, this.wa(t, e) }

    function Ue(t) { return t.j != t.g && (t.c = t.Ii(.5, t.c), t.j = t.g), t.c }

    function Be(t, e) { Qt.call(this), this.c = [], this.j = this.v = -1, this.wa(t, e) }

    function je(t) {
        var e = [],
            i = t.B,
            n = 0,
            r = t.c;
        t = t.a;
        var o, s;
        for (o = 0, s = r.length; o < s; ++o) {
            var a = r[o],
                n = Ce(i, n, a, t, .5);
            pe(e, n), n = a
        }
        return e
    }

    function ze(t, e) {
        var i, n, r = t.ma,
            o = [],
            s = [];
        for (i = 0, n = e.length; i < n; ++i) {
            var a = e[i];
            0 === i && (r = a.ma), pe(o, a.oa()), s.push(o.length)
        }
        t.ca(r, o, s)
    }

    function Ge(t, e, i, n) {
        for (var r = 0, o = t[i - n], s = t[i - n + 1]; e < i; e += n) var a = t[e],
            h = t[e + 1],
            r = r + (s * a - o * h),
            o = a,
            s = h;
        return r / 2
    }

    function qe(t, e, i, n) {
        var r, o, s = 0;
        for (r = 0, o = i.length; r < o; ++r) {
            var a = i[r],
                s = s + Ge(t, e, a, n);
            e = a
        }
        return s
    }

    function Ve(t, e) { Qt.call(this), this.c = this.j = -1, this.wa(t, e) }

    function We(t, e, i) { ee(t, e, i), t.u() }

    function Xe(t, e, i, n, r, o, s) {
        var a, h, l, u, p, c = r[o + 1],
            f = [],
            g = i[0];
        for (l = t[g - n], p = t[g - n + 1], a = e; a < g; a += n) u = t[a], h = t[a + 1], (c <= p && h <= c || p <= c && c <= h) && (l = (c - p) / (h - p) * (u - l) + l, f.push(l)), l = u, p = h;
        for (g = NaN, p = -(1 / 0), f.sort(ae), l = f[0], a = 1, h = f.length; a < h; ++a) {
            u = f[a];
            var d = Math.abs(u - l);
            d > p && (l = (l + u) / 2, Ae(t, e, i, n, l, c) && (g = l, p = d)), l = u
        }
        return isNaN(g) && (g = r[o]), s ? (s.push(g, c), s) : [g, c]
    }

    function He(t, e, i, n) {
        for (var r = 0, o = t[i - n], s = t[i - n + 1]; e < i; e += n) var a = t[e],
            h = t[e + 1],
            r = r + (a - o) * (h + s),
            o = a,
            s = h;
        return 0 < r
    }

    function Ye(t, e, i, n) {
        var r = 0;
        n = void 0 !== n && n;
        var o, s;
        for (o = 0, s = e.length; o < s; ++o) {
            var a = e[o],
                r = He(t, r, a, i);
            if (0 === o) { if (n && r || !n && !r) return !1 } else if (n && !r || !n && r) return !1;
            r = a
        }
        return !0
    }

    function Ke(t, e, i, n, r) {
        r = void 0 !== r && r;
        var o, s;
        for (o = 0, s = i.length; o < s; ++o) {
            var a = i[o],
                h = He(t, e, a, n);
            if (0 === o ? r && h || !r && !h : r && !h || !r && h)
                for (var h = t, l = a, u = n; e < l - u;) {
                    var p;
                    for (p = 0; p < u; ++p) {
                        var c = h[e + p];
                        h[e + p] = h[l - u + p], h[l - u + p] = c
                    }
                    e += u, l -= u
                }
            e = a
        }
        return e
    }

    function $e(t, e, i, n) { var r, o, s = 0; for (r = 0, o = e.length; r < o; ++r) s = Ke(t, s, e[r], i, n); return s }

    function Ze(t, e) { Qt.call(this), this.c = [], this.v = -1, this.C = null, this.P = this.D = this.O = -1, this.j = null, this.wa(t, e) }

    function Je(t) {
        if (t.v != t.g) {
            var e = G(t.H());
            t.C = Xe(t.qc(), 0, t.c, t.a, e, 0), t.v = t.g
        }
        return t.C
    }

    function Qe(t, e, i, n) {
        var r = n ? n : 32;
        n = [];
        var o;
        for (o = 0; o < r; ++o) pe(n, t.offset(e, i, 2 * Math.PI * o / r));
        return n.push(n[0], n[1]), t = new Ze(null), t.ca("XY", n, [n.length]), t
    }

    function ti(t) {
        var e = t[0],
            i = t[1],
            n = t[2];
        return t = t[3], e = [e, i, e, t, n, t, n, i, e, i], i = new Ze(null), i.ca("XY", e, [e.length]), i
    }

    function ei(t, e, i) {
        var n = e ? e : 32,
            r = t.Aa();
        e = t.ma;
        for (var o = new Ze(null, e), n = r * (n + 1), r = Array(n), s = 0; s < n; s++) r[s] = 0;
        return o.ca(e, r, [r.length]), ii(o, t.Ae(), t.yh(), i), o
    }

    function ii(t, e, i, n) {
        var r = t.oa(),
            o = t.ma,
            s = t.Aa(),
            a = t.ec(),
            h = r.length / s - 1;
        n = n ? n : 0;
        for (var l, u, p = 0; p <= h; ++p) u = p * s, l = n + 2 * At(p, h) * Math.PI / h, r[u] = e[0] + i * Math.cos(l), r[u + 1] = e[1] + i * Math.sin(l);
        t.ca(o, r, a)
    }

    function ni(t, e) { Qt.call(this), this.c = [], this.v = -1, this.C = null, this.P = this.D = this.O = -1, this.j = null, this.wa(t, e) }

    function ri(t) {
        if (t.v != t.g) {
            var e, i, n = t.B,
                r = t.c,
                o = t.a,
                s = 0,
                a = [];
            for (e = 0, i = r.length; e < i; ++e) {
                var h = r[e],
                    s = _(n, s, h[0], o);
                a.push((s[0] + s[2]) / 2, (s[1] + s[3]) / 2), s = h[h.length - 1]
            }
            for (n = oi(t), r = t.c, o = t.a, e = 0, i = [], h = 0, s = r.length; h < s; ++h) {
                var l = r[h];
                i = Xe(n, e, l, o, a, 2 * h, i), e = l[l.length - 1]
            }
            t.C = i, t.v = t.g
        }
        return t.C
    }

    function oi(t) {
        if (t.P != t.g) {
            var e, i = t.B;
            t: {
                e = t.c;
                var n, r;
                for (n = 0, r = e.length; n < r; ++n)
                    if (!Ye(i, e[n], t.a, void 0)) { e = !1; break t }
                e = !0
            }
            e ? t.j = i : (t.j = i.slice(), t.j.length = $e(t.j, t.c, t.a)), t.P = t.g
        }
        return t.j
    }

    function si(t, e, i, n) { ee(t, e, i), t.c = n, t.u() }

    function ai(t, e) {
        var i, n, r, o = t.ma,
            s = [],
            a = [];
        for (i = 0, n = e.length; i < n; ++i) {
            var h = e[i];
            0 === i && (o = h.ma);
            var l = s.length;
            r = h.ec();
            var u, p;
            for (u = 0, p = r.length; u < p; ++u) r[u] += l;
            pe(s, h.oa()), a.push(r)
        }
        si(t, o, s, a)
    }

    function hi(t) { return Array.isArray(t) ? t : kb(t) }

    function li(t) {
        if ("string" != typeof t) {
            var e = t[0];
            e != (0 | e) && (e = e + .5 | 0);
            var i = t[1];
            i != (0 | i) && (i = i + .5 | 0);
            var n = t[2];
            n != (0 | n) && (n = n + .5 | 0), t = "rgba(" + e + "," + i + "," + n + "," + (void 0 === t[3] ? 1 : t[3]) + ")"
        }
        return t
    }

    function ui(t) { var e = []; return e[0] = Ct(t[0] + .5 | 0, 0, 255), e[1] = Ct(t[1] + .5 | 0, 0, 255), e[2] = Ct(t[2] + .5 | 0, 0, 255), e[3] = Ct(t[3], 0, 1), e }

    function pi(t) { return "string" == typeof t || t instanceof CanvasPattern || t instanceof CanvasGradient ? t : li(t) }

    function ci(t) { return Fb.test(t) ? (-1 != t.indexOf("&") && (t = t.replace(Ab, "&amp;")), -1 != t.indexOf("<") && (t = t.replace(Rb, "&lt;")), -1 != t.indexOf(">") && (t = t.replace(_b, "&gt;")), -1 != t.indexOf('"') && (t = t.replace(Pb, "&quot;")), -1 != t.indexOf("'") && (t = t.replace(Ob, "&#39;")), -1 != t.indexOf("\0") && (t = t.replace(Db, "&#0;")), t) : t }

    function fi(t, e) { return t < e ? -1 : t > e ? 1 : 0 }

    function gi(t, e) { return 0 <= Ub(t, e) }

    function di(t, e) { var i, n = Ub(t, e); return (i = 0 <= n) && Array.prototype.splice.call(t, n, 1), i }

    function yi(t) { return Array.prototype.concat.apply(Array.prototype, arguments) }

    function mi(t) { var e = t.length; if (0 < e) { for (var i = Array(e), n = 0; n < e; n++) i[n] = t[n]; return i } return [] }

    function vi(t, e, i, n) { Array.prototype.splice.apply(t, bi(arguments, 1)) }

    function bi(t, e, i) { return 2 >= arguments.length ? Array.prototype.slice.call(t, e) : Array.prototype.slice.call(t, e, i) }

    function wi(t) { return -1 != Nb.indexOf(t) }

    function xi(t, e, i) { for (var n in t) e.call(i, t[n], n, t) }

    function Ei(t, e, i) {
        if (null !== t && e in t) throw Error('The object already contains the key "' + e + '"');
        t[e] = i
    }

    function Si(t, e) { for (var i, n, r = 1; r < arguments.length; r++) { n = arguments[r]; for (i in n) t[i] = n[i]; for (var o = 0; o < Wb.length; o++) i = Wb[o], Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } }

    function Ni() { var t = ab.document; return t ? t.documentMode : void 0 }

    function Li(t) {
        var e;
        if (!(e = nw[t])) {
            e = 0;
            for (var i = Tb(String(Vb)).split("."), n = Tb(String(t)).split("."), r = Math.max(i.length, n.length), o = 0; 0 == e && o < r; o++) {
                var s = i[o] || "",
                    a = n[o] || "",
                    h = RegExp("(\\d*)(\\D*)", "g"),
                    l = RegExp("(\\d*)(\\D*)", "g");
                do {
                    var u = h.exec(s) || ["", "", ""],
                        p = l.exec(a) || ["", "", ""];
                    if (0 == u[0].length && 0 == p[0].length) break;
                    e = fi(0 == u[1].length ? 0 : parseInt(u[1], 10), 0 == p[1].length ? 0 : parseInt(p[1], 10)) || fi(0 == u[2].length, 0 == p[2].length) || fi(u[2], p[2])
                } while (0 == e)
            }
            e = nw[t] = 0 <= e
        }
        return e
    }

    function Ci() { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] }

    function Mi(t, e) { return t[0] = e[0], t[1] = e[1], t[4] = e[2], t[5] = e[3], t[12] = e[4], t[13] = e[5], t }

    function Ii(t, e) { var i = document.createElement("CANVAS"); return t && (i.width = t), e && (i.height = e), i.getContext("2d") }

    function ki(t, e) {
        var i = t.style;
        i.WebkitTransform = e, i.MozTransform = e, i.b = e, i.msTransform = e, i.transform = e, Hb && Li("9.0") && (t.style.transformOrigin = "0 0")
    }

    function Ti(t, e) {
        var i;
        if (hw()) {
            var n = Mi(sw, e),
                r = Array(16);
            for (i = 0; 16 > i; ++i) r[i] = n[i].toFixed(6);
            ki(t, "matrix3d(" + r.join(",") + ")")
        } else if (aw()) {
            for (n = Array(6), i = 0; 6 > i; ++i) n[i] = e[i].toFixed(6);
            ki(t, "matrix(" + n.join(",") + ")")
        } else t.style.left = Math.round(e[4]) + "px", t.style.top = Math.round(e[5]) + "px"
    }

    function Ai(t, e) {
        var i = e.parentNode;
        i && i.replaceChild(t, e)
    }

    function Ri(t) { t && t.parentNode && t.parentNode.removeChild(t) }

    function _i(t) { for (; t.lastChild;) t.removeChild(t.lastChild) }

    function Pi(t, e) {
        var i, n, r = lw.length;
        for (n = 0; n < r; ++n) try { if (i = t.getContext(lw[n], e)) return i } catch (t) {}
        return null
    }

    function Oi(t, e, i, n) { 0 !== e && (t.translate(i, n), t.rotate(e), t.translate(-i, -n)) }

    function Di(t) { this.A = t.opacity, this.T = t.rotateWithView, this.o = t.rotation, this.i = t.scale, this.C = t.snapToPixel }

    function Fi(t) {
        t = t || {}, this.l = this.f = this.c = null, this.g = void 0 !== t.fill ? t.fill : null, this.b = void 0 !== t.stroke ? t.stroke : null, this.a = t.radius, this.v = [0, 0], this.s = this.D = this.j = null;
        var e, i, n = t.atlasManager,
            r = null,
            o = 0;
        this.b && (i = li(this.b.b), o = this.b.a, void 0 === o && (o = 1), r = this.b.g, dw || (r = null));
        var s = 2 * (this.a + o) + 1;
        if (i = { strokeStyle: i, Me: o, size: s, lineDash: r }, void 0 === n) n = Ii(s, s), this.f = n.canvas, e = s = this.f.width, this.fk(i, n, 0, 0), this.g ? this.l = this.f : (n = Ii(i.size, i.size), this.l = n.canvas, this.ek(i, n, 0, 0));
        else {
            s = Math.round(s), (r = !this.g) && (e = this.ek.bind(this, i));
            var o = this.b ? Wi(this.b) : "-",
                a = this.g ? Bi(this.g) : "-";
            this.c && o == this.c[1] && a == this.c[2] && this.a == this.c[3] || (this.c = ["c" + o + a + (void 0 !== this.a ? this.a.toString() : "-"), o, a, this.a]), n = n.add(this.c[0], s, s, this.fk.bind(this, i), e), this.f = n.image, this.v = [n.offsetX, n.offsetY], e = n.image.width, this.l = r ? n.kj : this.f
        }
        this.j = [s / 2, s / 2], this.D = [s, s], this.s = [e, e], Di.call(this, { opacity: 1, rotateWithView: !1, rotation: 0, scale: 1, snapToPixel: void 0 === t.snapToPixel || t.snapToPixel })
    }

    function Ui(t) { t = t || {}, this.b = void 0 !== t.color ? t.color : null, this.a = void 0 }

    function Bi(t) { return void 0 === t.a && (t.a = t.b instanceof CanvasPattern || t.b instanceof CanvasGradient ? b(t.b).toString() : "f" + (t.b ? li(t.b) : "-")), t.a }

    function ji() { this.a = -1 }

    function zi() { this.a = 64, this.b = Array(4), this.c = Array(this.a), this.f = this.g = 0, this.reset() }

    function Gi(t, e, i) {
        i || (i = 0);
        var n = Array(16);
        if (s(e))
            for (var r = 0; 16 > r; ++r) n[r] = e.charCodeAt(i++) | e.charCodeAt(i++) << 8 | e.charCodeAt(i++) << 16 | e.charCodeAt(i++) << 24;
        else
            for (r = 0; 16 > r; ++r) n[r] = e[i++] | e[i++] << 8 | e[i++] << 16 | e[i++] << 24;
        e = t.b[0], i = t.b[1];
        var o, r = t.b[2],
            a = t.b[3];
        o = e + (a ^ i & (r ^ a)) + n[0] + 3614090360 & 4294967295, e = i + (o << 7 & 4294967295 | o >>> 25), o = a + (r ^ e & (i ^ r)) + n[1] + 3905402710 & 4294967295, a = e + (o << 12 & 4294967295 | o >>> 20), o = r + (i ^ a & (e ^ i)) + n[2] + 606105819 & 4294967295, r = a + (o << 17 & 4294967295 | o >>> 15), o = i + (e ^ r & (a ^ e)) + n[3] + 3250441966 & 4294967295, i = r + (o << 22 & 4294967295 | o >>> 10), o = e + (a ^ i & (r ^ a)) + n[4] + 4118548399 & 4294967295, e = i + (o << 7 & 4294967295 | o >>> 25), o = a + (r ^ e & (i ^ r)) + n[5] + 1200080426 & 4294967295, a = e + (o << 12 & 4294967295 | o >>> 20), o = r + (i ^ a & (e ^ i)) + n[6] + 2821735955 & 4294967295, r = a + (o << 17 & 4294967295 | o >>> 15), o = i + (e ^ r & (a ^ e)) + n[7] + 4249261313 & 4294967295, i = r + (o << 22 & 4294967295 | o >>> 10), o = e + (a ^ i & (r ^ a)) + n[8] + 1770035416 & 4294967295, e = i + (o << 7 & 4294967295 | o >>> 25), o = a + (r ^ e & (i ^ r)) + n[9] + 2336552879 & 4294967295, a = e + (o << 12 & 4294967295 | o >>> 20), o = r + (i ^ a & (e ^ i)) + n[10] + 4294925233 & 4294967295, r = a + (o << 17 & 4294967295 | o >>> 15), o = i + (e ^ r & (a ^ e)) + n[11] + 2304563134 & 4294967295, i = r + (o << 22 & 4294967295 | o >>> 10), o = e + (a ^ i & (r ^ a)) + n[12] + 1804603682 & 4294967295, e = i + (o << 7 & 4294967295 | o >>> 25), o = a + (r ^ e & (i ^ r)) + n[13] + 4254626195 & 4294967295, a = e + (o << 12 & 4294967295 | o >>> 20), o = r + (i ^ a & (e ^ i)) + n[14] + 2792965006 & 4294967295, r = a + (o << 17 & 4294967295 | o >>> 15), o = i + (e ^ r & (a ^ e)) + n[15] + 1236535329 & 4294967295, i = r + (o << 22 & 4294967295 | o >>> 10), o = e + (r ^ a & (i ^ r)) + n[1] + 4129170786 & 4294967295, e = i + (o << 5 & 4294967295 | o >>> 27), o = a + (i ^ r & (e ^ i)) + n[6] + 3225465664 & 4294967295, a = e + (o << 9 & 4294967295 | o >>> 23), o = r + (e ^ i & (a ^ e)) + n[11] + 643717713 & 4294967295, r = a + (o << 14 & 4294967295 | o >>> 18), o = i + (a ^ e & (r ^ a)) + n[0] + 3921069994 & 4294967295, i = r + (o << 20 & 4294967295 | o >>> 12), o = e + (r ^ a & (i ^ r)) + n[5] + 3593408605 & 4294967295, e = i + (o << 5 & 4294967295 | o >>> 27), o = a + (i ^ r & (e ^ i)) + n[10] + 38016083 & 4294967295, a = e + (o << 9 & 4294967295 | o >>> 23), o = r + (e ^ i & (a ^ e)) + n[15] + 3634488961 & 4294967295, r = a + (o << 14 & 4294967295 | o >>> 18), o = i + (a ^ e & (r ^ a)) + n[4] + 3889429448 & 4294967295, i = r + (o << 20 & 4294967295 | o >>> 12), o = e + (r ^ a & (i ^ r)) + n[9] + 568446438 & 4294967295, e = i + (o << 5 & 4294967295 | o >>> 27), o = a + (i ^ r & (e ^ i)) + n[14] + 3275163606 & 4294967295, a = e + (o << 9 & 4294967295 | o >>> 23), o = r + (e ^ i & (a ^ e)) + n[3] + 4107603335 & 4294967295, r = a + (o << 14 & 4294967295 | o >>> 18), o = i + (a ^ e & (r ^ a)) + n[8] + 1163531501 & 4294967295, i = r + (o << 20 & 4294967295 | o >>> 12), o = e + (r ^ a & (i ^ r)) + n[13] + 2850285829 & 4294967295, e = i + (o << 5 & 4294967295 | o >>> 27), o = a + (i ^ r & (e ^ i)) + n[2] + 4243563512 & 4294967295, a = e + (o << 9 & 4294967295 | o >>> 23), o = r + (e ^ i & (a ^ e)) + n[7] + 1735328473 & 4294967295, r = a + (o << 14 & 4294967295 | o >>> 18), o = i + (a ^ e & (r ^ a)) + n[12] + 2368359562 & 4294967295, i = r + (o << 20 & 4294967295 | o >>> 12), o = e + (i ^ r ^ a) + n[5] + 4294588738 & 4294967295, e = i + (o << 4 & 4294967295 | o >>> 28), o = a + (e ^ i ^ r) + n[8] + 2272392833 & 4294967295, a = e + (o << 11 & 4294967295 | o >>> 21), o = r + (a ^ e ^ i) + n[11] + 1839030562 & 4294967295, r = a + (o << 16 & 4294967295 | o >>> 16), o = i + (r ^ a ^ e) + n[14] + 4259657740 & 4294967295, i = r + (o << 23 & 4294967295 | o >>> 9), o = e + (i ^ r ^ a) + n[1] + 2763975236 & 4294967295, e = i + (o << 4 & 4294967295 | o >>> 28), o = a + (e ^ i ^ r) + n[4] + 1272893353 & 4294967295, a = e + (o << 11 & 4294967295 | o >>> 21), o = r + (a ^ e ^ i) + n[7] + 4139469664 & 4294967295, r = a + (o << 16 & 4294967295 | o >>> 16), o = i + (r ^ a ^ e) + n[10] + 3200236656 & 4294967295, i = r + (o << 23 & 4294967295 | o >>> 9), o = e + (i ^ r ^ a) + n[13] + 681279174 & 4294967295, e = i + (o << 4 & 4294967295 | o >>> 28), o = a + (e ^ i ^ r) + n[0] + 3936430074 & 4294967295, a = e + (o << 11 & 4294967295 | o >>> 21), o = r + (a ^ e ^ i) + n[3] + 3572445317 & 4294967295, r = a + (o << 16 & 4294967295 | o >>> 16), o = i + (r ^ a ^ e) + n[6] + 76029189 & 4294967295, i = r + (o << 23 & 4294967295 | o >>> 9), o = e + (i ^ r ^ a) + n[9] + 3654602809 & 4294967295, e = i + (o << 4 & 4294967295 | o >>> 28), o = a + (e ^ i ^ r) + n[12] + 3873151461 & 4294967295, a = e + (o << 11 & 4294967295 | o >>> 21), o = r + (a ^ e ^ i) + n[15] + 530742520 & 4294967295, r = a + (o << 16 & 4294967295 | o >>> 16), o = i + (r ^ a ^ e) + n[2] + 3299628645 & 4294967295, i = r + (o << 23 & 4294967295 | o >>> 9), o = e + (r ^ (i | ~a)) + n[0] + 4096336452 & 4294967295, e = i + (o << 6 & 4294967295 | o >>> 26), o = a + (i ^ (e | ~r)) + n[7] + 1126891415 & 4294967295, a = e + (o << 10 & 4294967295 | o >>> 22), o = r + (e ^ (a | ~i)) + n[14] + 2878612391 & 4294967295, r = a + (o << 15 & 4294967295 | o >>> 17), o = i + (a ^ (r | ~e)) + n[5] + 4237533241 & 4294967295, i = r + (o << 21 & 4294967295 | o >>> 11), o = e + (r ^ (i | ~a)) + n[12] + 1700485571 & 4294967295, e = i + (o << 6 & 4294967295 | o >>> 26), o = a + (i ^ (e | ~r)) + n[3] + 2399980690 & 4294967295, a = e + (o << 10 & 4294967295 | o >>> 22), o = r + (e ^ (a | ~i)) + n[10] + 4293915773 & 4294967295, r = a + (o << 15 & 4294967295 | o >>> 17), o = i + (a ^ (r | ~e)) + n[1] + 2240044497 & 4294967295, i = r + (o << 21 & 4294967295 | o >>> 11), o = e + (r ^ (i | ~a)) + n[8] + 1873313359 & 4294967295, e = i + (o << 6 & 4294967295 | o >>> 26), o = a + (i ^ (e | ~r)) + n[15] + 4264355552 & 4294967295, a = e + (o << 10 & 4294967295 | o >>> 22), o = r + (e ^ (a | ~i)) + n[6] + 2734768916 & 4294967295, r = a + (o << 15 & 4294967295 | o >>> 17), o = i + (a ^ (r | ~e)) + n[13] + 1309151649 & 4294967295, i = r + (o << 21 & 4294967295 | o >>> 11), o = e + (r ^ (i | ~a)) + n[4] + 4149444226 & 4294967295, e = i + (o << 6 & 4294967295 | o >>> 26), o = a + (i ^ (e | ~r)) + n[11] + 3174756917 & 4294967295, a = e + (o << 10 & 4294967295 | o >>> 22), o = r + (e ^ (a | ~i)) + n[2] + 718787259 & 4294967295, r = a + (o << 15 & 4294967295 | o >>> 17), o = i + (a ^ (r | ~e)) + n[9] + 3951481745 & 4294967295, t.b[0] = t.b[0] + e & 4294967295, t.b[1] = t.b[1] + (r + (o << 21 & 4294967295 | o >>> 11)) & 4294967295, t.b[2] = t.b[2] + r & 4294967295, t.b[3] = t.b[3] + a & 4294967295
    }

    function qi(e, i) {
        var n;
        t(n) || (n = i.length);
        for (var r = n - e.a, o = e.c, a = e.g, h = 0; h < n;) {
            if (0 == a)
                for (; h <= r;) Gi(e, i, h), h += e.a;
            if (s(i)) {
                for (; h < n;)
                    if (o[a++] = i.charCodeAt(h++), a == e.a) { Gi(e, o), a = 0; break }
            } else
                for (; h < n;)
                    if (o[a++] = i[h++], a == e.a) { Gi(e, o), a = 0; break }
        }
        e.g = a, e.f += n
    }

    function Vi(t) { t = t || {}, this.b = void 0 !== t.color ? t.color : null, this.f = t.lineCap, this.g = void 0 !== t.lineDash ? t.lineDash : null, this.c = t.lineJoin, this.i = t.miterLimit, this.a = t.width, this.l = void 0 }

    function Wi(t) {
        if (void 0 === t.l) {
            var e = "s" + (t.b ? li(t.b) : "-") + "," + (void 0 !== t.f ? t.f.toString() : "-") + "," + (t.g ? t.g.toString() : "-") + "," + (void 0 !== t.c ? t.c : "-") + "," + (void 0 !== t.i ? t.i.toString() : "-") + "," + (void 0 !== t.a ? t.a.toString() : "-"),
                i = new zi;
            qi(i, e), e = Array((56 > i.g ? i.a : 2 * i.a) - i.g), e[0] = 128;
            for (var n = 1; n < e.length - 8; ++n) e[n] = 0;
            for (var r = 8 * i.f, n = e.length - 8; n < e.length; ++n) e[n] = 255 & r, r /= 256;
            for (qi(i, e), e = Array(16), n = r = 0; 4 > n; ++n)
                for (var o = 0; 32 > o; o += 8) e[r++] = i.b[n] >>> o & 255;
            if (8192 >= e.length) i = String.fromCharCode.apply(null, e);
            else
                for (i = "", n = 0; n < e.length; n += 8192) r = bi(e, n, n + 8192), i += String.fromCharCode.apply(null, r);
            t.l = i
        }
        return t.l
    }

    function Xi(t) { t = t || {}, this.i = null, this.g = $i, void 0 !== t.geometry && this.ik(t.geometry), this.c = void 0 !== t.fill ? t.fill : null, this.a = void 0 !== t.image ? t.image : null, this.f = void 0 !== t.stroke ? t.stroke : null, this.l = void 0 !== t.text ? t.text : null, this.b = t.zIndex }

    function Hi(t) {
        if ("function" != typeof t) {
            var e;
            Array.isArray(t) ? e = t : (x(t instanceof Xi, 41), e = [t]), t = function() { return e }
        }
        return t
    }

    function Yi() {
        if (!Iw) {
            var t = new Ui({ color: "rgba(255,255,255,0.4)" }),
                e = new Vi({ color: "#3399CC", width: 1.25 });
            Iw = [new Xi({ image: new Fi({ fill: t, stroke: e, radius: 5 }), fill: t, stroke: e })]
        }
        return Iw
    }

    function Ki() {
        var t = {},
            e = [255, 255, 255, 1],
            i = [0, 153, 255, 1];
        return t.Polygon = [new Xi({ fill: new Ui({ color: [255, 255, 255, .5] }) })], t.MultiPolygon = t.Polygon, t.LineString = [new Xi({ stroke: new Vi({ color: e, width: 5 }) }), new Xi({ stroke: new Vi({ color: i, width: 3 }) })], t.MultiLineString = t.LineString, t.Circle = t.Polygon.concat(t.LineString), t.Point = [new Xi({ image: new Fi({ radius: 6, fill: new Ui({ color: i }), stroke: new Vi({ color: e, width: 1.5 }) }), zIndex: 1 / 0 })], t.MultiPoint = t.Point, t.GeometryCollection = t.Polygon.concat(t.LineString, t.Point), t
    }

    function $i(t) { return t.Y() }

    function Zi(t) {
        t = t || {}, this.g = t.font, this.i = t.rotation, this.s = t.rotateWithView,
            this.a = t.scale, this.A = t.text, this.j = t.textAlign, this.o = t.textBaseline, this.b = void 0 !== t.fill ? t.fill : new Ui({ color: "#333" }), this.l = void 0 !== t.stroke ? t.stroke : null, this.f = void 0 !== t.offsetX ? t.offsetX : 0, this.c = void 0 !== t.offsetY ? t.offsetY : 0
    }

    function Ji() { this.b = {}, this.a = 0 }

    function Qi(t, e, i, n, r, o) { vt.call(this), this.j = null, this.a = t ? t : new Image, null !== n && (this.a.crossOrigin = n), this.c = o ? document.createElement("CANVAS") : null, this.l = o, this.i = null, this.f = r, this.g = i, this.o = e, this.s = !1, 2 == this.f && tn(this) }

    function tn(t) { var e = Ii(1, 1); try { e.drawImage(t.a, 0, 0), e.getImageData(0, 0, 1, 1) } catch (e) { t.s = !0 } }

    function en(t) {
        t = t || {}, this.c = void 0 !== t.anchor ? t.anchor : [.5, .5], this.f = null, this.a = void 0 !== t.anchorOrigin ? t.anchorOrigin : "top-left", this.j = void 0 !== t.anchorXUnits ? t.anchorXUnits : "fraction", this.s = void 0 !== t.anchorYUnits ? t.anchorYUnits : "fraction";
        var e = void 0 !== t.crossOrigin ? t.crossOrigin : null,
            i = void 0 !== t.img ? t.img : null,
            n = void 0 !== t.imgSize ? t.imgSize : null,
            r = t.src;
        x(!(void 0 !== r && i), 4), x(!i || i && n, 5), void 0 !== r && 0 !== r.length || !i || (r = i.src || b(i).toString()), x(void 0 !== r && 0 < r.length, 6);
        var o = void 0 !== t.src ? 0 : 2,
            s = void 0 !== t.color ? hi(t.color) : null,
            a = kw.get(r, e, s);
        a || (a = new Qi(i, r, n, e, o, s), kw.set(r, e, s, a)), this.b = a, this.D = void 0 !== t.offset ? t.offset : [0, 0], this.g = void 0 !== t.offsetOrigin ? t.offsetOrigin : "top-left", this.l = null, this.v = void 0 !== t.size ? t.size : null, Di.call(this, { opacity: void 0 !== t.opacity ? t.opacity : 1, rotation: void 0 !== t.rotation ? t.rotation : 0, scale: void 0 !== t.scale ? t.scale : 1, snapToPixel: void 0 === t.snapToPixel || t.snapToPixel, rotateWithView: void 0 !== t.rotateWithView && t.rotateWithView })
    }

    function nn(t) {
        this.v = this.s = this.f = null, this.j = void 0 !== t.fill ? t.fill : null, this.sa = [0, 0], this.b = t.points, this.g = void 0 !== t.radius ? t.radius : t.radius1, this.c = void 0 !== t.radius2 ? t.radius2 : this.g, this.l = void 0 !== t.angle ? t.angle : 0, this.a = void 0 !== t.stroke ? t.stroke : null, this.O = this.za = this.D = null;
        var e, i = t.atlasManager,
            n = "",
            r = "",
            o = 0,
            s = null,
            a = 0;
        this.a && (e = li(this.a.b), a = this.a.a, void 0 === a && (a = 1), s = this.a.g, dw || (s = null), r = this.a.c, void 0 === r && (r = "round"), n = this.a.f, void 0 === n && (n = "round"), o = this.a.i, void 0 === o && (o = 10));
        var h = 2 * (this.g + a) + 1,
            n = { strokeStyle: e, Me: a, size: h, lineCap: n, lineDash: s, lineJoin: r, miterLimit: o };
        if (void 0 === i) {
            var l = Ii(h, h);
            this.s = l.canvas, i = h = this.s.width, this.hk(n, l, 0, 0), this.j ? this.v = this.s : (l = Ii(n.size, n.size), this.v = l.canvas, this.gk(n, l, 0, 0))
        } else h = Math.round(h), (r = !this.j) && (l = this.gk.bind(this, n)), o = this.a ? Wi(this.a) : "-", s = this.j ? Bi(this.j) : "-", this.f && o == this.f[1] && s == this.f[2] && this.g == this.f[3] && this.c == this.f[4] && this.l == this.f[5] && this.b == this.f[6] || (this.f = ["r" + o + s + (void 0 !== this.g ? this.g.toString() : "-") + (void 0 !== this.c ? this.c.toString() : "-") + (void 0 !== this.l ? this.l.toString() : "-") + (void 0 !== this.b ? this.b.toString() : "-"), o, s, this.g, this.c, this.l, this.b]), l = i.add(this.f[0], h, h, this.hk.bind(this, n), l), this.s = l.image, this.sa = [l.offsetX, l.offsetY], i = l.image.width, this.v = r ? l.kj : this.s;
        this.D = [h / 2, h / 2], this.za = [h, h], this.O = [i, i], Di.call(this, { opacity: 1, rotateWithView: void 0 !== t.rotateWithView && t.rotateWithView, rotation: void 0 !== t.rotation ? t.rotation : 0, scale: 1, snapToPixel: void 0 === t.snapToPixel || t.snapToPixel })
    }

    function rn(t) {
        this.g = null, this.b = {}, this.b.point = {}, this.b.line = {}, this.b.polygon = {};
        var e = this.type = t.type;
        if ("unique" !== e && "range" !== e || (this.key = t.property), "single" === e) this.g = t = an(t);
        else if ("unique" === e)
            for (var i = t.values, e = 0; e < i.length; e++) {
                var n = i[e],
                    r = n.geomType;
                t = an(n), n = n.value, this.b[r][n] = t
            } else if ("range" === e)
                for (i = t.ranges, e = 0; e < i.length; e++) n = i[e], r = n.geomType, t = an(n), n = n.Ts.toLocaleString(), this.b[r][n] = t
    }

    function on(t, e, i) {
        var n, r;
        for (r in t.b[i])
            if (r = r.split(","), e >= parseFloat(r[0]) && e <= parseFloat(r[1])) { n = t.b[i][r]; break }
        return n
    }

    function sn(t) { var e, i = {}; for (e in t) { var n = t[e]; "stroke" === e ? i[e] = new Vi(n) : "fill" === e ? i[e] = new Ui(n) : "text" === e && (i[e] = new Zi(n)) } return i }

    function an(t) {
        var e, i = {},
            n = t.vectorOptions;
        "point" === t.geomType && (n = { image: n });
        for (var r in n)
            if (t = {}, "image" === r) {
                var o = n[r];
                t = sn(o);
                var s = {};
                for (e in o) s[e] = o[e];
                for (e in t) s[e] = t[e];
                if (t = s, o = o.type, "circle" === o) t = new Fi(t);
                else if ("icon" === o) t = new en(t);
                else {
                    var s = { Vs: { points: 4, angle: Math.PI / 4 }, Ys: { points: 3, rotation: Math.PI / 4, angle: 0 }, Ws: { points: 5, angle: 0 }, Qs: { points: 4, angle: 0 } },
                        a = { points: 3 },
                        h = void 0;
                    for (h in s[o]) a[h] = s[o][h];
                    for (h in t) a[h] = t[h];
                    t = new nn(a)
                }
                i[r] = t
            } else {
                for (e in t) i[e] = t[e];
                t = sn(n);
                for (e in t) i[e] = t[e]
            }
        return new Xi(i)
    }

    function hn(t, e, i, n) { this.da = t, this.ha = e, this.ia = i, this.ka = n }

    function ln(t, e, i) { return t.da <= e && e <= t.ha && t.ia <= i && i <= t.ka }

    function un(t, e) { return t.da == e.da && t.ia == e.ia && t.ha == e.ha && t.ka == e.ka }

    function pn(t, e) { return t.da <= e.ha && t.ha >= e.da && t.ia <= e.ka && t.ka >= e.ia }

    function cn(t, e, i) { return void 0 === i && (i = [0, 0]), i[0] = t[0] + 2 * e, i[1] = t[1] + 2 * e, i }

    function fn(t, e, i) { return void 0 === i && (i = [0, 0]), i[0] = t[0] * e + .5 | 0, i[1] = t[1] * e + .5 | 0, i }

    function gn(t, e) { return Array.isArray(t) ? t : (void 0 === e ? e = [t, t] : e[0] = e[1] = t, e) }

    function dn(t, e, i, n) { return void 0 !== n ? (n[0] = t, n[1] = e, n[2] = i, n) : [t, e, i] }

    function yn(t) {
        var e, i, n = t[0],
            r = Array(n),
            o = 1 << n - 1;
        for (e = 0; e < n; ++e) i = 48, t[1] & o && (i += 1), t[2] & o && (i += 2), r[e] = String.fromCharCode(i), o >>= 1;
        return r.join("")
    }

    function mn(t) {
        this.minZoom = void 0 !== t.minZoom ? t.minZoom : 0, this.b = t.resolutions, x(me(this.b, function(t, e) { return e - t }), 17), this.maxZoom = this.b.length - 1, this.g = void 0 !== t.origin ? t.origin : null, this.f = null, void 0 !== t.origins && (this.f = t.origins, x(this.f.length == this.b.length, 20));
        var e = t.extent;
        void 0 === e || this.g || this.f || (this.g = X(e)), x(!this.g && this.f || this.g && !this.f, 18), this.c = null, void 0 !== t.tileSizes && (this.c = t.tileSizes, x(this.c.length == this.b.length, 19)), this.i = void 0 !== t.tileSize ? t.tileSize : this.c ? null : 256, x(!this.i && this.c || this.i && !this.c, 22), this.s = void 0 !== e ? e : null, this.a = null, this.l = [0, 0], void 0 !== t.sizes ? this.a = t.sizes.map(function(t) { return new hn(Math.min(0, t[0]), Math.max(t[0] - 1, -1), Math.min(0, t[1]), Math.max(t[1] - 1, -1)) }, this) : e && Nn(this, e)
    }

    function vn(t, e, i, n, r) { for (r = t.Na(e, r), e = e[0] - 1; e >= t.minZoom;) { if (i.call(null, e, xn(t, r, e, n))) return !0;--e } return !1 }

    function bn(t, e, i, n) { return e[0] < t.maxZoom ? (n = t.Na(e, n), xn(t, n, e[0] + 1, i)) : null }

    function wn(t, e, i, n) {
        Sn(t, e[0], e[1], i, !1, Tw);
        var r = Tw[1],
            o = Tw[2];
        return Sn(t, e[2], e[3], i, !0, Tw), t = Tw[1], e = Tw[2], void 0 !== n ? (n.da = r, n.ha = t, n.ia = o, n.ka = e) : n = new hn(r, t, o, e), n
    }

    function xn(t, e, i, n) { return i = t.aa(i), wn(t, e, i, n) }

    function En(t, e) {
        var i = t.$a(e[0]),
            n = t.aa(e[0]),
            r = gn(t.gb(e[0]), t.l);
        return [i[0] + (e[1] + .5) * r[0] * n, i[1] + (e[2] + .5) * r[1] * n]
    }

    function Sn(t, e, i, n, r, o) {
        var s = t.Kc(n),
            a = n / t.aa(s),
            h = t.$a(s);
        return t = gn(t.gb(s), t.l), e = a * Math.floor((e - h[0]) / n + (r ? .5 : 0)) / t[0], i = a * Math.floor((i - h[1]) / n + (r ? 0 : .5)) / t[1], r ? (e = Math.ceil(e) - 1, i = Math.ceil(i) - 1) : (e = Math.floor(e), i = Math.floor(i)), dn(s, e, i, o)
    }

    function Nn(t, e) {
        for (var i = t.b.length, n = Array(i), r = t.minZoom; r < i; ++r) n[r] = xn(t, e, r);
        t.a = n
    }

    function Ln(t) {
        var e = t.l;
        if (!e) {
            var e = In(t),
                i = Mn(e, void 0, void 0),
                e = new mn({ extent: e, origin: X(e), resolutions: i, tileSize: void 0 });
            t.l = e
        }
        return e
    }

    function Cn(t) { var e = {}; return db(e, void 0 !== t ? t : {}), void 0 === e.extent && (e.extent = qt("EPSG:3857").H()), e.resolutions = Mn(e.extent, e.maxZoom, e.tileSize), delete e.maxZoom, new mn(e) }

    function Mn(t, e, i) { e = void 0 !== e ? e : 42; var n = V(t); for (t = Y(t), i = gn(void 0 !== i ? i : 256), i = Math.max(t / i[0], n / i[1]), e += 1, n = Array(e), t = 0; t < e; ++t) n[t] = i / Math.pow(2, t); return n }

    function In(t) { t = qt(t); var e = t.H(); return e || (t = 180 * bb.degrees / t.Gc(), e = A(-t, -t, t, t)), e }

    function kn(t) { this.a = t.html, this.b = t.tileRanges ? t.tileRanges : null }

    function Tn(t) { St.call(this), this.i = void 0, this.a = "geometry", this.c = null, this.l = void 0, this.f = null, lt(this, Nt(this.a), this.wf, this), void 0 !== t && (t instanceof Zt || !t ? this.ob(t) : this.G(t)) }

    function An(t) {
        if ("function" != typeof t) {
            var e;
            Array.isArray(t) ? e = t : (x(t instanceof Xi, 41), e = [t]), t = function() { return e }
        }
        return t
    }

    function Rn() { this.defaultDataProjection = null }

    function _n(t, e, i) { var n; return i && (n = { dataProjection: i.dataProjection ? i.dataProjection : t.ib(e), featureProjection: i.featureProjection }), Pn(t, n) }

    function Pn(t, e) { var i; return e && (i = { featureProjection: e.featureProjection, dataProjection: e.dataProjection ? e.dataProjection : t.defaultDataProjection, rightHanded: e.rightHanded }, e.decimals && (i.decimals = e.decimals)), i }

    function On(t, e, i) {
        var n, r = i ? qt(i.featureProjection) : null,
            o = i ? qt(i.dataProjection) : null;
        if (n = r && o && !Vt(r, o) ? t instanceof Zt ? (e ? t.clone() : t).Db(e ? r : o, e ? o : r) : $t(e ? t.slice() : t, e ? r : o, e ? o : r) : t, e && i && i.decimals) {
            var s = Math.pow(10, i.decimals);
            t = function(t) { for (var e = 0, i = t.length; e < i; ++e) t[e] = Math.round(t[e] * s) / s; return t }, Array.isArray(n) ? t(n) : n.cd(t)
        }
        return n
    }

    function Dn() { this.defaultDataProjection = null }

    function Fn(t) { return "string" == typeof t ? (t = JSON.parse(t)) ? t : null : null !== t ? t : null }

    function Un(t) { Zt.call(this), this.f = t ? t : null, zn(this) }

    function Bn(t) { var e, i, n = []; for (e = 0, i = t.length; e < i; ++e) n.push(t[e].clone()); return n }

    function jn(t) {
        var e, i;
        if (t.f)
            for (e = 0, i = t.f.length; e < i; ++e) pt(t.f[e], "change", t.u, t)
    }

    function zn(t) {
        var e, i;
        if (t.f)
            for (e = 0, i = t.f.length; e < i; ++e) lt(t.f[e], "change", t.u, t)
    }

    function Gn(t) { t = t ? t : {}, this.defaultDataProjection = null, this.defaultDataProjection = qt(t.defaultDataProjection ? t.defaultDataProjection : "EPSG:4326"), this.b = t.geometryName }

    function qn(t, e) { return t ? On((0, Aw[t.type])(t), !1, e) : null }

    function Vn(t, e) { return (0, Rw[t.Z()])(On(t, !0, e), e) }

    function Wn(t) { St.call(this), this.a = t ? t : [], Xn(this) }

    function Xn(t) { t.set("length", t.a.length) }

    function Hn(t, e) { dt.call(this, t), this.element = e }

    function Yn(t, e) { vt.call(this), this.ta = t, this.state = e, this.a = null, this.key = "" }

    function Kn(t) { t.b("change") }

    function $n(t, e) { return Ow.createElementNS(t, e) }

    function Zn(t, e) { return Jn(t, e, []).join("") }

    function Jn(t, e, i) {
        if (t.nodeType == Node.CDATA_SECTION_NODE || t.nodeType == Node.TEXT_NODE) e ? i.push(String(t.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : i.push(t.nodeValue);
        else
            for (t = t.firstChild; t; t = t.nextSibling) Jn(t, e, i);
        return i
    }

    function Qn(t) { return t instanceof Document }

    function tr(t) { return t instanceof Node }

    function er(t) { return (new DOMParser).parseFromString(t, "application/xml") }

    function ir(t, e) {
        return function(i, n) {
            var r = t.call(e, i, n);
            void 0 !== r && pe(n[n.length - 1], r)
        }
    }

    function nr(t, e) {
        return function(i, n) {
            var r = t.call(void 0 !== e ? e : this, i, n);
            void 0 !== r && n[n.length - 1].push(r)
        }
    }

    function rr(t, e) {
        return function(i, n) {
            var r = t.call(void 0 !== e ? e : this, i, n);
            void 0 !== r && (n[n.length - 1] = r)
        }
    }

    function or(t) {
        return function(e, i) {
            var n = t.call(this, e, i);
            if (void 0 !== n) {
                var r, o = i[i.length - 1],
                    s = e.localName;
                r = s in o ? o[s] : o[s] = [], r.push(n)
            }
        }
    }

    function sr(t, e) {
        return function(i, n) {
            var r = t.call(this, i, n);
            void 0 !== r && (n[n.length - 1][void 0 !== e ? e : i.localName] = r)
        }
    }

    function ar(t, e) { return function(i, n, r) { t.call(void 0 !== e ? e : this, i, n, r), r[r.length - 1].node.appendChild(i) } }

    function hr(t) {
        var e, i;
        return function(n, r, o) {
            if (!e) {
                e = {};
                var s = {};
                s[n.localName] = t, e[n.namespaceURI] = s, i = lr(n.localName)
            }
            gr(e, i, r, o)
        }
    }

    function lr(t, e) { return function(i, n, r) { return i = n[n.length - 1].node, n = t, void 0 === n && (n = r), r = e, void 0 === e && (r = i.namespaceURI), $n(r, n) } }

    function ur(t, e) { for (var i = e.length, n = Array(i), r = 0; r < i; ++r) n[r] = t[e[r]]; return n }

    function pr(t, e, i) { i = void 0 !== i ? i : {}; var n, r; for (n = 0, r = t.length; n < r; ++n) i[t[n]] = e; return i }

    function cr(t, e, i, n) {
        for (e = e.firstElementChild; e; e = e.nextElementSibling) {
            var r = t[e.namespaceURI];
            void 0 !== r && (r = r[e.localName]) && r.call(n, e, i)
        }
    }

    function fr(t, e, i, n, r) { return n.push(t), cr(e, i, n, r), n.pop() }

    function gr(t, e, i, n, r, o) { for (var s, a, h = (void 0 !== r ? r : i).length, l = 0; l < h; ++l) s = i[l], void 0 !== s && (a = e.call(o, s, n, void 0 !== r ? r[l] : void 0), void 0 !== a && t[a.namespaceURI][a.localName].call(o, a, s, n)) }

    function dr(t, e, i, n, r, o, s) { r.push(t), gr(e, i, n, r, o, s), r.pop() }

    function yr(t, e, i, n) {
        return function(r, o, s) {
            var a = new XMLHttpRequest;
            a.open("GET", "function" == typeof t ? t(r, o, s) : t, !0), "arraybuffer" == e.Z() && (a.responseType = "arraybuffer"), a.onload = function() { if (!a.status || 200 <= a.status && 300 > a.status) { var t, r = e.Z(); "json" == r || "text" == r ? t = a.responseText : "xml" == r ? (t = a.responseXML) || (t = er(a.responseText)) : "arraybuffer" == r && (t = a.response), t ? i.call(this, e.Ia(t, { featureProjection: s }), e.ib(t)) : n.call(this) } else n.call(this) }.bind(this), a.send()
        }
    }

    function mr(t, e) { return yr(t, e, function(t, e) { this.xh(e), this.Nk(t) }, function() { this.state = 3, Kn(this) }) }

    function vr(t, e) { return yr(t, e, function(t) { this.Bc(t) }, v) }

    function br() {
        return [
            [-(1 / 0), -(1 / 0), 1 / 0, 1 / 0]
        ]
    }

    function wr(t) { St.call(this), this.f = qt(t.projection), this.l = xr(t.attributions), this.O = t.logo, this.Ta = void 0 !== t.state ? t.state : "ready", this.D = void 0 !== t.wrapX && t.wrapX }

    function xr(t) {
        if ("string" == typeof t) return [new kn({ html: t })];
        if (t instanceof kn) return [t];
        if (Array.isArray(t)) {
            for (var e = t.length, i = Array(e), n = 0; n < e; n++) {
                var r = t[n];
                i[n] = "string" == typeof r ? new kn({ html: r }) : r
            }
            return i
        }
        return null
    }

    function Er(t, e) { t.Ta = e, t.u() }

    function Sr(t) { this.b = Fw(t), this.a = {} }

    function Nr(t, e, i) {
        var n = t.a[b(i)];
        P([n.da, n.ia, n.ha, n.ka], e) || (t.remove(i), t.Ka(e, i))
    }

    function Lr(t) { return t.b.all().map(function(t) { return t.value }) }

    function Cr(t, e) { return t.b.search({ da: e[0], ia: e[1], ha: e[2], ka: e[3] }).map(function(t) { return t.value }) }

    function Mr(t, e, i, n) { return Ir(Cr(t, e), i, n) }

    function Ir(t, e, i) { for (var n, r = 0, o = t.length; r < o && !(n = e.call(i, t[r])); r++); return n }

    function kr(t) {
        t = t || {}, wr.call(this, { attributions: t.attributions, logo: t.logo, projection: void 0, state: "ready", wrapX: void 0 === t.wrapX || t.wrapX }), this.U = v, this.P = t.format, this.X = void 0 == t.overlaps || t.overlaps, this.fa = t.url, void 0 !== t.loader ? this.U = t.loader : void 0 !== this.fa && (x(this.P, 7), this.U = vr(this.fa, this.P)), this.bc = void 0 !== t.strategy ? t.strategy : br;
        var e = void 0 === t.useSpatialIndex || t.useSpatialIndex;
        this.a = e ? new Sr : null, this.qa = new Sr, this.i = {}, this.j = {}, this.o = {}, this.s = {}, this.c = null;
        var i, n;
        t.features instanceof Wn ? (i = t.features, n = i.a) : Array.isArray(t.features) && (n = t.features), e || void 0 !== i || (i = new Wn(n)), void 0 !== n && Rr(this, n), void 0 !== i && _r(this, i)
    }

    function Tr(t, e, i) { t.s[e] = [lt(i, "change", t.dk, t), lt(i, "propertychange", t.dk, t)] }

    function Ar(t, e, i) {
        var n = !0,
            r = i.Ja();
        return void 0 !== r ? r.toString() in t.j ? n = !1 : t.j[r.toString()] = i : (x(!(e in t.o), 30), t.o[e] = i), n
    }

    function Rr(t, e) {
        var i, n, r, o, s = [],
            a = [],
            h = [];
        for (n = 0, r = e.length; n < r; n++) o = e[n], i = b(o).toString(), Ar(t, i, o) && a.push(o);
        for (n = 0, r = a.length; n < r; n++) {
            o = a[n], i = b(o).toString(), Tr(t, i, o);
            var l = o.Y();
            l ? (i = l.H(), s.push(i), h.push(o)) : t.i[i] = o
        }
        for (t.a && t.a.load(s, h), n = 0, r = a.length; n < r; n++) t.b(new Dr("addfeature", a[n]))
    }

    function _r(t, e) {
        var i = !1;
        lt(t, "addfeature", function(t) { i || (i = !0, e.push(t.feature), i = !1) }), lt(t, "removefeature", function(t) { i || (i = !0, e.remove(t.feature), i = !1) }), lt(e, _w, function(t) { i || (i = !0, this.Nb(t.element), i = !1) }, t), lt(e, Pw, function(t) { i || (i = !0, this.Kb(t.element), i = !1) }, t), t.c = e
    }

    function Pr(t, e, i) { t.Rb([e[0], e[1], e[0], e[1]], function(t) { if (t.Y().Cb(e)) return i.call(void 0, t) }) }

    function Or(t, e) {
        for (var i in t.j)
            if (t.j[i] === e) { delete t.j[i]; break }
    }

    function Dr(t, e) { dt.call(this, t), this.feature = e }

    function Fr(t) {
        St.call(this);
        var e = db({}, t);
        e.opacity = void 0 !== t.opacity ? t.opacity : 1, e.visible = void 0 === t.visible || t.visible, e.zIndex = void 0 !== t.zIndex ? t.zIndex : 0, e.maxResolution = void 0 !== t.maxResolution ? t.maxResolution : 1 / 0, e.minResolution = void 0 !== t.minResolution ? t.minResolution : 0, this.G(e)
    }

    function Ur(t) {
        var e = t.tc(),
            i = t.Zg(),
            n = t.Ib(),
            r = t.H(),
            o = t.uc(),
            s = t.rc(),
            a = t.sc();
        return { layer: t, opacity: Ct(e, 0, 1), O: i, visible: n, Id: !0, extent: r, zIndex: o, maxResolution: s, minResolution: Math.max(a, 0) }
    }

    function Br(t) {
        var e = t || {};
        t = db({}, e), delete t.layers, e = e.layers, Fr.call(this, t), this.f = [], this.a = {}, lt(this, Nt("layers"), this.Nn, this), e ? Array.isArray(e) ? e = new Wn(e.slice()) : x(e instanceof Wn, 43) : e = new Wn, this.Nj(e)
    }

    function jr(t, e, i, n, r) { dt.call(this, t), this.vectorContext = e, this.frameState = i, this.context = n, this.glContext = r }

    function zr(t) {
        var e = db({}, t);
        delete e.source, Fr.call(this, e), this.A = this.o = this.j = null, t.map && this.setMap(t.map), lt(this, Nt("source"), this.eo, this), this.td(t.source ? t.source : null)
    }

    function Gr(t, e) { return t.visible && e >= t.minResolution && e < t.maxResolution }

    function qr(t) {
        t = t ? t : {};
        var e = db({}, t);
        delete e.preload, delete e.useInterimTilesOnError, zr.call(this, e), this.v(void 0 !== t.preload ? t.preload : 0), this.C(void 0 === t.useInterimTilesOnError || t.useInterimTilesOnError)
    }

    function Vr(t) { zr.call(this, t ? t : {}) }

    function Wr(t) {
        t = t ? t : {};
        var e = db({}, t);
        delete e.style, delete e.renderBuffer, delete e.updateWhileAnimating, delete e.updateWhileInteracting, zr.call(this, e), this.a = void 0 !== t.renderBuffer ? t.renderBuffer : 100, this.v = null, this.i = void 0, this.l(t.style), this.P = void 0 !== t.updateWhileAnimating && t.updateWhileAnimating, this.U = void 0 !== t.updateWhileInteracting && t.updateWhileInteracting
    }

    function Xr(t) { return t.get("renderOrder") }

    function Hr(t, e, i, n, r) { Yn.call(this, t, e), this.s = i, this.g = new Image, null !== n && (this.g.crossOrigin = n), this.c = {}, this.o = null, this.A = r }

    function Yr(t) { t.o.forEach(ct), t.o = null }

    function Kr() { this.f = 0, this.b = {}, this.g = this.a = null }

    function $r(t) { Kr.call(this), this.c = void 0 !== t ? t : 2048 }

    function Zr(t) { return t.f > t.c }

    function Jr(t, e, i, n) { var r = Kt(i, e, t); return i = e.getPointResolution(n, i), e = e.Gc(), void 0 !== e && (i *= e), e = t.Gc(), void 0 !== e && (i /= e), t = t.getPointResolution(i, r) / i, isFinite(t) && 0 < t && (i /= t), i }

    function Qr(t, e, i, n) { t = i - t, e = n - e; var r = Math.sqrt(t * t + e * e); return [Math.round(i + t / r), Math.round(n + e / r)] }

    function to(t, e, i, n, r, o, s, a, h, l, u) {
        var p = Ii(Math.round(i * t), Math.round(i * e));
        if (0 === h.length) return p.canvas;
        p.scale(i, i);
        var c = T();
        h.forEach(function(t) { O(c, t.extent) });
        var f = Ii(Math.round(i * Y(c) / n), Math.round(i * V(c) / n)),
            g = i / n;
        h.forEach(function(t) { f.drawImage(t.image, l, l, t.image.width - 2 * l, t.image.height - 2 * l, (t.extent[0] - c[0]) * g, -(t.extent[3] - c[3]) * g, Y(t.extent) * g, V(t.extent) * g) });
        var d = X(s);
        return a.f.forEach(function(t) {
            var e = t.source,
                r = t.target,
                s = e[1][0],
                a = e[1][1],
                h = e[2][0],
                l = e[2][1];
            t = (r[0][0] - d[0]) / o;
            var u = -(r[0][1] - d[1]) / o,
                g = (r[1][0] - d[0]) / o,
                y = -(r[1][1] - d[1]) / o,
                m = (r[2][0] - d[0]) / o,
                v = -(r[2][1] - d[1]) / o,
                r = e[0][0],
                e = e[0][1],
                s = s - r,
                a = a - e,
                h = h - r,
                l = l - e;
            t: {
                for (s = [
                        [s, a, 0, 0, g - t],
                        [h, l, 0, 0, m - t],
                        [0, 0, s, a, y - u],
                        [0, 0, h, l, v - u]
                    ], a = s.length, h = 0; h < a; h++) {
                    for (var l = h, b = Math.abs(s[h][h]), w = h + 1; w < a; w++) {
                        var x = Math.abs(s[w][h]);
                        x > b && (b = x, l = w)
                    }
                    if (0 === b) { s = null; break t }
                    for (b = s[l], s[l] = s[h], s[h] = b, l = h + 1; l < a; l++)
                        for (b = -s[l][h] / s[h][h], w = h; w < a + 1; w++) s[l][w] = h == w ? 0 : s[l][w] + b * s[h][w]
                }
                for (h = Array(a), l = a - 1; 0 <= l; l--)
                    for (h[l] = s[l][a] / s[l][l], b = l - 1; 0 <= b; b--) s[b][a] -= s[b][l] * h[l];s = h
            }
            s && (p.save(), p.beginPath(), zw ? (h = (t + g + m) / 3, l = (u + y + v) / 3, a = Qr(h, l, t, u), g = Qr(h, l, g, y), m = Qr(h, l, m, v), p.moveTo(g[0], g[1]), p.lineTo(a[0], a[1]), p.lineTo(m[0], m[1])) : (p.moveTo(g, y), p.lineTo(t, u), p.lineTo(m, v)), p.clip(), p.transform(s[0], s[2], s[1], s[3], t, u), p.translate(c[0] - r, c[3] - e), p.scale(n / i, -n / i), p.drawImage(f.canvas, 0, 0), p.restore())
        }), u && (p.save(), p.strokeStyle = "black", p.lineWidth = 1, a.f.forEach(function(t) {
            var e = t.target;
            t = (e[0][0] - d[0]) / o;
            var i = -(e[0][1] - d[1]) / o,
                n = (e[1][0] - d[0]) / o,
                r = -(e[1][1] - d[1]) / o,
                s = (e[2][0] - d[0]) / o,
                e = -(e[2][1] - d[1]) / o;
            p.beginPath(), p.moveTo(n, r), p.lineTo(t, i), p.lineTo(s, e), p.closePath(), p.stroke()
        }), p.restore()), p.canvas
    }

    function eo(t, e, i, n, r) {
        this.g = t, this.c = e;
        var o = {},
            s = Wt(this.c, this.g);
        this.a = function(t) { var e = t[0] + "/" + t[1]; return o[e] || (o[e] = s(t)), o[e] }, this.i = n, this.s = r * r, this.f = [], this.j = !1, this.o = this.g.a && !!n && !!this.g.H() && Y(n) == Y(this.g.H()), this.b = this.g.H() ? Y(this.g.H()) : null, this.l = this.c.H() ? Y(this.c.H()) : null, t = X(i), e = H(i), n = z(i), i = j(i), r = this.a(t);
        var a = this.a(e),
            h = this.a(n),
            l = this.a(i);
        if (io(this, t, e, n, i, r, a, h, l, 10), this.j) {
            var u = 1 / 0;
            this.f.forEach(function(t) { u = Math.min(u, t.source[0][0], t.source[1][0], t.source[2][0]) }), this.f.forEach(function(t) {
                if (Math.max(t.source[0][0], t.source[1][0], t.source[2][0]) - u > this.b / 2) {
                    var e = [
                        [t.source[0][0], t.source[0][1]],
                        [t.source[1][0], t.source[1][1]],
                        [t.source[2][0], t.source[2][1]]
                    ];
                    e[0][0] - u > this.b / 2 && (e[0][0] -= this.b), e[1][0] - u > this.b / 2 && (e[1][0] -= this.b), e[2][0] - u > this.b / 2 && (e[2][0] -= this.b), Math.max(e[0][0], e[1][0], e[2][0]) - Math.min(e[0][0], e[1][0], e[2][0]) < this.b / 2 && (t.source = e)
                }
            }, this)
        }
        o = {}
    }

    function io(t, e, i, n, r, o, s, a, h, l) {
        var u = E([o, s, a, h]),
            p = t.b ? Y(u) / t.b : null,
            c = t.b,
            f = t.g.a && .5 < p && 1 > p,
            g = !1;
        if (0 < l) {
            if (t.c.g && t.l) var d = E([e, i, n, r]),
                g = g | .25 < Y(d) / t.l;
            !f && t.g.g && p && (g |= .25 < p)
        }
        if (g || !t.i || K(u, t.i)) {
            if (!(g || isFinite(o[0]) && isFinite(o[1]) && isFinite(s[0]) && isFinite(s[1]) && isFinite(a[0]) && isFinite(a[1]) && isFinite(h[0]) && isFinite(h[1]))) {
                if (!(0 < l)) return;
                g = !0
            }
            if (0 < l && (g || (u = t.a([(e[0] + n[0]) / 2, (e[1] + n[1]) / 2]), c = f ? (At(o[0], c) + At(a[0], c)) / 2 - At(u[0], c) : (o[0] + a[0]) / 2 - u[0], u = (o[1] + a[1]) / 2 - u[1], g = c * c + u * u > t.s), g)) return void(Math.abs(e[0] - n[0]) <= Math.abs(e[1] - n[1]) ? (f = [(i[0] + n[0]) / 2, (i[1] + n[1]) / 2], c = t.a(f), u = [(r[0] + e[0]) / 2, (r[1] + e[1]) / 2], p = t.a(u), io(t, e, i, f, u, o, s, c, p, l - 1), io(t, u, f, n, r, p, c, a, h, l - 1)) : (f = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2], c = t.a(f), u = [(n[0] + r[0]) / 2, (n[1] + r[1]) / 2], p = t.a(u), io(t, e, f, u, r, o, c, p, h, l - 1), io(t, f, i, n, u, c, s, a, p, l - 1)));
            if (f) {
                if (!t.o) return;
                t.j = !0
            }
            t.f.push({ source: [o, a, h], target: [e, n, r] }), t.f.push({ source: [o, s, a], target: [e, i, n] })
        }
    }

    function no(t) { var e = T(); return t.f.forEach(function(t) { t = t.source, D(e, t[0]), D(e, t[1]), D(e, t[2]) }), e }

    function ro(t, e, i, n, r, o, s, a, h, l, u) {
        if (Yn.call(this, r, 0), this.O = void 0 !== u && u, this.D = s, this.C = a, this.l = null, this.c = {}, this.o = e, this.A = n, this.T = o ? o : r, this.g = [], this.Td = null, this.s = 0, o = n.Na(this.T), a = this.A.H(), r = this.o.H(), o = a ? W(o, a) : o, 0 === B(o)) this.state = 4;
        else if ((a = t.H()) && (r = r ? W(r, a) : a), n = n.aa(this.T[0]), n = Jr(t, i, G(o), n), !isFinite(n) || 0 >= n) this.state = 4;
        else if (this.v = new eo(t, i, o, r, n * (void 0 !== l ? l : .5)), 0 === this.v.f.length) this.state = 4;
        else if (this.s = e.Kc(n), i = no(this.v), r && (t.a ? (i[1] = Ct(i[1], r[1], r[3]), i[3] = Ct(i[3], r[1], r[3])) : i = W(i, r)), B(i)) {
            for (t = xn(e, i, this.s), e = t.da; e <= t.ha; e++)
                for (i = t.ia; i <= t.ka; i++)(l = h(this.s, e, i, s)) && this.g.push(l);
            0 === this.g.length && (this.state = 4)
        } else this.state = 4
    }

    function oo(t, e) {
        var i = /\{z\}/g,
            n = /\{x\}/g,
            r = /\{y\}/g,
            o = /\{-y\}/g;
        return function(s) { if (s) return t.replace(i, s[0].toString()).replace(n, s[1].toString()).replace(r, function() { return (-s[2] - 1).toString() }).replace(o, function() { var t = e.a ? e.a[s[0]] : null; return x(t, 55), (t.ka - t.ia + 1 + s[2]).toString() }) }
    }

    function so(t, e) { for (var i = t.length, n = Array(i), r = 0; r < i; ++r) n[r] = oo(t[r], e); return ao(n) }

    function ao(t) { return 1 === t.length ? t[0] : function(e, i, n) { if (e) return t[At((e[1] << e[0]) + e[2], t.length)](e, i, n) } }

    function ho() {}

    function lo(t) {
        var e = [],
            i = /\{(\d)-(\d)\}/.exec(t) || /\{([a-z])-([a-z])\}/.exec(t);
        if (i) { var n, r = i[2].charCodeAt(0); for (n = i[1].charCodeAt(0); n <= r; ++n) e.push(t.replace(i[0], String.fromCharCode(n))) } else e.push(t);
        return e
    }

    function uo(t) { wr.call(this, { attributions: t.attributions, extent: t.extent, logo: t.logo, projection: t.projection, state: t.state, wrapX: t.wrapX }), this.fa = void 0 !== t.opaque && t.opaque, this.qa = void 0 !== t.tilePixelRatio ? t.tilePixelRatio : 1, this.tileGrid = void 0 !== t.tileGrid ? t.tileGrid : null, this.a = new $r(t.cacheSize), this.j = [0, 0], this.Rc = "" }

    function po(t, e, i, n, r) {
        if (e = t.te(e), !e) return !1;
        for (var o, s, a = !0, h = n.da; h <= n.ha; ++h)
            for (var l = n.ia; l <= n.ka; ++l) o = t.fc(i, h, l), s = !1, e.b.hasOwnProperty(o) && (o = e.get(o), (s = 2 === o.W()) && (s = !1 !== r(o))), s || (a = !1);
        return a
    }

    function co(t, e) { t.Rc !== e && (t.Rc = e, t.u()) }

    function fo(t, e, i) {
        var n = void 0 !== i ? i : t.f;
        if (i = t.yb(n), t.D && n.g) {
            var r = e;
            e = r[0], t = En(i, r), n = In(n), C(n, t) ? e = r : (r = Y(n), t[0] += r * Math.ceil((n[0] - t[0]) / r), e = i.ue(t, e))
        }
        if (r = e[0], n = e[1], t = e[2], i.minZoom > r || r > i.maxZoom) i = !1;
        else {
            var o = i.H();
            i = !(i = o ? xn(i, o, r) : i.a ? i.a[r] : null) || ln(i, n, t)
        }
        return i ? e : null
    }

    function go(t, e) { dt.call(this, t), this.tile = e }

    function yo(t) { uo.call(this, { attributions: t.attributions, cacheSize: t.cacheSize, extent: t.extent, logo: t.logo, opaque: t.opaque, projection: t.projection, state: t.state, tileGrid: t.tileGrid, tilePixelRatio: t.tilePixelRatio, wrapX: t.wrapX }), this.tileLoadFunction = t.tileLoadFunction, this.tileUrlFunction = this.hd ? this.hd.bind(this) : ho, this.urls = null, t.urls ? this.lb(t.urls) : t.url && this.rb(t.url), t.tileUrlFunction && this.kb(t.tileUrlFunction) }

    function mo(t) { yo.call(this, { attributions: t.attributions, cacheSize: t.cacheSize, extent: t.extent, logo: t.logo, opaque: t.opaque, projection: t.projection, state: t.state, tileGrid: t.tileGrid, tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : wo, tilePixelRatio: t.tilePixelRatio, tileUrlFunction: t.tileUrlFunction, url: t.url, urls: t.urls, wrapX: t.wrapX }), this.crossOrigin = void 0 !== t.crossOrigin ? t.crossOrigin : null, this.tileClass = void 0 !== t.tileClass ? t.tileClass : Hr, this.i = {}, this.s = {}, this.ra = t.reprojectionErrorThreshold, this.C = !1 }

    function vo(t, e, i, n, r, o, s) { return e = [e, i, n], r = (i = fo(t, e, o)) ? t.tileUrlFunction(i, r, o) : void 0, r = new t.tileClass(e, void 0 !== r ? 0 : 4, void 0 !== r ? r : "", t.crossOrigin, t.tileLoadFunction), r.key = s, lt(r, "change", t.ak, t), r }

    function bo(t, e, i, n, r, o) {
        var s, a = t.fc(e, i, n),
            h = t.Rc;
        if (t.a.b.hasOwnProperty(a)) {
            if (s = t.a.get(a), s.key != h) {
                var l = s;
                s.a && s.a.key == h ? (s = s.a, 2 == l.W() && (s.a = l)) : (s = vo(t, e, i, n, r, o, h), 2 == l.W() ? s.a = l : l.a && 2 == l.a.W() && (s.a = l.a, l.a = null)), s.a && (s.a.a = null), t.a.replace(a, s)
            }
        } else s = vo(t, e, i, n, r, o, h), t.a.set(a, s);
        return s
    }

    function wo(t, e) { t.ub().src = e }

    function xo(t, e) {
        var i = void 0 !== e ? t.toFixed(e) : "" + t,
            n = i.indexOf("."),
            n = -1 === n ? i.length : n;
        return 2 < n ? i : Array(3 - n).join("0") + i
    }

    function Eo(t) {
        t = ("" + t).split(".");
        for (var e = ["1", "3"], i = 0; i < Math.max(t.length, e.length); i++) {
            var n = parseInt(t[i] || "0", 10),
                r = parseInt(e[i] || "0", 10);
            if (n > r) return 1;
            if (r > n) return -1
        }
        return 0
    }

    function So(t, e) {
        var i = [];
        Object.keys(e).forEach(function(t) { null !== e[t] && void 0 !== e[t] && i.push(t + "=" + encodeURIComponent(e[t])) });
        var n = i.join("&");
        return t = t.replace(/[?&]$/, ""), t = -1 === t.indexOf("?") ? t + "?" : t + "&", t + n
    }

    function No(t) {
        t = t || {};
        var e = t.params || {};
        mo.call(this, { attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, logo: t.logo, opaque: !("TRANSPARENT" in e ? e.TRANSPARENT : 1), projection: t.projection, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileGrid: t.tileGrid, tileLoadFunction: t.tileLoadFunction, url: t.url, urls: t.urls, wrapX: void 0 === t.wrapX || t.wrapX }), this.A = void 0 !== t.gutter ? t.gutter : 0, this.c = e, this.o = !0, this.v = t.serverType, this.U = void 0 === t.hidpi || t.hidpi, this.P = "", Co(this), this.X = T(), Io(this), co(this, Mo(this))
    }

    function Lo(t, e, i, n, r, o, s) {
        var a = t.urls;
        if (a) {
            if (s.WIDTH = i[0], s.HEIGHT = i[1], s[t.o ? "CRS" : "SRS"] = o.Ya(), "STYLES" in t.c || (s.STYLES = ""), 1 != r) switch (t.v) {
                case "geoserver":
                    i = 90 * r + .5 | 0, s.FORMAT_OPTIONS = "FORMAT_OPTIONS" in s ? s.FORMAT_OPTIONS + (";dpi:" + i) : "dpi:" + i;
                    break;
                case "mapserver":
                    s.MAP_RESOLUTION = 90 * r;
                    break;
                case "carmentaserver":
                case "qgis":
                    s.DPI = 90 * r;
                    break;
                default:
                    x(!1, 52)
            }
            return o = o.b, t.o && "ne" == o.substr(0, 2) && (t = n[0], n[0] = n[1], n[1] = t, t = n[2], n[2] = n[3], n[3] = t), s.BBOX = n.join(","), So(1 == a.length ? a[0] : a[At((e[1] << e[0]) + e[2], a.length)], s)
        }
    }

    function Co(t) {
        var e = 0,
            i = [];
        if (t.urls) { var n, r; for (n = 0, r = t.urls.length; n < r; ++n) i[e++] = t.urls[n] }
        t.P = i.join("#")
    }

    function Mo(t) {
        var e, i = 0,
            n = [];
        for (e in t.c) n[i++] = e + "-" + t.c[e];
        return n.join("/")
    }

    function Io(t) { t.o = 0 <= Eo(t.c.VERSION || "1.3.0") }

    function ko(t, e, i, n, r) { vt.call(this), this.l = r, this.extent = t, this.f = i, this.resolution = e, this.state = n }

    function To(t) { t.b("change") }

    function Ao(t, e, i, n, r, o, s) { ko.call(this, t, e, i, 0, n), this.o = r, this.g = new Image, null !== o && (this.g.crossOrigin = o), this.i = {}, this.c = null, this.state = 0, this.j = s }

    function Ro(t, e, i, n, r, o) {
        this.A = e, this.s = t.H();
        var s = e.H(),
            a = s ? W(i, s) : i,
            s = Jr(t, e, G(a), n);
        this.j = new eo(t, e, a, this.s, .5 * s), this.c = n, this.g = i, t = no(this.j), this.o = (this.Lb = o(t, s, r)) ? this.Lb.f : 1, this.Ke = this.i = null, r = 2, o = [], this.Lb && (r = 0, o = this.Lb.l), ko.call(this, i, n, this.o, r, o)
    }

    function _o(t) { wr.call(this, { attributions: t.attributions, extent: t.extent, logo: t.logo, projection: t.projection, state: t.state }), this.C = void 0 !== t.resolutions ? t.resolutions : null, this.a = null, this.ra = 0 }

    function Po(t, e) { return t.C && (e = t.C[le(t.C, e, 0)]), e }

    function Oo(t, e) { t.a().src = e }

    function Do(t, e) { dt.call(this, t), this.image = e }

    function Fo(t) { t = t || {}, _o.call(this, { attributions: t.attributions, logo: t.logo, projection: t.projection, resolutions: t.resolutions }), this.qa = void 0 !== t.crossOrigin ? t.crossOrigin : null, this.j = t.url, this.P = void 0 !== t.imageLoadFunction ? t.imageLoadFunction : Oo, this.i = t.params || {}, this.A = !0, Bo(this), this.fa = t.serverType, this.xa = void 0 === t.hidpi || t.hidpi, this.c = null, this.U = [0, 0], this.X = 0, this.s = void 0 !== t.ratio ? t.ratio : 1.5 }

    function Uo(t, e, i, n, r, o) {
        if (x(void 0 !== t.j, 9), o[t.A ? "CRS" : "SRS"] = r.Ya(), "STYLES" in t.i || (o.STYLES = ""), 1 != n) switch (t.fa) {
            case "geoserver":
                n = 90 * n + .5 | 0, o.FORMAT_OPTIONS = "FORMAT_OPTIONS" in o ? o.FORMAT_OPTIONS + (";dpi:" + n) : "dpi:" + n;
                break;
            case "mapserver":
                o.MAP_RESOLUTION = 90 * n;
                break;
            case "carmentaserver":
            case "qgis":
                o.DPI = 90 * n;
                break;
            default:
                x(!1, 8)
        }
        o.WIDTH = i[0], o.HEIGHT = i[1], i = r.b;
        var s;
        return s = t.A && "ne" == i.substr(0, 2) ? [e[1], e[0], e[3], e[2]] : e, o.BBOX = s.join(","), So(t.j, o)
    }

    function Bo(t) { t.A = 0 <= Eo(t.i.VERSION || "1.3.0") }

    function jo(t) { this.j = t.matrixIds, mn.call(this, { extent: t.extent, origin: t.origin, origins: t.origins, resolutions: t.resolutions, tileSize: t.tileSize, tileSizes: t.tileSizes, sizes: t.sizes }) }

    function zo(t, e) {
        var i, n = [],
            r = [],
            o = [],
            s = [],
            a = [];
        i = qt(t.SupportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"));
        var h = i.Gc(),
            l = "ne" == i.b.substr(0, 2);
        return t.TileMatrix.sort(function(t, e) { return e.ScaleDenominator - t.ScaleDenominator }), t.TileMatrix.forEach(function(t) {
            r.push(t.Identifier);
            var e = 28e-5 * t.ScaleDenominator / h,
                i = t.TileWidth,
                u = t.TileHeight;
            l ? o.push([t.TopLeftCorner[1], t.TopLeftCorner[0]]) : o.push(t.TopLeftCorner), n.push(e), s.push(i == u ? i : [i, u]), a.push([t.MatrixWidth, -t.MatrixHeight])
        }), new jo({ extent: e, origins: o, resolutions: n, matrixIds: r, tileSizes: s, sizes: a })
    }

    function Go(t) {
        function e(t) {
            return t = "KVP" == n ? So(t, o) : t.replace(/\{(\w+?)\}/g, function(t, e) { return e.toLowerCase() in o ? o[e.toLowerCase()] : t }),
                function(e) { if (e) { var i = { TileMatrix: r.j[e[0]], TileCol: e[1], TileRow: -e[2] - 1 }; return db(i, s), e = t, e = "KVP" == n ? So(e, i) : e.replace(/\{(\w+?)\}/g, function(t, e) { return i[e] }) } }
        }
        this.U = void 0 !== t.version ? t.version : "1.0.0", this.A = void 0 !== t.format ? t.format : "image/jpeg", this.c = void 0 !== t.dimensions ? t.dimensions : {}, this.v = t.layer, this.o = t.matrixSet, this.P = t.style;
        var i = t.urls;
        void 0 === i && void 0 !== t.url && (i = lo(t.url));
        var n = this.X = void 0 !== t.requestEncoding ? t.requestEncoding : "KVP",
            r = t.tileGrid,
            o = { layer: this.v, style: this.P, tilematrixset: this.o };
        "KVP" == n && db(o, { Service: "WMTS", Request: "GetTile", Version: this.U, Format: this.A });
        var s = this.c,
            a = i && 0 < i.length ? ao(i.map(e)) : ho;
        mo.call(this, { attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, logo: t.logo, projection: t.projection, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileClass: t.tileClass, tileGrid: r, tileLoadFunction: t.tileLoadFunction, tilePixelRatio: t.tilePixelRatio, tileUrlFunction: a, urls: i, wrapX: void 0 !== t.wrapX && t.wrapX }), co(this, qo(this))
    }

    function qo(t) {
        var e, i = 0,
            n = [];
        for (e in t.c) n[i++] = e + "-" + t.c[e];
        return n.join("/")
    }

    function Vo(t, e) {
        if (t in $w) {
            var i = $w[t];
            e && Si(i, e), i.type = i.type || "wmts";
            var n;
            if ("aggregate" == i.type) {
                for (var r = [], o = 0; o < i.subLayersIds.length; o++) r[o] = Vo(i.subLayersIds[o]);
                n = new Br({ minResolution: i.minResolution, maxResolution: i.maxResolution, opacity: i.opacity, layers: r })
            } else if ("wms" == i.type) n = i.singleTile ? new Vr({ minResolution: i.minResolution, maxResolution: i.maxResolution, opacity: i.opacity, source: Yo(t, i) }) : new qr({ minResolution: i.minResolution, maxResolution: i.maxResolution, opacity: i.opacity, source: Ho(t, i), useInterimTilesOnError: !1 });
            else if ("wmts" == i.type) n = new qr({ minResolution: i.minResolution, maxResolution: i.maxResolution, opacity: i.opacity, source: Xo(t, i), useInterimTilesOnError: !1 });
            else if ("geojson" == i.type) {
                var s = new Gn,
                    a = new kr;
                n = new Wr({ source: a }),
                    function() {
                        var t = new XMLHttpRequest;
                        t.open("GET", i.styleUrl, !0), t.responseType = "text", t.onload = function() {
                            if (200 <= t.status && 300 > t.status) {
                                var e = JSON.parse(t.responseText),
                                    i = new rn(e);
                                n.l(function(t) { return [i.a(t)] })
                            }
                        }, t.send()
                    }(),
                    function() {
                        var t = new XMLHttpRequest;
                        t.open("GET", i.geojsonUrl, !0), t.responseType = "text", t.onload = function() {
                            if (200 <= t.status && 300 > t.status) {
                                var e = t.responseText;
                                a.clear(), a.Bc(s.Ia(e))
                            }
                        }, t.send()
                    }()
            }
        }
        return Object.defineProperties(Object(n), {
            id: { get: function() { return t } },
            label: { get: function() { return i.label } },
            tooltip: { get: function() { return i.tooltip } },
            Xs: { get: function() { return i.styleUrl } },
            time: {
                get: function() { if (n instanceof zr) { var t = n.ja(); if (t instanceof Go) return t.c.Ls; if (t instanceof Fo || t instanceof No) return t.Lf().Ks } },
                set: function(t) {
                    if (n instanceof zr) {
                        var e = n.ja();
                        e instanceof Go ? e.fl({ Time: t }) : (e instanceof Fo || e instanceof No) && e.Mf({ TIME: t }), n.set("time", t)
                    }
                }
            },
            nj: {
                get: function() {
                    return t;
                }
            },
            ro: { get: function() { return i.tooltip } }
        }), n
    }

    function Wo(t) { if (t in Zw) return Zw[t]; var e = new kn({ html: t }); return Zw[t] = e }

    function Xo(t, e) {
        var i, n = e.resolutions ? e.resolutions : Jw;
        i = [];
        var r = n.length;
        if (0 > 1 * (r - 0)) i = [];
        else
            for (var o = 0; o < r; o += 1) i.push(o);
        return n = new jo({ origin: [42e4, 35e4], resolutions: n, matrixIds: i }), i = e.format || "png", r = e.timestamp ? e.timestamp : e.timestamps[0], new Go({ crossOrigin: "anonymous", attributions: [Wo('<a href="' + e.attributionUrl + '" target="new">' + e.attribution + "</a>")], url: "http://wmts{5-9}.geo.admin.ch/1.0.0/{Layer}/default/{Time}/21781/{TileMatrix}/{TileRow}/{TileCol}.".replace("http:", location.protocol) + i, tileGrid: n, layer: e.serverLayerName ? e.serverLayerName : t, requestEncoding: "REST", dimensions: { Time: r } })
    }

    function Ho(t, e) { return new No({ crossOrigin: "anonymous", wrapX: !1, gutter: e.gutter || 0, attributions: [Wo('<a href="' + e.attributionUrl + '" target="new">' + e.attribution + "</a>")], params: { LAYERS: e.wmsLayers || t, TIME: e.timestamp }, url: e.wmsUrl.split("?")[0].replace("http:", location.protocol) }) }

    function Yo(t, e) { return new Fo({ crossOrigin: "anonymous", attributions: [Wo('<a href="' + e.attributionUrl + '" target="new">' + e.attribution + "</a>")], params: { LAYERS: e.wmsLayers || t, TIME: e.timestamp }, ratio: 1, url: e.wmsUrl.split("?")[0].replace("http:", location.protocol) }) }

    function Ko() { this.b = ix }

    function $o(t) { return t instanceof Ko && t.constructor === Ko && t.b === ix ? "" : "type_error:Const" }

    function Zo() { this.b = "", this.a = nx }

    function Jo(t) { var e = new Zo; return e.b = t, e }

    function Qo() { this.b = "", this.a = ax }

    function ts(t) { var e = new Qo; return e.b = t, e }

    function es() { this.b = hx }

    function is() { this.b = "", this.g = cx, this.a = null }

    function ns(t) { return t instanceof is && t.constructor === is && t.g === cx ? t.b : (n(t), "type_error:SafeHtml") }

    function rs(t) {
        function e(t) {
            if (r(t)) Bb(t, e);
            else {
                var o;
                t instanceof is ? o = t : (o = null, t.mh && (o = t.oe()), t = ci(t.md ? t.Jc() : String(t)), o = os(t, o)), n += ns(o), o = o.oe(), 0 == i ? i = o : 0 != o && i != o && (i = null)
            }
        }
        var i = 0,
            n = "";
        return Bb(arguments, e), os(n, i)
    }

    function os(t, e) { var i = new is; return i.b = t, i.a = e, i }

    function ss(e, i) { this.x = t(e) ? e : 0, this.y = t(i) ? i : 0 }

    function as(t, e) { this.width = t, this.height = e }

    function hs(t) { return t ? new Ms(Es(t)) : Sb || (Sb = new Ms) }

    function ls(t, e) { xi(e, function(e, i) { "style" == i ? t.style.cssText = e : "class" == i ? t.className = e : "for" == i ? t.htmlFor = e : gx.hasOwnProperty(i) ? t.setAttribute(gx[i], e) : 0 == i.lastIndexOf("aria-", 0) || 0 == i.lastIndexOf("data-", 0) ? t.setAttribute(i, e) : t[i] = e }) }

    function us(t) { return t = t.document, t = "CSS1Compat" == t.compatMode ? t.documentElement : t.body, new as(t.clientWidth, t.clientHeight) }

    function ps(t) { var e = cs(t); return t = gs(t), Hb && Li("10") && t.pageYOffset != e.scrollTop ? new ss(e.scrollLeft, e.scrollTop) : new ss(t.pageXOffset || e.scrollLeft, t.pageYOffset || e.scrollTop) }

    function cs(t) { return t.scrollingElement ? t.scrollingElement : $b || "CSS1Compat" != t.compatMode ? t.body || t.documentElement : t.documentElement }

    function fs(t) { return t ? gs(t) : window }

    function gs(t) { return t.parentWindow || t.defaultView }

    function ds(t, e, i) { return ys(document, arguments) }

    function ys(t, e) {
        var i = String(e[0]),
            n = e[1];
        if (!Qw && n && (n.name || n.type)) {
            if (i = ["<", i], n.name && i.push(' name="', ci(n.name), '"'), n.type) {
                i.push(' type="', ci(n.type), '"');
                var o = {};
                Si(o, n), delete o.type, n = o
            }
            i.push(">"), i = i.join("")
        }
        return i = t.createElement(i), n && (s(n) ? i.className = n : r(n) ? i.className = n.join(" ") : ls(i, n)), 2 < e.length && ms(t, i, e, 2), i
    }

    function ms(t, e, i, n) {
        function r(i) { i && e.appendChild(s(i) ? t.createTextNode(i) : i) }
        for (; n < i.length; n++) { var a = i[n];!o(a) || l(a) && 0 < a.nodeType ? r(a) : Bb(Cs(a) ? mi(a) : a, r) }
    }

    function vs(t, e) { ms(Es(t), t, arguments, 1) }

    function bs(t, e) { e.parentNode && e.parentNode.insertBefore(t, e) }

    function ws(t) { return t && t.parentNode ? t.parentNode.removeChild(t) : null }

    function xs(t, e) { if (!t || !e) return !1; if (t.contains && 1 == e.nodeType) return t == e || t.contains(e); if ("undefined" != typeof t.compareDocumentPosition) return t == e || !!(16 & t.compareDocumentPosition(e)); for (; e && t != e;) e = e.parentNode; return e == t }

    function Es(t) { return 9 == t.nodeType ? t : t.ownerDocument || t.document }

    function Ss(t, e) { e ? t.tabIndex = 0 : (t.tabIndex = -1, t.removeAttribute("tabIndex")) }

    function Ns(t) { return t = t.getAttributeNode("tabindex"), null != t && t.specified }

    function Ls(t) { return t = t.tabIndex, a(t) && 0 <= t && 32768 > t }

    function Cs(t) { if (t && "number" == typeof t.length) { if (l(t)) return "function" == typeof t.item || "string" == typeof t.item; if (h(t)) return "function" == typeof t.item } return !1 }

    function Ms(t) { this.b = t || ab.document || document }

    function Is(t) { return tx && t.children ? t.children : jb(t.childNodes, function(t) { return 1 == t.nodeType }) }

    function ks(t, e) { e ? t.setAttribute("role", e) : t.removeAttribute("role") }

    function Ts(t, e, i) { r(i) && (i = i.join(" ")); var n = "aria-" + e; "" === i || void 0 == i ? (Kw || (Kw = { atomic: !1, autocomplete: "none", dropeffect: "none", haspopup: !1, live: "off", multiline: !1, multiselectable: !1, orientation: "vertical", readonly: !1, relevant: "additions text", required: !1, sort: "none", busy: !1, disabled: !1, hidden: !1, invalid: "false" }), i = Kw, e in i ? t.setAttribute(n, i[e]) : t.removeAttribute(n)) : t.setAttribute(n, i) }

    function As(t) { return t.classList ? t.classList : (t = t.className, s(t) && t.match(/\S+/g) || []) }

    function Rs(t, e) { return t.classList ? t.classList.contains(e) : gi(As(t), e) }

    function _s(t, e) { t.classList ? t.classList.add(e) : Rs(t, e) || (t.className += 0 < t.className.length ? " " + e : e) }

    function Ps(t, e) {
        if (t.classList) Bb(e, function(e) { _s(t, e) });
        else {
            var i = {};
            Bb(As(t), function(t) { i[t] = !0 }), Bb(e, function(t) { i[t] = !0 }), t.className = "";
            for (var n in i) t.className += 0 < t.className.length ? " " + n : n
        }
    }

    function Os(t, e) { t.classList ? t.classList.remove(e) : Rs(t, e) && (t.className = jb(As(t), function(t) { return t != e }).join(" ")) }

    function Ds(t, e) { t.classList ? Bb(e, function(e) { Os(t, e) }) : t.className = jb(As(t), function(t) { return !gi(e, t) }).join(" ") }

    function Fs() { 0 != vx && (bx[u(this)] = this), this.o = this.o, this.A = this.A }

    function Us(e, i) { e.o ? i.call(void 0) : (e.A || (e.A = []), e.A.push(t(void 0) ? f(i, void 0) : i)) }

    function Bs(t) { t && "function" == typeof t.Pa && t.Pa() }

    function js(t, e) { this.type = t, this.g = this.target = e, this.f = !1, this.Jk = !0 }

    function zs(t) { return zs[" "](t), t }

    function Gs(t, e) {
        if (js.call(this, t ? t.type : ""), this.relatedTarget = this.g = this.target = null, this.b = this.button = this.screenY = this.screenX = this.clientY = this.clientX = this.offsetY = this.offsetX = 0, this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.c = !1, this.a = null, t) {
            var i = this.type = t.type,
                n = t.changedTouches ? t.changedTouches[0] : null;
            this.target = t.target || t.srcElement, this.g = e;
            var r = t.relatedTarget;
            if (r) {
                if (Kb) {
                    var o;
                    t: {
                        try { zs(r.nodeName), o = !0; break t } catch (t) {}
                        o = !1
                    }
                    o || (r = null)
                }
            } else "mouseover" == i ? r = t.fromElement : "mouseout" == i && (r = t.toElement);
            this.relatedTarget = r, null === n ? (this.offsetX = $b || void 0 !== t.offsetX ? t.offsetX : t.layerX, this.offsetY = $b || void 0 !== t.offsetY ? t.offsetY : t.layerY, this.clientX = void 0 !== t.clientX ? t.clientX : t.pageX, this.clientY = void 0 !== t.clientY ? t.clientY : t.pageY, this.screenX = t.screenX || 0, this.screenY = t.screenY || 0) : (this.clientX = void 0 !== n.clientX ? n.clientX : n.pageX, this.clientY = void 0 !== n.clientY ? n.clientY : n.pageY, this.screenX = n.screenX || 0, this.screenY = n.screenY || 0), this.button = t.button, this.b = t.keyCode || 0, this.ctrlKey = t.ctrlKey, this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.metaKey = t.metaKey, this.c = Zb ? t.metaKey : t.ctrlKey, this.state = t.state, this.a = t, t.defaultPrevented && this.preventDefault()
        }
    }

    function qs(t) { return !((dx ? 0 != t.a.button : "click" != t.type && !(t.a.button & wx[0])) || $b && Zb && t.ctrlKey) }

    function Vs(t) { return !(!t || !t[xx]) }

    function Ws(t, e, i, n, r) { this.listener = t, this.b = null, this.src = e, this.type = i, this.$e = !!n, this.zf = r, this.key = ++Ex, this.Rd = this.dd = !1 }

    function Xs(t) { t.Rd = !0, t.listener = null, t.b = null, t.src = null, t.zf = null }

    function Hs(t) { this.src = t, this.b = {}, this.a = 0 }

    function Ys(t, e) {
        var i = e.type;
        i in t.b && di(t.b[i], e) && (Xs(e), 0 == t.b[i].length && (delete t.b[i], t.a--))
    }

    function Ks(t, e, i, n, r) { return t = t.b[e.toString()], e = -1, t && (e = $s(t, i, n, r)), -1 < e ? t[e] : null }

    function $s(t, e, i, n) { for (var r = 0; r < t.length; ++r) { var o = t[r]; if (!o.Rd && o.listener == e && o.$e == !!i && o.zf == n) return r } return -1 }

    function Zs(t, e, i, n, o) { if (r(e)) { for (var s = 0; s < e.length; s++) Zs(t, e[s], i, n, o); return null } return i = ha(i), Vs(t) ? t.na(e, i, n, o) : Js(t, e, i, !1, n, o) }

    function Js(t, e, i, n, r, o) {
        if (!e) throw Error("Invalid event type");
        var s = !!r,
            a = aa(t);
        if (a || (t[Sx] = a = new Hs(t)), i = a.add(e, i, n, r, o), i.b) return i;
        if (n = Qs(), i.b = n, n.src = t, n.listener = i, t.addEventListener) t.addEventListener(e.toString(), n, s);
        else {
            if (!t.attachEvent) throw Error("addEventListener and attachEvent are unavailable.");
            t.attachEvent(na(e.toString()), n)
        }
        return Lx++, i
    }

    function Qs() {
        var t = sa,
            e = yx ? function(i) { return t.call(e.src, e.listener, i) } : function(i) { if (i = t.call(e.src, e.listener, i), !i) return i };
        return e
    }

    function ta(t, e, i, n, o) {
        if (r(e))
            for (var s = 0; s < e.length; s++) ta(t, e[s], i, n, o);
        else i = ha(i), Vs(t) ? t.l.add(String(e), i, !0, n, o) : Js(t, e, i, !0, n, o)
    }

    function ea(t, e, i, n, o) {
        if (r(e))
            for (var s = 0; s < e.length; s++) ea(t, e[s], i, n, o);
        else i = ha(i), Vs(t) ? t.Gb(e, i, n, o) : t && (t = aa(t)) && (e = Ks(t, e, i, !!n, o)) && ia(e)
    }

    function ia(t) {
        if (!a(t) && t && !t.Rd) {
            var e = t.src;
            if (Vs(e)) Ys(e.l, t);
            else {
                var i = t.type,
                    n = t.b;
                e.removeEventListener ? e.removeEventListener(i, n, t.$e) : e.detachEvent && e.detachEvent(na(i), n), Lx--, (i = aa(e)) ? (Ys(i, t), 0 == i.a && (i.src = null, e[Sx] = null)) : Xs(t)
            }
        }
    }

    function na(t) { return t in Nx ? Nx[t] : Nx[t] = "on" + t }

    function ra(t, e, i, n) {
        var r = !0;
        if ((t = aa(t)) && (e = t.b[e.toString()]))
            for (e = e.concat(), t = 0; t < e.length; t++) {
                var o = e[t];
                o && o.$e == i && !o.Rd && (o = oa(o, n), r = r && !1 !== o)
            }
        return r
    }

    function oa(t, e) {
        var i = t.listener,
            n = t.zf || t.src;
        return t.dd && ia(t), i.call(n, e)
    }

    function sa(t, e) {
        if (t.Rd) return !0;
        if (!yx) {
            var i;
            if (!(i = e)) t: {
                i = ["window", "event"];
                for (var n, r = ab; n = i.shift();) {
                    if (null == r[n]) { i = null; break t }
                    r = r[n]
                }
                i = r
            }
            if (n = i, i = new Gs(n, this), r = !0, !(0 > n.keyCode || void 0 != n.returnValue)) {
                t: { var o = !1; if (0 == n.keyCode) try { n.keyCode = -1; break t } catch (t) { o = !0 }(o || void 0 == n.returnValue) && (n.returnValue = !0) }
                for (n = [], o = i.g; o; o = o.parentNode) n.push(o);
                for (var o = t.type, s = n.length - 1; !i.f && 0 <= s; s--) {
                    i.g = n[s];
                    var a = ra(n[s], o, !0, i),
                        r = r && a
                }
                for (s = 0; !i.f && s < n.length; s++) i.g = n[s],
                a = ra(n[s], o, !1, i),
                r = r && a
            }
            return r
        }
        return oa(t, new Gs(e, this))
    }

    function aa(t) { return t = t[Sx], t instanceof Hs ? t : null }

    function ha(t) { return h(t) ? t : (t[Cx] || (t[Cx] = function(e) { return t.handleEvent(e) }), t[Cx]) }

    function la(t, e, i, n, r) {
        if (!(Hb || Yb || $b && Li("525"))) return !0;
        if (Zb && r) return ua(t);
        if (r && !n) return !1;
        if (a(e) && (e = pa(e)), !i && (17 == e || 18 == e || Zb && 91 == e)) return !1;
        if (($b || Yb) && n && i) switch (t) {
            case 220:
            case 219:
            case 221:
            case 192:
            case 186:
            case 189:
            case 187:
            case 188:
            case 190:
            case 191:
            case 192:
            case 222:
                return !1
        }
        if (Hb && n && e == t) return !1;
        switch (t) {
            case 13:
                return !0;
            case 27:
                return !($b || Yb)
        }
        return ua(t)
    }

    function ua(t) {
        if (48 <= t && 57 >= t || 96 <= t && 106 >= t || 65 <= t && 90 >= t || ($b || Yb) && 0 == t) return !0;
        switch (t) {
            case 32:
            case 43:
            case 63:
            case 64:
            case 107:
            case 109:
            case 110:
            case 111:
            case 186:
            case 59:
            case 189:
            case 187:
            case 61:
            case 188:
            case 190:
            case 191:
            case 192:
            case 222:
            case 219:
            case 220:
            case 221:
                return !0;
            default:
                return !1
        }
    }

    function pa(t) {
        if (Kb) t = ca(t);
        else if (Zb && $b) t: switch (t) {
            case 93:
                t = 91
        }
        return t
    }

    function ca(t) {
        switch (t) {
            case 61:
                return 187;
            case 59:
                return 186;
            case 173:
                return 189;
            case 224:
                return 91;
            case 0:
                return 224;
            default:
                return t
        }
    }

    function fa(t) { Fs.call(this), this.a = t, this.b = {} }

    function ga(t) { xi(t.b, function(t, e) { this.b.hasOwnProperty(e) && ia(t) }, t), t.b = {} }

    function da() { Fs.call(this), this.l = new Hs(this), this.X = this, this.P = null }

    function ya(t, e) {
        var i, n = t.kf();
        if (n)
            for (i = []; n; n = n.kf()) i.push(n);
        var n = t.X,
            r = e,
            o = r.type || r;
        if (s(r)) r = new js(r, n);
        else if (r instanceof js) r.target = r.target || n;
        else {
            var a = r,
                r = new js(o, n);
            Si(r, a)
        }
        var h, a = !0;
        if (i)
            for (var l = i.length - 1; !r.f && 0 <= l; l--) h = r.g = i[l], a = ma(h, o, !0, r) && a;
        if (r.f || (h = r.g = n, a = ma(h, o, !0, r) && a, r.f || (a = ma(h, o, !1, r) && a)), i)
            for (l = 0; !r.f && l < i.length; l++) h = r.g = i[l], a = ma(h, o, !1, r) && a;
        return a
    }

    function ma(t, e, i, n) {
        if (e = t.l.b[String(e)], !e) return !0;
        e = e.concat();
        for (var r = !0, o = 0; o < e.length; ++o) {
            var s = e[o];
            if (s && !s.Rd && s.$e == i) {
                var a = s.listener,
                    h = s.zf || s.src;
                s.dd && Ys(t.l, s), r = !1 !== a.call(h, n) && r
            }
        }
        return r && 0 != n.Jk
    }

    function va(t, e, i, n) { this.top = t, this.right = e, this.bottom = i, this.left = n }

    function ba(t, e, i, n) { this.left = t, this.top = e, this.width = i, this.height = n }

    function wa(t, e) { var i = Es(t); return i.defaultView && i.defaultView.getComputedStyle && (i = i.defaultView.getComputedStyle(t, null)) ? i[e] || i.getPropertyValue(e) || "" : "" }

    function xa(t, e) { return wa(t, e) || (t.currentStyle ? t.currentStyle[e] : null) || t.style && t.style[e] }

    function Ea(t, e, i) {
        var n;
        e instanceof ss ? (n = e.x, e = e.y) : (n = e, e = i), t.style.left = Ca(n, !1), t.style.top = Ca(e, !1)
    }

    function Sa(t) { var e; try { e = t.getBoundingClientRect() } catch (t) { return { left: 0, top: 0, right: 0, bottom: 0 } } return Hb && t.ownerDocument.body && (t = t.ownerDocument, e.left -= t.documentElement.clientLeft + t.body.clientLeft, e.top -= t.documentElement.clientTop + t.body.clientTop), e }

    function Na(t) {
        var e, i = Es(t),
            n = new ss(0, 0);
        return e = i ? Es(i) : document, e = !Hb || 9 <= Number(ow) || "CSS1Compat" == hs(e).b.compatMode ? e.documentElement : e.body, t == e ? n : (t = Sa(t), i = ps(hs(i).b), n.x = t.left + i.x, n.y = t.top + i.y, n)
    }

    function La(t, e, i) {
        if (e instanceof as) i = e.height, e = e.width;
        else if (void 0 == i) throw Error("missing height argument");
        t.style.width = Ca(e, !0), t.style.height = Ca(i, !0)
    }

    function Ca(t, e) { return "number" == typeof t && (t = (e ? Math.round(t) : t) + "px"), t }

    function Ma(t) {
        var e = Ia;
        if ("none" != xa(t, "display")) return e(t);
        var i = t.style,
            n = i.display,
            r = i.visibility,
            o = i.position;
        return i.visibility = "hidden", i.position = "absolute", i.display = "inline", t = e(t), i.display = n, i.position = o, i.visibility = r, t
    }

    function Ia(e) {
        var i = e.offsetWidth,
            n = e.offsetHeight,
            r = $b && !i && !n;
        return t(i) && !r || !e.getBoundingClientRect ? new as(i, n) : (e = Sa(e), new as(e.right - e.left, e.bottom - e.top))
    }

    function ka(t, e) { var i = t.style; "opacity" in i ? i.opacity = e : "MozOpacity" in i ? i.MozOpacity = e : "filter" in i && (i.filter = "" === e ? "" : "alpha(opacity=" + 100 * Number(e) + ")") }

    function Ta(t, e) { t.style.display = e ? "" : "none" }

    function Aa(t, e) {
        var i = e ? null : t.getElementsByTagName("*");
        if (Ix) {
            var n = "none";
            if (t.style && (t.style[Ix] = n), i)
                for (var r, o = 0; r = i[o]; o++) r.style && (r.style[Ix] = n)
        } else if ((Hb || Xb) && (n = "on", t.setAttribute("unselectable", n), i))
            for (o = 0; r = i[o]; o++) r.setAttribute("unselectable", n)
    }

    function Ra(t, e) {
        if ("none" == (t.currentStyle ? t.currentStyle[e + "Style"] : null)) return 0;
        var i, n = t.currentStyle ? t.currentStyle[e + "Width"] : null;
        if (n in kx) i = kx[n];
        else if (/^\d+px?$/.test(n)) i = parseInt(n, 10);
        else {
            i = t.style.left;
            var r = t.runtimeStyle.left;
            t.runtimeStyle.left = t.currentStyle.left, t.style.left = n, n = t.style.pixelLeft, t.style.left = i, t.runtimeStyle.left = r, i = n
        }
        return i
    }

    function _a(t, e, i) { da.call(this), this.target = t, this.handle = e || t, this.i = i || new ba(NaN, NaN, NaN, NaN), this.c = Es(t), this.b = new fa(this), Us(this, g(Bs, this.b)), this.f = this.g = this.v = this.T = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.j = !0, this.a = !1, Zs(this.handle, ["touchstart", "mousedown"], this.al, !1, this) }

    function Pa(t, e, i) { var n = ps(hs(t.c).b); return e += n.x - t.s.x, i += n.y - t.s.y, t.s = n, t.g += e, t.f += i, new ss(Da(t, t.g), Fa(t, t.f)) }

    function Oa(t, e, i, n) { t.target.style.left = i + "px", t.target.style.top = n + "px", ya(t, new Ua("drag", t, e.clientX, e.clientY, 0, i, n)) }

    function Da(t, e) {
        var i = t.i,
            n = isNaN(i.left) ? null : i.left,
            i = isNaN(i.width) ? 0 : i.width;
        return Math.min(null != n ? n + i : 1 / 0, Math.max(null != n ? n : -(1 / 0), e))
    }

    function Fa(t, e) {
        var i = t.i,
            n = isNaN(i.top) ? null : i.top,
            i = isNaN(i.height) ? 0 : i.height;
        return Math.min(null != n ? n + i : 1 / 0, Math.max(null != n ? n : -(1 / 0), e))
    }

    function Ua(e, i, n, r, o, s, a) { js.call(this, e), this.clientX = n, this.clientY = r, this.left = t(s) ? s : i.g, this.top = t(a) ? a : i.f }

    function Ba(t, e) {
        this.oc = {}, this.hb = [], this.b = 0;
        var i = arguments.length;
        if (1 < i) { if (i % 2) throw Error("Uneven number of arguments"); for (var n = 0; n < i; n += 2) this.set(arguments[n], arguments[n + 1]) } else if (t) {
            var r;
            if (t instanceof Ba)
                for (n = ja(t), za(t), r = [], i = 0; i < t.hb.length; i++) r.push(t.oc[t.hb[i]]);
            else {
                var i = [],
                    o = 0;
                for (n in t) i[o++] = n;
                n = i, i = [], o = 0;
                for (r in t) i[o++] = t[r];
                r = i
            }
            for (i = 0; i < n.length; i++) this.set(n[i], r[i])
        }
    }

    function ja(t) { return za(t), t.hb.concat() }

    function za(t) {
        if (t.b != t.hb.length) {
            for (var e = 0, i = 0; e < t.hb.length;) {
                var n = t.hb[e];
                Object.prototype.hasOwnProperty.call(t.oc, n) && (t.hb[i++] = n), e++
            }
            t.hb.length = i
        }
        if (t.b != t.hb.length) {
            for (var r = {}, i = e = 0; e < t.hb.length;) n = t.hb[e], Object.prototype.hasOwnProperty.call(r, n) || (t.hb[i++] = n, r[n] = 1), e++;
            t.hb.length = i
        }
    }

    function Ga(t, e) {
        var i = t;
        e && (i = f(t, e)), !h(ab.setImmediate) || ab.Window && ab.Window.prototype && !wi("Edge") && ab.Window.prototype.setImmediate == ab.setImmediate ? (Ax || (Ax = qa()), Ax(i)) : ab.setImmediate(i)
    }

    function qa() {
        var e = ab.MessageChannel;
        if ("undefined" == typeof e && "undefined" != typeof window && window.postMessage && window.addEventListener && !wi("Presto") && (e = function() {
                var t = document.createElement("IFRAME");
                t.style.display = "none", t.src = "", document.documentElement.appendChild(t);
                var e = t.contentWindow,
                    t = e.document;
                t.open(), t.write(""), t.close();
                var i = "callImmediate" + Math.random(),
                    n = "file:" == e.location.protocol ? "*" : e.location.protocol + "//" + e.location.host,
                    t = f(function(t) { "*" != n && t.origin != n || t.data != i || this.port1.onmessage() }, this);
                e.addEventListener("message", t, !1), this.port1 = {}, this.port2 = { postMessage: function() { e.postMessage(i, n) } }
            }), "undefined" != typeof e && !wi("Trident") && !wi("MSIE")) {
            var i = new e,
                n = {},
                r = n;
            return i.port1.onmessage = function() {
                    if (t(n.next)) {
                        n = n.next;
                        var e = n.vi;
                        n.vi = null, e()
                    }
                },
                function(t) { r.next = { vi: t }, r = r.next, i.port2.postMessage(0) }
        }
        return "undefined" != typeof document && "onreadystatechange" in document.createElement("SCRIPT") ? function(t) {
            var e = document.createElement("SCRIPT");
            e.onreadystatechange = function() { e.onreadystatechange = null, e.parentNode.removeChild(e), e = null, t(), t = null }, document.documentElement.appendChild(e)
        } : function(t) { ab.setTimeout(t, 0) }
    }

    function Va(t, e) {
        if (h(t)) e && (t = f(t, e));
        else {
            if (!t || "function" != typeof t.handleEvent) throw Error("Invalid listener argument");
            t = f(t.handleEvent, t)
        }
        2147483647 < Number(0) || ab.setTimeout(t, 0)
    }

    function Wa(t) { da.call(this), this.b = t, t = Hb ? "focusout" : "blur", this.a = Zs(this.b, Hb ? "focusin" : "focus", this, !Hb), this.g = Zs(this.b, t, this, !Hb) }

    function Xa() {}

    function Ha(t) { da.call(this), this.b = t || hs(), this.za = _x, this.T = null, this.Fa = !1, this.a = null, this.j = void 0, this.c = this.g = this.f = this.sh = null }

    function Ya(t, e) {
        switch (t) {
            case 1:
                return e ? "disable" : "enable";
            case 2:
                return e ? "highlight" : "unhighlight";
            case 4:
                return e ? "activate" : "deactivate";
            case 8:
                return e ? "select" : "unselect";
            case 16:
                return e ? "check" : "uncheck";
            case 32:
                return e ? "focus" : "blur";
            case 64:
                return e ? "open" : "close"
        }
        throw Error("Invalid component state")
    }

    function Ka(t) { return t.j || (t.j = new fa(t)), t.j }

    function $a(t, e) {
        if (t == e) throw Error("Unable to set parent component");
        if (e && t.f && t.T && th(t.f, t.T) && t.f != e) throw Error("Unable to set parent component");
        t.f = e, Ha.ga.$h.call(t, e)
    }

    function Za(t, e, i) {
        if (t.Fa) throw Error("Component already rendered");
        t.a || t.Lc(), e ? e.insertBefore(t.a, i || null) : t.b.b.body.appendChild(t.a), t.f && !t.f.Fa || t.xb()
    }

    function Ja(t) { return null == t.za && (t.za = "rtl" == xa(t.Fa ? t.a : t.b.b.body, "direction")), t.za }

    function Qa(t) { return t.g ? t.g.length : 0 }

    function th(t, e) { var i; return t.c && e ? (i = t.c, i = (null !== i && e in i ? i[e] : void 0) || null) : i = null, i }

    function eh(t, e) { return t.g ? t.g[e] || null : null }

    function ih(t, e, i) { t.g && Bb(t.g, e, i) }

    function nh(t, e) { return t.g && e ? Ub(t.g, e) : -1 }

    function rh(t, e) { this.g = t, this.a = e }

    function oh(t, e) { Ha.call(this, e), this.fa = !!t, this.v = null }

    function sh(t, e) {
        t.U || (t.U = new rh(t.a, t.b));
        var i = t.U;
        if (e) {
            i.b || (i.b = []);
            for (var n = Is(i.a.b.body), r = 0; r < n.length; r++) {
                var o, s = n[r];
                (o = s != i.g) && (o = s.getAttribute("aria-hidden"), o = !(null == o || void 0 == o ? 0 : String(o))), o && (Ts(s, "hidden", !0), i.b.push(s))
            }
        } else if (i.b) {
            for (r = 0; r < i.b.length; r++) i.b[r].removeAttribute("aria-hidden");
            i.b = null
        }
    }

    function ah(t, e) { t.eb && Ta(t.eb, e), t.wb && Ta(t.wb, e), Ta(t.V(), e), Ta(t.ac, e) }

    function hh(t, e, i) { oh.call(this, e, i), this.s = t || "modal-dialog", this.i = gh(gh(new fh, Ux, !0), Bx, !1, !0) }

    function lh(t, e) {
        if (t.rh = e, t.Fa) {
            var i = t.b,
                n = t.ff(),
                r = t.eb;
            e ? (r && i.lj(r, t.V()), i.lj(n, t.V())) : (i.Zi(r), i.Zi(n))
        }
        t.ld && sh(t, e)
    }

    function uh(t, e) {
        var i = Tb(t.s + "-title-draggable").split(" ");
        if (t.V() && (e ? Ps(t.Ud, i) : Ds(t.Ud, i)), e && !t.Pc) {
            var n;
            n = new _a(t.V(), t.Ud), t.Pc = n, Ps(t.Ud, i), Zs(t.Pc, "start", t.$r, !1, t)
        } else !e && t.Pc && (t.Pc.Pa(), t.Pc = null)
    }

    function ph(t) {
        var e = t.i,
            i = e && e.Fg;
        i ? (e = e.get(i), ya(t, new ch(i, e)) && t.gc(!1)) : t.gc(!1)
    }

    function ch(t, e) { this.type = Px, this.key = t, this.caption = e }

    function fh(t) { t || hs(), Ba.call(this) }

    function gh(t, e, i, n) { return t.set(e.key, e.caption, i, n) }

    function dh(t, e) { da.call(this), t && yh(this, t, e) }

    function yh(t, e, i) { t.Cf && mh(t), t.Ed = e, t.Bf = Zs(t.Ed, "keypress", t, i), t.nh = Zs(t.Ed, "keydown", t.In, i, t), t.Cf = Zs(t.Ed, "keyup", t.Jn, i, t) }

    function mh(t) { t.Bf && (ia(t.Bf), ia(t.nh), ia(t.Cf), t.Bf = null, t.nh = null, t.Cf = null), t.Ed = null, t.Jb = -1, t.Qc = -1 }

    function vh(t, e, i, n) { Gs.call(this, n), this.type = "key", this.b = t }

    function bh(t, e) { if (!t) throw Error("Invalid class name " + t); if (!h(e)) throw Error("Invalid decorator function " + e) }

    function wh(t) { this.a = t }

    function xh(t, e) { t && (t.tabIndex = e ? 0 : -1) }

    function Eh(t, e) {
        var i = t.Ma(),
            n = [i, e.Od == Qx ? i + "-horizontal" : i + "-vertical"];
        return e.isEnabled() || n.push(i + "-disabled"), n
    }

    function Sh() {}

    function Nh(t, e, i) {
        if (t = t.V ? t.V() : t) {
            var n = [e];
            Hb && !Li("7") && (n = Th(As(t), e), n.push(e)), (i ? Ps : Ds)(t, n)
        }
    }

    function Lh(t, e, i) {
        (t = i || t.bj()) && (i = e.getAttribute("role") || null, t != i && ks(e, t))
    }

    function Ch(t, e) { t.isEnabled() || Ih(e, 1, !t.isEnabled()), 8 & t.Sa && Ih(e, 8, !!(8 & t.Oa)), 16 & t.Sa && Ih(e, 16, !!(16 & t.Oa)), 64 & t.Sa && Ih(e, 64, !!(64 & t.Oa)) }

    function Mh(t, e) {
        var i;
        if (32 & t.Sa && (i = t.V())) {
            if (!e && 32 & t.Oa) {
                try { i.blur() } catch (t) {}
                32 & t.Oa && t.cj()
            }(Ns(i) && Ls(i)) != e && Ss(i, e)
        }
    }

    function Ih(t, e, i) {
        Kx || (Kx = { 1: "disabled", 8: "selected", 16: "checked", 64: "expanded" }), e = Kx[e];
        var n = t.getAttribute("role") || null;
        n && (n = $x[n] || e, e = "checked" == e || "selected" == e ? n : e), e && Ts(t, e, i)
    }

    function kh(t, e) {
        var i = t.Ma(),
            n = [i],
            r = t.Ma();
        for (r != i && n.push(r), i = e.W(), r = []; i;) {
            var o = i & -i;
            r.push(t.gf(o)), i &= ~o
        }
        return n.push.apply(n, r), (i = e.Ai) && n.push.apply(n, i), Hb && !Li("7") && n.push.apply(n, Th(n)), n
    }

    function Th(t, e) { var i = []; return e && (t = yi(t, [e])), Bb([], function(n) {!zb(n, g(gi, t)) || e && !gi(n, e) || i.push(n.join("_")) }), i }

    function Ah(e, i, n) {
        if (Ha.call(this, n), !i) {
            i = this.constructor;
            for (var r; i && (r = u(i), !(r = Yx[r]));) i = i.ga ? i.ga.constructor : null;
            i = r ? h(r.Ec) ? r.Ec() : new r : null
        }
        this.i = i, this.qf = t(e) ? e : null
    }

    function Rh(t, i) {
        var n = Ka(t),
            r = t.V();
        i ? (n.na(r, "mouseover", t.jh).na(r, "mousedown", t.sf).na(r, "mouseup", t.Gd).na(r, "mouseout", t.gh), t.xe != e && n.na(r, "contextmenu", t.xe), Hb && (Li(9) || n.na(r, "dblclick", t.dj), t.v || (t.v = new zh(t), Us(t, g(Bs, t.v))))) : (n.Gb(r, "mouseover", t.jh).Gb(r, "mousedown", t.sf).Gb(r, "mouseup", t.Gd).Gb(r, "mouseout", t.gh), t.xe != e && n.Gb(r, "contextmenu", t.xe), Hb && (Li(9) || n.Gb(r, "dblclick", t.dj), Bs(t.v), t.v = null))
    }

    function _h(t, e) { Uh(t, 2, e) && Dh(t, 2, e) }

    function Ph(t, e) { Uh(t, 4, e) && Dh(t, 4, e) }

    function Oh(t, e) { Uh(t, 64, e) && Dh(t, 64, e) }

    function Dh(t, e, i, n) {
        if (n || 1 != e) {
            if (t.Sa & e && i != !!(t.Oa & e)) {
                var r = t.i;
                (n = t.V()) && ((r = r.gf(e)) && Nh(t, r, i), Ih(n, e, i)), t.Oa = i ? t.Oa | e : t.Oa & ~e
            }
        } else t.Je(!i)
    }

    function Fh(t, e) { return !!(255 & e) && !!(t.Sa & e) }

    function Uh(t, e, i) { return !!(t.Sa & e) && !!(t.Oa & e) != i && (!(t.Le & e) || ya(t, Ya(e, i))) && !t.o }

    function Bh(t, e) { return !!t.relatedTarget && xs(e, t.relatedTarget) }

    function jh(t, e) {
        if (Fh(t, 16)) {
            var i = !(16 & t.Oa);
            Uh(t, 16, i) && Dh(t, 16, i)
        }
        return Fh(t, 8) && Uh(t, 8, !0) && Dh(t, 8, !0), Fh(t, 64) && Oh(t, !(64 & t.Oa)), i = new js("action", t), e && (i.altKey = e.altKey, i.ctrlKey = e.ctrlKey, i.metaKey = e.metaKey, i.shiftKey = e.shiftKey, i.c = e.c), ya(t, i)
    }

    function zh(t) { Fs.call(this), this.a = t, this.b = !1, this.g = new fa(this), Us(this, g(Bs, this.g)), t = this.a.a, this.g.na(t, "mousedown", this.c).na(t, "mouseup", this.i).na(t, "click", this.f) }

    function Gh(t, e) { if (!Jx) return t.button = 0, t.type = e, t; var i = document.createEvent("MouseEvents"); return i.initMouseEvent(e, t.bubbles, t.cancelable, t.view || null, t.detail, t.screenX, t.screenY, t.clientX, t.clientY, t.ctrlKey, t.altKey, t.shiftKey, t.metaKey, 0, t.relatedTarget || null), i }

    function qh(t, e, i) { Ha.call(this, i), this.we = e || wh.Ec(), this.Od = t || tE }

    function Vh(t) { return t.oh || t.V() }

    function Wh(t, e) {
        var i = Ka(t),
            n = Vh(t);
        e ? i.na(n, "focus", t.aj).na(n, "blur", t.$i).na(t.kd || (t.kd = new dh(Vh(t))), "key", t.pc) : i.Gb(n, "focus", t.aj).Gb(n, "blur", t.$i).Gb(t.kd || (t.kd = new dh(Vh(t))), "key", t.pc)
    }

    function Xh(t, e) {
        var i = e.V(),
            i = i.id || (i.id = e.Ja());
        t.kc || (t.kc = {}), t.kc[i] = e
    }

    function Hh(t) { Zh(t, function(t, e) { return (t + 1) % e }, Qa(t) - 1) }

    function Yh(t) { Zh(t, function(t, e) { return t--, 0 > t ? e - 1 : t }, 0) }

    function Kh(t) { Zh(t, function(t, e) { return (t + 1) % e }, t.Ha) }

    function $h(t) { Zh(t, function(t, e) { return t--, 0 > t ? e - 1 : t }, t.Ha) }

    function Zh(t, e, i) {
        i = 0 > i ? nh(t, t.Va) : i;
        var n = Qa(t);
        i = e.call(t, i, n);
        for (var r = 0; r <= n;) {
            var o = eh(t, i);
            if (o && t.ui(o)) { t.Sd(i); break }
            r++, i = e.call(t, i, n)
        }
    }

    function Jh() {}

    function Qh(t, e, i) { Ah.call(this, t, i || Jh.Ec(), e), this.Yb(1, !1), this.Yb(2, !1), this.Yb(4, !1), this.Yb(32, !1), this.Oa = 1 }

    function tl() { this.a = [] }

    function el(t, e) {
        var i = t.a[e];
        if (!i) {
            switch (e) {
                case 0:
                    i = t.Ma() + "-highlight";
                    break;
                case 1:
                    i = t.Ma() + "-checkbox";
                    break;
                case 2:
                    i = t.Ma() + "-content"
            }
            t.a[e] = i
        }
        return i
    }

    function il(t, e, i) { return t = el(t, 2), i.tb("DIV", t, e) }

    function nl(t, e, i, n) {
        Lh(t, i, e.rf()), Ch(e, i);
        var r;
        if (r = t.pf(i)) {
            r = r.firstChild;
            var o = el(t, 1);
            r = !!r && l(r) && 1 == r.nodeType && Rs(r, o)
        } else r = !1;
        n != r && (n ? _s(i, "goog-option") : Os(i, "goog-option"), i = t.pf(i), n ? (t = el(t, 1), i.insertBefore(e.b.tb("DIV", t), i.firstChild || null)) : i.removeChild(i.firstChild))
    }

    function rl(t, e, i, n) { Ah.call(this, t, n || tl.Ec(), i), this.sh = e }

    function ol() {}

    function sl(t, e) { Ah.call(this, null, t || ol.Ec(), e), this.Yb(1, !1), this.Yb(2, !1), this.Yb(4, !1), this.Yb(32, !1), this.Oa = 1 }

    function al(t) { this.a = t || "menu" }

    function hl(t, e) { qh.call(this, tE, e || al.Ec(), t), 0 != this.Bd && this.Fa && Wh(this, !1), this.Bd = !1, this.jd && this.Nc && xh(Vh(this), !1) }

    function ll(t, e, i) { dt.call(this, t), this.map = e, this.frameState = void 0 !== i ? i : null }

    function ul(t, e) { this.b = t, this.c = e }

    function pl(t) { ul.call(this, t, { mousedown: this.vo, mousemove: this.wo, mouseup: this.zo, mouseover: this.yo, mouseout: this.xo }), this.a = t.g, this.g = [] }

    function cl(t, e) { for (var i, n = t.g, r = e.clientX, o = e.clientY, s = 0, a = n.length; s < a && (i = n[s]); s++) { var h = Math.abs(o - i[1]); if (25 >= Math.abs(r - i[0]) && 25 >= h) return !0 } return !1 }

    function fl(t) {
        var e = Il(t, t),
            i = e.preventDefault;
        return e.preventDefault = function() { t.preventDefault(), i() }, e.pointerId = 1, e.isPrimary = !0, e.pointerType = "mouse", e
    }

    function gl(t) { ul.call(this, t, { MSPointerDown: this.Eo, MSPointerMove: this.Fo, MSPointerUp: this.Io, MSPointerOut: this.Go, MSPointerOver: this.Ho, MSPointerCancel: this.Do, MSGotPointerCapture: this.Bo, MSLostPointerCapture: this.Co }), this.a = t.g, this.g = ["", "unavailable", "touch", "pen", "mouse"] }

    function dl(t, e) { var i = e; return "number" == typeof e.pointerType && (i = Il(e, e), i.pointerType = t.g[e.pointerType]), i }

    function yl(t) { ul.call(this, t, { pointerdown: this.mr, pointermove: this.nr, pointerup: this.qr, pointerout: this.or, pointerover: this.pr, pointercancel: this.lr, gotpointercapture: this.ln, lostpointercapture: this.uo }) }

    function ml(t, e, i) { dt.call(this, t), this.b = e, t = i ? i : {}, this.buttons = vl(t), this.pressure = bl(t, this.buttons), this.bubbles = "bubbles" in t && t.bubbles, this.cancelable = "cancelable" in t && t.cancelable, this.view = "view" in t ? t.view : null, this.detail = "detail" in t ? t.detail : null, this.screenX = "screenX" in t ? t.screenX : 0, this.screenY = "screenY" in t ? t.screenY : 0, this.clientX = "clientX" in t ? t.clientX : 0, this.clientY = "clientY" in t ? t.clientY : 0, this.ctrlKey = "ctrlKey" in t && t.ctrlKey, this.altKey = "altKey" in t && t.altKey, this.shiftKey = "shiftKey" in t && t.shiftKey, this.metaKey = "metaKey" in t && t.metaKey, this.button = "button" in t ? t.button : 0, this.relatedTarget = "relatedTarget" in t ? t.relatedTarget : null, this.pointerId = "pointerId" in t ? t.pointerId : 0, this.width = "width" in t ? t.width : 0, this.height = "height" in t ? t.height : 0, this.pointerType = "pointerType" in t ? t.pointerType : "", this.isPrimary = "isPrimary" in t && t.isPrimary, e.preventDefault && (this.preventDefault = function() { e.preventDefault() }) }

    function vl(t) {
        if (t.buttons || eE) t = t.buttons;
        else switch (t.which) {
            case 1:
                t = 1;
                break;
            case 2:
                t = 4;
                break;
            case 3:
                t = 2;
                break;
            default:
                t = 0
        }
        return t
    }

    function bl(t, e) { var i = 0; return i = t.pressure ? t.pressure : e ? .5 : 0 }

    function wl(t, e) { ul.call(this, t, { touchstart: this.qs, touchmove: this.ps, touchend: this.os, touchcancel: this.ns }), this.a = t.g, this.l = e, this.g = void 0, this.i = 0, this.f = void 0 }

    function xl(t, e, i) { return e = Il(e, i), e.pointerId = i.identifier + 2, e.bubbles = !0, e.cancelable = !0, e.detail = t.i, e.button = 0, e.buttons = 1, e.width = i.webkitRadiusX || i.radiusX || 0, e.height = i.webkitRadiusY || i.radiusY || 0, e.pressure = i.webkitForce || i.force || .5, e.isPrimary = t.g === i.identifier, e.pointerType = "touch", e.clientX = i.clientX, e.clientY = i.clientY, e.screenX = i.screenX, e.screenY = i.screenY, e }

    function El(t, e, i) {
        function n() { e.preventDefault() }
        var r, o, s = Array.prototype.slice.call(e.changedTouches),
            a = s.length;
        for (r = 0; r < a; ++r) o = xl(t, e, s[r]), o.preventDefault = n, i.call(t, e, o)
    }

    function Sl(t, e) {
        var i = t.l.g,
            n = e.changedTouches[0];
        if (t.g === n.identifier) {
            var r = [n.clientX, n.clientY];
            i.push(r), gb.setTimeout(function() { ce(i, r) }, 2500)
        }
    }

    function Nl(t) { vt.call(this), this.c = t, this.g = {}, this.f = {}, this.a = [], ww ? Ll(this, new yl(this)) : xw ? Ll(this, new gl(this)) : (t = new pl(this), Ll(this, t), bw && Ll(this, new wl(this, t))), t = this.a.length; for (var e, i = 0; i < t; i++) e = this.a[i], Cl(this, Object.keys(e.c)) }

    function Ll(t, e) {
        var i = Object.keys(e.c);
        i && (i.forEach(function(t) {
            var i = e.c[t];
            i && (this.f[t] = i.bind(e))
        }, t), t.a.push(e))
    }

    function Cl(t, e) { e.forEach(function(t) { lt(this.c, t, this.i, this) }, t) }

    function Ml(t, e) { e.forEach(function(t) { pt(this.c, t, this.i, this) }, t) }

    function Il(t, e) { for (var i, n = {}, r = 0, o = uE.length; r < o; r++) i = uE[r][0], n[i] = t[i] || e[i] || uE[r][1]; return n }

    function kl(t, e, i) {
        t.out(e, i);
        var n = e.target,
            r = e.relatedTarget;
        n && r && n.contains(r) || (e.bubbles = !1, Al(t, hE, e, i))
    }

    function Tl(t, e, i) {
        e.bubbles = !0, Al(t, oE, e, i);
        var n = e.target,
            r = e.relatedTarget;
        n && r && n.contains(r) || (e.bubbles = !1, Al(t, aE, e, i))
    }

    function Al(t, e, i, n) { t.b(new ml(e, n, i)) }

    function Rl(t, e) { t.b(new ml(e.type, e, e)) }

    function _l(t, e, i, n, r) { ll.call(this, t, e, r), this.originalEvent = i, this.pixel = e.pe(i), this.coordinate = e.Za(this.pixel), this.dragging = void 0 !== n && n }

    function Pl(t, e, i, n, r) { _l.call(this, t, e, i.b, n, r), this.b = i }

    function Ol(t) { vt.call(this), this.f = t, this.l = 0, this.j = !1, this.c = [], this.g = null, t = this.f.a, this.T = 0, this.A = {}, this.i = new Nl(t), this.a = null, this.o = lt(this.i, nE, this.Vn, this), this.s = lt(this.i, iE, this.Qr, this) }

    function Dl(t, e) {
        var i;
        i = new Pl(cE, t.f, e), t.b(i), 0 !== t.l ? (gb.clearTimeout(t.l), t.l = 0, i = new Pl(fE, t.f, e), t.b(i)) : t.l = gb.setTimeout(function() {
            this.l = 0;
            var t = new Pl(pE, this.f, e);
            this.b(t)
        }.bind(t), 250)
    }

    function Fl(t, e) { e.type == mE || e.type == vE ? delete t.A[e.pointerId] : e.type == yE && (t.A[e.pointerId] = !0), t.T = Object.keys(t.A).length }

    function Ul() { return [1, 0, 0, 1, 0, 0] }

    function Bl(t) { return zl(t, 1, 0, 0, 1, 0, 0) }

    function jl(t, e) {
        var i = t[0],
            n = t[1],
            r = t[2],
            o = t[3],
            s = t[4],
            a = t[5],
            h = e[0],
            l = e[1],
            u = e[2],
            p = e[3],
            c = e[4],
            f = e[5];
        return t[0] = i * h + r * l, t[1] = n * h + o * l, t[2] = i * u + r * p, t[3] = n * u + o * p, t[4] = i * c + r * f + s, t[5] = n * c + o * f + a, t
    }

    function zl(t, e, i, n, r, o, s) { return t[0] = e, t[1] = i, t[2] = n, t[3] = r, t[4] = o, t[5] = s, t }

    function Gl(t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t }

    function ql(t, e) {
        var i = e[0],
            n = e[1];
        return e[0] = t[0] * i + t[2] * n + t[4], e[1] = t[1] * i + t[3] * n + t[5], e
    }

    function Vl(t, e) {
        var i = Math.cos(e),
            n = Math.sin(e);
        jl(t, zl(wE, i, n, -n, i, 0, 0))
    }

    function Wl(t, e, i) { return jl(t, zl(wE, e, 0, 0, i, 0, 0)) }

    function Xl(t, e, i) { jl(t, zl(wE, 1, 0, 0, 1, e, i)) }

    function Hl(t, e, i, n, r, o, s, a) { var h = Math.sin(o); return o = Math.cos(o), t[0] = n * o, t[1] = r * h, t[2] = -n * h, t[3] = r * o, t[4] = s * n * o - a * n * h + e, t[5] = s * r * h + a * r * o + i, t }

    function Yl(t) {
        var e = t[0] * t[3] - t[1] * t[2];
        x(0 !== e, 32);
        var i = t[0],
            n = t[1],
            r = t[2],
            o = t[3],
            s = t[4],
            a = t[5];
        return t[0] = o / e, t[1] = -n / e, t[2] = -r / e, t[3] = i / e, t[4] = (r * a - o * s) / e, t[5] = -(i * a - n * s) / e, t
    }

    function Kl(t, e) { this.i = e, this.g = {}, this.s = {} }

    function $l(t) {
        var e = t.viewState,
            i = t.coordinateToPixelTransform,
            n = t.pixelToCoordinateTransform;
        Hl(i, t.size[0] / 2, t.size[1] / 2, 1 / e.resolution, -1 / e.resolution, -e.rotation, -e.center[0], -e.center[1]), Yl(Gl(n, i))
    }

    function Zl() { if (32 < kw.a) { var t, e, i = 0; for (t in kw.b) e = kw.b[t], 0 !== (3 & i++) || bt(e) || (delete kw.b[t], --kw.a) } }

    function Jl(t, e) { var i = b(e).toString(); if (i in t.g) return t.g[i]; var n = t.Jg(e); return t.g[i] = n, t.s[i] = lt(n, "change", t.Ln, t), n }

    function Ql(t, e) {
        for (var i in t.g)
            if (!(i in e.layerStates)) { e.postRenderFunctions.push(t.Sr.bind(t)); break }
    }

    function tu(t, e) { return t.zIndex - e.zIndex }

    function eu(t, e) { this.o = t, this.f = e, this.b = [], this.g = [], this.a = {} }

    function iu(t) {
        var e = t.b,
            i = t.g,
            n = e[0];
        return 1 == e.length ? (e.length = 0, i.length = 0) : (e[0] = e.pop(), i[0] = i.pop(), nu(t, 0)), e = t.f(n), delete t.a[e], n
    }

    function nu(t, e) {
        for (var i = t.b, n = t.g, r = i.length, o = i[e], s = n[e], a = e; e < r >> 1;) {
            var h = 2 * e + 1,
                l = 2 * e + 2,
                h = l < r && n[l] < n[h] ? l : h;
            i[e] = i[h], n[e] = n[h], e = h
        }
        i[e] = o, n[e] = s, ru(t, a, e)
    }

    function ru(t, e, i) {
        var n = t.b;
        t = t.g;
        for (var r = n[i], o = t[i]; i > e;) {
            var s = i - 1 >> 1;
            if (!(t[s] > o)) break;
            n[i] = n[s], t[i] = t[s], i = s
        }
        n[i] = r, t[i] = o
    }

    function ou(t) {
        var e, i, n, r = t.o,
            o = t.b,
            s = t.g,
            a = 0,
            h = o.length;
        for (i = 0; i < h; ++i) e = o[i], n = r(e), 1 / 0 == n ? delete t.a[t.f(e)] : (s[a] = n, o[a++] = e);
        for (o.length = a, s.length = a, r = (t.b.length >> 1) - 1; 0 <= r; r--) nu(t, r)
    }

    function su(t, e) { eu.call(this, function(e) { return t.apply(null, e) }, function(t) { return t[0].pb() }), this.s = e, this.l = 0, this.i = {} }

    function au(t, e, i) { for (var n, r, o = 0; t.l < e && o < i && 0 < t.b.length;) n = iu(t)[0], r = n.pb(), 0 !== n.W() || r in t.i || (t.i[r] = !0, ++t.l, ++o, n.load()) }

    function hu(t) { return function(e) { if (e) return [Ct(e[0], t[0], t[2]), Ct(e[1], t[1], t[3])] } }

    function lu(t) { return t }

    function uu(t, e, i) { this.center = t, this.resolution = e, this.rotation = i }

    function pu(t) { return function(e, i, n) { if (void 0 !== e) return e = le(t, e, n), e = Ct(e + i, 0, t.length - 1), i = Math.floor(e), e != i && i < t.length - 1 ? t[i] / Math.pow(t[i] / t[i + 1], e - i) : t[i] } }

    function cu(t, e, i) { return function(n, r, o) { if (void 0 !== n) return n = Math.max(Math.floor(Math.log(e / n) / Math.log(t) + (-o / 2 + .5)) + r, 0), void 0 !== i && (n = Math.min(n, i)), e / Math.pow(t, n) } }

    function fu(t) { if (void 0 !== t) return 0 }

    function gu(t, e) { if (void 0 !== t) return t + e }

    function du(t) { var e = 2 * Math.PI / t; return function(t, i) { if (void 0 !== t) return t = Math.floor((t + i) / e + .5) * e } }

    function yu() { var t = Tt(5); return function(e, i) { if (void 0 !== e) return Math.abs(e + i) <= t ? 0 : e + i } }

    function mu(t, e) { return t[0] += e[0], t[1] += e[1], t }

    function vu(t, e) {
        var i = t[0],
            n = t[1],
            r = e[0],
            o = e[1],
            s = r[0],
            r = r[1],
            a = o[0],
            o = o[1],
            h = a - s,
            l = o - r,
            i = 0 === h && 0 === l ? 0 : (h * (i - s) + l * (n - r)) / (h * h + l * l || 0);
        return 0 >= i || (1 <= i ? (s = a, r = o) : (s += i * h, r += i * l)), [s, r]
    }

    function bu(t, e, i) { t = At(t + 180, 360) - 180; var n = Math.abs(3600 * t); return Math.floor(n / 3600) + "° " + xo(Math.floor(n / 60 % 60)) + "′ " + xo(n % 60, i || 0) + "″ " + e.charAt(0 > t ? 1 : 0) }

    function wu(t, e, i) { return t ? e.replace("{x}", t[0].toFixed(i)).replace("{y}", t[1].toFixed(i)) : "" }

    function xu(t, e) {
        for (var i = !0, n = t.length - 1; 0 <= n; --n)
            if (t[n] != e[n]) { i = !1; break }
        return i
    }

    function Eu(t, e) {
        var i = Math.cos(e),
            n = Math.sin(e),
            r = t[1] * i + t[0] * n;
        return t[0] = t[0] * i - t[1] * n, t[1] = r, t
    }

    function Su(t, e) {
        var i = t[0] - e[0],
            n = t[1] - e[1];
        return i * i + n * n
    }

    function Nu(t, e) { return Su(t, vu(t, e)) }

    function Lu(t, e) { return wu(t, "{x}, {y}", e) }

    function Cu(t) {
        St.call(this), t = t || {}, this.c = [0, 0];
        var e = {};
        e[xE] = void 0 !== t.center ? t.center : null, this.j = Bt(t.projection);
        var i, n, r, o = void 0 !== t.minZoom ? t.minZoom : 0;
        i = void 0 !== t.maxZoom ? t.maxZoom : 28;
        var s = void 0 !== t.zoomFactor ? t.zoomFactor : 2;
        if (void 0 !== t.resolutions) i = t.resolutions, n = i[0], r = i[i.length - 1], i = pu(i);
        else {
            n = Bt(t.projection), r = n.H();
            var a = (r ? Math.max(Y(r), V(r)) : 360 * bb.degrees / n.Gc()) / 256 / Math.pow(2, 0),
                h = a / Math.pow(2, 28);
            n = t.maxResolution, void 0 !== n ? o = 0 : n = a / Math.pow(s, o), r = t.minResolution, void 0 === r && (r = void 0 !== t.maxZoom ? void 0 !== t.maxResolution ? n / Math.pow(s, i) : a / Math.pow(s, i) : h), i = o + Math.floor(Math.log(n / r) / Math.log(s)), r = n / Math.pow(s, i - o), i = cu(s, n, i - o)
        }
        this.a = n, this.i = r, this.s = s, this.f = t.resolutions, this.l = o, o = void 0 !== t.extent ? hu(t.extent) : lu, (void 0 !== t.enableRotation ? t.enableRotation : 1) ? (s = t.constrainRotation, s = void 0 === s || !0 === s ? yu() : !1 === s ? gu : "number" == typeof s ? du(s) : gu) : s = fu, this.o = new uu(o, i, s), void 0 !== t.resolution ? e[EE] = t.resolution : void 0 !== t.zoom && (e[EE] = this.constrainResolution(this.a, t.zoom - this.l)), e[SE] = void 0 !== t.rotation ? t.rotation : 0, this.G(e)
    }

    function Mu(t, e) { return void 0 !== e ? (e[0] = t.c[0], e[1] = t.c[1], e) : t.c.slice() }

    function Iu(t, e) { return Math.max(Y(t) / e[0], V(t) / e[1]) }

    function ku(t) {
        var e = t.a,
            i = Math.log(e / t.i) / Math.log(2);
        return function(t) { return e / Math.pow(2, t * i) }
    }

    function Tu(t) {
        var e = t.a,
            i = Math.log(e / t.i) / Math.log(2);
        return function(t) { return Math.log(e / t) / Math.log(2) / i }
    }

    function Au(t) { return !!t.cb() && void 0 !== t.aa() }

    function Ru(t, e) { t.c[1] += e }

    function _u(t) { St.call(this), this.element = t.element ? t.element : null, this.a = this.P = null, this.s = [], this.render = t.render ? t.render : v, t.target && this.c(t.target) }

    function Pu(t) {
        t = t ? t : {}, this.O = document.createElement("UL"), this.A = document.createElement("LI"), this.O.appendChild(this.A), this.A.style.display = "none", this.f = void 0 === t.collapsed || t.collapsed, this.j = void 0 === t.collapsible || t.collapsible, this.j || (this.f = !1);
        var e = void 0 !== t.className ? t.className : "ol-attribution",
            i = void 0 !== t.tipLabel ? t.tipLabel : "Attributions",
            n = void 0 !== t.collapseLabel ? t.collapseLabel : "»";
        "string" == typeof n ? (this.v = document.createElement("span"), this.v.textContent = n) : this.v = n, n = void 0 !== t.label ? t.label : "i", "string" == typeof n ? (this.C = document.createElement("span"), this.C.textContent = n) : this.C = n;
        var r = this.j && !this.f ? this.v : this.C,
            n = document.createElement("button");
        n.setAttribute("type", "button"), n.title = i, n.appendChild(r), lt(n, "click", this.$o, this), i = document.createElement("div"), i.className = e + " ol-unselectable ol-control" + (this.f && this.j ? " ol-collapsed" : "") + (this.j ? "" : " ol-uncollapsible"), i.appendChild(this.O), i.appendChild(n), _u.call(this, { element: i, render: t.render ? t.render : Ou, target: t.target }), this.D = !0, this.o = {}, this.l = {}, this.U = {}
    }

    function Ou(t) {
        if (t = t.frameState) {
            var e, i, n, r, o, s, a, h, l, u, p, c = t.layerStatesArray,
                f = db({}, t.attributions),
                g = {},
                d = t.viewState.projection;
            for (i = 0, e = c.length; i < e; i++)
                if ((s = c[i].layer.ja()) && (u = b(s).toString(), l = s.l))
                    for (n = 0, r = l.length; n < r; n++)
                        if (a = l[n], h = b(a).toString(), !(h in f)) {
                            if (o = t.usedTiles[u]) {
                                var y = s.yb(d);
                                t: {
                                    p = a;
                                    var m = d;
                                    if (p.b) {
                                        var v, w, x, E = void 0;
                                        for (E in o)
                                            if (E in p.b) {
                                                x = o[E];
                                                var S;
                                                for (v = 0, w = p.b[E].length; v < w; ++v) {
                                                    if (S = p.b[E][v], pn(S, x)) { p = !0; break t }
                                                    var N = xn(y, In(m), parseInt(E, 10)),
                                                        L = N.ha - N.da + 1;
                                                    if ((x.da < N.da || x.ha > N.ha) && (pn(S, new hn(At(x.da, L), At(x.ha, L), x.ia, x.ka)) || x.ha - x.da + 1 > L && pn(S, N))) { p = !0; break t }
                                                }
                                            }
                                        p = !1
                                    } else p = !0
                                }
                            } else p = !1;
                            p ? (h in g && delete g[h], f[h] = a) : g[h] = a
                        }
            e = [f, g], i = e[0], e = e[1];
            for (var C in this.o) C in i ? (this.l[C] || (this.o[C].style.display = "", this.l[C] = !0), delete i[C]) : C in e ? (this.l[C] && (this.o[C].style.display = "none", delete this.l[C]), delete e[C]) : (Ri(this.o[C]), delete this.o[C], delete this.l[C]);
            for (C in i) n = document.createElement("LI"), n.innerHTML = i[C].a, this.O.appendChild(n), this.o[C] = n, this.l[C] = !0;
            for (C in e) n = document.createElement("LI"), n.innerHTML = e[C].a, n.style.display = "none", this.O.appendChild(n), this.o[C] = n;
            C = !nt(this.l) || !nt(t.logos), this.D != C && (this.element.style.display = C ? "" : "none", this.D = C), C && nt(this.l) ? this.element.classList.add("ol-logo-only") : this.element.classList.remove("ol-logo-only");
            var M;
            t = t.logos, C = this.U;
            for (M in C) M in t || (Ri(C[M]), delete C[M]);
            for (var I in t) e = t[I], e instanceof HTMLElement && (this.A.appendChild(e), C[I] = e), I in C || (M = new Image, M.src = I, "" === e ? i = M : (i = document.createElement("a"), i.href = e, i.appendChild(M)), this.A.appendChild(i), C[I] = i);
            this.A.style.display = nt(t) ? "none" : ""
        } else this.D && (this.element.style.display = "none", this.D = !1)
    }

    function Du(t) { t.element.classList.toggle("ol-collapsed"), t.f ? Ai(t.v, t.C) : Ai(t.C, t.v), t.f = !t.f }

    function Fu(t) { return Math.pow(t, 3) }

    function Uu(t) { return 1 - Fu(1 - t) }

    function Bu(t) { return 3 * t * t - 2 * t * t * t }

    function ju(t) { return t }

    function zu(t) { return .5 > t ? Bu(2 * t) : 1 - Bu(2 * (t - .5)) }

    function Gu(t) {
        var e = t.source,
            i = t.start ? t.start : Date.now(),
            n = e[0],
            r = e[1],
            o = void 0 !== t.duration ? t.duration : 1e3,
            s = t.easing ? t.easing : Bu;
        return function(t, e) {
            if (e.time < i) return e.animate = !0, e.viewHints[0] += 1, !0;
            if (e.time < i + o) {
                var a = 1 - s((e.time - i) / o),
                    h = n - e.viewState.center[0],
                    l = r - e.viewState.center[1];
                return e.animate = !0, e.viewState.center[0] += a * h, e.viewState.center[1] += a * l, e.viewHints[0] += 1, !0
            }
            return !1
        }
    }

    function qu(t) {
        var e = t.rotation ? t.rotation : 0,
            i = t.start ? t.start : Date.now(),
            n = void 0 !== t.duration ? t.duration : 1e3,
            r = t.easing ? t.easing : Bu,
            o = t.anchor ? t.anchor : null;
        return function(t, s) {
            if (s.time < i) return s.animate = !0, s.viewHints[0] += 1, !0;
            if (s.time < i + n) {
                var a = 1 - r((s.time - i) / n),
                    a = (e - s.viewState.rotation) * a;
                if (s.animate = !0, s.viewState.rotation += a, o) {
                    var h = s.viewState.center;
                    h[0] -= o[0], h[1] -= o[1], Eu(h, a), mu(h, o)
                }
                return s.viewHints[0] += 1, !0
            }
            return !1
        }
    }

    function Vu(t) {
        var e = t.resolution,
            i = t.start ? t.start : Date.now(),
            n = void 0 !== t.duration ? t.duration : 1e3,
            r = t.easing ? t.easing : Bu;
        return function(t, o) {
            if (o.time < i) return o.animate = !0, o.viewHints[0] += 1, !0;
            if (o.time < i + n) {
                var s = 1 - r((o.time - i) / n),
                    a = e - o.viewState.resolution;
                return o.animate = !0, o.viewState.resolution += s * a, o.viewHints[0] += 1, !0
            }
            return !1
        }
    }

    function Wu(t) {
        t = t ? t : {};
        var e = void 0 !== t.className ? t.className : "ol-rotate",
            i = void 0 !== t.label ? t.label : "⇧";
        this.f = null, "string" == typeof i ? (this.f = document.createElement("span"), this.f.className = "ol-compass", this.f.textContent = i) : (this.f = i, this.f.classList.add("ol-compass"));
        var n = t.tipLabel ? t.tipLabel : "Reset rotation",
            i = document.createElement("button");
        i.className = e + "-reset", i.setAttribute("type", "button"), i.title = n, i.appendChild(this.f), lt(i, "click", Wu.prototype.v, this), n = document.createElement("div"), n.className = e + " ol-unselectable ol-control", n.appendChild(i), e = t.render ? t.render : Xu, this.l = t.resetNorth ? t.resetNorth : void 0, _u.call(this, { element: n, render: e, target: t.target }), this.o = void 0 !== t.duration ? t.duration : 250, this.j = void 0 === t.autoHide || t.autoHide, this.A = void 0, this.j && this.element.classList.add("ol-hidden")
    }

    function Xu(t) {
        if (t = t.frameState) {
            if (t = t.viewState.rotation, t != this.A) {
                var e = "rotate(" + t + "rad)";
                if (this.j) {
                    var i = this.element.classList.contains("ol-hidden");
                    i || 0 !== t ? i && 0 !== t && this.element.classList.remove("ol-hidden") : this.element.classList.add("ol-hidden")
                }
                this.f.style.msTransform = e, this.f.style.webkitTransform = e, this.f.style.transform = e
            }
            this.A = t
        }
    }

    function Hu(t) {
        t = t ? t : {};
        var e = void 0 !== t.className ? t.className : "ol-zoom",
            i = void 0 !== t.delta ? t.delta : 1,
            n = void 0 !== t.zoomInLabel ? t.zoomInLabel : "+",
            r = void 0 !== t.zoomOutLabel ? t.zoomOutLabel : "−",
            o = void 0 !== t.zoomInTipLabel ? t.zoomInTipLabel : "Zoom in",
            s = void 0 !== t.zoomOutTipLabel ? t.zoomOutTipLabel : "Zoom out",
            a = document.createElement("button");
        a.className = e + "-in", a.setAttribute("type", "button"), a.title = o, a.appendChild("string" == typeof n ? document.createTextNode(n) : n), lt(a, "click", Hu.prototype.l.bind(this, i)), n = document.createElement("button"), n.className = e + "-out", n.setAttribute("type", "button"), n.title = s, n.appendChild("string" == typeof r ? document.createTextNode(r) : r), lt(n, "click", Hu.prototype.l.bind(this, -i)), i = document.createElement("div"), i.className = e + " ol-unselectable ol-control", i.appendChild(a), i.appendChild(n), _u.call(this, { element: i, target: t.target }), this.f = void 0 !== t.duration ? t.duration : 250
    }

    function Yu(t) { t = t ? t : {}; var e = new Wn; return (void 0 !== t.zoom ? t.zoom : 1) && e.push(new Hu(t.zoomOptions)), (void 0 !== t.rotate ? t.rotate : 1) && e.push(new Wu(t.rotateOptions)), (void 0 !== t.attribution ? t.attribution : 1) && e.push(new Pu(t.attributionOptions)), e }

    function Ku(t, e, i) { this.f = t, this.g = e, this.i = i, this.b = [], this.a = this.c = 0 }

    function $u(t, e) {
        var i = t.f,
            n = t.a,
            r = t.g - n,
            o = Math.log(t.g / t.a) / t.f;
        return Gu({ source: e, duration: o, easing: function(t) { return n * (Math.exp(i * t * o) - 1) / r } })
    }

    function Zu(t) { St.call(this), this.A = null, this.i(!0), this.handleEvent = t.handleEvent }

    function Ju(t, e, i, n, r) {
        if (void 0 !== i) {
            var o = e.Ra(),
                s = e.cb();
            void 0 !== o && s && r && 0 < r && (t.mb(qu({ rotation: o, duration: r, easing: Uu })), n && t.mb(Gu({ source: s, duration: r, easing: Uu }))), e.rotate(i, n)
        }
    }

    function Qu(t, e, i, n, r) {
        var o = e.aa();
        i = e.constrainResolution(o, i, 0), tp(t, e, i, n, r)
    }

    function tp(t, e, i, n, r) {
        if (i) {
            var o = e.aa(),
                s = e.cb();
            if (void 0 !== o && s && i !== o && r && 0 < r && (t.mb(Vu({ resolution: o, duration: r, easing: Uu })), n && t.mb(Gu({ source: s, duration: r, easing: Uu }))), n) {
                var a;
                t = e.cb(), r = e.aa(), void 0 !== t && void 0 !== r && (a = [n[0] - i * (n[0] - t[0]) / r, n[1] - i * (n[1] - t[1]) / r]), e.qb(a)
            }
            e.Xb(i)
        }
    }

    function ep(t) { t = t ? t : {}, this.a = t.delta ? t.delta : 1, Zu.call(this, { handleEvent: ip }), this.c = void 0 !== t.duration ? t.duration : 250 }

    function ip(t) {
        var e = !1,
            i = t.originalEvent;
        if (t.type == fE) {
            var e = t.map,
                n = t.coordinate,
                i = i.shiftKey ? -this.a : this.a,
                r = e.$();
            Qu(e, r, i, n, this.c), t.preventDefault(), e = !0
        }
        return !e
    }

    function np(t) { return t = t.originalEvent, t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey }

    function rp(t) { return t = t.originalEvent, 0 == t.button && !($b && fw && t.ctrlKey) }

    function op(t) { return "pointermove" == t.type }

    function sp(t) { return t.type == pE }

    function ap(t) { return t = t.originalEvent, !t.altKey && !(t.metaKey || t.ctrlKey) && !t.shiftKey }

    function hp(t) { return t = t.originalEvent, !t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey }

    function lp(t) { return t = t.originalEvent.target.tagName, "INPUT" !== t && "SELECT" !== t && "TEXTAREA" !== t }

    function up(t) { return x(t.b, 56), "mouse" == t.b.pointerType }

    function pp(t) { return t = t.b, t.isPrimary && 0 === t.button }

    function cp(t) { t = t ? t : {}, Zu.call(this, { handleEvent: t.handleEvent ? t.handleEvent : gp }), this.Te = t.handleDownEvent ? t.handleDownEvent : tt, this.qg = t.handleDragEvent ? t.handleDragEvent : v, this.wg = t.handleMoveEvent ? t.handleMoveEvent : v, this.Bg = t.handleUpEvent ? t.handleUpEvent : tt, this.C = !1, this.fa = {}, this.j = [] }

    function fp(t) { for (var e = t.length, i = 0, n = 0, r = 0; r < e; r++) i += t[r].clientX, n += t[r].clientY; return [i / e, n / e] }

    function gp(t) {
        if (!(t instanceof Pl)) return !0;
        var e = !1,
            i = t.type;
        return i !== yE && i !== gE && i !== mE || (i = t.b, t.type == mE ? delete this.fa[i.pointerId] : t.type == yE ? this.fa[i.pointerId] = i : i.pointerId in this.fa && (this.fa[i.pointerId] = i), this.j = it(this.fa)), this.C && (t.type == gE ? this.qg(t) : t.type == mE && (this.C = this.Bg(t))), t.type == yE ? (this.C = t = this.Te(t), e = this.ud(t)) : t.type == dE && this.wg(t), !e
    }

    function dp(t) { cp.call(this, { handleDownEvent: vp, handleDragEvent: yp, handleUpEvent: mp }), t = t ? t : {}, this.a = t.kinetic, this.c = this.o = null, this.v = t.condition ? t.condition : ap, this.s = !1 }

    function yp(t) {
        var e = fp(this.j);
        if (this.a && this.a.b.push(e[0], e[1], Date.now()), this.c) {
            var i = this.c[0] - e[0],
                n = e[1] - this.c[1];
            t = t.map.$();
            var r = t.W(),
                n = i = [i, n],
                o = r.resolution;
            n[0] *= o, n[1] *= o, Eu(i, r.rotation), mu(i, r.center), i = t.ce(i), t.qb(i)
        }
        this.c = e
    }

    function mp(t) {
        var e = t.map;
        if (t = e.$(), 0 === this.j.length) {
            var i;
            if (i = !this.s && this.a)
                if (i = this.a, 6 > i.b.length) i = !1;
                else {
                    var n = Date.now() - i.i,
                        r = i.b.length - 3;
                    if (i.b[r + 2] < n) i = !1;
                    else {
                        for (var o = r - 3; 0 < o && i.b[o + 2] > n;) o -= 3;
                        var n = i.b[r + 2] - i.b[o + 2],
                            s = i.b[r] - i.b[o],
                            r = i.b[r + 1] - i.b[o + 1];
                        i.c = Math.atan2(r, s), i.a = Math.sqrt(s * s + r * r) / n, i = i.a > i.g
                    }
                }
            return i ? (i = this.a, i = (i.g - i.a) / i.f, r = this.a.c, o = t.cb(), this.o = $u(this.a, o), e.mb(this.o), o = e.Qa(o), e = e.Za([o[0] - i * Math.cos(r), o[1] - i * Math.sin(r)]), e = t.ce(e), t.qb(e)) : e.render(), Ru(t, -1), !1
        }
        return this.c = null, !0
    }

    function vp(t) {
        if (0 < this.j.length && this.v(t)) {
            var e = t.map,
                i = e.$();
            return this.c = null, this.C || Ru(i, 1), this.o && ce(e.fa, this.o) && (i.qb(t.frameState.viewState.center), this.o = null), this.a && (t = this.a, t.b.length = 0, t.c = 0, t.a = 0), this.s = 1 < this.j.length, !0
        }
        return !1
    }

    function bp(t) { t = t ? t : {}, cp.call(this, { handleDownEvent: Ep, handleDragEvent: wp, handleUpEvent: xp }), this.c = t.condition ? t.condition : np, this.a = void 0, this.o = void 0 !== t.duration ? t.duration : 250 }

    function wp(t) {
        if (up(t)) {
            var e = t.map,
                i = e.bb();
            if (t = t.pixel, i = Math.atan2(i[1] / 2 - t[1], t[0] - i[0] / 2), void 0 !== this.a) {
                t = i - this.a;
                var n = e.$(),
                    r = n.Ra();
                Ju(e, n, r - t)
            }
            this.a = i
        }
    }

    function xp(t) {
        if (!up(t)) return !0;
        t = t.map;
        var e = t.$();
        Ru(e, -1);
        var i = e.Ra(),
            n = this.o,
            i = e.constrainRotation(i, 0);
        return Ju(t, e, i, void 0, n), !1
    }

    function Ep(t) { return !!(up(t) && rp(t) && this.c(t)) && (Ru(t.map.$(), 1), this.a = void 0, !0) }

    function Sp(t) { this.f = null, this.a = document.createElement("div"), this.a.style.position = "absolute", this.a.className = "ol-box " + t, this.g = this.c = this.b = null }

    function Np(t) {
        var e = t.c,
            i = t.g;
        t = t.a.style, t.left = Math.min(e[0], i[0]) + "px", t.top = Math.min(e[1], i[1]) + "px", t.width = Math.abs(i[0] - e[0]) + "px", t.height = Math.abs(i[1] - e[1]) + "px"
    }

    function Lp(t) {
        var e = t.c,
            i = t.g,
            e = [e, [e[0], i[1]], i, [i[0], e[1]]].map(t.b.Za, t.b);
        e[4] = e[0].slice(), t.f ? t.f.wa([e]) : t.f = new Ze([e])
    }

    function Cp(t, e, i) { dt.call(this, t), this.coordinate = e, this.mapBrowserEvent = i }

    function Mp(t) { cp.call(this, { handleDownEvent: Ap, handleDragEvent: kp, handleUpEvent: Tp }), t = t ? t : {}, this.a = new Sp(t.className || "ol-dragbox"), this.c = null, this.D = t.condition ? t.condition : Q, this.v = t.boxEndCondition ? t.boxEndCondition : Ip }

    function Ip(t, e, i) { return t = i[0] - e[0], e = i[1] - e[1], 64 <= t * t + e * e }

    function kp(t) {
        if (up(t)) {
            var e = this.a,
                i = t.pixel;
            e.c = this.c, e.g = i, Lp(e), Np(e), this.b(new Cp("boxdrag", t.coordinate, t))
        }
    }

    function Tp(t) { return !up(t) || (this.a.setMap(null), this.v(t, this.c, t.pixel) && (this.s(t), this.b(new Cp("boxend", t.coordinate, t))), !1) }

    function Ap(t) {
        if (up(t) && rp(t) && this.D(t)) {
            this.c = t.pixel, this.a.setMap(t.map);
            var e = this.a,
                i = this.c;
            return e.c = this.c, e.g = i, Lp(e), Np(e), this.b(new Cp("boxstart", t.coordinate, t)), !0
        }
        return !1
    }

    function Rp(t) {
        t = t ? t : {};
        var e = t.condition ? t.condition : hp;
        this.o = void 0 !== t.duration ? t.duration : 200, this.O = void 0 !== t.out && t.out, Mp.call(this, { condition: e, className: t.className || "ol-dragzoom" })
    }

    function _p(t) { Zu.call(this, { handleEvent: Pp }), t = t || {}, this.a = function(t) { return ap(t) && lp(t) }, this.c = void 0 !== t.condition ? t.condition : this.a, this.j = void 0 !== t.duration ? t.duration : 100, this.o = void 0 !== t.pixelDelta ? t.pixelDelta : 128 }

    function Pp(t) {
        var e = !1;
        if ("keydown" == t.type) {
            var i = t.originalEvent.keyCode;
            if (this.c(t) && (40 == i || 37 == i || 39 == i || 38 == i)) {
                var n = t.map,
                    e = n.$(),
                    r = e.aa() * this.o,
                    o = 0,
                    s = 0;
                40 == i ? s = -r : 37 == i ? o = -r : 39 == i ? o = r : s = r, i = [o, s], Eu(i, e.Ra()), r = this.j, (o = e.cb()) && (r && 0 < r && n.mb(Gu({ source: o, duration: r, easing: ju })), n = e.ce([o[0] + i[0], o[1] + i[1]]), e.qb(n)), t.preventDefault(), e = !0
            }
        }
        return !e
    }

    function Op(t) { Zu.call(this, { handleEvent: Dp }), t = t ? t : {}, this.c = t.condition ? t.condition : lp, this.a = t.delta ? t.delta : 1, this.j = void 0 !== t.duration ? t.duration : 100 }

    function Dp(t) {
        var e = !1;
        if ("keydown" == t.type || "keypress" == t.type) {
            var i = t.originalEvent.charCode;
            if (this.c(t) && (43 == i || 45 == i)) {
                var e = t.map,
                    i = 43 == i ? this.a : -this.a,
                    n = e.$();
                Qu(e, n, i, void 0, this.j), t.preventDefault(), e = !0
            }
        }
        return !e
    }

    function Fp(t) { Zu.call(this, { handleEvent: Up }), t = t || {}, this.c = 0, this.C = void 0 !== t.duration ? t.duration : 250, this.s = void 0 === t.useAnchor || t.useAnchor, this.a = null, this.o = this.j = void 0 }

    function Up(t) {
        var e = !1;
        if ("wheel" == t.type || "mousewheel" == t.type) {
            var e = t.map,
                i = t.originalEvent;
            this.s && (this.a = t.coordinate);
            var n;
            "wheel" == t.type ? (n = i.deltaY, pw && i.deltaMode === gb.WheelEvent.DOM_DELTA_PIXEL && (n /= gw), i.deltaMode === gb.WheelEvent.DOM_DELTA_LINE && (n *= 40)) : "mousewheel" == t.type && (n = -i.wheelDeltaY, cw && (n /= 3)), this.c += n, void 0 === this.j && (this.j = Date.now()), n = Math.max(80 - (Date.now() - this.j), 0), gb.clearTimeout(this.o), this.o = gb.setTimeout(this.v.bind(this, e), n), t.preventDefault(), e = !0
        }
        return !e
    }

    function Bp(t) { cp.call(this, { handleDownEvent: Gp, handleDragEvent: jp, handleUpEvent: zp }), t = t || {}, this.c = null, this.o = void 0, this.a = !1, this.s = 0, this.D = void 0 !== t.threshold ? t.threshold : .3, this.v = void 0 !== t.duration ? t.duration : 250 }

    function jp(t) {
        var e = 0,
            i = this.j[0],
            n = this.j[1],
            i = Math.atan2(n.clientY - i.clientY, n.clientX - i.clientX);
        void 0 !== this.o && (e = i - this.o, this.s += e, !this.a && Math.abs(this.s) > this.D && (this.a = !0)), this.o = i, t = t.map, i = t.a.getBoundingClientRect(), n = fp(this.j), n[0] -= i.left, n[1] -= i.top, this.c = t.Za(n), this.a && (i = t.$(), n = i.Ra(), t.render(), Ju(t, i, n + e, this.c))
    }

    function zp(t) {
        if (2 > this.j.length) {
            t = t.map;
            var e = t.$();
            if (Ru(e, -1), this.a) {
                var i = e.Ra(),
                    n = this.c,
                    r = this.v,
                    i = e.constrainRotation(i, 0);
                Ju(t, e, i, n, r)
            }
            return !1
        }
        return !0
    }

    function Gp(t) { return 2 <= this.j.length && (t = t.map, this.c = null, this.o = void 0, this.a = !1, this.s = 0, this.C || Ru(t.$(), 1), t.render(), !0) }

    function qp(t) { cp.call(this, { handleDownEvent: Xp, handleDragEvent: Vp, handleUpEvent: Wp }), t = t ? t : {}, this.c = null, this.s = void 0 !== t.duration ? t.duration : 400, this.a = void 0, this.o = 1 }

    function Vp(t) {
        var e = 1,
            i = this.j[0],
            n = this.j[1],
            r = i.clientX - n.clientX,
            i = i.clientY - n.clientY,
            r = Math.sqrt(r * r + i * i);
        void 0 !== this.a && (e = this.a / r), this.a = r, 1 != e && (this.o = e), t = t.map;
        var r = t.$(),
            i = r.aa(),
            n = t.a.getBoundingClientRect(),
            o = fp(this.j);
        o[0] -= n.left, o[1] -= n.top, this.c = t.Za(o), t.render(), tp(t, r, i * e, this.c)
    }

    function Wp(t) {
        if (2 > this.j.length) {
            t = t.map;
            var e = t.$();
            Ru(e, -1);
            var i = e.aa(),
                n = this.c,
                r = this.s,
                i = e.constrainResolution(i, 0, this.o - 1);
            return tp(t, e, i, n, r), !1
        }
        return !0
    }

    function Xp(t) { return 2 <= this.j.length && (t = t.map, this.c = null, this.a = void 0, this.o = 1, this.C || Ru(t.$(), 1), t.render(), !0) }

    function Hp(t) {
        t = t ? t : {};
        var e = new Wn,
            i = new Ku(-.005, .05, 100);
        return (void 0 !== t.altShiftDragRotate ? t.altShiftDragRotate : 1) && e.push(new bp), (void 0 !== t.doubleClickZoom ? t.doubleClickZoom : 1) && e.push(new ep({ delta: t.zoomDelta, duration: t.zoomDuration })), (void 0 !== t.dragPan ? t.dragPan : 1) && e.push(new dp({ kinetic: i })), (void 0 !== t.pinchRotate ? t.pinchRotate : 1) && e.push(new Bp), (void 0 !== t.pinchZoom ? t.pinchZoom : 1) && e.push(new qp({ duration: t.zoomDuration })), (void 0 !== t.keyboard ? t.keyboard : 1) && (e.push(new _p), e.push(new Op({ delta: t.zoomDelta, duration: t.zoomDuration }))), (void 0 !== t.mouseWheelZoom ? t.mouseWheelZoom : 1) && e.push(new Fp({ duration: t.zoomDuration })), (void 0 !== t.shiftDragZoom ? t.shiftDragZoom : 1) && e.push(new Rp({ duration: t.zoomDuration })), e
    }

    function Yp(t) { Pt.call(this, { code: t, units: "m", extent: LE, global: !0, worldExtent: CE }) }

    function Kp(t, e, i) {
        var n = t.length;
        i = 1 < i ? i : 2, void 0 === e && (e = 2 < i ? t.slice() : Array(n));
        for (var r = 0; r < n; r += i) e[r] = 6378137 * Math.PI * t[r] / 180, e[r + 1] = 6378137 * Math.log(Math.tan(Math.PI * (t[r + 1] + 90) / 360));
        return e
    }

    function $p(t, e, i) {
        var n = t.length;
        i = 1 < i ? i : 2, void 0 === e && (e = 2 < i ? t.slice() : Array(n));
        for (var r = 0; r < n; r += i) e[r] = 180 * t[r] / (6378137 * Math.PI), e[r + 1] = 360 * Math.atan(Math.exp(t[r + 1] / 6378137)) / Math.PI - 90;
        return e
    }

    function Zp(t, e) { Pt.call(this, { code: t, units: "degrees", extent: kE, axisOrientation: e, global: !0, metersPerUnit: TE, worldExtent: kE }) }

    function Jp() { Ot(ME), Ot(AE), Dt() }

    function Qp(t) {
        t = t ? t : {};
        var e = db({}, t);
        delete e.preload, delete e.useInterimTilesOnError, Wr.call(this, e), this.X(t.preload ? t.preload : 0), this.fa(!t.useInterimTilesOnError || t.useInterimTilesOnError), x(void 0 == t.renderMode || "image" == t.renderMode || "hybrid" == t.renderMode || "vector" == t.renderMode, 28), this.s = t.renderMode || "hybrid"
    }

    function tc() {}

    function ec(t, e, i, n, r) { this.f = t, this.v = e, this.c = i, this.C = n, this.bc = r, this.i = this.b = this.a = this.Xa = this.X = this.U = null, this.vb = this.fa = this.A = this.sa = this.O = this.D = 0, this.ra = !1, this.l = this.qa = 0, this.xa = !1, this.za = 0, this.g = "", this.Ua = this.Ta = 0, this.sb = !1, this.o = this.Hb = 0, this.P = this.s = this.j = null, this.T = [], this.Yd = Ul() }

    function ic(t, e, i) {
        if (t.i) {
            e = Jt(e, 0, i, 2, t.C, t.T), i = t.f;
            var n = t.Yd,
                r = i.globalAlpha;
            1 != t.A && (i.globalAlpha = r * t.A);
            var o = t.qa;
            t.ra && (o += t.bc);
            var s, a;
            for (s = 0, a = e.length; s < a; s += 2) {
                var h = e[s] - t.D,
                    l = e[s + 1] - t.O;
                if (t.xa && (h = Math.round(h), l = Math.round(l)), 0 !== o || 1 != t.l) {
                    var u = h + t.D,
                        p = l + t.O;
                    Hl(n, u, p, t.l, t.l, o, -u, -p), i.setTransform.apply(i, n)
                }
                i.drawImage(t.i, t.fa, t.vb, t.za, t.sa, h, l, t.za, t.sa)
            }
            0 === o && 1 == t.l || i.setTransform(1, 0, 0, 1, 0, 0), 1 != t.A && (i.globalAlpha = r)
        }
    }

    function nc(t, e, i, n) {
        var r = 0;
        if (t.P && "" !== t.g) {
            t.j && sc(t, t.j), t.s && ac(t, t.s);
            var o = t.P,
                s = t.f,
                a = t.Xa;
            for (a ? (a.font != o.font && (a.font = s.font = o.font), a.textAlign != o.textAlign && (a.textAlign = s.textAlign = o.textAlign), a.textBaseline != o.textBaseline && (a.textBaseline = s.textBaseline = o.textBaseline)) : (s.font = o.font, s.textAlign = o.textAlign, s.textBaseline = o.textBaseline, t.Xa = { font: o.font, textAlign: o.textAlign, textBaseline: o.textBaseline }), e = Jt(e, r, i, n, t.C, t.T), o = t.f, s = t.Hb, t.sb && (s += t.bc); r < i; r += n) {
                var a = e[r] + t.Ta,
                    h = e[r + 1] + t.Ua;
                if (0 !== s || 1 != t.o) {
                    var l = Hl(t.Yd, a, h, t.o, t.o, s, -a, -h);
                    o.setTransform.apply(o, l)
                }
                t.s && o.strokeText(t.g, a, h), t.j && o.fillText(t.g, a, h)
            }
            0 === s && 1 == t.o || o.setTransform(1, 0, 0, 1, 0, 0)
        }
    }

    function rc(t, e, i, n, r, o) { var s = t.f; for (t = Jt(e, i, n, r, t.C, t.T), s.moveTo(t[0], t[1]), e = t.length, o && (e -= 2), i = 2; i < e; i += 2) s.lineTo(t[i], t[i + 1]); return o && s.closePath(), n }

    function oc(t, e, i, n, r) { var o, s; for (o = 0, s = n.length; o < s; ++o) i = rc(t, e, i, n[o], r, !0); return i }

    function sc(t, e) {
        var i = t.f,
            n = t.U;
        n ? n.fillStyle != e.fillStyle && (n.fillStyle = i.fillStyle = e.fillStyle) : (i.fillStyle = e.fillStyle, t.U = { fillStyle: e.fillStyle })
    }

    function ac(t, e) {
        var i = t.f,
            n = t.X;
        n ? (n.lineCap != e.lineCap && (n.lineCap = i.lineCap = e.lineCap), dw && !ge(n.lineDash, e.lineDash) && i.setLineDash(n.lineDash = e.lineDash), n.lineJoin != e.lineJoin && (n.lineJoin = i.lineJoin = e.lineJoin), n.lineWidth != e.lineWidth && (n.lineWidth = i.lineWidth = e.lineWidth), n.miterLimit != e.miterLimit && (n.miterLimit = i.miterLimit = e.miterLimit), n.strokeStyle != e.strokeStyle && (n.strokeStyle = i.strokeStyle = e.strokeStyle)) : (i.lineCap = e.lineCap, dw && i.setLineDash(e.lineDash), i.lineJoin = e.lineJoin, i.lineWidth = e.lineWidth, i.miterLimit = e.miterLimit, i.strokeStyle = e.strokeStyle, t.X = { lineCap: e.lineCap, lineDash: e.lineDash, lineJoin: e.lineJoin, lineWidth: e.lineWidth, miterLimit: e.miterLimit, strokeStyle: e.strokeStyle })
    }

    function hc(t) { wt.call(this), this.a = t }

    function lc(t, e) { var i = e.W(); return 2 != i && 3 != i && lt(e, "change", t.Op, t), 0 == i && (e.load(), i = e.W()), 2 == i }

    function uc(t) {
        var e = t.a;
        e.Ib() && "ready" == e.Zg() && t.u()
    }

    function pc(t, e) { e.$j() && t.postRenderFunctions.push(function(t, e, i) { e = b(t).toString(), t.zd(i.viewState.projection, i.usedTiles[e]) }.bind(null, e)) }

    function cc(t, e) { if (e) { var i, n, r; for (n = 0, r = e.length; n < r; ++n) i = e[n], t[b(i).toString()] = i } }

    function fc(t, e) {
        var i = e.O;
        void 0 !== i && ("string" == typeof i ? t.logos[i] = "" : i && (x("string" == typeof i.href, 44), x("string" == typeof i.src, 45), t.logos[i.src] = i.href))
    }

    function gc(t, e, i, n) { e = b(e).toString(), i = i.toString(), e in t ? i in t[e] ? (t = t[e][i], n.da < t.da && (t.da = n.da), n.ha > t.ha && (t.ha = n.ha), n.ia < t.ia && (t.ia = n.ia), n.ka > t.ka && (t.ka = n.ka)) : t[e][i] = n : (t[e] = {}, t[e][i] = n) }

    function dc(t, e, i) { return [e * (Math.round(t[0] / e) + i[0] % 2 / 2), e * (Math.round(t[1] / e) + i[1] % 2 / 2)] }

    function yc(t, e, i, n, r, o, s, a, h, l) {
        var u = b(e).toString();
        u in t.wantedTiles || (t.wantedTiles[u] = {});
        var p = t.wantedTiles[u];
        t = t.tileQueue;
        var c, f, g, d, y, m, v = i.minZoom;
        for (m = s; m >= v; --m)
            for (f = xn(i, o, m, f), g = i.aa(m), d = f.da; d <= f.ha; ++d)
                for (y = f.ia; y <= f.ka; ++y) s - m <= a ? (c = e.Ic(m, d, y, n, r), 0 == c.W() && (p[c.pb()] = !0, c.pb() in t.a || t.c([c, u, En(i, c.ta), g])), void 0 !== h && h.call(l, c)) : e.bi(m, d, y, r)
    }

    function mc(t) { hc.call(this, t), this.O = Ul() }

    function vc(t, e, i) {
        var n = e.pixelRatio,
            r = e.size[0] * n,
            o = e.size[1] * n,
            s = e.viewState.rotation,
            a = X(i),
            h = H(i),
            l = z(i);
        i = j(i), ql(e.coordinateToPixelTransform, a), ql(e.coordinateToPixelTransform, h), ql(e.coordinateToPixelTransform, l), ql(e.coordinateToPixelTransform, i), t.save(), Oi(t, -s, r / 2, o / 2), t.beginPath(), t.moveTo(a[0] * n, a[1] * n), t.lineTo(h[0] * n, h[1] * n), t.lineTo(l[0] * n, l[1] * n), t.lineTo(i[0] * n, i[1] * n), t.clip(), Oi(t, s, r / 2, o / 2)
    }

    function bc(t, e, i, n, r) {
        var o = t.a;
        if (bt(o, e)) {
            var s = n.size[0] * n.pixelRatio,
                a = n.size[1] * n.pixelRatio,
                h = n.viewState.rotation;
            Oi(i, -h, s / 2, a / 2), t = void 0 !== r ? r : xc(t, n, 0), o.b(new jr(e, new ec(i, n.pixelRatio, n.extent, t, n.viewState.rotation), n, i, null)), Oi(i, h, s / 2, a / 2)
        }
    }

    function wc(t, e, i, n) { bc(t, "postcompose", e, i, n) }

    function xc(t, e, i) {
        var n = e.viewState,
            r = e.pixelRatio,
            o = r / n.resolution;
        return Hl(t.O, r * e.size[0] / 2, r * e.size[1] / 2, o, -o, -n.rotation, -n.center[0] + i, -n.center[1])
    }

    function Ec() {}

    function Sc(t, e, i, n) { this.ra = t, this.U = e, this.overlaps = n, this.f = null, this.c = 0, this.resolution = i, this.za = this.sa = null, this.a = [], this.coordinates = [], this.Xa = Ul(), this.b = [], this.X = [], this.fa = Ul(), this.vb = Ul() }

    function Nc(t, e, i, n, r, o) {
        var s, a, h, l = t.coordinates.length,
            u = t.Tg(),
            p = [e[i], e[i + 1]],
            c = [NaN, NaN],
            f = !0;
        for (s = i + r; s < n; s += r) c[0] = e[s], c[1] = e[s + 1], h = k(u, c), h !== a ? (f && (t.coordinates[l++] = p[0], t.coordinates[l++] = p[1]), t.coordinates[l++] = c[0], t.coordinates[l++] = c[1], f = !1) : 1 === h ? (t.coordinates[l++] = c[0], t.coordinates[l++] = c[1], f = !1) : f = !0, p[0] = c[0], p[1] = c[1], a = h;
        return s === i + r && (t.coordinates[l++] = p[0], t.coordinates[l++] = p[1]), o && (t.coordinates[l++] = e[i], t.coordinates[l++] = e[i + 1]), l
    }

    function Lc(t, e) { t.sa = [0, e, 0], t.a.push(t.sa), t.za = [0, e, 0], t.b.push(t.za) }

    function Cc(t, e, i, n, r, o, s, a, h) {
        var l;
        ge(n, t.Xa) ? l = t.X : (l = Jt(t.coordinates, 0, t.coordinates.length, 2, n, t.X), Gl(t.Xa, n)), n = !nt(o);
        var u, p, c, f, g, d, y = 0,
            m = s.length,
            v = t.fa,
            w = t.vb,
            x = 0,
            E = 0;
        for (t = t.a != s || t.overlaps ? 0 : 200; y < m;) {
            var S, N, L, C, M = s[y];
            switch (M[0]) {
                case 0:
                    u = M[1], n && o[b(u).toString()] || !u.Y() ? y = M[2] : void 0 === h || K(h, u.Y().H()) ? ++y : y = M[2] + 1;
                    break;
                case 1:
                    x > t && (e.fill(), x = 0), E > t && (e.stroke(), E = 0), x || E || e.beginPath(), ++y;
                    break;
                case 2:
                    u = M[1], p = l[u], M = l[u + 1], g = l[u + 2] - p, u = l[u + 3] - M, u = Math.sqrt(g * g + u * u), e.moveTo(p + u, M), e.arc(p, M, u, 0, 2 * Math.PI, !0), ++y;
                    break;
                case 3:
                    e.closePath(), ++y;
                    break;
                case 4:
                    u = M[1], p = M[2], S = M[3], N = M[4] * i, L = M[5] * i;
                    var I = M[6],
                        k = M[7],
                        T = M[8],
                        A = M[9];
                    C = M[10], g = M[11], d = M[12];
                    var R = M[13],
                        _ = M[14];
                    for (C && (g += r); u < p; u += 2) {
                        if (M = l[u] - N, C = l[u + 1] - L, R && (M = Math.round(M), C = Math.round(C)), 1 != d || 0 !== g) {
                            var P = M + N,
                                O = C + L;
                            Hl(v, P, O, d, d, g, -P, -O), e.transform.apply(e, v)
                        }
                        P = e.globalAlpha, 1 != k && (e.globalAlpha = P * k);
                        var O = _ + T > S.width ? S.width - T : _,
                            D = I + A > S.height ? S.height - A : I;
                        e.drawImage(S, T, A, O, D, M, C, O * i, D * i), 1 != k && (e.globalAlpha = P), 1 == d && 0 === g || (Yl(Gl(w, v)), e.transform.apply(e, w))
                    }++y;
                    break;
                case 5:
                    for (u = M[1], p = M[2], L = M[3], I = M[4] * i, k = M[5] * i, g = M[6], d = M[7] * i, S = M[8], N = M[9], (C = M[10]) && (g += r); u < p; u += 2) {
                        for (M = l[u] + I, C = l[u + 1] + k, 1 == d && 0 === g || (Hl(v, M, C, d, d, g, -M, -C), e.transform.apply(e, v)), T = L.split("\n"), A = T.length, 1 < A ? (R = Math.round(1.5 * e.measureText("M").width), C -= (A - 1) / 2 * R) : R = 0, _ = 0; _ < A; _++) P = T[_], N && e.strokeText(P, M, C), S && e.fillText(P, M, C), C += R;
                        1 == d && 0 === g || (Yl(Gl(w, v)), e.transform.apply(e, w))
                    }++y;
                    break;
                case 6:
                    if (void 0 !== a && (u = M[1], u = a(u))) return u;
                    ++y;
                    break;
                case 7:
                    t ? x++ : e.fill(), ++y;
                    break;
                case 8:
                    for (u = M[1], p = M[2], M = l[u], C = l[u + 1], g = M + .5 | 0, d = C + .5 | 0, g === c && d === f || (e.moveTo(M, C), c = g, f = d), u += 2; u < p; u += 2) M = l[u], C = l[u + 1], g = M + .5 | 0, d = C + .5 | 0, (u == p - 2 || g !== c || d !== f) && (e.lineTo(M, C), c = g, f = d);
                    ++y;
                    break;
                case 9:
                    x && (e.fill(), x = 0), e.fillStyle = M[1], ++y;
                    break;
                case 10:
                    c = void 0 === M[7] || M[7], f = M[2], E && (e.stroke(), E = 0), e.strokeStyle = M[1], e.lineWidth = c ? f * i : f, e.lineCap = M[3], e.lineJoin = M[4], e.miterLimit = M[5], dw && e.setLineDash(M[6]), f = c = NaN, ++y;
                    break;
                case 11:
                    e.font = M[1], e.textAlign = M[2], e.textBaseline = M[3], ++y;
                    break;
                case 12:
                    t ? E++ : e.stroke(), ++y;
                    break;
                default:
                    ++y
            }
        }
        x && e.fill(), E && e.stroke()
    }

    function Mc(t) {
        var e = t.b;
        e.reverse();
        var i, n, r, o = e.length,
            s = -1;
        for (i = 0; i < o; ++i)
            if (n = e[i], r = n[0], 6 == r) s = i;
            else if (0 == r) {
            for (n[2] = i, n = t.b, r = i; s < r;) {
                var a = n[s];
                n[s] = n[r], n[r] = a, ++s, --r
            }
            s = -1
        }
    }

    function Ic(t, e) {
        t.sa[2] = t.a.length, t.sa = null, t.za[2] = t.b.length, t.za = null;
        var i = [6, e];
        t.a.push(i), t.b.push(i)
    }

    function kc(t, e, i, n) { Sc.call(this, t, e, i, n), this.j = this.P = null, this.O = this.D = this.C = this.v = this.T = this.A = this.s = this.o = this.l = this.i = this.g = void 0 }

    function Tc(t, e, i, n) { Sc.call(this, t, e, i, n), this.g = { je: void 0, ee: void 0, fe: null, ge: void 0, he: void 0, ie: void 0, ph: 0, strokeStyle: void 0, lineCap: void 0, lineDash: null, lineJoin: void 0, lineWidth: void 0, miterLimit: void 0 } }

    function Ac(t, e, i, n, r) { var o = t.coordinates.length; return e = Nc(t, e, i, n, r, !1), o = [8, o, e], t.a.push(o), t.b.push(o), n }

    function Rc(t) {
        var e = t.g,
            i = e.strokeStyle,
            n = e.lineCap,
            r = e.lineDash,
            o = e.lineJoin,
            s = e.lineWidth,
            a = e.miterLimit;
        e.je == i && e.ee == n && ge(e.fe, r) && e.ge == o && e.he == s && e.ie == a || (e.ph != t.coordinates.length && (t.a.push([12]), e.ph = t.coordinates.length), t.a.push([10, i, s, n, o, a, r], [1]), e.je = i, e.ee = n, e.fe = r, e.ge = o, e.he = s, e.ie = a)
    }

    function _c(t, e, i, n) { Sc.call(this, t, e, i, n), this.g = { yi: void 0, je: void 0, ee: void 0, fe: null, ge: void 0, he: void 0, ie: void 0, fillStyle: void 0, strokeStyle: void 0, lineCap: void 0, lineDash: null, lineJoin: void 0, lineWidth: void 0, miterLimit: void 0 } }

    function Pc(t, e, i, n, r) {
        var o = t.g,
            s = void 0 !== o.fillStyle,
            o = void 0 != o.strokeStyle,
            a = n.length;
        if (!s && !o) return n[a - 1];
        var h = [1];
        for (t.a.push(h), t.b.push(h), h = 0; h < a; ++h) {
            var l = n[h],
                u = t.coordinates.length;
            i = Nc(t, e, i, l, r, !0), i = [8, u, i], t.a.push(i), t.b.push(i), o && (i = [3], t.a.push(i), t.b.push(i)), i = l
        }
        return e = [7], t.b.push(e), s && t.a.push(e), o && (s = [12], t.a.push(s), t.b.push(s)), i
    }

    function Oc(t) {
        var e = t.g,
            i = e.fillStyle,
            n = e.strokeStyle,
            r = e.lineCap,
            o = e.lineDash,
            s = e.lineJoin,
            a = e.lineWidth,
            h = e.miterLimit;
        void 0 !== i && e.yi != i && (t.a.push([9, i]), e.yi = e.fillStyle), void 0 === n || e.je == n && e.ee == r && e.fe == o && e.ge == s && e.he == a && e.ie == h || (t.a.push([10, n, a, r, s, h, o]), e.je = n, e.ee = r, e.fe = o, e.ge = s, e.he = a, e.ie = h)
    }

    function Dc(t, e, i, n) { Sc.call(this, t, e, i, n), this.O = this.D = this.C = null, this.j = "", this.s = this.o = 0, this.A = void 0, this.v = this.T = 0, this.l = this.i = this.g = null }

    function Fc(t, e, i, n, r) {
        if ("" !== t.j && t.l && (t.g || t.i)) {
            if (t.g) {
                var o = t.g,
                    s = t.C;
                if (!s || s.fillStyle != o.fillStyle) {
                    var a = [9, o.fillStyle];
                    t.a.push(a), t.b.push(a), s ? s.fillStyle = o.fillStyle : t.C = { fillStyle: o.fillStyle }
                }
            }
            t.i && (o = t.i, s = t.D, s && s.lineCap == o.lineCap && s.lineDash == o.lineDash && s.lineJoin == o.lineJoin && s.lineWidth == o.lineWidth && s.miterLimit == o.miterLimit && s.strokeStyle == o.strokeStyle || (a = [10, o.strokeStyle, o.lineWidth, o.lineCap, o.lineJoin, o.miterLimit, o.lineDash, !1], t.a.push(a), t.b.push(a), s ? (s.lineCap = o.lineCap, s.lineDash = o.lineDash, s.lineJoin = o.lineJoin, s.lineWidth = o.lineWidth, s.miterLimit = o.miterLimit, s.strokeStyle = o.strokeStyle) : t.D = { lineCap: o.lineCap, lineDash: o.lineDash, lineJoin: o.lineJoin, lineWidth: o.lineWidth, miterLimit: o.miterLimit, strokeStyle: o.strokeStyle })), o = t.l, s = t.O,
                s && s.font == o.font && s.textAlign == o.textAlign && s.textBaseline == o.textBaseline || (a = [11, o.font, o.textAlign, o.textBaseline], t.a.push(a), t.b.push(a), s ? (s.font = o.font, s.textAlign = o.textAlign, s.textBaseline = o.textBaseline) : t.O = { font: o.font, textAlign: o.textAlign, textBaseline: o.textBaseline }), Lc(t, r), o = t.coordinates.length, e = Nc(t, e, 0, i, n, !1), e = [5, o, e, t.j, t.o, t.s, t.T, t.v, !!t.g, !!t.i, t.A], t.a.push(e), t.b.push(e), Ic(t, r)
        }
    }

    function Uc(t, e, i, n, r) { this.s = t, this.f = e, this.j = n, this.o = i, this.c = r, this.a = {}, this.i = Ii(1, 1), this.l = Ul() }

    function Bc(t) { for (var e in t.a) { var i, n = t.a[e]; for (i in n) n[i].Jf() } }

    function jc(t, e, i, n, r, o, s) {
        var a = Object.keys(t.a).map(Number);
        a.sort(function(t, e) { return e - t });
        var h, l, u, p, c;
        for (h = 0, l = a.length; h < l; ++h)
            for (p = t.a[a[h].toString()], u = RE.length - 1; 0 <= u; --u)
                if (c = p[RE[u]], void 0 !== c && (c = Cc(c, e, 1, i, n, r, c.b, o, s))) return c
    }

    function zc(t, e) { return b(t) - b(e) }

    function Gc(t, e) { var i = .5 * t / e; return i * i }

    function qc(t, e, i, n, r, o) { var s, a, h = !1; return (s = i.a) && (a = s.Ce(), 2 == a || 3 == a ? s.ai(r, o) : (0 == a && s.load(), s.qh(r, o), h = !0)), (r = (0, i.g)(e)) && (n = r.se(n), (0, PE[n.Z()])(t, n, i, e)), h }

    function Vc(t, e, i, n, r, o) { this.c = void 0 !== o ? o : null, ko.call(this, t, e, i, void 0 !== o ? 0 : 2, n), this.g = r }

    function Wc(t) { _o.call(this, { attributions: t.attributions, logo: t.logo, projection: t.projection, resolutions: t.resolutions, state: t.state }), this.fa = t.canvasFunction, this.U = null, this.X = 0, this.qa = void 0 !== t.ratio ? t.ratio : 1.5 }

    function Xc(t) { this.c = t.source, this.Ua = Ul(), this.i = Ii(), this.j = [0, 0], this.xa = void 0 == t.renderBuffer ? 100 : t.renderBuffer, this.A = null, Wc.call(this, { attributions: t.attributions, canvasFunction: this.hm.bind(this), logo: t.logo, projection: t.projection, ratio: t.ratio, resolutions: t.resolutions, state: this.c.W() }), this.P = null, this.s = void 0, this.Xj(t.style), lt(this.c, "change", this.gq, this) }

    function Hc(t, e, i, n, r) { return i = n / i, Hl(t.Ua, r[0] / 2, r[1] / 2, i, -i, 0, -e[0], -e[1]) }

    function Yc(t) { mc.call(this, t), this.f = null, this.s = Ul(), this.c = this.j = null }

    function Kc(t) { mc.call(this, t), this.c = Ii(), this.j = null, this.o = T(), this.P = [0, 0, 0], this.D = Ul(), this.C = 0 }

    function $c(t, e, i, n) {
        var r, o, s, a = i.pixelRatio,
            h = i.viewState,
            l = h.center,
            u = h.projection,
            p = h.rotation,
            c = i.size,
            f = Math.round(a * c[0] / 2),
            c = Math.round(a * c[1] / 2),
            h = a / h.resolution,
            g = t.a,
            d = g.ja(),
            y = a * d.hf(u),
            m = d.yb(u),
            g = bt(g, "render"),
            v = e,
            b = 1;
        if (p || g) {
            v = t.c, r = v.canvas;
            var b = d.Tb(a) / a,
                w = e.canvas.width * b;
            o = e.canvas.height * b, s = Math.round(Math.sqrt(w * w + o * o)), r.width != s ? r.width = r.height = s : v.clearRect(0, 0, s, s), r = (s - w) / 2 / b, o = (s - o) / 2 / b, h *= b, f = Math.round(b * (f + r)), c = Math.round(b * (c + o))
        }
        w = v.globalAlpha, v.globalAlpha = n.opacity;
        var x, E = t.j,
            S = d.Yg(u) && 1 == n.opacity;
        S || (E.reverse(), x = []);
        var N = n.extent;
        if (n = void 0 !== N) {
            var L = X(N),
                C = H(N),
                M = z(N),
                N = j(N);
            ql(i.coordinateToPixelTransform, L), ql(i.coordinateToPixelTransform, C), ql(i.coordinateToPixelTransform, M), ql(i.coordinateToPixelTransform, N);
            var I = r || 0,
                k = o || 0;
            v.save();
            var T = v.canvas.width / 2,
                A = v.canvas.height / 2;
            Oi(v, -p, T, A), v.beginPath(), v.moveTo(b * (L[0] * a + I), b * (L[1] * a + k)), v.lineTo(b * (C[0] * a + I), b * (C[1] * a + k)), v.lineTo(b * (M[0] * a + I), b * (M[1] * a + k)), v.lineTo(b * (N[0] * a + I), b * (N[1] * a + k)), v.clip(), Oi(v, p, T, A)
        }
        for (L = 0, C = E.length; L < C; ++L) {
            var M = E[L],
                N = M.ta,
                A = m.Na(N, t.o),
                T = N[0],
                R = j(m.Na(m.ue(l, T, t.P))),
                N = Math.round(Y(A) * h),
                I = Math.round(V(A) * h),
                k = Math.round((A[0] - R[0]) * h / N) * N + f + Math.round((R[0] - l[0]) * h),
                A = Math.round((R[1] - A[3]) * h / I) * I + c + Math.round((l[1] - R[1]) * h);
            if (!S) {
                R = [k, A, k + N, A + I], v.save();
                for (var _ = 0, P = x.length; _ < P; ++_) {
                    var O = x[_];
                    K(R, O) && (v.beginPath(), v.moveTo(R[0], R[1]), v.lineTo(R[0], R[3]), v.lineTo(R[2], R[3]), v.lineTo(R[2], R[1]), v.moveTo(O[0], O[1]), v.lineTo(O[2], O[1]), v.lineTo(O[2], O[3]), v.lineTo(O[0], O[3]), v.closePath(), v.clip())
                }
                x.push(R)
            }
            T = d.$g(T, a, u), v.drawImage(M.ub(), y, y, T[0], T[1], k, A, N, I), S || v.restore()
        }
        n && v.restore(), g && (a = r - f / b + f, u = o - c / b + c, l = Hl(t.D, s / 2 - a, s / 2 - u, h, -h, -p, -l[0] + a / h, -l[1] - u / h), bc(t, "render", v, i, l)), (p || g) && e.drawImage(v.canvas, -Math.round(r), -Math.round(o), s / b, s / b), v.globalAlpha = w
    }

    function Zc(t) { mc.call(this, t), this.c = !1, this.C = -1, this.v = NaN, this.A = T(), this.j = this.T = null, this.o = Ii() }

    function Jc(t) { Kc.call(this, t), this.T = !1, this.A = Ul(), this.C = "vector" == t.s ? 1 : 0 }

    function Qc(t, e, i) {
        function n(t) {
            var e, i = t.Tc();
            if (i ? e = i.call(t, d) : (i = r.i) && (e = i(t, d)), e) {
                Array.isArray(e) || (e = [e]);
                var i = v,
                    n = m;
                if (e) {
                    var o = !1;
                    if (Array.isArray(e))
                        for (var s = 0, a = e.length; s < a; ++s) o = qc(n, t, e[s], i, this.v, this) || o;
                    else o = qc(n, t, e, i, this.v, this) || o;
                    t = o
                } else t = !1;
                this.T = this.T || t, h.ke = h.ke || t
            }
        }
        var r = t.a,
            o = i.pixelRatio;
        i = i.viewState.projection;
        var s = r.g,
            a = Xr(r) || null,
            h = e.f;
        if (h.ke || h.Gk != s || h.Vh != a) {
            h.He = null, h.ke = !1;
            var l, u = r.ja(),
                p = u.tileGrid,
                c = e.ta,
                f = e.j,
                g = "tile-pixels" == f.Ub(),
                d = p.aa(c[0]);
            if (g) var y = g = u.Tb(),
                p = gn(p.gb(c[0])),
                p = [0, 0, p[0] * y, p[1] * y];
            else g = d, p = p.Na(c), Vt(i, f) || (l = !0, e.xh(i));
            h.ke = !1;
            var m = new Uc(0, p, g, u.i, r.a),
                v = Gc(g, o);
            for (e = e.c, a && a !== h.Vh && e.sort(a), u = 0, g = e.length; u < g; ++u) o = e[u], l && o.Y().Db(f, i), n.call(t, o);
            Bc(m), h.Gk = s, h.Vh = a, h.He = m, h.resolution = NaN
        }
    }

    function tf(t, e) { Kl.call(this, 0, e), this.f = Ii(), this.b = this.f.canvas, this.b.style.width = "100%", this.b.style.height = "100%", this.b.className = "ol-unselectable", t.insertBefore(this.b, t.childNodes[0] || null), this.a = !0, this.c = Ul() }

    function ef(t, e, i) {
        var n = t.i,
            r = t.f;
        if (bt(n, e)) {
            var o = i.extent,
                s = i.pixelRatio,
                a = i.viewState.rotation,
                h = i.viewState,
                l = i.pixelRatio / h.resolution;
            t = Hl(t.c, t.b.width / 2, t.b.height / 2, l, -l, -h.rotation, -h.center[0], -h.center[1]), n.b(new jr(e, new ec(r, s, o, t, a), i, r, null))
        }
    }

    function nf(t, e) { hc.call(this, t), this.target = e }

    function rf(t) {
        var e = document.createElement("DIV");
        e.style.position = "absolute", nf.call(this, t, e), this.f = null, this.c = Ul()
    }

    function of(t) {
        var e = document.createElement("DIV");
        e.style.position = "absolute", nf.call(this, t, e), this.c = !0, this.l = 1, this.i = 0, this.f = {}
    }

    function sf(t, e) { this.target = document.createElement("DIV"), this.target.style.position = "absolute", this.target.style.width = "100%", this.target.style.height = "100%", this.c = t, this.g = e, this.i = X(t.Na(e)), this.l = t.aa(e[0]), this.a = {}, this.b = null, this.f = Ul(), this.j = [0, 0] }

    function af(t) {
        this.i = Ii();
        var e = this.i.canvas;
        e.style.maxWidth = "none", e.style.position = "absolute", nf.call(this, t, e), this.f = !1, this.l = -1, this.s = NaN, this.j = T(), this.c = this.o = null, this.T = Ul(), this.A = Ul()
    }

    function hf(t, e, i, n) {
        var r = t.i;
        t = t.a, bt(t, e) && t.b(new jr(e, new ec(r, i.pixelRatio, i.extent, n, i.viewState.rotation), i, r, null))
    }

    function lf(t, e) {
        Kl.call(this, 0, e), this.f = Ii();
        var i = this.f.canvas;
        i.style.position = "absolute", i.style.width = "100%", i.style.height = "100%", i.className = "ol-unselectable", t.insertBefore(i, t.childNodes[0] || null), this.c = Ul(), this.b = document.createElement("DIV"), this.b.className = "ol-unselectable", i = this.b.style, i.position = "absolute", i.width = "100%", i.height = "100%", lt(this.b, "touchstart", mt), t.insertBefore(this.b, t.childNodes[0] || null), this.a = !0
    }

    function uf(t, e, i) {
        var n = t.i;
        if (bt(n, e)) {
            var r = i.extent,
                o = i.pixelRatio,
                s = i.viewState,
                a = s.rotation,
                h = t.f,
                l = h.canvas;
            t = Hl(t.c, l.width / 2, l.height / 2, o / s.resolution, -o / s.resolution, -a, -s.center[0], -s.center[1]), n.b(new jr(e, new ec(h, o, r, t, a), i, h, null))
        }
    }

    function pf(t) { this.b = t }

    function cf(t) { this.b = t }

    function ff(t) { this.b = t }

    function gf() { this.b = "precision mediump float;varying vec2 a;varying float b;uniform float k;uniform sampler2D l;void main(void){vec4 texColor=texture2D(l,a);gl_FragColor.rgb=texColor.rgb;float alpha=texColor.a*b*k;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}" }

    function df() { this.b = "varying vec2 a;varying float b;attribute vec2 c;attribute vec2 d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;void main(void){mat4 offsetMatrix=i;if(g==1.0){offsetMatrix=i*j;}vec4 offsets=offsetMatrix*vec4(e,0.,0.);gl_Position=h*vec4(c,0.,1.)+offsets;a=d;b=f;}" }

    function yf(t, e) { this.j = t.getUniformLocation(e, "j"), this.o = t.getUniformLocation(e, "i"), this.i = t.getUniformLocation(e, "k"), this.l = t.getUniformLocation(e, "h"), this.b = t.getAttribLocation(e, "e"), this.a = t.getAttribLocation(e, "f"), this.f = t.getAttribLocation(e, "c"), this.g = t.getAttribLocation(e, "g"), this.c = t.getAttribLocation(e, "d") }

    function mf(t) { this.b = void 0 !== t ? t : [], this.a = BE }

    function vf(t, e) { this.l = t, this.b = e, this.a = {}, this.c = {}, this.f = {}, this.o = this.s = this.i = this.j = null, (this.g = he(cb, "OES_element_index_uint")) && e.getExtension("OES_element_index_uint"), lt(this.l, "webglcontextlost", this.Yq, this), lt(this.l, "webglcontextrestored", this.Zq, this) }

    function bf(t, e, i) {
        var n = t.b,
            r = i.b,
            o = String(b(i));
        if (o in t.a) n.bindBuffer(e, t.a[o].buffer);
        else {
            var s = n.createBuffer();
            n.bindBuffer(e, s);
            var a;
            34962 == e ? a = new Float32Array(r) : 34963 == e && (a = t.g ? new Uint32Array(r) : new Uint16Array(r)), n.bufferData(e, a, i.a), t.a[o] = { cc: i, buffer: s }
        }
    }

    function wf(t, e) {
        var i = t.b,
            n = String(b(e)),
            r = t.a[n];
        i.isContextLost() || i.deleteBuffer(r.buffer), delete t.a[n]
    }

    function xf(t) {
        if (!t.i) {
            var e = t.b,
                i = e.createFramebuffer();
            e.bindFramebuffer(e.FRAMEBUFFER, i);
            var n = Lf(e, 1, 1),
                r = e.createRenderbuffer();
            e.bindRenderbuffer(e.RENDERBUFFER, r), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, 1, 1), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, r), e.bindTexture(e.TEXTURE_2D, null), e.bindRenderbuffer(e.RENDERBUFFER, null), e.bindFramebuffer(e.FRAMEBUFFER, null), t.i = i, t.s = n, t.o = r
        }
        return t.i
    }

    function Ef(t, e) {
        var i = String(b(e));
        if (i in t.c) return t.c[i];
        var n = t.b,
            r = n.createShader(e.Z());
        return n.shaderSource(r, e.b), n.compileShader(r), t.c[i] = r
    }

    function Sf(t, e, i) {
        var n = b(e) + "/" + b(i);
        if (n in t.f) return t.f[n];
        var r = t.b,
            o = r.createProgram();
        return r.attachShader(o, Ef(t, e)), r.attachShader(o, Ef(t, i)), r.linkProgram(o), t.f[n] = o
    }

    function Nf(t, e, i) { var n = t.createTexture(); return t.bindTexture(t.TEXTURE_2D, n), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), void 0 !== e && t.texParameteri(3553, 10242, e), void 0 !== i && t.texParameteri(3553, 10243, i), n }

    function Lf(t, e, i) { var n = Nf(t, void 0, void 0); return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e, i, 0, t.RGBA, t.UNSIGNED_BYTE, null), n }

    function Cf(t, e) { var i = Nf(t, 33071, 33071); return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e), i }

    function Mf(t, e) { this.C = this.v = void 0, this.o = G(e), this.T = [], this.i = [], this.O = void 0, this.c = [], this.f = [], this.za = this.sa = void 0, this.a = [], this.D = this.j = null, this.P = void 0, this.Ta = Ul(), this.Ua = Ul(), this.X = this.U = void 0, this.sb = Ul(), this.ra = Ci(), this.vb = this.fa = this.Xa = void 0, this.xa = [], this.l = [], this.b = [], this.A = null, this.g = [], this.s = [], this.qa = void 0 }

    function If(t, e) {
        var i = t.A,
            n = t.j,
            r = t.xa,
            o = t.l,
            s = e.b;
        return function() {
            if (!s.isContextLost()) { var t, a; for (t = 0, a = r.length; t < a; ++t) s.deleteTexture(r[t]); for (t = 0, a = o.length; t < a; ++t) s.deleteTexture(o[t]) }
            wf(e, i), wf(e, n)
        }
    }

    function kf(t, e, i, n) {
        var r, o, s, a, h, l, u = t.v,
            p = t.C,
            c = t.O,
            f = t.sa,
            g = t.za,
            d = t.P,
            y = t.U,
            m = t.X,
            v = t.Xa ? 1 : 0,
            b = t.fa,
            w = t.vb,
            x = t.qa,
            E = Math.cos(b),
            b = Math.sin(b),
            S = t.a.length,
            N = t.b.length;
        for (r = 0; r < i; r += n) h = e[r] - t.o[0], l = e[r + 1] - t.o[1], o = N / 8, s = -w * u, a = -w * (c - p), t.b[N++] = h, t.b[N++] = l, t.b[N++] = s * E - a * b, t.b[N++] = s * b + a * E, t.b[N++] = y / g, t.b[N++] = (m + c) / f, t.b[N++] = d, t.b[N++] = v, s = w * (x - u), a = -w * (c - p), t.b[N++] = h, t.b[N++] = l, t.b[N++] = s * E - a * b, t.b[N++] = s * b + a * E, t.b[N++] = (y + x) / g, t.b[N++] = (m + c) / f, t.b[N++] = d, t.b[N++] = v, s = w * (x - u), a = w * p, t.b[N++] = h, t.b[N++] = l, t.b[N++] = s * E - a * b, t.b[N++] = s * b + a * E, t.b[N++] = (y + x) / g, t.b[N++] = m / f, t.b[N++] = d, t.b[N++] = v, s = -w * u, a = w * p, t.b[N++] = h, t.b[N++] = l, t.b[N++] = s * E - a * b, t.b[N++] = s * b + a * E, t.b[N++] = y / g, t.b[N++] = m / f, t.b[N++] = d, t.b[N++] = v, t.a[S++] = o, t.a[S++] = o + 1, t.a[S++] = o + 2, t.a[S++] = o, t.a[S++] = o + 2, t.a[S++] = o + 3
    }

    function Tf(t, e) {
        var i = e.b;
        t.T.push(t.a.length), t.i.push(t.a.length), t.A = new mf(t.b), bf(e, 34962, t.A), t.j = new mf(t.a), bf(e, 34963, t.j);
        var n = {};
        Af(t.xa, t.c, n, i), Af(t.l, t.f, n, i), t.v = void 0, t.C = void 0, t.O = void 0, t.c = null, t.f = null, t.sa = void 0, t.za = void 0, t.a = null, t.P = void 0, t.U = void 0, t.X = void 0, t.Xa = void 0, t.fa = void 0, t.vb = void 0, t.b = null, t.qa = void 0
    }

    function Af(t, e, i, n) { var r, o, s, a = e.length; for (s = 0; s < a; ++s) r = e[s], o = b(r).toString(), o in i ? r = i[o] : (r = Cf(n, r), i[o] = r), t[s] = r }

    function Rf(t, e, i, n, r, o) {
        var s = i.g ? 5125 : 5123;
        if (i = i.g ? 4 : 2, nt(n)) {
            var a;
            for (t = 0, n = r.length, a = 0; t < n; ++t) {
                e.bindTexture(3553, r[t]);
                var h = o[t];
                e.drawElements(4, h - a, s, a * i), a = h
            }
        } else {
            a = 0;
            var l, h = 0;
            for (l = r.length; h < l; ++h) {
                e.bindTexture(3553, r[h]);
                for (var u = 0 < h ? o[h - 1] : 0, p = o[h], c = u; a < t.g.length && t.g[a] <= p;) {
                    var f = b(t.s[a]).toString();
                    void 0 !== n[f] ? (c !== u && e.drawElements(4, u - c, s, c * i), u = c = a === t.g.length - 1 ? p : t.g[a + 1]) : u = a === t.g.length - 1 ? p : t.g[a + 1], a++
                }
                c !== u && e.drawElements(4, u - c, s, c * i)
            }
        }
    }

    function _f(t, e, i) { this.c = e, this.i = t, this.f = i, this.a = {} }

    function Pf(t, e) { var i, n = []; for (i in t.a) n.push(If(t.a[i], e)); return function() { for (var t, e = n.length, i = 0; i < e; i++) t = n[i].apply(this, arguments); return t } }

    function Of(t, e) { for (var i in t.a) Tf(t.a[i], e) }

    function Df(t, e, i, n, r, o, s, a, h, l, u) {
        var p, c, f = zE;
        for (p = RE.length - 1; 0 <= p; --p)
            if (c = t.a[RE[p]], void 0 !== c && (c = c.jb(e, i, n, r, f, o, s, a, h, l, u))) return c
    }

    function Ff(t, e, i, n, r, o, s, a) { var h = i.b; return h.bindFramebuffer(h.FRAMEBUFFER, xf(i)), void 0 !== Df(t, i, e, n, r, o, s, a, function() { var t = new Uint8Array(4); return h.readPixels(0, 0, 1, 1, h.RGBA, h.UNSIGNED_BYTE, t), 0 < t[3] }, !1) }

    function Uf(t, e, i, n, r, o, s) { this.b = t, this.f = e, this.g = o, this.c = s, this.j = r, this.l = n, this.i = i, this.a = null }

    function Bf() { this.b = "precision mediump float;varying vec2 a;uniform float f;uniform sampler2D g;void main(void){vec4 texColor=texture2D(g,a);gl_FragColor.rgb=texColor.rgb;gl_FragColor.a=texColor.a*f;}" }

    function jf() { this.b = "varying vec2 a;attribute vec2 b;attribute vec2 c;uniform mat4 d;uniform mat4 e;void main(void){gl_Position=e*vec4(b,0.,1.);a=(d*vec4(c,0.,1.)).st;}" }

    function zf(t, e) { this.g = t.getUniformLocation(e, "f"), this.f = t.getUniformLocation(e, "e"), this.i = t.getUniformLocation(e, "d"), this.c = t.getUniformLocation(e, "g"), this.b = t.getAttribLocation(e, "b"), this.a = t.getAttribLocation(e, "c") }

    function Gf(t, e) { hc.call(this, e), this.f = t, this.U = new mf([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]), this.i = this.Mb = null, this.l = void 0, this.s = Ul(), this.T = Ul(), this.C = Ci(), this.A = null }

    function qf(t, e, i) {
        var n = t.f.f;
        if (void 0 === t.l || t.l != i) {
            e.postRenderFunctions.push(function(t, e, i) { t.isContextLost() || (t.deleteFramebuffer(e), t.deleteTexture(i)) }.bind(null, n, t.i, t.Mb)), e = Lf(n, i, i);
            var r = n.createFramebuffer();
            n.bindFramebuffer(36160, r), n.framebufferTexture2D(36160, 36064, 3553, e, 0), t.Mb = e, t.i = r, t.l = i
        } else n.bindFramebuffer(36160, t.i)
    }

    function Vf(t, e, i, n) {
        if (t = t.a, bt(t, e)) {
            var r = n.viewState;
            t.b(new jr(e, new Uf(i, r.center, r.resolution, r.rotation, n.size, n.extent, n.pixelRatio), n, null, i))
        }
    }

    function Wf(t, e) { Gf.call(this, t, e), this.o = this.j = this.c = null }

    function Xf(t, e) { var i = e.a(); return Cf(t.f.f, i) }

    function Hf(t, e, i, n, r, o, s, a) { e *= o, i *= o, t = t.T, Bl(t), Wl(t, 2 * n / e, 2 * n / i), Vl(t, -s), Xl(t, a[0] - r[0], a[1] - r[1]), Wl(t, (a[2] - a[0]) / 2, (a[3] - a[1]) / 2), Xl(t, 1, 1) }

    function Yf() { this.b = "precision mediump float;varying vec2 a;uniform sampler2D e;void main(void){gl_FragColor=texture2D(e,a);}" }

    function Kf() { this.b = "varying vec2 a;attribute vec2 b;attribute vec2 c;uniform vec4 d;void main(void){gl_Position=vec4(b*d.xy+d.zw,0.,1.);a=c;}" }

    function $f(t, e) { this.g = t.getUniformLocation(e, "e"), this.f = t.getUniformLocation(e, "d"), this.b = t.getAttribLocation(e, "b"), this.a = t.getAttribLocation(e, "c") }

    function Zf(t, e) { Gf.call(this, t, e), this.O = VE, this.X = WE, this.c = null, this.D = new mf([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0]), this.v = this.j = null, this.o = -1, this.P = [0, 0] }

    function Jf(t, e) { Gf.call(this, t, e), this.o = !1, this.P = -1, this.O = NaN, this.v = T(), this.j = this.c = this.D = null }

    function Qf(t, e) {
        Kl.call(this, 0, e), this.b = document.createElement("CANVAS"), this.b.style.width = "100%", this.b.style.height = "100%", this.b.className = "ol-unselectable", t.insertBefore(this.b, t.childNodes[0] || null), this.T = this.v = 0, this.C = Ii(), this.o = !0, this.f = Pi(this.b, { antialias: !0, depth: !1, failIfMajorPerformanceCaveat: !0, preserveDrawingBuffer: !1, stencil: !0 }), this.c = new vf(this.b, this.f), lt(this.b, "webglcontextlost", this.Pp, this), lt(this.b, "webglcontextrestored", this.Qp, this), this.a = new Kr, this.A = null, this.j = new eu(function(t) {
            var e = t[1];
            t = t[2];
            var i = e[0] - this.A[0],
                e = e[1] - this.A[1];
            return 65536 * Math.log(t) + Math.sqrt(i * i + e * e) / t
        }.bind(this), function(t) { return t[0].pb() }), this.D = function() {
            if (0 !== this.j.b.length) {
                ou(this.j);
                var t = iu(this.j);
                tg(this, t[0], t[3], t[4])
            }
            return !1
        }.bind(this), this.l = 0, ig(this)
    }

    function tg(t, e, i, n) {
        var r = t.f,
            o = e.pb();
        if (t.a.b.hasOwnProperty(o)) t = t.a.get(o), r.bindTexture(3553, t.Mb), 9729 != t.qj && (r.texParameteri(3553, 10240, 9729), t.qj = 9729), 9729 != t.sj && (r.texParameteri(3553, 10241, 9729), t.sj = 9729);
        else {
            var s = r.createTexture();
            if (r.bindTexture(3553, s), 0 < n) {
                var a = t.C.canvas,
                    h = t.C;
                t.v !== i[0] || t.T !== i[1] ? (a.width = i[0], a.height = i[1], t.v = i[0], t.T = i[1]) : h.clearRect(0, 0, i[0], i[1]), h.drawImage(e.ub(), n, n, i[0], i[1], 0, 0, i[0], i[1]), r.texImage2D(3553, 0, 6408, 6408, 5121, a)
            } else r.texImage2D(3553, 0, 6408, 6408, 5121, e.ub());
            r.texParameteri(3553, 10240, 9729), r.texParameteri(3553, 10241, 9729), r.texParameteri(3553, 10242, 33071), r.texParameteri(3553, 10243, 33071), t.a.set(o, { Mb: s, qj: 9729, sj: 9729 })
        }
    }

    function eg(t, e, i) {
        var n = t.i;
        if (bt(n, e)) {
            t = t.c;
            var r = i.viewState;
            n.b(new jr(e, new Uf(t, r.center, r.resolution, r.rotation, i.size, i.extent, i.pixelRatio), i, null, t))
        }
    }

    function ig(t) { t = t.f, t.activeTexture(33984), t.blendFuncSeparate(770, 771, 1, 771), t.disable(2884), t.disable(2929), t.disable(3089), t.disable(2960) }

    function ng(t) {
        St.call(this);
        var e = rg(t);
        this.Bg = void 0 !== t.loadTilesWhileAnimating && t.loadTilesWhileAnimating, this.Eg = void 0 !== t.loadTilesWhileInteracting && t.loadTilesWhileInteracting, this.Rg = void 0 !== t.pixelRatio ? t.pixelRatio : gw, this.Kg = e.logos, this.Ua = function() { this.i = void 0, this.Tr.call(this, Date.now()) }.bind(this), this.qg = Ul(), this.om = Ul(), this.wg = 0, this.f = null, this.Te = T(), this.X = this.ra = null, this.a = document.createElement("DIV"), this.a.className = "ol-viewport" + (bw ? " ol-touch" : ""), this.a.style.position = "relative", this.a.style.overflow = "hidden", this.a.style.width = "100%", this.a.style.height = "100%", this.a.style.msTouchAction = "none", this.a.style.touchAction = "none", this.O = document.createElement("DIV"), this.O.className = "ol-overlaycontainer", this.a.appendChild(this.O), this.D = document.createElement("DIV"), this.D.className = "ol-overlaycontainer-stopevent", t = ["click", "dblclick", "mousedown", "touchstart", "mspointerdown", yE, "mousewheel", "wheel"];
        for (var i = 0, n = t.length; i < n; ++i) lt(this.D, t[i], yt);
        this.a.appendChild(this.D), this.Hb = new Ol(this);
        for (var r in bE) lt(this.Hb, bE[r], this.gj, this);
        this.sb = e.keyboardEventTarget, this.v = null, lt(this.a, "wheel", this.Fd, this), lt(this.a, "mousewheel", this.Fd, this), this.j = e.controls, this.l = e.interactions, this.A = e.overlays, this.Eh = {}, this.C = new e.Ur(this.a, this), this.Ta = null, this.fa = [], this.Se = [], this.bc = new su(this.en.bind(this), this.ho.bind(this)), this.jg = {}, lt(this, Nt("layergroup"), this.Kn, this), lt(this, Nt("view"), this.jo, this), lt(this, Nt("size"), this.co, this), lt(this, Nt("target"), this.fo, this), this.G(e.values), this.j.forEach(function(t) { t.setMap(this) }, this), lt(this.j, _w, function(t) { t.element.setMap(this) }, this), lt(this.j, Pw, function(t) { t.element.setMap(null) }, this), this.l.forEach(function(t) { t.setMap(this) }, this), lt(this.l, _w, function(t) { t.element.setMap(this) }, this), lt(this.l, Pw, function(t) { t.element.setMap(null) }, this), this.A.forEach(this.pi, this), lt(this.A, _w, function(t) { this.pi(t.element) }, this), lt(this.A, Pw, function(t) {
            var e = t.element.Ja();
            void 0 !== e && delete this.Eh[e.toString()], t.element.setMap(null)
        }, this)
    }

    function rg(t) {
        var e = null;
        void 0 !== t.keyboardEventTarget && (e = "string" == typeof t.keyboardEventTarget ? document.getElementById(t.keyboardEventTarget) : t.keyboardEventTarget);
        var i = {},
            n = {};
        if (void 0 === t.logo || "boolean" == typeof t.logo && t.logo) n["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAAHGAAABxgEXwfpGAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAhNQTFRF////AP//AICAgP//AFVVQECA////K1VVSbbbYL/fJ05idsTYJFtbbcjbJllmZszWWMTOIFhoHlNiZszTa9DdUcHNHlNlV8XRIVdiasrUHlZjIVZjaMnVH1RlIFRkH1RkH1ZlasvYasvXVsPQH1VkacnVa8vWIVZjIFRjVMPQa8rXIVVkXsXRsNveIFVkIFZlIVVj3eDeh6GmbMvXH1ZkIFRka8rWbMvXIFVkIFVjIFVkbMvWH1VjbMvWIFVlbcvWIFVla8vVIFVkbMvWbMvVH1VkbMvWIFVlbcvWIFVkbcvVbMvWjNPbIFVkU8LPwMzNIFVkbczWIFVkbsvWbMvXIFVkRnB8bcvW2+TkW8XRIFVkIlZlJVloJlpoKlxrLl9tMmJwOWd0Omh1RXF8TneCT3iDUHiDU8LPVMLPVcLPVcPQVsPPVsPQV8PQWMTQWsTQW8TQXMXSXsXRX4SNX8bSYMfTYcfTYsfTY8jUZcfSZsnUaIqTacrVasrVa8jTa8rWbI2VbMvWbcvWdJObdcvUdszUd8vVeJaee87Yfc3WgJyjhqGnitDYjaarldPZnrK2oNbborW5o9bbo9fbpLa6q9ndrL3ArtndscDDutzfu8fJwN7gwt7gxc/QyuHhy+HizeHi0NfX0+Pj19zb1+Tj2uXk29/e3uLg3+Lh3+bl4uXj4ufl4+fl5Ofl5ufl5ujm5+jmySDnBAAAAFp0Uk5TAAECAgMEBAYHCA0NDg4UGRogIiMmKSssLzU7PkJJT1JTVFliY2hrdHZ3foSFhYeJjY2QkpugqbG1tre5w8zQ09XY3uXn6+zx8vT09vf4+Pj5+fr6/P39/f3+gz7SsAAAAVVJREFUOMtjYKA7EBDnwCPLrObS1BRiLoJLnte6CQy8FLHLCzs2QUG4FjZ5GbcmBDDjxJBXDWxCBrb8aM4zbkIDzpLYnAcE9VXlJSWlZRU13koIeW57mGx5XjoMZEUqwxWYQaQbSzLSkYGfKFSe0QMsX5WbjgY0YS4MBplemI4BdGBW+DQ11eZiymfqQuXZIjqwyadPNoSZ4L+0FVM6e+oGI6g8a9iKNT3o8kVzNkzRg5lgl7p4wyRUL9Yt2jAxVh6mQCogae6GmflI8p0r13VFWTHBQ0rWPW7ahgWVcPm+9cuLoyy4kCJDzCm6d8PSFoh0zvQNC5OjDJhQopPPJqph1doJBUD5tnkbZiUEqaCnB3bTqLTFG1bPn71kw4b+GFdpLElKIzRxxgYgWNYc5SCENVHKeUaltHdXx0dZ8uBI1hJ2UUDgq82CM2MwKeibqAvSO7MCABq0wXEPiqWEAAAAAElFTkSuQmCC"] = "http://openlayers.org/";
        else { var r = t.logo; "string" == typeof r ? n[r] = "" : r instanceof HTMLElement ? n[b(r).toString()] = r : r && (x("string" == typeof r.href, 44), x("string" == typeof r.src, 45), n[r.src] = r.href) }
        r = t.layers instanceof Br ? t.layers : new Br({ layers: t.layers }), i.layergroup = r, i.target = t.target, i.view = void 0 !== t.view ? t.view : new Cu;
        var o, r = Kl;
        void 0 !== t.renderer ? Array.isArray(t.renderer) ? o = t.renderer : "string" == typeof t.renderer ? o = [t.renderer] : x(!1, 46) : o = XE;
        var s, a;
        for (s = 0, a = o.length; s < a; ++s) { var h = o[s]; if ("canvas" == h) { if (yw) { r = tf; break } } else { if ("dom" == h) { r = lf; break } if ("webgl" == h && ew) { r = Qf; break } } }
        return void 0 !== t.controls ? Array.isArray(t.controls) ? o = new Wn(t.controls.slice()) : (x(t.controls instanceof Wn, 47), o = t.controls) : o = Yu(), void 0 !== t.interactions ? Array.isArray(t.interactions) ? s = new Wn(t.interactions.slice()) : (x(t.interactions instanceof Wn, 48), s = t.interactions) : s = Hp(), void 0 !== t.overlays ? Array.isArray(t.overlays) ? t = new Wn(t.overlays.slice()) : (x(t.overlays instanceof Wn, 49), t = t.overlays) : t = new Wn, { controls: o, interactions: s, keyboardEventTarget: e, logos: n, overlays: t, Ur: r, values: i }
    }

    function og(t) {
        t = t ? t : {};
        var e = void 0 !== t.className ? t.className : "ol-scale-line";
        this.j = document.createElement("DIV"), this.j.className = e + "-inner", this.f = document.createElement("DIV"), this.f.className = e + " ol-unselectable", this.f.appendChild(this.j), this.A = null, this.o = void 0 !== t.minWidth ? t.minWidth : 64, this.l = !1, this.C = void 0, this.v = "", _u.call(this, { element: this.f, render: t.render ? t.render : sg, target: t.target }), lt(this, Nt(YE), this.O, this), this.D(t.units || JE)
    }

    function sg(t) {
        (t = t.frameState) ? this.A = t.viewState: this.A = null, ag(this)
    }

    function ag(t) {
        var e = t.A;
        if (e) {
            var i = e.projection,
                n = i.Gc(),
                e = i.getPointResolution(e.resolution, e.center) * n,
                n = t.o * e,
                i = "",
                r = t.Ub();
            r == KE ? (i = bb.degrees, e /= i, n < i / 60 ? (i = "″", e *= 3600) : n < i ? (i = "′", e *= 60) : i = "°") : r == $E ? .9144 > n ? (i = "in", e /= .0254) : 1609.344 > n ? (i = "ft", e /= .3048) : (i = "mi", e /= 1609.344) : r == ZE ? (e /= 1852, i = "nm") : r == JE ? 1 > n ? (i = "mm", e *= 1e3) : 1e3 > n ? i = "m" : (i = "km", e /= 1e3) : r == QE ? .9144 > n ? (i = "in", e *= 39.37) : 1609.344 > n ? (i = "ft", e /= .30480061) : (i = "mi", e /= 1609.3472) : x(!1, 33);
            for (var o, r = 3 * Math.floor(Math.log(t.o * e) / Math.log(10));;) { if (o = HE[(r % 3 + 3) % 3] * Math.pow(10, Math.floor(r / 3)), n = Math.round(o / e), isNaN(n)) return t.f.style.display = "none", void(t.l = !1); if (n >= t.o) break;++r }
            e = o + " " + i, t.v != e && (t.j.innerHTML = e, t.v = e), t.C != n && (t.j.style.width = n + "px", t.C = n), t.l || (t.f.style.display = "", t.l = !0)
        } else t.l && (t.f.style.display = "none", t.l = !1)
    }

    function hg(t, e, i, n) {
        function r() { delete gb[s], o.parentNode.removeChild(o) }
        var o = gb.document.createElement("script"),
            s = "olc_" + b(e);
        o.async = !0, o.src = t + (-1 == t.indexOf("?") ? "?" : "&") + (n || "callback") + "=" + s;
        var a = gb.setTimeout(function() { r(), i && i() }, 1e4);
        gb[s] = function(t) { gb.clearTimeout(a), r(), e(t) }, gb.document.getElementsByTagName("head")[0].appendChild(o)
    }

    function lg(t) { St.call(this), this.o = t.id, this.j = void 0 === t.insertFirst || t.insertFirst, this.s = void 0 === t.stopEvent || t.stopEvent, this.f = document.createElement("DIV"), this.f.className = "ol-overlay-container", this.f.style.position = "absolute", this.autoPan = void 0 !== t.autoPan && t.autoPan, this.i = void 0 !== t.autoPanAnimation ? t.autoPanAnimation : {}, this.l = void 0 !== t.autoPanMargin ? t.autoPanMargin : 20, this.a = { Ze: "", Df: "", gg: "", kg: "", visible: !0 }, this.c = null, lt(this, Nt("element"), this.tn, this), lt(this, Nt("map"), this.Pn, this), lt(this, Nt("offset"), this.Tn, this), lt(this, Nt("position"), this.Wn, this), lt(this, Nt("positioning"), this.Xn, this), void 0 !== t.element && this.Bj(t.element), this.Rk(void 0 !== t.offset ? t.offset : [0, 0]), this.Uk(void 0 !== t.positioning ? t.positioning : "top-left"), void 0 !== t.position && this.Hf(t.position) }

    function ug(t, e) {
        var i = t.getBoundingClientRect(),
            n = i.left + gb.pageXOffset,
            i = i.top + gb.pageYOffset;
        return [n, i, n + e[0], i + e[1]]
    }

    function pg(t, e) { t.a.visible !== e && (t.f.style.display = e ? "" : "none", t.a.visible = e) }

    function cg(t) {
        var e = t.Gf(),
            i = t.Aj();
        if (void 0 !== e && e.f && void 0 !== i) {
            var i = e.Qa(i),
                n = e.bb(),
                e = t.f.style,
                r = t.Ti(),
                o = t.Wi(),
                s = r[0],
                r = r[1];
            "bottom-right" == o || "center-right" == o || "top-right" == o ? ("" !== t.a.Df && (t.a.Df = e.left = ""), s = Math.round(n[0] - i[0] - s) + "px", t.a.gg != s && (t.a.gg = e.right = s)) : ("" !== t.a.gg && (t.a.gg = e.right = ""), "bottom-center" != o && "center-center" != o && "top-center" != o || (s -= t.f.offsetWidth / 2), s = Math.round(i[0] + s) + "px", t.a.Df != s && (t.a.Df = e.left = s)), "bottom-left" == o || "bottom-center" == o || "bottom-right" == o ? ("" !== t.a.kg && (t.a.kg = e.top = ""), i = Math.round(n[1] - i[1] - r) + "px", t.a.Ze != i && (t.a.Ze = e.bottom = i)) : ("" !== t.a.Ze && (t.a.Ze = e.bottom = ""), "center-left" != o && "center-center" != o && "center-right" != o || (r -= t.f.offsetHeight / 2), i = Math.round(i[1] + r) + "px", t.a.kg != i && (t.a.kg = e.top = i)), pg(t, !0)
        } else pg(t, !1)
    }

    function fg() { this.j = !0, this.i = this.f = this.c = this.g = this.a = this.l = this.b = null, gg(this) }

    function gg(t) {
        function e(t) { t.style.position = 480 >= document.body.clientWidth ? "static" : "absolute" }
        t.a = document.createElement("div"), t.a.className = "ga-tooltip-content", lt(t.a, "mousewheel", t.lo, t);
        var i = document.createElement("a");
        i.className = "ga-tooltip-closer", lt(i, "click", t.pn, t), t.g = document.createElement("div"), t.g.className = "ga-tooltip", t.g.appendChild(i), t.g.appendChild(t.a), t.c = new lg({ element: t.g });
        var n = t.c.V().parentNode;
        e(n), window.onresize = function() { e(n) }
    }

    function dg(t) {
        var e = [];
        t = t.results || [];
        for (var i = 0, n = t.length; i < n; i++) {
            var r = t[i],
                o = r.geometry.coordinates;
            if (o) {
                var s;
                switch (r.geometry.type) {
                    case "Point":
                        s = new se(o);
                        break;
                    case "LineString":
                        s = new Fe(o);
                        break;
                    case "Polygon":
                        s = new Ze(o);
                        break;
                    case "MultiPoint":
                        s = new we(o);
                        break;
                    case "MultiLineString":
                        s = new Be(o);
                        break;
                    case "MultiPolygon":
                        s = new ni(o);
                        break;
                    case "GeometryCollection":
                        s = new Un(o)
                }
                s && e.push(new Tn({ geometry: s }))
            }
        }
        return e
    }

    function yg(t) { t.a.innerHTML = "", t.g.style.display = "none", t.f && t.b.dg(t.f) }

    function mg(e) {
        var i = "canvas";
        null != e.renderer && (i = e.renderer), e.renderer = i;
        var i = [42e4, 3e4, 9e5, 35e4],
            n = qt("EPSG:21781");
        if (n.Qj(i), i = new Cu({ resolutions: [650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1, .5, .25, .1], extent: i, projection: n, center: [66e4, 19e4], zoom: 0 }), t(e.view) && (null != e.view.cb() && i.qb(e.view.cb()), t(e.view.aa()) && i.Xb(e.view.aa()), t(e.view.Ra()) && i.Ld(e.view.Ra()), delete e.view), e.view = i, e.logo = !1, e.interactions = t(e.interactions) ? e.interactions : Hp(), e.controls = t(e.controls) ? e.controls : Yu({ zoomOptions: { zoomInTipLabel: ub.translate("Zoom in"), zoomOutTipLabel: ub.translate("Zoom out") }, rotateOptions: { tipLabel: ub.translate("Reset rotation") }, attributionOptions: { collapsible: !1 } }), ng.call(this, e), this.zg(new og), this.qa = window.GeoAdmin.serviceUrl, this.U = this.xa = this.P = null, n = this.s = new hh("geocoder-dialog"), i = ub.translate("Geocoding results"), n.dl = i, n.vd)
            if (n = n.vd, "textContent" in n) n.textContent = i;
            else if (3 == n.nodeType) n.data = i;
        else if (n.firstChild && 3 == n.firstChild.nodeType) {
            for (; n.lastChild != n.firstChild;) n.removeChild(n.lastChild);
            n.firstChild.data = i
        } else {
            for (var r; r = n.firstChild;) n.removeChild(r);
            n.appendChild(Es(n).createTextNode(String(i)))
        }
        i = this.s, 1 != i.rh && lh(i, !0), i = this.s, i.i = null, i.dc && (i.i ? (n = i.i, n.Oc = i.dc, n.render()) : i.dc.innerHTML = ns(fx), Ta(i.dc, !!i.i)), this.o = null, e.tooltip = null == e.tooltip || e.tooltip, e.tooltip && (this.o = new fg, this.o.setMap(this))
    }

    function vg(t, e) {
        var i = e.geom_st_box2d,
            i = i.replace("BOX(", "").replace(")", "").replace(",", " ").split(" "),
            i = [parseFloat(i[0]), parseFloat(i[1]), parseFloat(i[2]), parseFloat(i[3])],
            n = e.origin,
            r = { address: "10", parcel: "10", gazetteer: "8" };
        r.hasOwnProperty(n) ? (n = parseInt(r[n], 10), i = [(i[0] + i[2]) / 2, (i[1] + i[3]) / 2], t.$().ig(n), t.$().qb(i), t.xa = ds("DIV"), Ps(t.xa, ["crosshair", "cross"]), t.U && t.eg(t.U), t.U = new lg({ element: t.xa, position: i }), t.ae(t.U)) : t.$().Ad(i, t.bb())
    }

    function bg(t) { Cu.call(this, t) }

    function wg(t) {
        t = t ? t : {}, this.f = void 0 !== t.className ? t.className : "ol-full-screen";
        var e = void 0 !== t.label ? t.label : "⤢";
        this.j = "string" == typeof e ? document.createTextNode(e) : e, e = void 0 !== t.labelActive ? t.labelActive : "×", this.o = "string" == typeof e ? document.createTextNode(e) : e;
        var i = t.tipLabel ? t.tipLabel : "Toggle full-screen",
            e = document.createElement("button");
        e.className = this.f + "-" + Eg(), e.setAttribute("type", "button"), e.title = i, e.appendChild(this.j), lt(e, "click", this.C, this), i = document.createElement("div"), i.className = this.f + " ol-unselectable ol-control " + (xg() ? "" : "ol-unsupported"), i.appendChild(e), _u.call(this, { element: i, target: t.target }), this.v = void 0 !== t.keys && t.keys, this.l = t.source
    }

    function xg() { var t = document.body; return !!(t.webkitRequestFullscreen || t.mozRequestFullScreen && document.mozFullScreenEnabled || t.msRequestFullscreen && document.msFullscreenEnabled || t.requestFullscreen && document.fullscreenEnabled) }

    function Eg() { return !!(document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement || document.fullscreenElement) }

    function Sg(t) { t.requestFullscreen ? t.requestFullscreen() : t.msRequestFullscreen ? t.msRequestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.webkitRequestFullscreen && t.webkitRequestFullscreen() }

    function Ng(t) {
        t = t ? t : {};
        var e = document.createElement("DIV");
        e.className = void 0 !== t.className ? t.className : "ol-mouse-position", _u.call(this, { element: e, render: t.render ? t.render : Lg, target: t.target }), lt(this, Nt("projection"), this.ep, this), t.coordinateFormat && this.Mk(t.coordinateFormat), t.projection && this.Hj(qt(t.projection)), this.A = void 0 !== t.undefinedHTML ? t.undefinedHTML : "", this.o = e.innerHTML, this.j = this.l = this.f = null
    }

    function Lg(t) { t = t.frameState, t ? this.f != t.viewState.projection && (this.f = t.viewState.projection, this.l = null) : this.f = null, Cg(this, this.j) }

    function Cg(t, e) {
        var i = t.A;
        if (e && t.f) {
            if (!t.l) {
                var n = t.Gj();
                t.l = n ? Xt(t.f, n) : Ht
            }(n = t.a.Za(e)) && (t.l(n, n), i = (i = t.Ji()) ? i(n) : n.toString())
        }
        t.o && i == t.o || (t.element.innerHTML = i, t.o = i)
    }

    function Mg(t) {
        t = t ? t : {}, this.l = void 0 === t.collapsed || t.collapsed, this.j = void 0 === t.collapsible || t.collapsible, this.j || (this.l = !1);
        var e = void 0 !== t.className ? t.className : "ol-overviewmap",
            i = void 0 !== t.tipLabel ? t.tipLabel : "Overview map",
            n = void 0 !== t.collapseLabel ? t.collapseLabel : "«";
        "string" == typeof n ? (this.o = document.createElement("span"), this.o.textContent = n) : this.o = n, n = void 0 !== t.label ? t.label : "»", "string" == typeof n ? (this.A = document.createElement("span"), this.A.textContent = n) : this.A = n;
        var r = this.j && !this.l ? this.o : this.A,
            n = document.createElement("button");
        n.setAttribute("type", "button"), n.title = i, n.appendChild(r), lt(n, "click", this.hp, this), i = document.createElement("DIV"), i.className = "ol-overviewmap-map";
        var o = this.f = new ng({ controls: new Wn, interactions: new Wn, target: i, view: t.view });
        t.layers && t.layers.forEach(function(t) { o.$d(t) }, this), r = document.createElement("DIV"), r.className = "ol-overviewmap-box", r.style.boxSizing = "border-box", this.v = new lg({ position: [0, 0], positioning: "bottom-left", element: r }), this.f.ae(this.v), r = document.createElement("div"), r.className = e + " ol-unselectable ol-control" + (this.l && this.j ? " ol-collapsed" : "") + (this.j ? "" : " ol-uncollapsible"), r.appendChild(i), r.appendChild(n), _u.call(this, { element: r, render: t.render ? t.render : Ig, target: t.target })
    }

    function Ig() {
        var t = this.a,
            e = this.f;
        if (t.f && e.f) {
            var i = t.bb(),
                t = t.$().Cc(i),
                n = e.bb(),
                i = e.$().Cc(n),
                r = e.Qa(X(t)),
                o = e.Qa(z(t)),
                e = Math.abs(r[0] - o[0]),
                r = Math.abs(r[1] - o[1]),
                o = n[0],
                n = n[1];
            e < .1 * o || r < .1 * n || e > .75 * o || r > .75 * n ? kg(this) : M(i, t) || (t = this.f, i = this.a.$(), t.$().qb(i.cb()))
        }
        Tg(this)
    }

    function kg(t) {
        var e = t.a;
        t = t.f;
        var i = e.bb(),
            e = e.$().Cc(i),
            i = t.bb();
        t = t.$(), Z(e, 1 / (.1 * Math.pow(2, Math.log(7.5) / Math.LN2 / 2))), t.Ad(e, i)
    }

    function Tg(t) {
        var e = t.a,
            i = t.f;
        if (e.f && i.f) {
            var n, r = e.bb(),
                o = e.$(),
                s = i.$(),
                i = o.Ra(),
                e = t.v,
                a = t.v.V(),
                h = o.Cc(r),
                r = s.aa(),
                o = j(h),
                s = H(h);
            (t = t.a.$().cb()) && (n = [o[0] - t[0], o[1] - t[1]], Eu(n, i), mu(n, t)), e.Hf(n), a && (a.style.width = Math.abs((o[0] - s[0]) / r) + "px", a.style.height = Math.abs((s[1] - o[1]) / r) + "px")
        }
    }

    function Ag(t) {
        t.element.classList.toggle("ol-collapsed"), t.l ? Ai(t.o, t.A) : Ai(t.A, t.o), t.l = !t.l;
        var e = t.f;
        t.l || e.f || (e.wd(), kg(t), ut(e, "postrender", function() { Tg(this) }, t))
    }

    function Rg(t) {
        t = t ? t : {}, this.f = void 0, this.l = eS, this.o = [], this.C = this.j = 0, this.U = null, this.fa = !1, this.X = void 0 !== t.duration ? t.duration : 200;
        var e = void 0 !== t.className ? t.className : "ol-zoomslider",
            i = document.createElement("button");
        i.setAttribute("type", "button"), i.className = e + "-thumb ol-unselectable";
        var n = document.createElement("div");
        n.className = e + " ol-unselectable ol-control", n.appendChild(i), this.A = new Nl(n), lt(this.A, nE, this.sn, this), lt(this.A, iE, this.ej, this), lt(this.A, rE, this.fj, this), lt(n, "click", this.qn, this), lt(i, "click", yt), _u.call(this, { element: n, render: t.render ? t.render : _g })
    }

    function _g(t) {
        if (t.frameState) {
            if (!this.fa) {
                var e = this.element,
                    i = e.offsetWidth,
                    n = e.offsetHeight,
                    r = e.firstElementChild,
                    o = gb.getComputedStyle(r),
                    e = r.offsetWidth + parseFloat(o.marginRight) + parseFloat(o.marginLeft),
                    r = r.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);
                this.U = [e, r], i > n ? (this.l = 1, this.C = i - e) : (this.l = eS, this.j = n - r), this.fa = !0
            }
            t = t.frameState.viewState.resolution, t !== this.f && (this.f = t, Pg(this, t))
        }
    }

    function Pg(t, e) {
        var i;
        i = 1 - Tu(t.a.$())(e);
        var n = t.element.firstElementChild;
        1 == t.l ? n.style.left = t.C * i + "px" : n.style.top = t.j * i + "px"
    }

    function Og(t, e) { return ku(t.a.$())(1 - e) }

    function Dg(t) {
        t = t ? t : {}, this.f = t.extent ? t.extent : null;
        var e = void 0 !== t.className ? t.className : "ol-zoom-extent",
            i = void 0 !== t.label ? t.label : "E",
            n = void 0 !== t.tipLabel ? t.tipLabel : "Fit to extent",
            r = document.createElement("button");
        r.setAttribute("type", "button"), r.title = n, r.appendChild("string" == typeof i ? document.createTextNode(i) : i), lt(r, "click", this.l, this), i = document.createElement("div"), i.className = e + " ol-unselectable ol-control", i.appendChild(r), _u.call(this, { element: i, target: t.target })
    }

    function Fg(t) { St.call(this), t = t ? t : {}, this.a = null, lt(this, Nt("tracking"), this.Mo, this), this.uh(void 0 !== t.tracking && t.tracking) }

    function Ug(t) { t = t ? t : {}, this.defaultDataProjection = null, this.b = t.geometryName }

    function Bg(t, e) {
        if (!t) return null;
        var i;
        if ("number" == typeof t.x && "number" == typeof t.y) i = "Point";
        else if (t.points) i = "MultiPoint";
        else if (t.paths) i = 1 === t.paths.length ? "LineString" : "MultiLineString";
        else if (t.rings) {
            var n = t.rings,
                r = jg(t),
                o = [];
            i = [];
            var s, a;
            for (s = 0, a = n.length; s < a; ++s) {
                var h = ue(n[s]);
                He(h, 0, h.length, r.length) ? o.push([n[s]]) : i.push(n[s])
            }
            for (; i.length;) {
                for (n = i.shift(), r = !1, s = o.length - 1; 0 <= s; s--)
                    if (M(new Ve(o[s][0]).H(), new Ve(n).H())) { o[s].push(n), r = !0; break }
                r || o.push([n.reverse()])
            }
            t = db({}, t), 1 === o.length ? (i = "Polygon", t.rings = o[0]) : (i = "MultiPolygon", t.rings = o)
        }
        return On((0, iS[i])(t), !1, e)
    }

    function jg(t) { var e = "XY"; return !0 === t.hasZ && !0 === t.hasM ? e = "XYZM" : !0 === t.hasZ ? e = "XYZ" : !0 === t.hasM && (e = "XYM"), e }

    function zg(t) { return t = t.ma, { hasZ: "XYZ" === t || "XYZM" === t, hasM: "XYM" === t || "XYZM" === t } }

    function Gg(t, e) { return (0, nS[t.Z()])(On(t, !0, e), e) }

    function qg() { this.f = new XMLSerializer, this.defaultDataProjection = null }

    function Vg(t, e, i) { return t = Wg(t, e, i), 0 < t.length ? t[0] : null }

    function Wg(t, e, i) { var n = []; for (e = e.firstChild; e; e = e.nextSibling) e.nodeType == Node.ELEMENT_NODE && pe(n, t.Zc(e, i)); return n }

    function Xg(t) { t = t ? t : {}, this.featureType = t.featureType, this.featureNS = t.featureNS, this.srsName = t.srsName, this.schemaLocation = "", this.b = {}, this.b["http://www.opengis.net/gml"] = { featureMember: rr(Xg.prototype.Ee), featureMembers: rr(Xg.prototype.Ee) }, qg.call(this) }

    function Hg(t) { return t = Zn(t, !1), Yg(t) }

    function Yg(t) { if (t = /^\s*(true|1)|(false|0)\s*$/.exec(t)) return void 0 !== t[1] || !1 }

    function Kg(t) { return t = Zn(t, !1), t = Date.parse(t), isNaN(t) ? void 0 : t / 1e3 }

    function $g(t) { return t = Zn(t, !1), Zg(t) }

    function Zg(t) { if (t = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(t)) return parseFloat(t[1]) }

    function Jg(t) { return t = Zn(t, !1), Qg(t) }

    function Qg(t) { if (t = /^\s*(\d+)\s*$/.exec(t)) return parseInt(t[1], 10) }

    function td(t) { return Zn(t, !1).trim() }

    function ed(t, e) { rd(t, e ? "1" : "0") }

    function id(t, e) { t.appendChild(Ow.createTextNode(e.toPrecision())) }

    function nd(t, e) { t.appendChild(Ow.createTextNode(e.toString())) }

    function rd(t, e) { t.appendChild(Ow.createTextNode(e)) }

    function od(t) { t = t ? t : {}, Xg.call(this, t), this.o = void 0 !== t.surface && t.surface, this.i = void 0 !== t.curve && t.curve, this.l = void 0 === t.multiCurve || t.multiCurve, this.j = void 0 === t.multiSurface || t.multiSurface, this.schemaLocation = t.schemaLocation ? t.schemaLocation : "http://www.opengis.net/gml http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd" }

    function sd(t, e, i) {
        i = i[i.length - 1].srsName, e = e.ba();
        for (var n, r = e.length, o = Array(r), s = 0; s < r; ++s) {
            n = e[s];
            var a = s,
                h = "enu";
            i && (h = qt(i).b), o[a] = "en" === h.substr(0, 2) ? n[0] + " " + n[1] : n[1] + " " + n[0]
        }
        rd(t, o.join(" "))
    }

    function ad(t) { t = t ? t : {}, Xg.call(this, t), this.b["http://www.opengis.net/gml"].featureMember = nr(Xg.prototype.Ee), this.schemaLocation = t.schemaLocation ? t.schemaLocation : "http://www.opengis.net/gml http://schemas.opengis.net/gml/2.1.2/feature.xsd" }

    function hd(t) { t = t ? t : {}, qg.call(this), this.defaultDataProjection = qt("EPSG:4326"), this.b = t.readExtensions }

    function ld(t, e, i) { return t.push(parseFloat(e.getAttribute("lon")), parseFloat(e.getAttribute("lat"))), "ele" in i ? (t.push(i.ele), delete i.ele) : t.push(0), "time" in i ? (t.push(i.time), delete i.time) : t.push(0), t }

    function ud(t, e) {
        var i = e[e.length - 1],
            n = t.getAttribute("href");
        null !== n && (i.link = n), cr(dS, t, e)
    }

    function pd(t, e) { e[e.length - 1].extensionsNode_ = t }

    function cd(t, e) {
        var i = e[0],
            n = fr({ flatCoordinates: [] }, yS, t, e);
        if (n) {
            var r = n.flatCoordinates;
            delete n.flatCoordinates;
            var o = new Fe(null);
            return o.ca("XYZM", r), On(o, !1, i), i = new Tn(o), i.G(n), i
        }
    }

    function fd(t, e) {
        var i = e[0],
            n = fr({ flatCoordinates: [], ends: [] }, vS, t, e);
        if (n) {
            var r = n.flatCoordinates;
            delete n.flatCoordinates;
            var o = n.ends;
            delete n.ends;
            var s = new Be(null);
            return s.ca("XYZM", r, o), On(s, !1, i), i = new Tn(s), i.G(n), i
        }
    }

    function gd(t, e) {
        var i = e[0],
            n = fr({}, xS, t, e);
        if (n) {
            var r = ld([], t, n),
                r = new se(r, "XYZM");
            return On(r, !1, i), i = new Tn(r), i.G(n), i
        }
    }

    function dd(t, e) {
        e || (e = []);
        for (var i = 0, n = e.length; i < n; ++i) {
            var r = e[i];
            if (t.b) {
                var o = r.get("extensionsNode_") || null;
                t.b(r, o)
            }
            r.set("extensionsNode_", void 0)
        }
    }

    function yd(t, e, i) { t.setAttribute("href", e), e = i[i.length - 1].properties, dr({ node: t }, SS, Dw, [e.linkText, e.linkType], i, ES) }

    function md(t, e, i) {
        var n = i[i.length - 1],
            r = n.node.namespaceURI,
            o = n.properties;
        switch (t.setAttributeNS(null, "lat", e[1]), t.setAttributeNS(null, "lon", e[0]), n.geometryLayout) {
            case "XYZM":
                0 !== e[3] && (o.time = e[3]);
            case "XYZ":
                0 !== e[2] && (o.ele = e[2]);
                break;
            case "XYM":
                0 !== e[2] && (o.time = e[2])
        }
        e = "rtept" == t.nodeName ? CS[r] : AS[r], n = ur(o, e), dr({ node: t, properties: o }, RS, Dw, n, i, e)
    }

    function vd(t, e) { var i = t.Y(); if (i && (i = _S[i.Z()])) return $n(e[e.length - 1].node.namespaceURI, i) }

    function bd() { this.defaultDataProjection = null }

    function wd(t) { return "string" == typeof t ? t : "" }

    function xd(t) { t = t ? t : {}, this.defaultDataProjection = null, this.defaultDataProjection = qt("EPSG:4326"), this.b = t.altitudeMode ? t.altitudeMode : "none" }

    function Ed(t) {
        t = t ? t : {}, qg.call(this), this.defaultDataProjection = qt("EPSG:4326");
        var e;
        t.defaultStyle ? e = t.defaultStyle : (e = BS) || (jS = [255, 255, 255, 1], zS = new Ui({ color: jS }), GS = [20, 2], VS = qS = "pixels", WS = [64, 64], XS = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png", HS = .5, YS = new en({ anchor: GS, anchorOrigin: "bottom-left", anchorXUnits: qS, anchorYUnits: VS, crossOrigin: "anonymous", rotation: 0, scale: HS, size: WS, src: XS }), KS = new Vi({ color: jS, width: 1 }), $S = new Vi({ color: [51, 51, 51, 1], width: 2 }), ZS = new Zi({ font: "bold 16px Helvetica", fill: zS, stroke: $S, scale: .8 }), JS = new Xi({ fill: zS, image: YS, text: ZS, stroke: KS, zIndex: 0 }), e = BS = [JS]), this.g = e, this.c = void 0 === t.extractStyles || t.extractStyles, this.l = void 0 === t.writeStyles || t.writeStyles, this.b = {}, this.i = void 0 === t.showPointNames || t.showPointNames
    }

    function Sd(t, e) {
        var i, n = [0, 0],
            r = "start";
        if (t.a) {
            var o = t.a.qe();
            o && 2 == o.length && (n[0] = t.a.i * o[0] / 2, n[1] = -t.a.i * o[1] / 2, r = "left")
        }
        if (nt(t.Wa())) i = new Zi({ text: e, offsetX: n[0], offsetY: n[1], textAlign: r });
        else {
            var o = t.Wa(),
                s = {};
            for (i in o) s[i] = o[i];
            i = s, i.Vk(e), i.Wk(r), i.Sk(n[0]), i.Tk(n[1])
        }
        return new Xi({ text: i })
    }

    function Nd(t, e, i, n, r) {
        return function() {
            var o = r,
                s = "";
            if (o && this.Y() && (o = "Point" === this.Y().Z()), o && (s = this.get("name"), o = o && s), t) return o ? (o = Sd(t[0], s), t.concat(o)) : t;
            if (e) { var a = Ld(e, i, n); return o ? (o = Sd(a[0], s), a.concat(o)) : a }
            return o ? (o = Sd(i[0], s), i.concat(o)) : i
        }
    }

    function Ld(t, e, i) { return Array.isArray(t) ? t : "string" == typeof t ? (!(t in i) && "#" + t in i && (t = "#" + t), Ld(i[t], e, i)) : e }

    function Cd(t) { if (t = Zn(t, !1), t = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(t)) return t = t[1], [parseInt(t.substr(6, 2), 16), parseInt(t.substr(4, 2), 16), parseInt(t.substr(2, 2), 16), parseInt(t.substr(0, 2), 16) / 255] }

    function Md(t) { t = Zn(t, !1); for (var e, i = [], n = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?))?\s*/i; e = n.exec(t);) i.push(parseFloat(e[1]), parseFloat(e[2]), e[3] ? parseFloat(e[3]) : 0), t = t.substr(e[0].length); return "" !== t ? void 0 : i }

    function Id(t) { var e = Zn(t, !1).trim(); return t.baseURI ? new URL(e, t.baseURI).href : e }

    function kd(t) { if (t = $g(t), void 0 !== t) return Math.sqrt(t) }

    function Td(t, e) { return fr(null, oN, t, e) }

    function Ad(t, e) {
        var i = fr({ B: [], jl: [] }, aN, t, e);
        if (i) {
            var n, r, o = i.B,
                i = i.jl;
            for (n = 0, r = Math.min(o.length, i.length); n < r; ++n) o[4 * n + 3] = i[n];
            return i = new Fe(null), i.ca("XYZM", o), i
        }
    }

    function Rd(t, e) {
        var i = fr({}, rN, t, e),
            n = fr(null, hN, t, e);
        if (n) { var r = new Fe(null); return r.ca("XYZ", n), r.G(i), r }
    }

    function _d(t, e) {
        var i = fr({}, rN, t, e),
            n = fr(null, hN, t, e);
        if (n) { var r = new Ze(null); return r.ca("XYZ", n, [n.length]), r.G(i), r }
    }

    function Pd(t, e) {
        var i = fr([], gN, t, e);
        if (!i) return null;
        if (0 === i.length) return new Un(i);
        var n, r, o, s, a = !0,
            h = i[0].Z();
        for (o = 1, s = i.length; o < s; ++o)
            if (r = i[o], r.Z() != h) { a = !1; break }
        if (a)
            if ("Point" == h) {
                for (n = i[0], a = n.ma, h = n.oa(), o = 1, s = i.length; o < s; ++o) r = i[o], pe(h, r.oa());
                n = new we(null), n.ca(a, h), Ud(n, i)
            } else "LineString" == h ? (n = new Be(null), ze(n, i), Ud(n, i)) : "Polygon" == h ? (n = new ni(null), ai(n, i), Ud(n, i)) : "GeometryCollection" == h ? n = new Un(i) : x(!1, 37);
        else n = new Un(i);
        return n
    }

    function Od(t, e) {
        var i = fr({}, rN, t, e),
            n = fr(null, hN, t, e);
        if (n) { var r = new se(null); return r.ca("XYZ", n), r.G(i), r }
    }

    function Dd(t, e) {
        var i = fr({}, rN, t, e),
            n = fr([null], sN, t, e);
        if (n && n[0]) {
            var r, o, s = new Ze(null),
                a = n[0],
                h = [a.length];
            for (r = 1, o = n.length; r < o; ++r) pe(a, n[r]), h.push(a.length);
            return s.ca("XYZ", a, h), s.G(i), s
        }
    }

    function Fd(t, e) {
        var i = fr({}, SN, t, e);
        if (!i) return null;
        var n = "fillStyle" in i ? i.fillStyle : zS,
            r = i.fill;
        void 0 === r || r || (n = null);
        var r = "imageStyle" in i ? i.imageStyle : YS,
            o = "textStyle" in i ? i.textStyle : ZS,
            s = "strokeStyle" in i ? i.strokeStyle : KS,
            i = i.outline;
        return void 0 === i || i || (s = null), [new Xi({ fill: n, image: r, stroke: s, text: o, zIndex: void 0 })]
    }

    function Ud(t, e) {
        var i, n, r, o, s = e.length,
            a = Array(e.length),
            h = Array(e.length);
        for (r = o = !1, n = 0; n < s; ++n) i = e[n], a[n] = i.get("extrude"), h[n] = i.get("altitudeMode"), r = r || void 0 !== a[n], o = o || h[n];
        r && t.set("extrude", a), o && t.set("altitudeMode", h)
    }

    function Bd(t, e) { cr(nN, t, e) }

    function jd(t, e) {
        var i;
        for (i = e.firstChild; i; i = i.nextSibling)
            if (i.nodeType == Node.ELEMENT_NODE) { var n = zd(t, i); if (n) return n }
    }

    function zd(t, e) {
        var i;
        for (i = e.firstElementChild; i; i = i.nextElementSibling)
            if (he(tN, i.namespaceURI) && "name" == i.localName) return td(i);
        for (i = e.firstElementChild; i; i = i.nextElementSibling) { var n = i.localName; if (he(tN, i.namespaceURI) && ("Document" == n || "Folder" == n || "Placemark" == n || "kml" == n) && (n = zd(t, i))) return n }
    }

    function Gd(t, e) { var i, n = []; for (i = e.firstChild; i; i = i.nextSibling) i.nodeType == Node.ELEMENT_NODE && pe(n, qd(t, i)); return n }

    function qd(t, e) {
        var i, n = [];
        for (i = e.firstElementChild; i; i = i.nextElementSibling)
            if (he(tN, i.namespaceURI) && "NetworkLink" == i.localName) {
                var r = fr({}, yN, i, []);
                n.push(r)
            }
        for (i = e.firstElementChild; i; i = i.nextElementSibling) r = i.localName, !he(tN, i.namespaceURI) || "Document" != r && "Folder" != r && "kml" != r || pe(n, qd(t, i));
        return n
    }

    function Vd(t, e) {
        var i, n = hi(e),
            n = [255 * (4 == n.length ? n[3] : 1), n[2], n[1], n[0]];
        for (i = 0; 4 > i; ++i) {
            var r = parseInt(n[i], 10).toString(16);
            n[i] = 1 == r.length ? "0" + r : r
        }
        rd(t, n.join(""))
    }

    function Wd(t, e, i) { t = { node: t }; var n, r, o = e.Z(); "GeometryCollection" == o ? (n = e.Vg(), r = Qd) : "MultiPoint" == o ? (n = e.If(), r = KN) : "MultiLineString" == o ? (n = e.re(), r = $N) : "MultiPolygon" == o ? (n = e.lf(), r = JN) : x(!1, 39), dr(t, UN, r, n, i) }

    function Xd(t, e, i) { dr({ node: t }, FN, ZN, [e], i) }

    function Hd(t, e, i) {
        var n = { node: t };
        e.Ja() && t.setAttribute("id", e.Ja()), t = e.N();
        var r = e.Tc();
        r && (r = r.call(e, 0)) && (r = Array.isArray(r) ? r[0] : r, this.l && (t.Style = r), (r = r.Wa()) && (t.name = r.Wa())), r = BN[i[i.length - 1].node.namespaceURI], t = ur(t, r), dr(n, jN, Dw, t, i, r), t = i[0], (e = e.Y()) && (e = On(e, !0, t)), dr(n, jN, Qd, [e], i)
    }

    function Yd(t, e, i) {
        var n = e.oa();
        t = { node: t }, t.layout = e.ma, t.stride = e.Aa(), dr(t, zN, HN, [n], i)
    }

    function Kd(t, e, i) {
        e = e.jf();
        var n = e.shift();
        t = { node: t }, dr(t, GN, YN, e, i), dr(t, GN, QN, [n], i)
    }

    function $d(t, e) { id(t, Math.round(e * e * 1e6) / 1e6) }

    function Zd(t, e, i) { return $n(QS[0], "gx:" + i) }

    function Jd(t, e) { return $n(e[e.length - 1].node.namespaceURI, "Placemark") }

    function Qd(t, e) { if (t) return $n(e[e.length - 1].node.namespaceURI, IN[t.Z()]) }

    function ty(t, e, i, n) { this.g = t, this.b = e, this.c = i, this.f = n }

    function ey(t) { this.defaultDataProjection = null, t = t ? t : {}, this.defaultDataProjection = new Pt({ code: "", units: "tile-pixels" }), this.b = t.featureClass ? t.featureClass : ty, this.g = t.geometryName ? t.geometryName : "geometry", this.a = t.layerName ? t.layerName : "layer", this.f = t.layers ? t.layers : null }

    function iy(t, e, i) {
        for (var n = 0, r = 0, o = t.length; r < o; ++r) {
            var s, a, h = t[r];
            for (s = 0, a = h.length; s < a; ++s) {
                var l = h[s];
                e.push(l.x, l.y)
            }
            n += 2 * s, i.push(n)
        }
    }

    function ny(t) { this.jc = t }

    function ry(t) { this.jc = t }

    function oy(t, e, i) { this.jc = t, this.b = e, this.a = i }

    function sy(t, e) { oy.call(this, "And", t, e) }

    function ay(t, e, i) { this.jc = "BBOX", this.geometryName = t, this.extent = e, this.srsName = i }

    function hy(t, e) { this.jc = t, this.b = e }

    function ly(t, e, i, n) { hy.call(this, t, e), this.g = i, this.a = n }

    function uy(t, e, i) { ly.call(this, "PropertyIsEqualTo", t, e, i) }

    function py(t, e) { ly.call(this, "PropertyIsGreaterThan", t, e) }

    function cy(t, e) { ly.call(this, "PropertyIsGreaterThanOrEqualTo", t, e) }

    function fy(t, e, i, n) { this.jc = t, this.geometryName = e || "the_geom", this.geometry = i, this.srsName = n }

    function gy(t, e, i) { fy.call(this, "Intersects", t, e, i) }

    function dy(t, e, i) { hy.call(this, "PropertyIsBetween", t), this.a = e, this.g = i }

    function yy(t, e, i, n, r, o) { hy.call(this, "PropertyIsLike", t), this.f = e, this.i = void 0 !== i ? i : "*", this.c = void 0 !== n ? n : ".", this.g = void 0 !== r ? r : "!", this.a = o }

    function my(t) { hy.call(this, "PropertyIsNull", t) }

    function vy(t, e) { ly.call(this, "PropertyIsLessThan", t, e) }

    function by(t, e) { ly.call(this, "PropertyIsLessThanOrEqualTo", t, e) }

    function wy(t) { this.jc = "Not", this.condition = t }

    function xy(t, e, i) { ly.call(this, "PropertyIsNotEqualTo", t, e, i) }

    function Ey(t, e) { oy.call(this, "Or", t, e) }

    function Sy(t, e, i) { fy.call(this, "Within", t, e, i) }

    function Ny(t, e) { return new sy(t, e) }

    function Ly(t, e, i) { return new ay(t, e, i) }

    function Cy() { qg.call(this), this.defaultDataProjection = qt("EPSG:4326") }

    function My(t, e) { e[e.length - 1].Ne[t.getAttribute("k")] = t.getAttribute("v") }

    function Iy(t) { return t.getAttributeNS("http://www.w3.org/1999/xlink", "href") }

    function ky() {}

    function Ty() {}

    function Ay(t, e, i, n) {
        var r;
        r = void 0 !== n ? n : [];
        for (var o = n = 0; o < e;) { var s = t[o++]; for (r[n++] = t[o++], r[n++] = s, s = 2; s < i; ++s) r[n++] = t[o++] }
        r.length = n
    }

    function Ry(t) { t = t ? t : {}, this.defaultDataProjection = null, this.defaultDataProjection = qt("EPSG:4326"), this.b = t.factor ? t.factor : 1e5, this.a = t.geometryLayout ? t.geometryLayout : "XY" }

    function _y(t, e, i) {
        var n, r = Array(e);
        for (n = 0; n < e; ++n) r[n] = 0;
        var o, s;
        for (o = 0, s = t.length; o < s;)
            for (n = 0; n < e; ++n, ++o) {
                var a = t[o],
                    h = a - r[n];
                r[n] = a, t[o] = h
            }
        return Oy(t, i ? i : 1e5)
    }

    function Py(t, e, i) {
        var n, r = Array(e);
        for (n = 0; n < e; ++n) r[n] = 0;
        t = Dy(t, i ? i : 1e5);
        var o;
        for (i = 0, o = t.length; i < o;)
            for (n = 0; n < e; ++n, ++i) r[n] += t[i], t[i] = r[n];
        return t
    }

    function Oy(t, e) {
        var i, n, r = e ? e : 1e5;
        for (i = 0, n = t.length; i < n; ++i) t[i] = Math.round(t[i] * r);
        for (r = 0, i = t.length; r < i; ++r) n = t[r], t[r] = 0 > n ? ~(n << 1) : n << 1;
        for (r = "", i = 0, n = t.length; i < n; ++i) {
            for (var o, s = t[i], a = ""; 32 <= s;) o = (32 | 31 & s) + 63, a += String.fromCharCode(o), s >>= 5;
            a += String.fromCharCode(s + 63), r += a
        }
        return r
    }

    function Dy(t, e) {
        var i, n, r = e ? e : 1e5,
            o = [],
            s = 0,
            a = 0;
        for (i = 0, n = t.length; i < n; ++i) {
            var h = t.charCodeAt(i) - 63,
                s = s | (31 & h) << a;
            32 > h ? (o.push(s), a = s = 0) : a += 5
        }
        for (s = 0, a = o.length; s < a; ++s) i = o[s], o[s] = 1 & i ? ~(i >> 1) : i >> 1;
        for (s = 0, a = o.length; s < a; ++s) o[s] /= r;
        return o
    }

    function Fy(t) { t = t ? t : {}, this.defaultDataProjection = null, this.defaultDataProjection = qt(t.defaultDataProjection ? t.defaultDataProjection : "EPSG:4326") }

    function Uy(t, e) { var i, n, r, o, s = []; for (r = 0, o = t.length; r < o; ++r) i = t[r], 0 < r && s.pop(), n = 0 <= i ? e[i] : e[~i].slice().reverse(), s.push.apply(s, n); for (i = 0, n = s.length; i < n; ++i) s[i] = s[i].slice(); return s }

    function By(t, e, i, n, r) { t = t.geometries; var o, s, a = []; for (o = 0, s = t.length; o < s; ++o) a[o] = jy(t[o], e, i, n, r); return a }

    function jy(t, e, i, n, r) {
        var o = t.type,
            s = bL[o];
        return e = "Point" === o || "MultiPoint" === o ? s(t, i, n) : s(t, e), i = new Tn, i.ob(On(e, !1, r)), void 0 !== t.id && i.ic(t.id), t.properties && i.G(t.properties), i
    }

    function zy(t, e, i) { t[0] = t[0] * e[0] + i[0], t[1] = t[1] * e[1] + i[1] }

    function Gy(t) { t = t ? t : {}, this.i = t.featureType, this.g = t.featureNS, this.b = t.gmlFormat ? t.gmlFormat : new od, this.c = t.schemaLocation ? t.schemaLocation : "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd", qg.call(this) }

    function qy(t, e) {
        for (var i = e.firstChild; i; i = i.nextSibling)
            if (i.nodeType == Node.ELEMENT_NODE) return Vy(t, i)
    }

    function Vy(t, e) {
        var i = {},
            n = Qg(e.getAttribute("numberOfFeatures"));
        return i.numberOfFeatures = n, fr(i, wL, e, [], t.b)
    }

    function Wy(t) {
        for (t = t.firstChild; t; t = t.nextSibling)
            if (t.nodeType == Node.ELEMENT_NODE) return fr({}, NL, t, [])
    }

    function Xy(t, e) {
        var i = $n("http://www.opengis.net/ogc", "Filter"),
            n = $n("http://www.opengis.net/ogc", "FeatureId");
        i.appendChild(n), n.setAttribute("fid", e), t.appendChild(i)
    }

    function Hy(t, e, i) {
        t = { node: t };
        var n = e.b;
        dr(t, ML, lr(n.jc), [n], i), e = e.a, dr(t, ML, lr(e.jc), [e], i)
    }

    function Yy(t, e) { void 0 !== e.a && t.setAttribute("matchCase", e.a.toString()), $y(t, e.b), Ky("Literal", t, "" + e.g) }

    function Ky(t, e, i) { t = $n("http://www.opengis.net/ogc", t), rd(t, i), e.appendChild(t) }

    function $y(t, e) { Ky("PropertyName", t, e) }

    function Zy(t) { t = t ? t : {}, this.defaultDataProjection = null, this.b = void 0 !== t.splitCollection && t.splitCollection }

    function Jy(t) { return t = t.ba(), 0 === t.length ? "" : t[0] + " " + t[1] }

    function Qy(t) { t = t.ba(); for (var e = [], i = 0, n = t.length; i < n; ++i) e.push(t[i][0] + " " + t[i][1]); return e.join(",") }

    function tm(t) {
        var e = [];
        t = t.jf();
        for (var i = 0, n = t.length; i < n; ++i) e.push("(" + Qy(t[i]) + ")");
        return e.join(",")
    }

    function em(t) { var e = t.Z(); return t = (0, IL[e])(t), e = e.toUpperCase(), 0 === t.length ? e + " EMPTY" : e + "(" + t + ")" }

    function im(t) { this.a = t, this.b = -1 }

    function nm(t) {
        var e = t.a.charAt(++t.b),
            i = { position: t.b, value: e };
        if ("(" == e) i.type = 2;
        else if ("," == e) i.type = 5;
        else if (")" == e) i.type = 3;
        else if ("0" <= e && "9" >= e || "." == e || "-" == e) {
            i.type = 4;
            var n, e = t.b,
                r = !1,
                o = !1;
            do "." == n ? r = !0 : "e" != n && "E" != n || (o = !0), n = t.a.charAt(++t.b); while ("0" <= n && "9" >= n || "." == n && (void 0 === r || !r) || !o && ("e" == n || "E" == n) || o && ("-" == n || "+" == n));
            t = parseFloat(t.a.substring(e, t.b--)), i.value = t
        } else if ("a" <= e && "z" >= e || "A" <= e && "Z" >= e) {
            i.type = 1, e = t.b;
            do n = t.a.charAt(++t.b); while ("a" <= n && "z" >= n || "A" <= n && "Z" >= n);
            t = t.a.substring(e, t.b--).toUpperCase(), i.value = t
        } else {
            if (" " == e || "\t" == e || "\r" == e || "\n" == e) return nm(t);
            if ("" !== e) throw Error("Unexpected character: " + e);
            i.type = 6
        }
        return i
    }

    function rm(t) { this.a = t }

    function om(t) {
        var e = t.b;
        if (t.match(1)) {
            var i = e.value;
            if ("GEOMETRYCOLLECTION" == i) {
                t: {
                    if (t.match(2)) {
                        e = [];
                        do e.push(om(t)); while (t.match(5));
                        if (t.match(3)) { t = e; break t }
                    } else if (lm(t)) { t = []; break t }
                    throw Error(um(t))
                }
                return new Un(t)
            }
            var n = TL[i],
                e = kL[i];
            if (!n || !e) throw Error("Invalid geometry type: " + i);
            return t = n.call(t), new e(t)
        }
        throw Error(um(t))
    }

    function sm(t) {
        for (var e = [], i = 0; 2 > i; ++i) {
            var n = t.b;
            if (!t.match(4)) break;
            e.push(n.value)
        }
        if (2 == e.length) return e;
        throw Error(um(t))
    }

    function am(t) { for (var e = [sm(t)]; t.match(5);) e.push(sm(t)); return e }

    function hm(t) { for (var e = [t.Fh()]; t.match(5);) e.push(t.Fh()); return e }

    function lm(t) { var e = 1 == t.b.type && "EMPTY" == t.b.value; return e && (t.b = nm(t.a)), e }

    function um(t) { return "Unexpected `" + t.b.value + "` at position " + t.b.position + " in `" + t.a.a + "`" }

    function pm() { this.version = void 0 }

    function cm(t, e) { return fr({}, HL, t, e) }

    function fm(t, e) { return fr({}, qL, t, e) }

    function gm(t, e) { var i = cm(t, e); if (i) { var n = [Qg(t.getAttribute("width")), Qg(t.getAttribute("height"))]; return i.size = n, i } }

    function dm(t, e) { return fr([], YL, t, e) }

    function ym(t) { t = t ? t : {}, this.g = "http://mapserver.gis.umn.edu/mapserver", this.b = new ad, this.c = t.layers ? t.layers : null, qg.call(this) }

    function mm() { this.g = new Ty }

    function vm(t) { var e = td(t).split(" "); if (e && 2 == e.length) return t = +e[0], e = +e[1], isNaN(t) || isNaN(e) ? void 0 : [t, e] }

    function bm(t) { St.call(this), t = t || {}, this.a = null, this.c = Ht, this.f = void 0, lt(this, Nt("projection"), this.Ro, this), lt(this, Nt("tracking"), this.So, this), void 0 !== t.projection && this.yj(qt(t.projection)), void 0 !== t.trackingOptions && this.Xk(t.trackingOptions), this.Ef(void 0 !== t.tracking && t.tracking) }

    function wm(t, e, i) { Qt.call(this), this.Yh(t, e ? e : 0, i) }

    function xm(t) { var e = t.B[t.a] - t.B[0]; return t = t.B[t.a + 1] - t.B[1], e * e + t * t }

    function Em(t, e, i) { for (var n, r, o, s, a, h = [], l = t(0), u = t(1), p = e(l), c = e(u), f = [u, l], g = [c, p], d = [1, 0], y = {}, m = 1e5; 0 < --m && 0 < d.length;) o = d.pop(), l = f.pop(), p = g.pop(), u = o.toString(), u in y || (h.push(p[0], p[1]), y[u] = !0), s = d.pop(), u = f.pop(), c = g.pop(), a = (o + s) / 2, n = t(a), r = e(n), It(r[0], r[1], p[0], p[1], c[0], c[1]) < i ? (h.push(c[0], c[1]), u = s.toString(), y[u] = !0) : (d.push(s, a, a, o), g.push(c, r, r, p), f.push(u, n, n, l)); return h }

    function Sm(t, e, i, n, r) { var o = qt("EPSG:4326"); return Em(function(n) { return [t, e + (i - e) * n] }, Wt(o, n), r) }

    function Nm(t, e, i, n, r) { var o = qt("EPSG:4326"); return Em(function(n) { return [e + (i - e) * n, t] }, Wt(o, n), r) }

    function Lm(t) { t = t || {}, this.c = this.j = null, this.g = this.i = 1 / 0, this.f = this.l = -(1 / 0), this.v = this.T = 1 / 0, this.D = this.C = -(1 / 0), this.za = void 0 !== t.targetSize ? t.targetSize : 100, this.O = void 0 !== t.maxLines ? t.maxLines : 100, this.b = [], this.a = [], this.sa = void 0 !== t.strokeStyle ? t.strokeStyle : sC, this.A = this.o = void 0, this.s = null, this.setMap(void 0 !== t.map ? t.map : null) }

    function Cm(t, e, i, n, r, o, s) { var a = s; return e = Sm(e, i, n, t.c, r), a = void 0 !== t.b[a] ? t.b[a] : new Fe(null), a.ca("XY", e), K(a.H(), o) && (t.b[s++] = a), s }

    function Mm(t, e, i, n, r) { var o = r; return e = Nm(e, t.f, t.g, t.c, i), o = void 0 !== t.a[o] ? t.a[o] : new Fe(null), o.ca("XY", e), K(o.H(), n) && (t.a[r++] = o), r }

    function Im(t) { t = t ? t : {}, Zu.call(this, { handleEvent: Q }), this.c = t.formatConstructors ? t.formatConstructors : [], this.o = t.projection ? qt(t.projection) : null, this.a = null, this.target = t.target ? t.target : null }

    function km(t) {
        t = t.dataTransfer.files;
        var e, i, n;
        for (e = 0, i = t.length; e < i; ++e) {
            n = t.item(e);
            var r = new FileReader;
            r.addEventListener("load", this.j.bind(this, n)), r.readAsText(n)
        }
    }

    function Tm(t) { t.stopPropagation(), t.preventDefault(), t.dataTransfer.dropEffect = "copy" }

    function Am(t, e, i, n) { dt.call(this, t), this.features = i, this.file = e, this.projection = n }

    function Rm(t) { t = t ? t : {}, cp.call(this, { handleDownEvent: Om, handleDragEvent: _m, handleUpEvent: Pm }), this.s = t.condition ? t.condition : hp, this.a = this.c = void 0, this.o = 0, this.v = void 0 !== t.duration ? t.duration : 400 }

    function _m(t) {
        if (up(t)) {
            var e = t.map,
                i = e.bb(),
                n = t.pixel;
            if (t = n[0] - i[0] / 2, n = i[1] / 2 - n[1], i = Math.atan2(n, t), t = Math.sqrt(t * t + n * n), n = e.$(), void 0 !== this.c) {
                var r = i - this.c;
                Ju(e, n, n.Ra() - r)
            }
            this.c = i, void 0 !== this.a && (i = this.a * (n.aa() / t), tp(e, n, i)), void 0 !== this.a && (this.o = this.a / t), this.a = t
        }
    }

    function Pm(t) {
        if (!up(t)) return !0;
        t = t.map;
        var e = t.$();
        Ru(e, -1);
        var i = this.o - 1,
            n = e.Ra(),
            n = e.constrainRotation(n, 0);
        Ju(t, e, n, void 0, void 0);
        var n = e.aa(),
            r = this.v,
            n = e.constrainResolution(n, 0, i);
        return tp(t, e, n, void 0, r), this.o = 0, !1
    }

    function Om(t) { return !(!up(t) || !this.s(t)) && (Ru(t.map.$(), 1), this.a = this.c = void 0, !0) }

    function Dm(t, e) { dt.call(this, t), this.feature = e }

    function Fm(t) {
        cp.call(this, { handleDownEvent: jm, handleEvent: Bm, handleUpEvent: zm }), this.ra = null, this.P = !1, this.bc = t.source ? t.source : null, this.sb = t.features ? t.features : null, this.Kg = t.snapTolerance ? t.snapTolerance : 12, this.X = t.type, this.c = Ym(this.X), this.Ua = t.minPoints ? t.minPoints : this.c === pC ? 3 : 2, this.Ta = t.maxPoints ? t.maxPoints : 1 / 0, this.Se = t.finishCondition ? t.finishCondition : Q;
        var e = t.geometryFunction;
        if (!e)
            if ("Circle" === this.X) e = function(t, e) { var i = e ? e : new wm([NaN, NaN]); return i.Yh(t[0], Math.sqrt(Su(t[0], t[1]))), i };
            else {
                var i, e = this.c;
                e === lC ? i = se : e === uC ? i = Fe : e === pC && (i = Ze), e = function(t, e) { var n = e; return n ? n.wa(t) : n = new i(t), n }
            }
        this.D = e, this.U = this.v = this.a = this.O = this.o = this.s = null, this.Rg = t.clickTolerance ? t.clickTolerance * t.clickTolerance : 36, this.qa = new Wr({ source: new kr({ useSpatialIndex: !1, wrapX: !!t.wrapX && t.wrapX }), style: t.style ? t.style : Um() }), this.Hb = t.geometryName, this.Eg = t.condition ? t.condition : ap, this.xa = t.freehandCondition ? t.freehandCondition : hp, lt(this, Nt("active"), this.hl, this)
    }

    function Um() { var t = Ki(); return function(e) { return t[e.Y().Z()] } }

    function Bm(t) { this.c !== uC && this.c !== pC || !this.xa(t) || (this.P = !0); var e = !this.P; return this.P && t.type === gE ? (Wm(this, t), e = !1) : t.type === dE ? e = Gm(this, t) : t.type === fE && (e = !1), gp.call(this, t) && e }

    function jm(t) { return this.Eg(t) ? (this.ra = t.pixel, !0) : !!this.P && (this.ra = t.pixel, this.s || Vm(this, t), !0) }

    function zm(t) {
        this.P = !1;
        var e = this.ra,
            i = t.pixel,
            n = e[0] - i[0],
            e = e[1] - i[1],
            i = !0;
        return n * n + e * e <= this.Rg && (Gm(this, t), this.s ? this.c === cC ? this.me() : qm(this, t) ? this.Se(t) && this.me() : Wm(this, t) : (Vm(this, t), this.c === lC && this.me()), i = !1), i
    }

    function Gm(t, e) {
        if (t.s) {
            var i, n = e.coordinate,
                r = t.o.Y();
            t.c === lC ? i = t.a : t.c === pC ? (i = t.a[0], i = i[i.length - 1], qm(t, e) && (n = t.s.slice())) : (i = t.a, i = i[i.length - 1]), i[0] = n[0], i[1] = n[1], t.D(t.a, r), t.O && t.O.Y().wa(n), r instanceof Ze && t.c !== pC ? (t.v || (t.v = new Tn(new Fe(null))), r = r.Qi(0), n = t.v.Y(), n.ca(r.ma, r.oa())) : t.U && (n = t.v.Y(), n.wa(t.U)), Hm(t)
        } else n = e.coordinate.slice(), t.O ? t.O.Y().wa(n) : (t.O = new Tn(new se(n)), Hm(t));
        return !0
    }

    function qm(t, e) {
        var i = !1;
        if (t.o) {
            var n = !1,
                r = [t.s];
            if (t.c === uC ? n = t.a.length > t.Ua : t.c === pC && (n = t.a[0].length > t.Ua, r = [t.a[0][0], t.a[0][t.a[0].length - 2]]), n)
                for (var n = e.map, o = 0, s = r.length; o < s; o++) {
                    var a = r[o],
                        h = n.Qa(a),
                        l = e.pixel,
                        i = l[0] - h[0],
                        h = l[1] - h[1],
                        l = t.P && t.xa(e) ? 1 : t.Kg;
                    if (i = Math.sqrt(i * i + h * h) <= l) { t.s = a; break }
                }
        }
        return i
    }

    function Vm(t, e) {
        var i = e.coordinate;
        t.s = i, t.c === lC ? t.a = i.slice() : t.c === pC ? (t.a = [
            [i.slice(), i.slice()]
        ], t.U = t.a[0]) : (t.a = [i.slice(), i.slice()], t.c === cC && (t.U = t.a)), t.U && (t.v = new Tn(new Fe(t.U))), i = t.D(t.a), t.o = new Tn, t.Hb && t.o.sd(t.Hb), t.o.ob(i), Hm(t), t.b(new Dm("drawstart", t.o))
    }

    function Wm(t, e) {
        var i, n, r = e.coordinate,
            o = t.o.Y();
        t.c === uC ? (t.s = r.slice(), n = t.a, n.push(r.slice()), i = n.length > t.Ta, t.D(n, o)) : t.c === pC && (n = t.a[0], n.push(r.slice()), (i = n.length > t.Ta) && (t.s = n[0]), t.D(t.a, o)), Hm(t), i && t.me()
    }

    function Xm(t) { t.s = null; var e = t.o; return e && (t.o = null, t.O = null, t.v = null, t.qa.ja().clear(!0)), e }

    function Hm(t) {
        var e = [];
        t.o && e.push(t.o), t.v && e.push(t.v), t.O && e.push(t.O), t = t.qa.ja(), t.clear(!0), t.Bc(e)
    }

    function Ym(t) { var e; return "Point" === t || "MultiPoint" === t ? e = lC : "LineString" === t || "MultiLineString" === t ? e = uC : "Polygon" === t || "MultiPolygon" === t ? e = pC : "Circle" === t && (e = cC), e }

    function Km(t, e, i) { dt.call(this, t), this.features = e, this.mapBrowserEvent = i }

    function $m(t) { cp.call(this, { handleDownEvent: iv, handleDragEvent: nv, handleEvent: ov, handleUpEvent: rv }), this.Hb = t.condition ? t.condition : pp, this.Ua = function(t) { return ap(t) && sp(t) }, this.sb = t.deleteCondition ? t.deleteCondition : this.Ua, this.Ta = this.c = null, this.qa = [0, 0], this.D = this.U = !1, this.a = new Sr, this.O = void 0 !== t.pixelTolerance ? t.pixelTolerance : 10, this.s = this.xa = !1, this.o = [], this.P = new Wr({ source: new kr({ useSpatialIndex: !1, wrapX: !!t.wrapX }), style: t.style ? t.style : hv(), updateWhileAnimating: !0, updateWhileInteracting: !0 }), this.ra = { Point: this.zp, LineString: this.Jj, LinearRing: this.Jj, Polygon: this.Ap, MultiPoint: this.xp, MultiLineString: this.wp, MultiPolygon: this.yp, GeometryCollection: this.vp }, this.v = t.features, this.v.forEach(this.zh, this), lt(this.v, _w, this.tp, this), lt(this.v, Pw, this.up, this), this.X = null }

    function Zm(t, e) { t.D || (t.D = !0, t.b(new Km("modifystart", t.v, e))) }

    function Jm(t, e) { Qm(t, e), t.c && 0 === t.v.Sc() && (t.P.ja().Kb(t.c), t.c = null), pt(e, "change", t.Ij, t) }

    function Qm(t, e) {
        var i = t.a,
            n = [];
        i.forEach(function(t) { e === t.feature && n.push(t) });
        for (var r = n.length - 1; 0 <= r; --r) i.remove(n[r])
    }

    function tv(t, e) {
        var i = t.c;
        i ? i.Y().wa(e) : (i = new Tn(new se(e)), t.c = i, t.P.ja().Nb(i))
    }

    function ev(t, e) { return t.index - e.index }

    function iv(t) {
        if (!this.Hb(t)) return !1;
        sv(this, t.pixel, t.map), this.o.length = 0, this.D = !1;
        var e = this.c;
        if (e) {
            var i = [],
                e = e.Y().ba(),
                n = E([e]),
                n = Cr(this.a, n),
                r = {};
            n.sort(ev);
            for (var o = 0, s = n.length; o < s; ++o) {
                var a = n[o],
                    h = a.ua,
                    l = b(a.feature),
                    u = a.depth;
                u && (l += "-" + u.join("-")), r[l] || (r[l] = Array(2)), xu(h[0], e) && !r[l][0] ? (this.o.push([a, 0]), r[l][0] = a) : xu(h[1], e) && !r[l][1] ? ("LineString" !== a.geometry.Z() && "MultiLineString" !== a.geometry.Z() || !r[l][0] || 0 !== r[l][0].index) && (this.o.push([a, 1]), r[l][1] = a) : b(h) in this.Ta && !r[l][0] && !r[l][1] && i.push([a, e])
            }
            for (i.length && Zm(this, t), t = i.length - 1; 0 <= t; --t) this.po.apply(this, i[t])
        }
        return !!this.c
    }

    function nv(t) {
        this.U = !1, Zm(this, t), t = t.coordinate;
        for (var e = 0, i = this.o.length; e < i; ++e) {
            for (var n = this.o[e], r = n[0], o = r.depth, s = r.geometry, a = s.ba(), h = r.ua, n = n[1]; t.length < s.Aa();) t.push(0);
            switch (s.Z()) {
                case "Point":
                    a = t, h[0] = h[1] = t;
                    break;
                case "MultiPoint":
                    a[r.index] = t, h[0] = h[1] = t;
                    break;
                case "LineString":
                    a[r.index + n] = t, h[n] = t;
                    break;
                case "MultiLineString":
                    a[o[0]][r.index + n] = t, h[n] = t;
                    break;
                case "Polygon":
                    a[o[0]][r.index + n] = t, h[n] = t;
                    break;
                case "MultiPolygon":
                    a[o[1]][o[0]][r.index + n] = t, h[n] = t
            }
            r = s, this.s = !0, r.wa(a), this.s = !1
        }
        tv(this, t)
    }

    function rv(t) { for (var e, i = this.o.length - 1; 0 <= i; --i) e = this.o[i][0], Nr(this.a, E(e.ua), e); return this.D && (this.b(new Km("modifyend", this.v, t)), this.D = !1), !1 }

    function ov(t) {
        if (!(t instanceof Pl)) return !0;
        this.X = t;
        var e;
        return Mu(t.map.$())[1] || t.type != dE || this.C || (this.qa = t.pixel, sv(this, t.pixel, t.map)), this.c && this.sb(t) && (e = !(t.type != pE || !this.U) || this.Ek()), t.type == pE && (this.U = !1), gp.call(this, t) && !e
    }

    function sv(t, e, i) {
        function n(t, e) { return Nu(r, t.ua) - Nu(r, e.ua) }
        var r = i.Za(e),
            o = i.Za([e[0] - t.O, e[1] + t.O]),
            s = i.Za([e[0] + t.O, e[1] - t.O]),
            o = E([o, s]),
            o = Cr(t.a, o);
        if (0 < o.length) {
            o.sort(n);
            var s = o[0].ua,
                a = vu(r, s),
                h = i.Qa(a);
            if (Math.sqrt(Su(e, h)) <= t.O) { for (e = i.Qa(s[0]), i = i.Qa(s[1]), e = Su(h, e), i = Su(h, i), t.xa = Math.sqrt(Math.min(e, i)) <= t.O, t.xa && (a = e > i ? s[1] : s[0]), tv(t, a), i = {}, i[b(s)] = !0, e = 1, h = o.length; e < h && (a = o[e].ua, xu(s[0], a[0]) && xu(s[1], a[1]) || xu(s[0], a[1]) && xu(s[1], a[0])); ++e) i[b(a)] = !0; return void(t.Ta = i) }
        }
        t.c && (t.P.ja().Kb(t.c), t.c = null)
    }

    function av(t, e, i, n, r) { Mr(t.a, e.H(), function(t) { t.geometry === e && (void 0 === n || void 0 === t.depth || ge(t.depth, n)) && t.index > i && (t.index += r) }) }

    function hv() { var t = Ki(); return function() { return t.Point } }

    function lv(t, e, i, n) { dt.call(this, t), this.selected = e, this.deselected = i, this.mapBrowserEvent = n }

    function uv(t) {
        if (Zu.call(this, { handleEvent: pv }), t = t ? t : {}, this.C = t.condition ? t.condition : sp, this.v = t.addCondition ? t.addCondition : tt, this.D = t.removeCondition ? t.removeCondition : tt, this.O = t.toggleCondition ? t.toggleCondition : hp, this.o = !!t.multi && t.multi, this.j = t.filter ? t.filter : Q, this.c = new Wr({ source: new kr({ useSpatialIndex: !1, features: t.features, wrapX: t.wrapX }), style: t.style ? t.style : cv(), updateWhileAnimating: !0, updateWhileInteracting: !0 }), t.layers)
            if ("function" == typeof t.layers) t = t.layers;
            else {
                var e = t.layers;
                t = function(t) { return he(e, t) }
            }
        else t = Q;
        this.s = t, this.a = {}, t = this.c.ja().c, lt(t, _w, this.Bp, this), lt(t, Pw, this.Ep, this)
    }

    function pv(t) {
        if (!this.C(t)) return !0;
        var e = this.v(t),
            i = this.D(t),
            n = this.O(t),
            r = !e && !i && !n,
            o = t.map,
            s = this.c.ja().c,
            a = [],
            h = [];
        if (r) et(this.a), o.ne(t.pixel, function(t, e) { if (this.j(t, e)) { h.push(t); var i = b(t); return this.a[i] = e, !this.o } }, this, this.s), 0 < h.length && 1 == s.Sc() && s.item(0) == h[0] ? h.length = 0 : (0 !== s.Sc() && (a = Array.prototype.concat(s.a), s.clear()), s.th(h));
        else {
            for (o.ne(t.pixel, function(t, r) {
                    if (this.j(t, r)) {
                        if (!e && !n || he(s.a, t))(i || n) && he(s.a, t) && (a.push(t), o = b(t), delete this.a[o]);
                        else {
                            h.push(t);
                            var o = b(t);
                            this.a[o] = r
                        }
                        return !this.o
                    }
                }, this, this.s), r = a.length - 1; 0 <= r; --r) s.remove(a[r]);
            s.th(h)
        }
        return (0 < h.length || 0 < a.length) && this.b(new lv("select", h, a, t)), op(t)
    }

    function cv() {
        var t = Ki();
        return pe(t.Polygon, t.LineString), pe(t.GeometryCollection, t.LineString),
            function(e) { return t[e.Y().Z()] }
    }

    function fv(t) { cp.call(this, { handleEvent: gv, handleDownEvent: Q, handleUpEvent: dv }), t = t ? t : {}, this.s = t.source ? t.source : null, this.qa = void 0 === t.vertex || t.vertex, this.U = void 0 === t.edge || t.edge, this.o = t.features ? t.features : null, this.xa = [], this.D = {}, this.O = {}, this.X = {}, this.v = {}, this.P = null, this.c = void 0 !== t.pixelTolerance ? t.pixelTolerance : 10, this.Ta = yv.bind(this), this.a = new Sr, this.ra = { Point: this.Kp, LineString: this.Mj, LinearRing: this.Mj, Polygon: this.Lp, MultiPoint: this.Ip, MultiLineString: this.Hp, MultiPolygon: this.Jp, GeometryCollection: this.Gp } }

    function gv(t) {
        var e, i, n = t.pixel,
            r = t.coordinate;
        e = t.map;
        var o = e.Za([n[0] - this.c, n[1] + this.c]);
        i = e.Za([n[0] + this.c, n[1] - this.c]);
        var s, o = E([o, i]),
            a = Cr(this.a, o),
            o = !1,
            h = null;
        return i = null, 0 < a.length && (this.P = r, a.sort(this.Ta), a = a[0].ua, this.qa && !this.U ? (r = e.Qa(a[0]), s = e.Qa(a[1]), r = Su(n, r), n = Su(n, s), s = Math.sqrt(Math.min(r, n)), (s = s <= this.c) && (o = !0, h = r > n ? a[1] : a[0], i = e.Qa(h))) : this.U && (h = vu(r, a), i = e.Qa(h), Math.sqrt(Su(n, i)) <= this.c && (o = !0, this.qa && (r = e.Qa(a[0]), s = e.Qa(a[1]), r = Su(i, r), n = Su(i, s), s = Math.sqrt(Math.min(r, n)), s = s <= this.c))) && (h = r > n ? a[1] : a[0], i = e.Qa(h)), o && (i = [Math.round(i[0]), Math.round(i[1])])), e = h, o && (t.coordinate = e.slice(0, 2), t.pixel = i), gp.call(this, t)
    }

    function dv() { var t = it(this.v); return t.length && (t.forEach(this.gl, this), this.v = {}), !1 }

    function yv(t, e) { return Nu(this.P, t.ua) - Nu(this.P, e.ua) }

    function mv(t, e, i) { dt.call(this, t), this.features = e, this.coordinate = i }

    function vv(t) {
        if (cp.call(this, { handleDownEvent: bv, handleDragEvent: xv, handleMoveEvent: Ev, handleUpEvent: wv }), this.s = void 0, this.a = null, this.c = void 0 !== t.features ? t.features : null, t.layers)
            if ("function" == typeof t.layers) t = t.layers;
            else {
                var e = t.layers;
                t = function(t) { return he(e, t) }
            }
        else t = Q;
        this.v = t, this.o = null
    }

    function bv(t) { return this.o = Sv(this, t.pixel, t.map), !(this.a || !this.o) && (this.a = t.coordinate, Ev.call(this, t), this.b(new mv("translatestart", this.c, t.coordinate)), !0) }

    function wv(t) { return !!this.a && (this.a = null, Ev.call(this, t), this.b(new mv("translateend", this.c, t.coordinate)), !0) }

    function xv(t) {
        if (this.a) {
            t = t.coordinate;
            var e = t[0] - this.a[0],
                i = t[1] - this.a[1];
            if (this.c) this.c.forEach(function(t) {
                var n = t.Y();
                n.translate(e, i), t.ob(n)
            });
            else if (this.o) {
                var n = this.o.Y();
                n.translate(e, i), this.o.ob(n)
            }
            this.a = t, this.b(new mv("translating", this.c, t))
        }
    }

    function Ev(t) {
        var e = t.map.Hc();
        Sv(this, t.pixel, t.map) ? (this.s = e.style.cursor, e.style.cursor = this.a ? "-webkit-grabbing" : "-webkit-grab", e.style.cursor = this.a ? "grabbing" : "grab") : (e.style.cursor = void 0 !== this.s ? this.s : "", this.s = void 0)
    }

    function Sv(t, e, i) { var n = null; return e = i.ne(e, function(t) { return t }, t, t.v), t.c && he(t.c.a, e) && (n = e), n }

    function Nv(t) {
        t = t ? t : {};
        var e = db({}, t);
        delete e.gradient, delete e.radius, delete e.blur, delete e.shadow, delete e.weight, Wr.call(this, e), this.f = null, this.fa = void 0 !== t.shadow ? t.shadow : 250, this.X = void 0, this.c = null, lt(this, Nt("gradient"), this.yn, this), this.Pk(t.gradient ? t.gradient : fC), this.Kk(void 0 !== t.blur ? t.blur : 15), this.Pj(void 0 !== t.radius ? t.radius : 8), lt(this, Nt("blur"), this.kh, this), lt(this, Nt("radius"), this.kh, this), this.kh();
        var i, n = t.weight ? t.weight : "weight";
        i = "string" == typeof n ? function(t) { return t.get(n) } : n, this.l(function(t) {
            t = i(t), t = void 0 !== t ? Ct(t, 0, 1) : 1;
            var e = 255 * t | 0,
                n = this.c[e];
            return n || (n = [new Xi({ image: new en({ opacity: t, src: this.X }) })], this.c[e] = n), n
        }.bind(this)), this.set("renderOrder", null), lt(this, "render", this.ao, this)
    }

    function Lv(t) { mo.call(this, { cacheSize: t.cacheSize, crossOrigin: "anonymous", opaque: !0, projection: qt("EPSG:3857"), reprojectionErrorThreshold: t.reprojectionErrorThreshold, state: "loading", tileLoadFunction: t.tileLoadFunction, wrapX: void 0 === t.wrapX || t.wrapX }), this.o = void 0 !== t.culture ? t.culture : "en-us", this.c = void 0 !== t.maxZoom ? t.maxZoom : -1, hg("https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + t.imagerySet + "?uriScheme=https&include=ImageryProviders&key=" + t.key, this.A.bind(this), void 0, "jsonp") }

    function Cv(t) {
        t = t || {};
        var e = void 0 !== t.projection ? t.projection : "EPSG:3857",
            i = void 0 !== t.tileGrid ? t.tileGrid : Cn({ extent: In(e), maxZoom: t.maxZoom, minZoom: t.minZoom, tileSize: t.tileSize });
        mo.call(this, { attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, logo: t.logo, opaque: t.opaque, projection: e, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileGrid: i, tileLoadFunction: t.tileLoadFunction, tilePixelRatio: t.tilePixelRatio, tileUrlFunction: t.tileUrlFunction, url: t.url, urls: t.urls, wrapX: void 0 === t.wrapX || t.wrapX })
    }

    function Mv(t) { this.A = t.account, this.v = t.map || "", this.c = t.config || {}, this.o = {}, Cv.call(this, { attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, logo: t.logo, maxZoom: void 0 !== t.maxZoom ? t.maxZoom : 18, minZoom: t.minZoom, projection: t.projection, state: "loading", wrapX: t.wrapX }), Iv(this) }

    function Iv(t) {
        var e = JSON.stringify(t.c);
        if (t.o[e]) kv(t, t.o[e]);
        else {
            var i = "https://" + t.A + ".cartodb.com/api/v1/map";
            t.v && (i += "/named/" + t.v);
            var n = new XMLHttpRequest;
            n.addEventListener("load", t.Hn.bind(t, e)), n.addEventListener("error", t.Gn.bind(t)), n.open("POST", i), n.setRequestHeader("Content-type", "application/json"), n.send(JSON.stringify(t.c))
        }
    }

    function kv(t, e) { t.rb("https://" + e.cdn_url.https + "/" + t.A + "/api/v1/map/" + e.layergroupid + "/{z}/{x}/{y}.png") }

    function Tv(t) { kr.call(this, { attributions: t.attributions, extent: t.extent, logo: t.logo, projection: t.projection, wrapX: t.wrapX }), this.C = void 0, this.ra = void 0 !== t.distance ? t.distance : 20, this.v = [], this.xa = t.geometryFunction || function(t) { return t = t.Y(), x(t instanceof se, 10), t }, this.A = t.source, this.A.I("change", Tv.prototype.Ua, this) }

    function Av(t) {
        if (void 0 !== t.C) {
            t.v.length = 0;
            for (var e = T(), i = t.ra * t.C, n = t.A.Pf(), r = {}, o = 0, s = n.length; o < s; o++) {
                var a = n[o];
                b(a).toString() in r || !(a = t.xa(a)) || (a = a.ba(), R(a, e), S(e, i, e), a = t.A.Ug(e), a = a.filter(function(t) { return t = b(t).toString(), !(t in r) && (r[t] = !0) }), t.v.push(Rv(t, a)))
            }
        }
    }

    function Rv(t, e) {
        for (var i = [0, 0], n = e.length - 1; 0 <= n; --n) {
            var r = t.xa(e[n]);
            r ? mu(i, r.ba()) : e.splice(n, 1)
        }
        return n = 1 / e.length, i[0] *= n, i[1] *= n, i = new Tn(new se(i)), i.set("features", e), i
    }

    function _v(t) { t = t || {}, _o.call(this, { attributions: t.attributions, logo: t.logo, projection: t.projection, resolutions: t.resolutions }), this.X = void 0 !== t.crossOrigin ? t.crossOrigin : null, this.i = t.url, this.j = void 0 !== t.imageLoadFunction ? t.imageLoadFunction : Oo, this.A = t.params || {}, this.c = null, this.s = [0, 0], this.U = 0, this.P = void 0 !== t.ratio ? t.ratio : 1.5 }

    function Pv(t) { _o.call(this, { projection: t.projection, resolutions: t.resolutions }), this.X = void 0 !== t.crossOrigin ? t.crossOrigin : null, this.s = void 0 !== t.displayDpi ? t.displayDpi : 96, this.j = t.params || {}, this.U = t.url, this.c = void 0 !== t.imageLoadFunction ? t.imageLoadFunction : Oo, this.fa = void 0 === t.hidpi || t.hidpi, this.qa = void 0 !== t.metersPerUnit ? t.metersPerUnit : 1, this.A = void 0 !== t.ratio ? t.ratio : 1, this.xa = void 0 !== t.useOverlay && t.useOverlay, this.i = null, this.P = 0 }

    function Ov(t) {
        var e = t.imageExtent,
            i = void 0 !== t.crossOrigin ? t.crossOrigin : null,
            n = void 0 !== t.imageLoadFunction ? t.imageLoadFunction : Oo;
        _o.call(this, { attributions: t.attributions, logo: t.logo, projection: qt(t.projection) }), this.c = new Ao(e, void 0, 1, this.l, t.url, i, n), this.i = t.imageSize ? t.imageSize : null, lt(this.c, "change", this.o, this)
    }

    function Dv(t) {
        t = t || {};
        var e;
        e = void 0 !== t.attributions ? t.attributions : [dC], Cv.call(this, { attributions: e, cacheSize: t.cacheSize, crossOrigin: void 0 !== t.crossOrigin ? t.crossOrigin : "anonymous", opaque: void 0 === t.opaque || t.opaque, maxZoom: void 0 !== t.maxZoom ? t.maxZoom : 19, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileLoadFunction: t.tileLoadFunction, url: void 0 !== t.url ? t.url : "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png", wrapX: t.wrapX })
    }

    function Fv(t) {
        this.P = null, this.xa = void 0 !== t.operationType ? t.operationType : "pixel", this.Ua = void 0 !== t.threads ? t.threads : 1, this.c = jv(t.sources);
        for (var e = 0, i = this.c.length; e < i; ++e) lt(this.c[e], "change", this.u, this);
        this.i = Ii(), this.fa = new su(function() { return 1 }, this.u.bind(this));
        for (var e = Bv(this.c), i = {}, n = 0, r = e.length; n < r; ++n) i[b(e[n].layer)] = e[n];
        this.j = this.s = null, this.X = { animate: !1, attributions: {}, coordinateToPixelTransform: Ul(), extent: null, focus: null, index: 0, layerStates: i, layerStatesArray: e, logos: {}, pixelRatio: 1, pixelToCoordinateTransform: Ul(), postRenderFunctions: [], size: [0, 0], skippedFeatureUids: {}, tileQueue: this.fa, time: Date.now(), usedTiles: {}, viewState: { rotation: 0 }, viewHints: [], wantedTiles: {} }, _o.call(this, {}), void 0 !== t.operation && this.A(t.operation, t.lib)
    }

    function Uv(t, e, i) { var n = t.s; return !n || t.g !== n.Vr || i !== n.resolution || !P(e, n.extent) }

    function Bv(t) { return t.map(function(t) { return Ur(t.a) }) }

    function jv(t) {
        for (var e = t.length, i = Array(e), n = 0; n < e; ++n) {
            var r = n,
                o = t[n],
                s = null;
            o instanceof uo ? (o = new qr({ source: o }), s = new Kc(o)) : o instanceof _o && (o = new Vr({ source: o }), s = new Yc(o)), i[r] = s
        }
        return i
    }

    function zv(t, e, i) { dt.call(this, t), this.extent = e.extent, this.resolution = e.viewState.resolution / e.pixelRatio, this.data = i }

    function Gv(t) {
        var e = t.layer.indexOf("-"),
            e = -1 == e ? t.layer : t.layer.slice(0, e),
            e = wC[e],
            i = bC[t.layer];
        Cv.call(this, { attributions: xC, cacheSize: t.cacheSize, crossOrigin: "anonymous", maxZoom: void 0 != t.maxZoom ? t.maxZoom : e.maxZoom, minZoom: void 0 != t.minZoom ? t.minZoom : e.minZoom, opaque: i.opaque, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileLoadFunction: t.tileLoadFunction, url: void 0 !== t.url ? t.url : "https://stamen-tiles-{a-d}.a.ssl.fastly.net/" + t.layer + "/{z}/{x}/{y}." + i.Qb })
    }

    function qv(t) { t = t || {}, mo.call(this, { attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, logo: t.logo, projection: t.projection, reprojectionErrorThreshold: t.reprojectionErrorThreshold, tileGrid: t.tileGrid, tileLoadFunction: t.tileLoadFunction, url: t.url, urls: t.urls, wrapX: void 0 === t.wrapX || t.wrapX }), this.c = t.params || {}, this.o = T() }

    function Vv(t, e, i) { Yn.call(this, t, 2), this.l = e, this.c = i, this.g = {} }

    function Wv(t) { uo.call(this, { opaque: !1, projection: t.projection, tileGrid: t.tileGrid, wrapX: void 0 === t.wrapX || t.wrapX }) }

    function Xv(t) {
        if (this.c = null, mo.call(this, { attributions: t.attributions, cacheSize: t.cacheSize, crossOrigin: t.crossOrigin, projection: qt("EPSG:3857"), reprojectionErrorThreshold: t.reprojectionErrorThreshold, state: "loading", tileLoadFunction: t.tileLoadFunction, wrapX: void 0 === t.wrapX || t.wrapX }), t.jsonp) hg(t.url, this.Yj.bind(this), this.Nf.bind(this));
        else {
            var e = new XMLHttpRequest;
            e.addEventListener("load", this.nq.bind(this)), e.addEventListener("error", this.mq.bind(this)), e.open("GET", t.url), e.send()
        }
    }

    function Hv(t) {
        if (uo.call(this, { projection: qt("EPSG:3857"), state: "loading" }), this.s = void 0 === t.preemptive || t.preemptive, this.o = ho, this.i = void 0, this.c = t.jsonp || !1, t.url)
            if (this.c) hg(t.url, this.Dh.bind(this), this.Of.bind(this));
            else {
                var e = new XMLHttpRequest;
                e.addEventListener("load", this.rq.bind(this)), e.addEventListener("error", this.qq.bind(this)), e.open("GET", t.url), e.send()
            }
        else t.tileJSON ? this.Dh(t.tileJSON) : x(!1, 51)
    }

    function Yv(t, e, i, n, r, o) { Yn.call(this, t, e), this.s = i, this.g = n, this.T = r, this.c = this.o = this.l = null, this.A = o }

    function Kv(t, e, i, n, r) { 0 == t.state && !0 === r ? (ut(t, "change", function() { i.call(n, this.getData(e)) }, t), $v(t)) : !0 === r ? Ga(function() { i.call(n, this.getData(e)) }, t) : i.call(n, t.getData(e)) }

    function $v(t) {
        if (0 == t.state)
            if (t.state = 1, t.A) hg(t.s, t.Zj.bind(t), t.vf.bind(t));
            else {
                var e = new XMLHttpRequest;
                e.addEventListener("load", t.pq.bind(t)), e.addEventListener("error", t.oq.bind(t)), e.open("GET", t.s), e.send()
            }
    }

    function Zv(t, e, i, n, r) { Yn.call(this, t, e), this.g = Ii(), this.l = n, this.c = null, this.f = { ke: !1, Vh: null, Gk: -1, Wh: -1, He: null, $k: [] }, this.A = r, this.o = i }

    function Jv(t) { yo.call(this, { attributions: t.attributions, cacheSize: void 0 !== t.cacheSize ? t.cacheSize : 128, extent: t.extent, logo: t.logo, opaque: !1, projection: t.projection, state: t.state, tileGrid: t.tileGrid, tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : Qv, tileUrlFunction: t.tileUrlFunction, tilePixelRatio: t.tilePixelRatio, url: t.url, urls: t.urls, wrapX: void 0 === t.wrapX || t.wrapX }), this.c = t.format ? t.format : null, this.i = void 0 == t.overlaps || t.overlaps, this.tileClass = t.tileClass ? t.tileClass : Zv }

    function Qv(t, e) { t.Qk(mr(e, t.l)) }

    function tb(t) {
        t = t || {};
        var e = t.size,
            i = e[0],
            n = e[1],
            r = [],
            o = 256;
        switch (void 0 !== t.tierSizeCalculation ? t.tierSizeCalculation : "default") {
            case "default":
                for (; i > o || n > o;) r.push([Math.ceil(i / o), Math.ceil(n / o)]), o += o;
                break;
            case "truncated":
                for (; i > o || n > o;) r.push([Math.ceil(i / o), Math.ceil(n / o)]), i >>= 1, n >>= 1;
                break;
            default:
                x(!1, 53)
        }
        r.push([1, 1]), r.reverse();
        for (var o = [1], s = [0], n = 1, i = r.length; n < i; n++) o.push(1 << n), s.push(r[n - 1][0] * r[n - 1][1] + s[n - 1]);
        o.reverse();
        var e = [0, -e[1], e[0], 0],
            e = new mn({ extent: e, origin: X(e), resolutions: o }),
            a = t.url;
        mo.call(this, {
            attributions: t.attributions,
            cacheSize: t.cacheSize,
            crossOrigin: t.crossOrigin,
            logo: t.logo,
            reprojectionErrorThreshold: t.reprojectionErrorThreshold,
            tileClass: eb,
            tileGrid: e,
            tileUrlFunction: function(t) {
                if (t) {
                    var e = t[0],
                        i = t[1];
                    return t = -t[2] - 1, a + "TileGroup" + ((i + t * r[e][0] + s[e]) / 256 | 0) + "/" + e + "-" + i + "-" + t + ".jpg"
                }
            }
        })
    }

    function eb(t, e, i, n, r) { Hr.call(this, t, e, i, n, r), this.l = {} }

    function ib(t) { t = t || {}, this.a = void 0 !== t.initialSize ? t.initialSize : 256, this.g = void 0 !== t.maxSize ? t.maxSize : void 0 !== pb ? pb : 2048, this.b = void 0 !== t.space ? t.space : 1, this.c = [new rb(this.a, this.b)], this.f = this.a, this.i = [new rb(this.f, this.b)] }

    function nb(t, e, i, n, r, o, s) {
        var a, h, l, u = e ? t.i : t.c;
        for (h = 0, l = u.length; h < l; ++h) {
            if (a = u[h], a = a.add(i, n, r, o, s)) return a;
            a || h !== l - 1 || (e ? (a = Math.min(2 * t.f, t.g), t.f = a) : (a = Math.min(2 * t.a, t.g), t.a = a), a = new rb(a, t.b), u.push(a), ++l)
        }
        return null
    }

    function rb(t, e) { this.b = e, this.a = [{ x: 0, y: 0, width: t, height: t }], this.f = {}, this.g = Ii(t, t), this.c = this.g.canvas }

    function ob(t, e, i, n) { e = [e, 1], 0 < i.width && 0 < i.height && e.push(i), 0 < n.width && 0 < n.height && e.push(n), t.a.splice.apply(t.a, e) }
    var sb, ab = this,
        hb = "closure_uid_" + (1e9 * Math.random() >>> 0),
        lb = 0,
        ub = {};
    ub.be = window.GeoAdmin && window.GeoAdmin.lang ? window.GeoAdmin.lang : "de", ub.Ya = function() { return ub.be || ub.Lk("de"), ub.be }, ub.Lk = function(t) { ub.be = t, window.GeoAdmin && window.GeoAdmin.lang && (window.GeoAdmin.lang = t) }, ub.translate = function(t, e) { var i = ub[ub.Ya()]; return (i = i && i[t]) || (i = t), e && (i = ub.format(i, e)), i }, ub.format = function(t, e, i) { return e || (e = window), t.replace(/\$\{([\w.]+?)\}/g, function(t, n) { for (var r, o = n.split(/\.+/), s = 0; s < o.length && (0 == s && (r = e), void 0 !== r); s++) r = r[o[s]]; return "function" == typeof r && (r = i ? r.apply(null, i) : r()), "undefined" == typeof r ? "undefined" : r }) }, ub.im = { "Geocoding results": "Geokodierung Ergebnisse", "Zoom in": "Zoom in", "Zoom out": "Zoom out", "Reset rotation": "Rotation zurücksetzen" }, ub.km = { "Geocoding results": "Geocoding results", "Zoom in": "Zoom in", "Zoom out": "Zoom out", "Reset rotation": "Reset rotation" }, ub.tm = { "Geocoding results": "Résultat du géocodage", "Zoom in": "Zoom avant", "Zoom out": "Zoom arrière", "Reset rotation": "Annuler la rotation" }, ub.to = { "Geocoding results": "Risultati geocoding", "Zoom in": "Zoom in", "Zoom out": "Zoom out", "Reset rotation": "Annullare la rotazione" }, ub.Wr = { "Geocoding results": "Rezultatele geocodare", "Zoom in": "Zoom in", "Zoom out": "Zoom out", "Reset rotation": "Rotaziun reinizialisar" };
    var pb, cb, fb = 0;
    if ("undefined" != typeof window) var gb = window;
    else "undefined" != typeof global ? gb = global : "undefined" != typeof self && (gb = self);
    m(w, Error);
    var db = "function" == typeof Object.assign ? Object.assign : function(t, e) {
        if (!t || !t) throw new TypeError("Cannot convert undefined or null to object");
        for (var i = Object(t), n = 1, r = arguments.length; n < r; ++n) {
            var o = arguments[n];
            if (void 0 !== o && null !== o)
                for (var s in o) o.hasOwnProperty(s) && (i[s] = o[s])
        }
        return i
    };
    gt.prototype.Yd = !1, gt.prototype.Pa = function() { this.Yd || (this.Yd = !0, this.pa()) }, gt.prototype.pa = v, dt.prototype.preventDefault = dt.prototype.stopPropagation = function() { this.ur = !0 }, m(vt, gt), vt.prototype.addEventListener = function(t, e) {
        var i = this.sa[t];
        i || (i = this.sa[t] = []), -1 === i.indexOf(e) && i.push(e)
    }, vt.prototype.b = function(t) {
        var e = "string" == typeof t ? new dt(t) : t;
        t = e.type, e.target = this;
        var i, n = this.sa[t];
        if (n) {
            t in this.za || (this.za[t] = 0, this.Xa[t] = 0), ++this.za[t];
            for (var r = 0, o = n.length; r < o; ++r)
                if (!1 === n[r].call(this, e) || e.ur) { i = !1; break }
            if (--this.za[t], 0 === this.za[t]) {
                for (e = this.Xa[t], delete this.Xa[t]; e--;) this.removeEventListener(t, v);
                delete this.za[t]
            }
            return i
        }
    }, vt.prototype.pa = function() { ft(this) }, vt.prototype.removeEventListener = function(t, e) {
        var i = this.sa[t];
        if (i) {
            var n = i.indexOf(e);
            t in this.Xa ? (i[n] = v, ++this.Xa[t]) : (i.splice(n, 1), 0 === i.length && delete this.sa[t])
        }
    }, m(wt, vt), sb = wt.prototype, sb.u = function() {++this.g, this.b("change") }, sb.K = function() { return this.g }, sb.I = function(t, e, i) { if (Array.isArray(t)) { for (var n = t.length, r = Array(n), o = 0; o < n; ++o) r[o] = lt(this, t[o], e, i); return r } return lt(this, t, e, i) }, sb.L = function(t, e, i) { if (Array.isArray(t)) { for (var n = t.length, r = Array(n), o = 0; o < n; ++o) r[o] = ut(this, t[o], e, i); return r } return ut(this, t, e, i) }, sb.J = function(t, e, i) {
        if (Array.isArray(t))
            for (var n = 0, r = t.length; n < r; ++n) pt(this, t[n], e, i);
        else pt(this, t, e, i)
    }, sb.M = xt, m(Et, dt), m(St, wt);
    var yb = {};
    sb = St.prototype, sb.get = function(t) { var e; return this.T.hasOwnProperty(t) && (e = this.T[t]), e }, sb.R = function() { return Object.keys(this.T) }, sb.N = function() { return db({}, this.T) }, sb.set = function(t, e, i) { i ? this.T[t] = e : (i = this.T[t], this.T[t] = e, i !== e && Lt(this, t, i)) }, sb.G = function(t, e) { for (var i in t) this.set(i, t[i], e) }, sb.S = function(t, e) {
        if (t in this.T) {
            var i = this.T[t];
            delete this.T[t], e || Lt(this, t, i)
        }
    };
    var mb = function() { var t; return t = "cosh" in Math ? Math.cosh : function(t) { return t = Math.exp(t), (t + 1 / t) / 2 } }();
    _t.prototype.a = function(t) {
        for (var e = 0, i = t.length, n = t[i - 1][0], r = t[i - 1][1], o = 0; o < i; o++) var s = t[o][0],
            a = t[o][1],
            e = e + Tt(s - n) * (2 + Math.sin(Tt(r)) + Math.sin(Tt(a))),
            n = s,
            r = a;
        return e * this.radius * this.radius / 2
    }, _t.prototype.b = function(t, e) {
        var i = Tt(t[1]),
            n = Tt(e[1]),
            r = (n - i) / 2,
            o = Tt(e[0] - t[0]) / 2,
            i = Math.sin(r) * Math.sin(r) + Math.sin(o) * Math.sin(o) * Math.cos(i) * Math.cos(n);
        return 2 * this.radius * Math.atan2(Math.sqrt(i), Math.sqrt(1 - i))
    }, _t.prototype.offset = function(t, e, i) {
        var n = Tt(t[1]);
        e /= this.radius;
        var r = Math.asin(Math.sin(n) * Math.cos(e) + Math.cos(n) * Math.sin(e) * Math.cos(i));
        return [180 * (Tt(t[0]) + Math.atan2(Math.sin(i) * Math.sin(e) * Math.cos(n), Math.cos(e) - Math.sin(n) * Math.sin(r))) / Math.PI, 180 * r / Math.PI]
    };
    var vb = new _t(6370997),
        bb = {};
    bb.degrees = 2 * Math.PI * vb.radius / 360, bb.ft = .3048, bb.m = 1, bb["us-ft"] = 1200 / 3937, sb = Pt.prototype, sb.Ya = function() { return this.be }, sb.H = function() { return this.f }, sb.Ub = function() { return this.c }, sb.Gc = function() { return this.o || bb[this.c] }, sb.gn = function() { return this.i }, sb.so = function() { return this.g }, sb.ds = function(t) { this.g = t, this.a = !(!t || !this.f) }, sb.Qj = function(t) { this.f = t, this.a = !(!this.g || !t) }, sb.ls = function(t) { this.i = t }, sb.cs = function(t) { this.j = t }, sb.Wm = function(t, e) {
        if ("degrees" == this.Ub()) return t;
        var i = Xt(this, qt("EPSG:4326")),
            n = [e[0] - t / 2, e[1], e[0] + t / 2, e[1], e[0], e[1] - t / 2, e[0], e[1] + t / 2],
            n = i(n, n, 2),
            i = vb.b(n.slice(0, 2), n.slice(2, 4)),
            n = vb.b(n.slice(4, 6), n.slice(6, 8)),
            n = (i + n) / 2,
            i = this.Gc();
        return void 0 !== i && (n /= i), n
    }, sb.getPointResolution = function(t, e) { return this.j(t, e) };
    var wb = {},
        xb = {},
        Eb = null;
    m(Zt, St), sb = Zt.prototype, sb.Sb = function(t, e) { var i = e ? e : [NaN, NaN]; return this.Ob(t[0], t[1], i, 1 / 0), i }, sb.Cb = function(t) { return this.pd(t[0], t[1]) }, sb.pd = tt, sb.H = function(t) { this.A != this.g && (this.s = this.bf(this.s), this.A = this.g); var e = this.s; return t ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3]) : t = e, t }, sb.$b = function(t) { return this.se(t * t) }, sb.Db = function(t, e) { return this.cd(Wt(t, e)), this }, m(Qt, Zt), sb = Qt.prototype, sb.pd = tt, sb.bf = function(t) { return _(this.B, 0, this.B.length, this.a, t) }, sb.lc = function() { return this.B.slice(0, this.a) }, sb.oa = function() { return this.B }, sb.mc = function() { return this.B.slice(this.B.length - this.a) }, sb.nc = function() { return this.ma }, sb.se = function(t) { if (this.o != this.g && (et(this.i), this.l = 0, this.o = this.g), 0 > t || 0 !== this.l && t <= this.l) return this; var e = t.toString(); if (this.i.hasOwnProperty(e)) return this.i[e]; var i = this.Dd(t); return i.oa().length < this.B.length ? this.i[e] = i : (this.l = t, this) }, sb.Dd = function() { return this }, sb.Aa = function() { return this.a }, sb.cd = function(t) { this.B && (t(this.B, this.B, this.a), this.u()) }, sb.rotate = function(t, e) {
        var i = this.oa();
        if (i) {
            for (var n = i.length, r = this.Aa(), o = i ? i : [], s = Math.cos(t), a = Math.sin(t), h = e[0], l = e[1], u = 0, p = 0; p < n; p += r) {
                var c = i[p] - h,
                    f = i[p + 1] - l;
                for (o[u++] = h + c * s - f * a, o[u++] = l + c * a + f * s, c = p + 2; c < p + r; ++c) o[u++] = i[c]
            }
            i && o.length != u && (o.length = u), this.u()
        }
    }, sb.scale = function(t, e, i) {
        var n = e;
        void 0 === n && (n = t);
        var r = i;
        if (r || (r = G(this.H())), i = this.oa()) {
            e = i.length;
            for (var o = this.Aa(), s = i ? i : [], a = r[0], r = r[1], h = 0, l = 0; l < e; l += o) {
                var u = i[l] - a,
                    p = i[l + 1] - r;
                for (s[h++] = a + t * u, s[h++] = r + n * p, u = l + 2; u < l + o; ++u) s[h++] = i[u]
            }
            i && s.length != h && (s.length = h), this.u()
        }
    }, sb.translate = function(t, e) {
        var i = this.oa();
        if (i) {
            var n, r, o = i.length,
                s = this.Aa(),
                a = i ? i : [],
                h = 0;
            for (n = 0; n < o; n += s)
                for (a[h++] = i[n] + t, a[h++] = i[n + 1] + e, r = n + 2; r < n + s; ++r) a[h++] = i[r];
            i && a.length != h && (a.length = h), this.u()
        }
    }, m(se, Qt), sb = se.prototype, sb.clone = function() { var t = new se(null); return t.ca(this.ma, this.B.slice()), t }, sb.Ob = function(t, e, i, n) { var r = this.B; if (t = kt(t, e, r[0], r[1]), t < n) { for (n = this.a, e = 0; e < n; ++e) i[e] = r[e]; return i.length = n, t } return n }, sb.ba = function() { return this.B ? this.B.slice() : [] }, sb.bf = function(t) { return R(this.B, t) }, sb.Z = function() { return "Point" }, sb.ab = function(t) { return I(t, this.B[0], this.B[1]) }, sb.wa = function(t, e) { t ? (ie(this, e, t, 0), this.B || (this.B = []), this.B.length = ne(this.B, t), this.u()) : this.ca("XY", null) }, sb.ca = function(t, e) { ee(this, t, e), this.u() }, m(we, Qt), sb = we.prototype, sb.fm = function(t) { this.B ? pe(this.B, t.oa()) : this.B = t.oa().slice(), this.u() }, sb.clone = function() { var t = new we(null); return t.ca(this.ma, this.B.slice()), t }, sb.Ob = function(t, e, i, n) {
        if (n < L(this.H(), t, e)) return n;
        var r, o, s, a = this.B,
            h = this.a;
        for (r = 0, o = a.length; r < o; r += h)
            if (s = kt(t, e, a[r], a[r + 1]), s < n) {
                for (n = s, s = 0; s < h; ++s) i[s] = a[r + s];
                i.length = h
            }
        return n
    }, sb.ba = function() { return ve(this.B, 0, this.B.length, this.a) }, sb.Vm = function(t) { var e = this.B ? this.B.length / this.a : 0; return 0 > t || e <= t ? null : (e = new se(null), e.ca(this.ma, this.B.slice(t * this.a, (t + 1) * this.a)), e) }, sb.If = function() {
        var t, e, i = this.B,
            n = this.ma,
            r = this.a,
            o = [];
        for (t = 0, e = i.length; t < e; t += r) {
            var s = new se(null);
            s.ca(n, i.slice(t, t + r)), o.push(s)
        }
        return o
    }, sb.Z = function() { return "MultiPoint" }, sb.ab = function(t) {
        var e, i, n, r, o = this.B,
            s = this.a;
        for (e = 0, i = o.length; e < i; e += s)
            if (n = o[e], r = o[e + 1], I(t, n, r)) return !0;
        return !1
    }, sb.wa = function(t, e) { t ? (ie(this, e, t, 1), this.B || (this.B = []), this.B.length = re(this.B, 0, t, this.a), this.u()) : this.ca("XY", null) }, sb.ca = function(t, e) { ee(this, t, e), this.u() }, m(Fe, Qt), sb = Fe.prototype, sb.cm = function(t) { this.B ? pe(this.B, t) : this.B = t.slice(), this.u() }, sb.clone = function() { var t = new Fe(null); return t.ca(this.ma, this.B.slice()), t }, sb.Ob = function(t, e, i, n) { return n < L(this.H(), t, e) ? n : (this.v != this.g && (this.C = Math.sqrt(Ee(this.B, 0, this.B.length, this.a, 0)), this.v = this.g), Ne(this.B, 0, this.B.length, this.a, this.C, !1, t, e, i, n)) }, sb.sm = function(t, e) { return Re(this.B, 0, this.B.length, this.a, t, e) }, sb.mp = function(t, e) { return "XYM" != this.ma && "XYZM" != this.ma ? null : Me(this.B, 0, this.B.length, this.a, t, void 0 !== e && e) }, sb.ba = function() { return ve(this.B, 0, this.B.length, this.a) }, sb.Ii = function(t, e) { return Ce(this.B, 0, this.B.length, this.a, t, e) }, sb.np = function() {
        var t, e = this.B,
            i = this.a,
            n = e[0],
            r = e[1],
            o = 0;
        for (t = 0 + i; t < this.B.length; t += i) var s = e[t],
            a = e[t + 1],
            o = o + Math.sqrt((s - n) * (s - n) + (a - r) * (a - r)),
            n = s,
            r = a;
        return o
    }, sb.Dd = function(t) { var e = []; return e.length = Oe(this.B, 0, this.B.length, this.a, t, e, 0), t = new Fe(null), t.ca("XY", e), t }, sb.Z = function() { return "LineString" }, sb.ab = function(t) { return _e(this.B, 0, this.B.length, this.a, t) }, sb.wa = function(t, e) { t ? (ie(this, e, t, 1), this.B || (this.B = []), this.B.length = re(this.B, 0, t, this.a), this.u()) : this.ca("XY", null) }, sb.ca = function(t, e) { ee(this, t, e), this.u() }, m(Be, Qt), sb = Be.prototype, sb.dm = function(t) { this.B ? pe(this.B, t.oa().slice()) : this.B = t.oa().slice(), this.c.push(this.B.length), this.u() }, sb.clone = function() { var t = new Be(null); return t.ca(this.ma, this.B.slice(), this.c.slice()), t }, sb.Ob = function(t, e, i, n) { return n < L(this.H(), t, e) ? n : (this.j != this.g && (this.v = Math.sqrt(Se(this.B, 0, this.c, this.a, 0)), this.j = this.g), Le(this.B, 0, this.c, this.a, this.v, !1, t, e, i, n)) }, sb.pp = function(t, e, i) { return "XYM" != this.ma && "XYZM" != this.ma || 0 === this.B.length ? null : Ie(this.B, this.c, this.a, t, void 0 !== e && e, void 0 !== i && i) }, sb.ba = function() { return be(this.B, 0, this.c, this.a) }, sb.ec = function() { return this.c }, sb.Lm = function(t) { if (0 > t || this.c.length <= t) return null; var e = new Fe(null); return e.ca(this.ma, this.B.slice(0 === t ? 0 : this.c[t - 1], this.c[t])), e }, sb.re = function() {
        var t, e, i = this.B,
            n = this.c,
            r = this.ma,
            o = [],
            s = 0;
        for (t = 0, e = n.length; t < e; ++t) {
            var a = n[t],
                h = new Fe(null);
            h.ca(r, i.slice(s, a)), o.push(h), s = a
        }
        return o
    }, sb.Dd = function(t) {
        var e, i, n = [],
            r = [],
            o = this.B,
            s = this.c,
            a = this.a,
            h = 0,
            l = 0;
        for (e = 0, i = s.length; e < i; ++e) {
            var u = s[e],
                l = Oe(o, h, u, a, t, n, l);
            r.push(l), h = u
        }
        return n.length = l, t = new Be(null), t.ca("XY", n, r), t
    }, sb.Z = function() { return "MultiLineString" }, sb.ab = function(t) {
        t: {
            var e, i, n = this.B,
                r = this.c,
                o = this.a,
                s = 0;
            for (e = 0, i = r.length; e < i; ++e) {
                if (_e(n, s, r[e], o, t)) { t = !0; break t }
                s = r[e]
            }
            t = !1
        }
        return t
    }, sb.wa = function(t, e) {
        if (t) {
            ie(this, e, t, 2), this.B || (this.B = []);
            var i = oe(this.B, 0, t, this.a, this.c);
            this.B.length = 0 === i.length ? 0 : i[i.length - 1], this.u()
        } else this.ca("XY", null, this.c)
    }, sb.ca = function(t, e, i) { ee(this, t, e), this.c = i, this.u() }, m(Ve, Qt), sb = Ve.prototype, sb.clone = function() { var t = new Ve(null); return We(t, this.ma, this.B.slice()), t }, sb.Ob = function(t, e, i, n) { return n < L(this.H(), t, e) ? n : (this.c != this.g && (this.j = Math.sqrt(Ee(this.B, 0, this.B.length, this.a, 0)), this.c = this.g), Ne(this.B, 0, this.B.length, this.a, this.j, !0, t, e, i, n)) }, sb.op = function() { return Ge(this.B, 0, this.B.length, this.a) }, sb.ba = function() { return ve(this.B, 0, this.B.length, this.a) }, sb.Dd = function(t) { var e = []; return e.length = Oe(this.B, 0, this.B.length, this.a, t, e, 0), t = new Ve(null), We(t, "XY", e), t }, sb.Z = function() { return "LinearRing" }, sb.wa = function(t, e) { t ? (ie(this, e, t, 1), this.B || (this.B = []), this.B.length = re(this.B, 0, t, this.a), this.u()) : We(this, "XY", null) }, m(Ze, Qt), sb = Ze.prototype, sb.em = function(t) { this.B ? pe(this.B, t.oa()) : this.B = t.oa().slice(), this.c.push(this.B.length), this.u() }, sb.clone = function() { var t = new Ze(null); return t.ca(this.ma, this.B.slice(), this.c.slice()), t }, sb.Ob = function(t, e, i, n) { return n < L(this.H(), t, e) ? n : (this.D != this.g && (this.O = Math.sqrt(Se(this.B, 0, this.c, this.a, 0)), this.D = this.g), Le(this.B, 0, this.c, this.a, this.O, !0, t, e, i, n)) }, sb.pd = function(t, e) { return Ae(this.qc(), 0, this.c, this.a, t, e) }, sb.rp = function() { return qe(this.qc(), 0, this.c, this.a) }, sb.ba = function(t) { var e; return void 0 !== t ? (e = this.qc().slice(), Ke(e, 0, this.c, this.a, t)) : e = this.B, be(e, 0, this.c, this.a) }, sb.ec = function() { return this.c }, sb.Hm = function() { return new se(Je(this)) }, sb.Mm = function() { return this.c.length }, sb.Qi = function(t) { if (0 > t || this.c.length <= t) return null; var e = new Ve(null); return We(e, this.ma, this.B.slice(0 === t ? 0 : this.c[t - 1], this.c[t])), e }, sb.jf = function() {
        var t, e, i = this.ma,
            n = this.B,
            r = this.c,
            o = [],
            s = 0;
        for (t = 0, e = r.length; t < e; ++t) {
            var a = r[t],
                h = new Ve(null);
            We(h, i, n.slice(s, a)), o.push(h), s = a
        }
        return o
    }, sb.qc = function() {
        if (this.P != this.g) {
            var t = this.B;
            Ye(t, this.c, this.a) ? this.j = t : (this.j = t.slice(), this.j.length = Ke(this.j, 0, this.c, this.a)), this.P = this.g
        }
        return this.j
    }, sb.Dd = function(t) {
        var e = [],
            i = [];
        return e.length = De(this.B, 0, this.c, this.a, Math.sqrt(t), e, 0, i), t = new Ze(null), t.ca("XY", e, i), t
    }, sb.Z = function() { return "Polygon" }, sb.ab = function(t) { return Pe(this.qc(), 0, this.c, this.a, t) }, sb.wa = function(t, e) {
        if (t) {
            ie(this, e, t, 2), this.B || (this.B = []);
            var i = oe(this.B, 0, t, this.a, this.c);
            this.B.length = 0 === i.length ? 0 : i[i.length - 1], this.u()
        } else this.ca("XY", null, this.c)
    }, sb.ca = function(t, e, i) { ee(this, t, e), this.c = i, this.u() }, m(ni, Qt), sb = ni.prototype, sb.gm = function(t) {
        if (this.B) {
            var e = this.B.length;
            pe(this.B, t.oa()), t = t.ec().slice();
            var i, n;
            for (i = 0, n = t.length; i < n; ++i) t[i] += e
        } else this.B = t.oa().slice(), t = t.ec().slice(), this.c.push();
        this.c.push(t), this.u()
    }, sb.clone = function() { for (var t = new ni(null), e = this.c.length, i = Array(e), n = 0; n < e; ++n) i[n] = this.c[n].slice(); return si(t, this.ma, this.B.slice(), i), t }, sb.Ob = function(t, e, i, n) {
        if (n < L(this.H(), t, e)) return n;
        if (this.D != this.g) {
            var r, o, s = this.c,
                a = 0,
                h = 0;
            for (r = 0, o = s.length; r < o; ++r) var l = s[r],
                h = Se(this.B, a, l, this.a, h),
                a = l[l.length - 1];
            this.O = Math.sqrt(h), this.D = this.g
        }
        s = oi(this), a = this.c, h = this.a, r = this.O, o = 0;
        var u, p, l = [NaN, NaN];
        for (u = 0, p = a.length; u < p; ++u) {
            var c = a[u];
            n = Le(s, o, c, h, r, !0, t, e, i, n, l), o = c[c.length - 1]
        }
        return n
    }, sb.pd = function(t, e) {
        var i;
        t: {
            i = oi(this);
            var n = this.c,
                r = this.a,
                o = 0;
            if (0 !== n.length) {
                var s, a;
                for (s = 0, a = n.length; s < a; ++s) {
                    var h = n[s];
                    if (Ae(i, o, h, r, t, e)) { i = !0; break t }
                    o = h[h.length - 1]
                }
            }
            i = !1
        }
        return i
    }, sb.qp = function() {
        var t, e, i = oi(this),
            n = this.c,
            r = 0,
            o = 0;
        for (t = 0, e = n.length; t < e; ++t) var s = n[t],
            o = o + qe(i, r, s, this.a),
            r = s[s.length - 1];
        return o
    }, sb.ba = function(t) {
        var e;
        void 0 !== t ? (e = oi(this).slice(), $e(e, this.c, this.a, t)) : e = this.B, t = e, e = this.c;
        var i, n, r = this.a,
            o = 0,
            s = [],
            a = 0;
        for (i = 0, n = e.length; i < n; ++i) {
            var h = e[i];
            s[a++] = be(t, o, h, r, s[a]), o = h[h.length - 1]
        }
        return s.length = a, s
    }, sb.Im = function() { var t = new we(null); return t.ca("XY", ri(this).slice()), t }, sb.Dd = function(t) {
        var e = [],
            i = [],
            n = this.B,
            r = this.c,
            o = this.a;
        t = Math.sqrt(t);
        var s, a, h = 0,
            l = 0;
        for (s = 0, a = r.length; s < a; ++s) {
            var u = r[s],
                p = [],
                l = De(n, h, u, o, t, e, l, p);
            i.push(p), h = u[u.length - 1]
        }
        return e.length = l, n = new ni(null), si(n, "XY", e, i), n
    }, sb.Xm = function(t) {
        if (0 > t || this.c.length <= t) return null;
        var e;
        0 === t ? e = 0 : (e = this.c[t - 1], e = e[e.length - 1]), t = this.c[t].slice();
        var i = t[t.length - 1];
        if (0 !== e) { var n, r; for (n = 0, r = t.length; n < r; ++n) t[n] -= e }
        return n = new Ze(null), n.ca(this.ma, this.B.slice(e, i), t), n
    }, sb.lf = function() {
        var t, e, i, n, r = this.ma,
            o = this.B,
            s = this.c,
            a = [],
            h = 0;
        for (t = 0, e = s.length; t < e; ++t) {
            var l = s[t].slice(),
                u = l[l.length - 1];
            if (0 !== h)
                for (i = 0, n = l.length; i < n; ++i) l[i] -= h;
            i = new Ze(null), i.ca(r, o.slice(h, u), l), a.push(i), h = u
        }
        return a
    }, sb.Z = function() { return "MultiPolygon" }, sb.ab = function(t) {
        t: {
            var e, i, n = oi(this),
                r = this.c,
                o = this.a,
                s = 0;
            for (e = 0, i = r.length; e < i; ++e) {
                var a = r[e];
                if (Pe(n, s, a, o, t)) { t = !0; break t }
                s = a[a.length - 1]
            }
            t = !1
        }
        return t
    }, sb.wa = function(t, e) {
        if (t) {
            ie(this, e, t, 3), this.B || (this.B = []);
            var i, n, r = this.B,
                o = this.a,
                s = this.c,
                a = 0,
                s = s ? s : [],
                h = 0;
            for (i = 0, n = t.length; i < n; ++i) a = oe(r, a, t[i], o, s[h]), s[h++] = a, a = a[a.length - 1];
            s.length = h, 0 === s.length ? this.B.length = 0 : (r = s[s.length - 1], this.B.length = 0 === r.length ? 0 : r[r.length - 1]), this.u()
        } else si(this, "XY", null, this.c)
    };
    var Sb, Nb, Lb = /^#(?:[0-9a-f]{3}){1,2}$/i,
        Cb = /^(?:rgb)?\((0|[1-9]\d{0,2}),\s?(0|[1-9]\d{0,2}),\s?(0|[1-9]\d{0,2})\)$/i,
        Mb = /^(?:rgba)?\((0|[1-9]\d{0,2}),\s?(0|[1-9]\d{0,2}),\s?(0|[1-9]\d{0,2}),\s?(0|1|0\.\d{0,10})\)$/i,
        Ib = /^([a-z]*)$/i,
        kb = function() {
            var t = {},
                e = 0;
            return function(i) {
                var n;
                if (t.hasOwnProperty(i)) n = t[i];
                else {
                    if (1024 <= e) { n = 0; for (var r in t) 0 === (3 & n++) && (delete t[r], --e) }
                    n = i;
                    var o, s;
                    Ib.exec(n) && (r = document.createElement("div"), r.style.color = n, document.body.appendChild(r), n = window.getComputedStyle(r).color, document.body.removeChild(r)), Lb.exec(n) ? (o = n.length - 1, x(3 == o || 6 == o, 54), s = 3 == o ? 1 : 2, o = parseInt(n.substr(1 + 0 * s, s), 16), r = parseInt(n.substr(1 + 1 * s, s), 16), n = parseInt(n.substr(1 + 2 * s, s), 16), 1 == s && (o = (o << 4) + o, r = (r << 4) + r, n = (n << 4) + n), o = [o, r, n, 1]) : (s = Mb.exec(n)) ? (o = Number(s[1]), r = Number(s[2]), n = Number(s[3]), s = Number(s[4]), o = ui([o, r, n, s])) : (s = Cb.exec(n)) ? (o = Number(s[1]), r = Number(s[2]), n = Number(s[3]), o = ui([o, r, n, 1])) : x(!1, 14), n = o, t[i] = n, ++e
                }
                return n
            }
        }(),
        Tb = String.prototype.trim ? function(t) { return t.trim() } : function(t) { return t.replace(/^[\s\xa0]+|[\s\xa0]+$/g, "") },
        Ab = /&/g,
        Rb = /</g,
        _b = />/g,
        Pb = /"/g,
        Ob = /'/g,
        Db = /\x00/g,
        Fb = /[\x00&<>"']/,
        Ub = Array.prototype.indexOf ? function(t, e, i) { return Array.prototype.indexOf.call(t, e, i) } : function(t, e, i) {
            if (i = null == i ? 0 : 0 > i ? Math.max(0, t.length + i) : i, s(t)) return s(e) && 1 == e.length ? t.indexOf(e, i) : -1;
            for (; i < t.length; i++)
                if (i in t && t[i] === e) return i;
            return -1
        },
        Bb = Array.prototype.forEach ? function(t, e, i) { Array.prototype.forEach.call(t, e, i) } : function(t, e, i) { for (var n = t.length, r = s(t) ? t.split("") : t, o = 0; o < n; o++) o in r && e.call(i, r[o], o, t) },
        jb = Array.prototype.filter ? function(t, e, i) { return Array.prototype.filter.call(t, e, i) } : function(t, e, i) {
            for (var n = t.length, r = [], o = 0, a = s(t) ? t.split("") : t, h = 0; h < n; h++)
                if (h in a) {
                    var l = a[h];
                    e.call(i, l, h, t) && (r[o++] = l)
                }
            return r
        },
        zb = Array.prototype.every ? function(t, e, i) { return Array.prototype.every.call(t, e, i) } : function(t, e, i) {
            for (var n = t.length, r = s(t) ? t.split("") : t, o = 0; o < n; o++)
                if (o in r && !e.call(i, r[o], o, t)) return !1;
            return !0
        };
    t: {
        var Gb = ab.navigator;
        if (Gb) { var qb = Gb.userAgent; if (qb) { Nb = qb; break t } }
        Nb = ""
    }
    var Vb, Wb = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),
        Xb = wi("Opera"),
        Hb = wi("Trident") || wi("MSIE"),
        Yb = wi("Edge"),
        Kb = wi("Gecko") && !(-1 != Nb.toLowerCase().indexOf("webkit") && !wi("Edge")) && !(wi("Trident") || wi("MSIE")) && !wi("Edge"),
        $b = -1 != Nb.toLowerCase().indexOf("webkit") && !wi("Edge"),
        Zb = wi("Macintosh");
    t: {
        var Jb = "",
            Qb = function() { var t = Nb; return Kb ? /rv\:([^\);]+)(\)|;)/.exec(t) : Yb ? /Edge\/([\d\.]+)/.exec(t) : Hb ? /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(t) : $b ? /WebKit\/(\S+)/.exec(t) : Xb ? /(?:Version)[ \/]?(\S+)/.exec(t) : void 0 }();
        if (Qb && (Jb = Qb ? Qb[1] : ""), Hb) { var tw = Ni(); if (null != tw && tw > parseFloat(Jb)) { Vb = String(tw); break t } }
        Vb = Jb
    }
    var ew, iw, nw = {},
        rw = ab.document,
        ow = rw && Hb ? Ni() || ("CSS1Compat" == rw.compatMode ? parseInt(Vb, 10) : 5) : void 0,
        sw = Ci(),
        aw = function() {
            var t;
            return function() {
                if (void 0 === t) {
                    var e, i = document.createElement("P"),
                        n = { webkitTransform: "-webkit-transform", OTransform: "-o-transform", msTransform: "-ms-transform", MozTransform: "-moz-transform", transform: "transform" };
                    document.body.appendChild(i);
                    for (var r in n) r in i.style && (i.style[r] = "translate(1px,1px)", e = gb.getComputedStyle(i).getPropertyValue(n[r]));
                    document.body.removeChild(i), t = e && "none" !== e
                }
                return t
            }
        }(),
        hw = function() {
            var t;
            return function() {
                if (void 0 === t) {
                    var e, i = document.createElement("P"),
                        n = { webkitTransform: "-webkit-transform", OTransform: "-o-transform", msTransform: "-ms-transform", MozTransform: "-moz-transform", transform: "transform" };
                    document.body.appendChild(i);
                    for (var r in n) r in i.style && (i.style[r] = "translate3d(1px,1px,1px)", e = gb.getComputedStyle(i).getPropertyValue(n[r]));
                    document.body.removeChild(i), t = e && "none" !== e
                }
                return t
            }
        }(),
        lw = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"],
        uw = "undefined" != typeof navigator ? navigator.userAgent.toLowerCase() : "",
        pw = -1 !== uw.indexOf("firefox"),
        cw = -1 !== uw.indexOf("safari") && -1 === uw.indexOf("chrom"),
        fw = -1 !== uw.indexOf("macintosh"),
        gw = gb.devicePixelRatio || 1,
        dw = !1,
        yw = function() { if (!("HTMLCanvasElement" in gb)) return !1; try { var t = Ii(); return !!t && (t.setLineDash && (dw = !0), !0) } catch (t) { return !1 } }(),
        mw = "DeviceOrientationEvent" in gb,
        vw = "geolocation" in gb.navigator,
        bw = "ontouchstart" in gb,
        ww = "PointerEvent" in gb,
        xw = !!gb.navigator.msPointerEnabled,
        Ew = !1,
        Sw = [];
    if ("WebGLRenderingContext" in gb) try {
        var Nw = Pi(document.createElement("CANVAS"), { failIfMajorPerformanceCaveat: !0 });
        Nw && (Ew = !0, iw = Nw.getParameter(Nw.MAX_TEXTURE_SIZE), Sw = Nw.getSupportedExtensions())
    } catch (t) {}
    ew = Ew, cb = Sw, pb = iw;
    var Lw = [0, 0, 0, 1],
        Cw = [],
        Mw = [0, 0, 0, 1];
    sb = Di.prototype, sb.Rf = function() { return this.A }, sb.Sf = function() { return this.T }, sb.Tf = function() { return this.o }, sb.Uf = function() { return this.i }, sb.mf = function() { return this.C }, sb.Vf = function(t) { this.A = t }, sb.Wf = function(t) { this.o = t }, sb.Xf = function(t) { this.i = t }, m(Fi, Di), sb = Fi.prototype, sb.Dc = function() { return this.j }, sb.wq = function() { return this.g }, sb.Qf = function() { return this.l }, sb.Yc = function() { return this.f }, sb.Ce = function() { return 2 }, sb.qe = function() { return this.s }, sb.$a = function() { return this.v }, sb.xq = function() { return this.a }, sb.hc = function() { return this.D }, sb.yq = function() { return this.b }, sb.qh = v, sb.load = v, sb.ai = v, sb.fk = function(t, e, i, n) { e.setTransform(1, 0, 0, 1, 0, 0), e.translate(i, n), e.beginPath(), e.arc(t.size / 2, t.size / 2, this.a, 0, 2 * Math.PI, !0), this.g && (e.fillStyle = pi(this.g.b), e.fill()), this.b && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.Me, t.lineDash && e.setLineDash(t.lineDash), e.stroke()), e.closePath() }, sb.ek = function(t, e, i, n) { e.setTransform(1, 0, 0, 1, 0, 0), e.translate(i, n), e.beginPath(), e.arc(t.size / 2, t.size / 2, this.a, 0, 2 * Math.PI, !0), e.fillStyle = li(Lw), e.fill(), this.b && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.Me, t.lineDash && e.setLineDash(t.lineDash), e.stroke()), e.closePath() }, Ui.prototype.g = function() { return this.b }, Ui.prototype.f = function(t) { this.b = t, this.a = void 0 }, y(zi, ji), zi.prototype.reset = function() { this.b[0] = 1732584193, this.b[1] = 4023233417, this.b[2] = 2562383102, this.b[3] = 271733878, this.f = this.g = 0 }, sb = Vi.prototype, sb.Fq = function() { return this.b }, sb.Jm = function() { return this.f }, sb.Gq = function() { return this.g }, sb.Km = function() { return this.c }, sb.Pm = function() { return this.i }, sb.Hq = function() { return this.a }, sb.Iq = function(t) { this.b = t, this.l = void 0 }, sb.es = function(t) { this.f = t, this.l = void 0 }, sb.Jq = function(t) { this.g = t, this.l = void 0 }, sb.fs = function(t) { this.c = t, this.l = void 0 }, sb.gs = function(t) { this.i = t, this.l = void 0 }, sb.ks = function(t) { this.a = t, this.l = void 0 }, sb = Xi.prototype, sb.Y = function() { return this.i }, sb.Fm = function() { return this.g }, sb.Kq = function() { return this.c }, sb.Lq = function() { return this.a }, sb.Mq = function() { return this.f }, sb.Wa = function() { return this.l }, sb.Nq = function() { return this.b }, sb.ik = function(t) { "function" == typeof t ? this.g = t : "string" == typeof t ? this.g = function(e) { return e.get(t) } : t ? t && (this.g = function() { return t }) : this.g = $i, this.i = t }, sb.Oq = function(t) { this.b = t };
    var Iw = null;
    sb = Zi.prototype, sb.Dm = function() { return this.g }, sb.Rm = function() { return this.f }, sb.Sm = function() { return this.c }, sb.Pq = function() { return this.b }, sb.Qq = function() { return this.s }, sb.Rq = function() { return this.i }, sb.Sq = function() { return this.a }, sb.Tq = function() { return this.l }, sb.Wa = function() { return this.A }, sb.bn = function() { return this.j }, sb.cn = function() { return this.o }, sb.bs = function(t) { this.g = t }, sb.Sk = function(t) { this.f = t }, sb.Tk = function(t) { this.c = t }, sb.as = function(t) { this.b = t }, sb.Uq = function(t) { this.i = t }, sb.Vq = function(t) { this.a = t }, sb.hs = function(t) { this.l = t }, sb.Vk = function(t) { this.A = t }, sb.Wk = function(t) { this.j = t }, sb.js = function(t) { this.o = t }, Ji.prototype.clear = function() { this.b = {}, this.a = 0 }, Ji.prototype.get = function(t, e, i) { return t = e + ":" + t + ":" + (i ? li(i) : "null"), t in this.b ? this.b[t] : null }, Ji.prototype.set = function(t, e, i, n) { this.b[e + ":" + t + ":" + (i ? li(i) : "null")] = n, ++this.a };
    var kw = new Ji;
    m(Qi, vt), Qi.prototype.A = function() { this.f = 3, this.i.forEach(ct), this.i = null, this.b("change") }, Qi.prototype.T = function() {
        if (this.f = 2, this.g && (this.a.width = this.g[0], this.a.height = this.g[1]), this.g = [this.a.width, this.a.height], this.i.forEach(ct), this.i = null, tn(this), !this.s && null !== this.l) {
            this.c.width = this.a.width, this.c.height = this.a.height;
            var t = this.c.getContext("2d");
            t.drawImage(this.a, 0, 0);
            for (var e = t.getImageData(0, 0, this.a.width, this.a.height), i = e.data, n = this.l[0] / 255, r = this.l[1] / 255, o = this.l[2] / 255, s = 0, a = i.length; s < a; s += 4) i[s] *= n, i[s + 1] *= r, i[s + 2] *= o;
            t.putImageData(e, 0, 0)
        }
        this.b("change")
    }, Qi.prototype.load = function() { if (0 == this.f) { this.f = 1, this.i = [ut(this.a, "error", this.A, this), ut(this.a, "load", this.T, this)]; try { this.a.src = this.o } catch (t) { this.A() } } }, m(en, Di), sb = en.prototype, sb.Dc = function() {
        if (this.f) return this.f;
        var t = this.c,
            e = this.hc();
        if ("fraction" == this.j || "fraction" == this.s) {
            if (!e) return null;
            t = this.c.slice(), "fraction" == this.j && (t[0] *= e[0]), "fraction" == this.s && (t[1] *= e[1])
        }
        if ("top-left" != this.a) {
            if (!e) return null;
            t === this.c && (t = this.c.slice()), "top-right" != this.a && "bottom-right" != this.a || (t[0] = -t[0] + e[0]), "bottom-left" != this.a && "bottom-right" != this.a || (t[1] = -t[1] + e[1])
        }
        return this.f = t
    }, sb.Yc = function() { var t = this.b; return t.c ? t.c : t.a }, sb.qe = function() { return this.b.g }, sb.Ce = function() { return this.b.f }, sb.Qf = function() {
        var t = this.b;
        if (!t.j)
            if (t.s) {
                var e = t.g[0],
                    i = t.g[1],
                    n = Ii(e, i);
                n.fillRect(0, 0, e, i), t.j = n.canvas
            } else t.j = t.a;
        return t.j
    }, sb.$a = function() {
        if (this.l) return this.l;
        var t = this.D;
        if ("top-left" != this.g) {
            var e = this.hc(),
                i = this.b.g;
            if (!e || !i) return null;
            t = t.slice(), "top-right" != this.g && "bottom-right" != this.g || (t[0] = i[0] - e[0] - t[0]), "bottom-left" != this.g && "bottom-right" != this.g || (t[1] = i[1] - e[1] - t[1])
        }
        return this.l = t
    }, sb.zq = function() { return this.b.o }, sb.hc = function() { return this.v ? this.v : this.b.g }, sb.qh = function(t, e) { return lt(this.b, "change", t, e) }, sb.load = function() { this.b.load() }, sb.ai = function(t, e) { pt(this.b, "change", t, e) }, m(nn, Di), sb = nn.prototype, sb.Dc = function() { return this.D }, sb.Aq = function() { return this.l }, sb.Bq = function() { return this.j }, sb.Qf = function() { return this.v }, sb.Yc = function() { return this.s }, sb.qe = function() { return this.O }, sb.Ce = function() { return 2 }, sb.$a = function() { return this.sa }, sb.Cq = function() { return this.b }, sb.Dq = function() { return this.g }, sb.Ym = function() { return this.c }, sb.hc = function() { return this.za }, sb.Eq = function() { return this.a }, sb.qh = v, sb.load = v, sb.ai = v, sb.hk = function(t, e, i, n) {
        var r;
        for (e.setTransform(1, 0, 0, 1, 0, 0), e.translate(i, n), e.beginPath(), this.c !== this.g && (this.b *= 2), i = 0; i <= this.b; i++) n = 2 * i * Math.PI / this.b - Math.PI / 2 + this.l, r = 0 === i % 2 ? this.g : this.c, e.lineTo(t.size / 2 + r * Math.cos(n), t.size / 2 + r * Math.sin(n));
        this.j && (e.fillStyle = pi(this.j.b), e.fill()), this.a && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.Me, t.lineDash && e.setLineDash(t.lineDash), e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke()), e.closePath()
    }, sb.gk = function(t, e, i, n) {
        e.setTransform(1, 0, 0, 1, 0, 0), e.translate(i, n), e.beginPath(), this.c !== this.g && (this.b *= 2);
        var r;
        for (i = 0; i <= this.b; i++) r = 2 * i * Math.PI / this.b - Math.PI / 2 + this.l, n = 0 === i % 2 ? this.g : this.c, e.lineTo(t.size / 2 + n * Math.cos(r), t.size / 2 + n * Math.sin(r));
        e.fillStyle = Lw, e.fill(), this.a && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.Me, t.lineDash && e.setLineDash(t.lineDash), e.stroke()), e.closePath()
    }, rn.prototype.a = function(t) {
        function e(t) { return t instanceof se || t instanceof we ? "point" : t instanceof Fe || t instanceof Be ? "line" : t instanceof Ze || t instanceof ni ? "polygon" : void 0 }
        var i = this.type;
        return "single" === i ? this.g : "unique" === i ? (i = t.N(), i = i[this.key], t = e(t.Y()), this.b[t][i]) : "range" === i ? (i = t.N(), i = i[this.key], t = e(t.Y()), on(this, i, t)) : null
    };
    var Tw = [0, 0, 0];
    sb = mn.prototype, sb.Ei = function(t, e, i) {
        t = xn(this, t, e);
        for (var n = t.da, r = t.ha; n <= r; ++n)
            for (var o = t.ia, s = t.ka; o <= s; ++o) i([e, n, o])
    }, sb.H = function() { return this.s }, sb.Ri = function() { return this.maxZoom }, sb.Si = function() { return this.minZoom }, sb.$a = function(t) { return this.g ? this.g : this.f[t] }, sb.aa = function(t) { return this.b[t] }, sb.jk = function() { return this.b }, sb.Na = function(t, e) {
        var i = this.$a(t[0]),
            n = this.aa(t[0]),
            r = gn(this.gb(t[0]), this.l),
            o = i[0] + t[1] * r[0] * n,
            i = i[1] + t[2] * r[1] * n;
        return A(o, i, o + r[0] * n, i + r[1] * n, e)
    }, sb.nf = function(t, e, i) { return Sn(this, t[0], t[1], e, !1, i) }, sb.ue = function(t, e, i) { return e = this.aa(e), Sn(this, t[0], t[1], e, !1, i) }, sb.gb = function(t) { return this.i ? this.i : this.c[t] }, sb.Kc = function(t, e) { return Ct(le(this.b, t, e || 0), this.minZoom, this.maxZoom) }, kn.prototype.g = function() { return this.a }, m(Tn, St), sb = Tn.prototype, sb.clone = function() {
        var t = new Tn(this.N());
        t.sd(this.a);
        var e = this.Y();
        return e && t.ob(e.clone()), (e = this.c) && t.vh(e), t
    }, sb.Y = function() { return this.get(this.a) }, sb.Ja = function() { return this.i }, sb.Gm = function() { return this.a }, sb.No = function() { return this.c }, sb.Tc = function() { return this.l }, sb.Oo = function() { this.u() }, sb.wf = function() {
        this.f && (ct(this.f), this.f = null);
        var t = this.Y();
        t && (this.f = lt(t, "change", this.Oo, this)), this.u()
    }, sb.ob = function(t) { this.set(this.a, t) }, sb.vh = function(t) { this.l = (this.c = t) ? An(t) : void 0, this.u() }, sb.ic = function(t) { this.i = t, this.u() }, sb.sd = function(t) { pt(this, Nt(this.a), this.wf, this), this.a = t, lt(this, Nt(this.a), this.wf, this), this.wf() }, m(Dn, Rn), sb = Dn.prototype, sb.Z = function() { return "json" }, sb.vc = function(t, e) { return this.Pd(Fn(t), _n(this, t, e)) }, sb.Ia = function(t, e) { return this.Lh(Fn(t), _n(this, t, e)) }, sb.Qd = function(t, e) { return this.sk(Fn(t), _n(this, t, e)) }, sb.ib = function(t) { return this.zk(Fn(t)) }, sb.Oe = function(t, e) { return JSON.stringify(this.Vd(t, e)) }, sb.Ac = function(t, e) { return JSON.stringify(this.ng(t, e)) }, sb.Wd = function(t, e) { return JSON.stringify(this.og(t, e)) }, m(Un, Zt), sb = Un.prototype, sb.clone = function() { var t = new Un(null); return t.Ok(this.f), t }, sb.Ob = function(t, e, i, n) { if (n < L(this.H(), t, e)) return n; var r, o, s = this.f; for (r = 0, o = s.length; r < o; ++r) n = s[r].Ob(t, e, i, n); return n }, sb.pd = function(t, e) {
        var i, n, r = this.f;
        for (i = 0, n = r.length; i < n; ++i)
            if (r[i].pd(t, e)) return !0;
        return !1
    }, sb.bf = function(t) { A(1 / 0, 1 / 0, -(1 / 0), -(1 / 0), t); for (var e = this.f, i = 0, n = e.length; i < n; ++i) O(t, e[i].H()); return t }, sb.Vg = function() { return Bn(this.f) }, sb.se = function(t) {
        if (this.o != this.g && (et(this.i), this.l = 0, this.o = this.g), 0 > t || 0 !== this.l && t < this.l) return this;
        var e = t.toString();
        if (this.i.hasOwnProperty(e)) return this.i[e];
        var i, n, r = [],
            o = this.f,
            s = !1;
        for (i = 0, n = o.length; i < n; ++i) {
            var a = o[i],
                h = a.se(t);
            r.push(h), h !== a && (s = !0)
        }
        return s ? (t = new Un(null), jn(t), t.f = r, zn(t), t.u(), this.i[e] = t) : (this.l = t, this)
    }, sb.Z = function() { return "GeometryCollection" }, sb.ab = function(t) {
        var e, i, n = this.f;
        for (e = 0, i = n.length; e < i; ++e)
            if (n[e].ab(t)) return !0;
        return !1
    }, sb.rotate = function(t, e) {
        for (var i = this.f, n = 0, r = i.length; n < r; ++n) i[n].rotate(t, e);
        this.u()
    }, sb.scale = function(t, e, i) {
        i || (i = G(this.H()));
        for (var n = this.f, r = 0, o = n.length; r < o; ++r) n[r].scale(t, e, i);
        this.u()
    }, sb.Ok = function(t) { t = Bn(t), jn(this), this.f = t, zn(this), this.u() }, sb.cd = function(t) {
        var e, i, n = this.f;
        for (e = 0, i = n.length; e < i; ++e) n[e].cd(t);
        this.u()
    }, sb.translate = function(t, e) {
        var i, n, r = this.f;
        for (i = 0, n = r.length; i < n; ++i) r[i].translate(t, e);
        this.u()
    }, sb.pa = function() { jn(this), Zt.prototype.pa.call(this) }, m(Gn, Dn);
    var Aw = { Point: function(t) { return new se(t.coordinates) }, LineString: function(t) { return new Fe(t.coordinates) }, Polygon: function(t) { return new Ze(t.coordinates) }, MultiPoint: function(t) { return new we(t.coordinates) }, MultiLineString: function(t) { return new Be(t.coordinates) }, MultiPolygon: function(t) { return new ni(t.coordinates) }, GeometryCollection: function(t, e) { var i = t.geometries.map(function(t) { return qn(t, e) }); return new Un(i) } },
        Rw = { Point: function(t) { return { type: "Point", coordinates: t.ba() } }, LineString: function(t) { return { type: "LineString", coordinates: t.ba() } }, Polygon: function(t, e) { var i; return e && (i = e.rightHanded), { type: "Polygon", coordinates: t.ba(i) } }, MultiPoint: function(t) { return { type: "MultiPoint", coordinates: t.ba() } }, MultiLineString: function(t) { return { type: "MultiLineString", coordinates: t.ba() } }, MultiPolygon: function(t, e) { var i; return e && (i = e.rightHanded), { type: "MultiPolygon", coordinates: t.ba(i) } }, GeometryCollection: function(t, e) { return { type: "GeometryCollection", geometries: t.f.map(function(t) { var i = db({}, e); return delete i.featureProjection, Vn(t, i) }) } }, Circle: function() { return { type: "GeometryCollection", geometries: [] } } };
    sb = Gn.prototype, sb.Pd = function(t, e) {
        var i = qn(t.geometry, e),
            n = new Tn;
        return this.b && n.sd(this.b), n.ob(i), void 0 !== t.id && n.ic(t.id), t.properties && n.G(t.properties), n
    }, sb.Lh = function(t, e) {
        var i;
        if ("Feature" == t.type) i = [this.Pd(t, e)];
        else if ("FeatureCollection" == t.type) { i = []; var n, r, o = t.features; for (n = 0, r = o.length; n < r; ++n) i.push(this.Pd(o[n], e)) } else x(!1, 35);
        return i
    }, sb.sk = function(t, e) { return qn(t, e) }, sb.zk = function(t) { t = t.crs; var e; return t ? "name" == t.type ? e = qt(t.properties.name) : "EPSG" == t.type ? e = qt("EPSG:" + t.properties.code) : x(!1, 36) : e = this.defaultDataProjection, e }, sb.Vd = function(t, e) {
        e = Pn(this, e);
        var i = { type: "Feature" },
            n = t.Ja();
        return void 0 !== n && (i.id = n), (n = t.Y()) ? i.geometry = Vn(n, e) : i.geometry = null, n = t.N(), delete n[t.a], nt(n) ? i.properties = null : i.properties = n, i
    }, sb.ng = function(t, e) { e = Pn(this, e); var i, n, r = []; for (i = 0, n = t.length; i < n; ++i) r.push(this.Vd(t[i], e)); return { type: "FeatureCollection", features: r } }, sb.og = function(t, e) { return Vn(t, Pn(this, e)) }, m(Wn, St), sb = Wn.prototype, sb.clear = function() { for (; 0 < this.Sc();) this.pop() }, sb.th = function(t) { var e, i; for (e = 0, i = t.length; e < i; ++e) this.push(t[e]); return this }, sb.forEach = function(t, e) { this.a.forEach(t, e) }, sb.Ko = function() { return this.a }, sb.item = function(t) { return this.a[t] }, sb.Sc = function() { return this.get("length") }, sb.Af = function(t, e) { this.a.splice(t, 0, e), Xn(this), this.b(new Hn(_w, e)) }, sb.pop = function() { return this.Th(this.Sc() - 1) }, sb.push = function(t) { var e = this.a.length; return this.Af(e, t), e }, sb.remove = function(t) {
        var e, i, n = this.a;
        for (e = 0, i = n.length; e < i; ++e)
            if (n[e] === t) return this.Th(e)
    }, sb.Th = function(t) { var e = this.a[t]; return this.a.splice(t, 1), Xn(this), this.b(new Hn(Pw, e)), e }, sb.Yr = function(t, e) {
        var i = this.Sc();
        if (t < i) i = this.a[t], this.a[t] = e, this.b(new Hn(Pw, i)), this.b(new Hn(_w, e));
        else {
            for (; i < t; ++i) this.Af(i, void 0);
            this.Af(t, e)
        }
    };
    var _w = "add",
        Pw = "remove";
    m(Hn, dt), m(Yn, vt), Yn.prototype.pb = function() { return this.key + "/" + this.ta }, Yn.prototype.i = function() { return this.ta }, Yn.prototype.W = function() { return this.state };
    var Ow = document.implementation.createDocument("", "", null),
        Dw = lr();
    m(wr, St), sb = wr.prototype, sb.ya = v, sb.Da = function() { return this.l }, sb.Ca = function() { return this.O }, sb.Ea = function() { return this.f }, sb.W = function() { return this.Ta }, sb.Ba = function() { this.u() }, sb.va = function(t) { this.l = xr(t), this.u() };
    var Fw, Uw, Bw, jw;
    ! function() {
        var t = {},
            e = { la: t };
        ! function(i) {
            if ("object" == typeof t && "undefined" != typeof e) e.la = i();
            else {
                var n;
                n = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, n.Us = i()
            }
        }(function() {
            return function t(e, i, n) {
                function r(s, a) {
                    if (!i[s]) {
                        if (!e[s]) { var h = "function" == typeof require && require; if (!a && h) return h(s, !0); if (o) return o(s, !0); throw h = Error("Cannot find module '" + s + "'"), h.code = "MODULE_NOT_FOUND", h }
                        h = i[s] = { la: {} }, e[s][0].call(h.la, function(t) { var i = e[s][1][t]; return r(i ? i : t) }, h, h.la, t, e, i, n)
                    }
                    return i[s].la
                }
                for (var o = "function" == typeof require && require, s = 0; s < n.length; s++) r(n[s]);
                return r
            }({
                1: [function(t, e) {
                    function i(t, e) { return this instanceof i ? (this.vg = Math.max(4, t || 9), this.li = Math.max(2, Math.ceil(.4 * this.vg)), e && this.Wl(e), void this.clear()) : new i(t, e) }

                    function n(t, e) { r(t, 0, t.children.length, e, t) }

                    function r(t, e, i, n, r) { r || (r = c(null)), r.da = 1 / 0, r.ia = 1 / 0, r.ha = -(1 / 0), r.ka = -(1 / 0); for (var s; e < i; e++) s = t.children[e], o(r, t.nb ? n(s) : s); return r }

                    function o(t, e) { t.da = Math.min(t.da, e.da), t.ia = Math.min(t.ia, e.ia), t.ha = Math.max(t.ha, e.ha), t.ka = Math.max(t.ka, e.ka) }

                    function s(t, e) { return t.da - e.da }

                    function a(t, e) { return t.ia - e.ia }

                    function h(t) { return (t.ha - t.da) * (t.ka - t.ia) }

                    function l(t) { return t.ha - t.da + (t.ka - t.ia) }

                    function u(t, e) { return t.da <= e.da && t.ia <= e.ia && e.ha <= t.ha && e.ka <= t.ka }

                    function p(t, e) { return e.da <= t.ha && e.ia <= t.ka && e.ha >= t.da && e.ka >= t.ia }

                    function c(t) { return { children: t, height: 1, nb: !0, da: 1 / 0, ia: 1 / 0, ha: -(1 / 0), ka: -(1 / 0) } }

                    function f(t, e, i, n, r) { for (var o, s = [e, i]; s.length;) i = s.pop(), e = s.pop(), i - e <= n || (o = e + Math.ceil((i - e) / n / 2) * n, g(t, o, e, i, r), s.push(e, o, o, i)) }
                    e.la = i;
                    var g = t("quickselect");
                    i.prototype = {
                        all: function() { return this.gi(this.data, []) },
                        search: function(t) {
                            var e = this.data,
                                i = [],
                                n = this.Fb;
                            if (!p(t, e)) return i;
                            for (var r, o, s, a, h = []; e;) {
                                for (r = 0, o = e.children.length; r < o; r++) s = e.children[r], a = e.nb ? n(s) : s, p(t, a) && (e.nb ? i.push(s) : u(t, a) ? this.gi(s, i) : h.push(s));
                                e = h.pop()
                            }
                            return i
                        },
                        load: function(t) { if (!t || !t.length) return this; if (t.length < this.li) { for (var e = 0, i = t.length; e < i; e++) this.Ka(t[e]); return this } return t = this.ii(t.slice(), 0, t.length - 1, 0), this.data.children.length ? this.data.height === t.height ? this.ni(this.data, t) : (this.data.height < t.height && (e = this.data, this.data = t, t = e), this.ki(t, this.data.height - t.height - 1, !0)) : this.data = t, this },
                        Ka: function(t) { return t && this.ki(t, this.data.height - 1), this },
                        clear: function() { return this.data = c([]), this },
                        remove: function(t, e) {
                            if (!t) return this;
                            for (var i, n, r, o, s = this.data, a = this.Fb(t), h = [], l = []; s || h.length;) {
                                if (s || (s = h.pop(), n = h[h.length - 1], i = l.pop(), o = !0), s.nb) {
                                    t: {
                                        r = t;
                                        var p = s.children,
                                            c = e;
                                        if (c) {
                                            for (var f = 0; f < p.length; f++)
                                                if (c(r, p[f])) { r = f; break t }
                                            r = -1
                                        } else r = p.indexOf(r)
                                    }
                                    if (-1 !== r) { s.children.splice(r, 1), h.push(s), this.Ul(h); break }
                                }
                                o || s.nb || !u(s, a) ? n ? (i++, s = n.children[i], o = !1) : s = null : (h.push(s), l.push(i), i = 0, n = s, s = s.children[0])
                            }
                            return this
                        },
                        Fb: function(t) { return t },
                        Hg: s,
                        Ig: a,
                        toJSON: function() { return this.data },
                        gi: function(t, e) { for (var i = []; t;) t.nb ? e.push.apply(e, t.children) : i.push.apply(i, t.children), t = i.pop(); return e },
                        ii: function(t, e, i, r) {
                            var o, s = i - e + 1,
                                a = this.vg;
                            if (s <= a) return o = c(t.slice(e, i + 1)), n(o, this.Fb), o;
                            r || (r = Math.ceil(Math.log(s) / Math.log(a)), a = Math.ceil(s / Math.pow(a, r - 1))), o = c([]), o.nb = !1, o.height = r;
                            var h, l, u, s = Math.ceil(s / a),
                                a = s * Math.ceil(Math.sqrt(a));
                            for (f(t, e, i, a, this.Hg); e <= i; e += a)
                                for (l = Math.min(e + a - 1, i), f(t, e, l, s, this.Ig), h = e; h <= l; h += s) u = Math.min(h + s - 1, l), o.children.push(this.ii(t, h, u, r - 1));
                            return n(o, this.Fb), o
                        },
                        Tl: function(t, e, i, n) {
                            for (var r, o, s, a, l, u, p, c; n.push(e), !e.nb && n.length - 1 !== i;) {
                                for (p = c = 1 / 0, r = 0, o = e.children.length; r < o; r++) s = e.children[r], l = h(s), u = (Math.max(s.ha, t.ha) - Math.min(s.da, t.da)) * (Math.max(s.ka, t.ka) - Math.min(s.ia, t.ia)) - l, u < c ? (c = u, p = l < p ? l : p, a = s) : u === c && l < p && (p = l, a = s);
                                e = a || e.children[0]
                            }
                            return e
                        },
                        ki: function(t, e, i) {
                            var n = this.Fb;
                            i = i ? t : n(t);
                            var n = [],
                                r = this.Tl(i, this.data, e, n);
                            for (r.children.push(t), o(r, i); 0 <= e && n[e].children.length > this.vg;) this.bm(n, e), e--;
                            this.Ql(i, n, e)
                        },
                        bm: function(t, e) {
                            var i = t[e],
                                r = i.children.length,
                                o = this.li;
                            this.Rl(i, o, r), r = this.Sl(i, o, r), r = c(i.children.splice(r, i.children.length - r)), r.height = i.height, r.nb = i.nb, n(i, this.Fb), n(r, this.Fb), e ? t[e - 1].children.push(r) : this.ni(i, r)
                        },
                        ni: function(t, e) { this.data = c([t, e]), this.data.height = t.height + 1, this.data.nb = !1, n(this.data, this.Fb) },
                        Sl: function(t, e, i) { var n, o, s, a, l, u, p; for (l = u = 1 / 0, n = e; n <= i - e; n++) o = r(t, 0, n, this.Fb), s = r(t, n, i, this.Fb), a = Math.max(0, Math.min(o.ha, s.ha) - Math.max(o.da, s.da)) * Math.max(0, Math.min(o.ka, s.ka) - Math.max(o.ia, s.ia)), o = h(o) + h(s), a < l ? (l = a, p = n, u = o < u ? o : u) : a === l && o < u && (u = o, p = n); return p },
                        Rl: function(t, e, i) {
                            var n = t.nb ? this.Hg : s,
                                r = t.nb ? this.Ig : a,
                                o = this.hi(t, e, i, n);
                            e = this.hi(t, e, i, r), o < e && t.children.sort(n)
                        },
                        hi: function(t, e, i, n) {
                            t.children.sort(n), n = this.Fb;
                            var s, a, h = r(t, 0, e, n),
                                u = r(t, i - e, i, n),
                                p = l(h) + l(u);
                            for (s = e; s < i - e; s++) a = t.children[s], o(h, t.nb ? n(a) : a), p += l(h);
                            for (s = i - e - 1; s >= e; s--) a = t.children[s], o(u, t.nb ? n(a) : a), p += l(u);
                            return p
                        },
                        Ql: function(t, e, i) { for (; 0 <= i; i--) o(e[i], t) },
                        Ul: function(t) { for (var e, i = t.length - 1; 0 <= i; i--) 0 === t[i].children.length ? 0 < i ? (e = t[i - 1].children, e.splice(e.indexOf(t[i]), 1)) : this.clear() : n(t[i], this.Fb) },
                        Wl: function(t) {
                            var e = ["return a", " - b", ";"];
                            this.Hg = new Function("a", "b", e.join(t[0])), this.Ig = new Function("a", "b", e.join(t[1])), this.Fb = new Function("a", "return {minX: a" + t[0] + ", minY: a" + t[1] + ", maxX: a" + t[2] + ", maxY: a" + t[3] + "};")
                        }
                    }
                }, { quickselect: 2 }],
                2: [function(t, e) {
                    function i(t, e, o, s, a) {
                        for (o = o || 0, s = s || t.length - 1, a = a || r; s > o;) {
                            if (600 < s - o) {
                                var h = s - o + 1,
                                    l = e - o + 1,
                                    u = Math.log(h),
                                    p = .5 * Math.exp(2 * u / 3),
                                    u = .5 * Math.sqrt(u * p * (h - p) / h) * (0 > l - h / 2 ? -1 : 1);
                                i(t, e, Math.max(o, Math.floor(e - l * p / h + u)), Math.min(s, Math.floor(e + (h - l) * p / h + u)), a)
                            }
                            for (h = t[e], l = o, p = s, n(t, o, e), 0 < a(t[s], h) && n(t, o, s); l < p;) { for (n(t, l, p), l++, p--; 0 > a(t[l], h);) l++; for (; 0 < a(t[p], h);) p-- }
                            0 === a(t[o], h) ? n(t, o, p) : (p++, n(t, p, s)), p <= e && (o = p + 1), e <= p && (s = p - 1)
                        }
                    }

                    function n(t, e, i) {
                        var n = t[e];
                        t[e] = t[i], t[i] = n
                    }

                    function r(t, e) { return t < e ? -1 : t > e ? 1 : 0 }
                    e.la = i
                }, {}]
            }, {}, [1])(1)
        }), Fw = e.la
    }(), sb = Sr.prototype, sb.Ka = function(t, e) {
        var i = { da: t[0], ia: t[1], ha: t[2], ka: t[3], value: e };
        this.b.Ka(i), this.a[b(e)] = i
    }, sb.load = function(t, e) {
        for (var i = Array(e.length), n = 0, r = e.length; n < r; n++) {
            var o = t[n],
                s = e[n],
                o = { da: o[0], ia: o[1], ha: o[2], ka: o[3], value: s };
            i[n] = o, this.a[b(s)] = o
        }
        this.b.load(i)
    }, sb.remove = function(t) { t = b(t); var e = this.a[t]; return delete this.a[t], null !== this.b.remove(e) }, sb.forEach = function(t, e) { return Ir(Lr(this), t, e) }, sb.clear = function() { this.b.clear(), this.a = {} }, sb.H = function() { var t = this.b.data; return [t.da, t.ia, t.ha, t.ka] }, m(kr, wr), sb = kr.prototype, sb.Nb = function(t) {
        var e = b(t).toString();
        if (Ar(this, e, t)) {
            Tr(this, e, t);
            var i = t.Y();
            i ? (e = i.H(), this.a && this.a.Ka(e, t)) : this.i[e] = t, this.b(new Dr("addfeature", t))
        }
        this.u()
    }, sb.Bc = function(t) { Rr(this, t), this.u() }, sb.clear = function(t) {
        if (t) {
            for (var e in this.s) this.s[e].forEach(ct);
            this.c || (this.s = {}, this.j = {}, this.o = {})
        } else if (this.a) { this.a.forEach(this.Uh, this); for (var i in this.i) this.Uh(this.i[i]) }
        this.c && this.c.clear(), this.a && this.a.clear(), this.qa.clear(), this.i = {}, this.b(new Dr("clear")), this.u()
    }, sb.Ci = function(t, e) { return this.a ? this.a.forEach(t, e) : this.c ? this.c.forEach(t, e) : void 0 }, sb.Rb = function(t, e, i) { return this.a ? Mr(this.a, t, e, i) : this.c ? this.c.forEach(e, i) : void 0 }, sb.Di = function(t, e, i) { return this.Rb(t, function(n) { if (n.Y().ab(t) && (n = e.call(i, n))) return n }) }, sb.Ni = function() { return this.c }, sb.Pf = function() { var t; return this.c ? t = this.c.a : this.a && (t = Lr(this.a), nt(this.i) || pe(t, it(this.i))), t }, sb.Mi = function(t) { var e = []; return Pr(this, t, function(t) { e.push(t) }), e }, sb.Ug = function(t) { return Cr(this.a, t) }, sb.Gi = function(t, e) {
        var i = t[0],
            n = t[1],
            r = null,
            o = [NaN, NaN],
            s = 1 / 0,
            a = [-(1 / 0), -(1 / 0), 1 / 0, 1 / 0],
            h = e ? e : Q;
        return Mr(this.a, a, function(t) {
            if (h(t)) {
                var e = t.Y(),
                    l = s;
                s = e.Ob(i, n, o, s), s < l && (r = t, t = Math.sqrt(s), a[0] = i - t, a[1] = n - t, a[2] = i + t, a[3] = n + t)
            }
        }), r
    }, sb.H = function() { return this.a.H() }, sb.Li = function(t) { return t = this.j[t.toString()], void 0 !== t ? t : null }, sb.bk = function() { return this.P }, sb.ck = function() { return this.fa }, sb.dk = function(t) {
        t = t.target;
        var e = b(t).toString(),
            i = t.Y();
        i ? (i = i.H(), e in this.i ? (delete this.i[e], this.a && this.a.Ka(i, t)) : this.a && Nr(this.a, i, t)) : e in this.i || (this.a && this.a.remove(t), this.i[e] = t), i = t.Ja(), void 0 !== i ? (i = i.toString(), e in this.o ? (delete this.o[e], this.j[i] = t) : this.j[i] !== t && (Or(this, t), this.j[i] = t)) : e in this.o || (Or(this, t), this.o[e] = t), this.u(), this.b(new Dr("changefeature", t))
    }, sb.Hd = function(t, e, i) {
        var n = this.qa;
        t = this.bc(t, e);
        var r, o;
        for (r = 0, o = t.length; r < o; ++r) {
            var s = t[r];
            Mr(n, s, function(t) { return M(t.extent, s) }) || (this.U.call(this, s, e, i), n.Ka(s, { extent: s.slice() }))
        }
    }, sb.Kb = function(t) {
        var e = b(t).toString();
        e in this.i ? delete this.i[e] : this.a && this.a.remove(t), this.Uh(t), this.u()
    }, sb.Uh = function(t) {
        var e = b(t).toString();
        this.s[e].forEach(ct), delete this.s[e];
        var i = t.Ja();
        void 0 !== i ? delete this.j[i.toString()] : delete this.o[e], this.b(new Dr("removefeature", t))
    }, m(Dr, dt), m(Fr, St), sb = Fr.prototype, sb.H = function() { return this.get("extent") }, sb.rc = function() { return this.get("maxResolution") }, sb.sc = function() { return this.get("minResolution") }, sb.tc = function() { return this.get("opacity") }, sb.Ib = function() { return this.get("visible") }, sb.uc = function() { return this.get("zIndex") }, sb.Uc = function(t) { this.set("extent", t) }, sb.$c = function(t) { this.set("maxResolution", t) }, sb.ad = function(t) { this.set("minResolution", t) }, sb.Vc = function(t) { this.set("opacity", t) }, sb.Wc = function(t) { this.set("visible", t) }, sb.Xc = function(t) { this.set("zIndex", t) }, m(Br, Fr), sb = Br.prototype, sb.xf = function() { this.Ib() && this.u() }, sb.Nn = function() {
        this.f.forEach(ct), this.f.length = 0;
        var t = this.Md();
        this.f.push(lt(t, _w, this.Mn, this), lt(t, Pw, this.On, this));
        for (var e in this.a) this.a[e].forEach(ct);
        et(this.a);
        var i, n, t = t.a;
        for (e = 0, i = t.length; e < i; e++) n = t[e], this.a[b(n).toString()] = [lt(n, "propertychange", this.xf, this), lt(n, "change", this.xf, this)];
        this.u()
    }, sb.Mn = function(t) {
        t = t.element;
        var e = b(t).toString();
        this.a[e] = [lt(t, "propertychange", this.xf, this), lt(t, "change", this.xf, this)], this.u()
    }, sb.On = function(t) { t = b(t.element).toString(), this.a[t].forEach(ct), delete this.a[t], this.u() }, sb.Md = function() { return this.get("layers") }, sb.Nj = function(t) { this.set("layers", t) }, sb.Xg = function(t) {
        var e = void 0 !== t ? t : [],
            i = e.length;
        this.Md().forEach(function(t) { t.Xg(e) }), t = Ur(this);
        var n, r;
        for (n = e.length; i < n; i++) r = e[i], r.opacity *= t.opacity, r.visible = r.visible && t.visible, r.maxResolution = Math.min(r.maxResolution, t.maxResolution), r.minResolution = Math.max(r.minResolution, t.minResolution), void 0 !== t.extent && (r.extent = void 0 !== r.extent ? W(r.extent, t.extent) : t.extent);
        return e
    }, sb.Zg = function() { return "ready" }, m(jr, dt), m(zr, Fr), sb = zr.prototype, sb.Xg = function(t) { return t = t ? t : [], t.push(Ur(this)), t }, sb.ja = function() { return this.get("source") || null }, sb.Zg = function() { var t = this.ja(); return t ? t.W() : "undefined" }, sb.Mp = function() { this.u() }, sb.eo = function() {
        this.A && (ct(this.A), this.A = null);
        var t = this.ja();
        t && (this.A = lt(t, "change", this.Mp, this)), this.u()
    }, sb.setMap = function(t) {
        this.j && (ct(this.j), this.j = null), t || this.u(), this.o && (ct(this.o), this.o = null), t && (this.j = lt(t, "precompose", function(t) {
            var e = Ur(this);
            e.Id = !1, e.zIndex = 1 / 0, t.frameState.layerStatesArray.push(e), t.frameState.layerStates[b(this)] = e
        }, this), this.o = lt(this, "change", t.render, t), this.u())
    }, sb.td = function(t) { this.set("source", t) }, m(qr, zr), qr.prototype.f = function() { return this.get("preload") }, qr.prototype.v = function(t) { this.set("preload", t) }, qr.prototype.c = function() { return this.get("useInterimTilesOnError") }, qr.prototype.C = function(t) { this.set("useInterimTilesOnError", t) }, m(Vr, zr), m(Wr, zr), Wr.prototype.C = function() { return this.v }, Wr.prototype.D = function() { return this.i }, Wr.prototype.l = function(t) { this.v = void 0 !== t ? t : Yi, this.i = null === t ? void 0 : Hi(this.v), this.u() }, m(Hr, Yn), sb = Hr.prototype, sb.pa = function() { 1 == this.state && Yr(this), this.a && this.a.Pa(), this.state = 5, Kn(this), Yn.prototype.pa.call(this) }, sb.ub = function(t) { if (void 0 !== t) { var e = b(t); return e in this.c ? this.c[e] : (t = nt(this.c) ? this.g : this.g.cloneNode(!1), this.c[e] = t) } return this.g }, sb.pb = function() { return this.s }, sb.Uo = function() { this.state = 3, Yr(this), Kn(this) }, sb.Vo = function() { this.state = this.g.naturalWidth && this.g.naturalHeight ? 2 : 4, Yr(this), Kn(this) }, sb.load = function() { 0 != this.state && 3 != this.state || (this.state = 1, Kn(this), this.o = [ut(this.g, "error", this.Uo, this), ut(this.g, "load", this.Vo, this)], this.A(this, this.s)) }, sb = Kr.prototype, sb.clear = function() { this.f = 0, this.b = {}, this.g = this.a = null }, sb.forEach = function(t, e) { for (var i = this.a; i;) t.call(e, i.xd, i.Rc, this), i = i.Vb }, sb.get = function(t) { return t = this.b[t], x(void 0 !== t, 15), t === this.g ? t.xd : (t === this.a ? (this.a = this.a.Vb, this.a.Nd = null) : (t.Vb.Nd = t.Nd, t.Nd.Vb = t.Vb), t.Vb = null, t.Nd = this.g, this.g = this.g.Vb = t, t.xd) }, sb.pop = function() { var t = this.a; return delete this.b[t.Rc], t.Vb && (t.Vb.Nd = null), this.a = t.Vb, this.a || (this.g = null), --this.f, t.xd }, sb.replace = function(t, e) { this.get(t), this.b[t].xd = e }, sb.set = function(t, e) {
        x(!(t in this.b), 16);
        var i = { Rc: t, Vb: null, Nd: this.g, xd: e };
        this.g ? this.g.Vb = i : this.a = i, this.g = i, this.b[t] = i, ++this.f
    }, m($r, Kr), $r.prototype.zd = function(t) {
        for (var e, i; Zr(this);) {
            e = this.a.xd, i = e.ta[0].toString();
            var n;
            if ((n = i in t) && (e = e.ta, n = ln(t[i], e[1], e[2])), n) break;
            this.pop().Pa()
        }
    };
    var zw, Gw = gb,
        qw = -1 < Gw.navigator.userAgent.indexOf("OPR"),
        Vw = -1 < Gw.navigator.userAgent.indexOf("Edge");
    zw = !(!Gw.navigator.userAgent.match("CriOS") && null !== Gw.chrome && void 0 !== Gw.chrome && "Google Inc." === Gw.navigator.vendor && 0 == qw && 0 == Vw), m(ro, Yn), ro.prototype.pa = function() { 1 == this.state && (this.Td.forEach(ct), this.Td = null), Yn.prototype.pa.call(this) }, ro.prototype.ub = function(t) { if (void 0 !== t) { var e = b(t); return e in this.c ? this.c[e] : (t = nt(this.c) ? this.l : this.l.cloneNode(!1), this.c[e] = t) } return this.l }, ro.prototype.Ie = function() {
        var t = [];
        if (this.g.forEach(function(e) { e && 2 == e.W() && t.push({ extent: this.o.Na(e.ta), image: e.ub() }) }, this), this.g.length = 0, 0 === t.length) this.state = 3;
        else {
            var e = this.T[0],
                i = this.A.gb(e),
                n = "number" == typeof i ? i : i[0],
                i = "number" == typeof i ? i : i[1],
                e = this.A.aa(e),
                r = this.o.aa(this.s),
                o = this.A.Na(this.T);
            this.l = to(n, i, this.D, r, this.o.H(), e, o, this.v, t, this.C, this.O), this.state = 2
        }
        Kn(this)
    }, ro.prototype.load = function() {
        if (0 == this.state) {
            this.state = 1, Kn(this);
            var t = 0;
            this.Td = [], this.g.forEach(function(e) {
                var i = e.W();
                if (0 == i || 1 == i) {
                    t++;
                    var n;
                    n = lt(e, "change", function() {
                        var i = e.W();
                        2 != i && 3 != i && 4 != i || (ct(n), t--, 0 === t && (this.Td.forEach(ct), this.Td = null, this.Ie()))
                    }, this), this.Td.push(n)
                }
            }, this), this.g.forEach(function(t) { 0 == t.W() && t.load() }), 0 === t && gb.setTimeout(this.Ie.bind(this), 0)
        }
    }, m(uo, wr), sb = uo.prototype, sb.$j = function() { return Zr(this.a) }, sb.zd = function(t, e) {
        var i = this.te(t);
        i && i.zd(e)
    }, sb.hf = function() { return 0 }, sb.fc = function(t, e, i) { return t + "/" + e + "/" + i }, sb.Yg = function() { return this.fa }, sb.fb = function() { return this.tileGrid }, sb.yb = function(t) { return this.tileGrid ? this.tileGrid : Ln(t) }, sb.te = function(t) { var e = this.f; return e && !Vt(e, t) ? null : this.a }, sb.Tb = function() { return this.qa }, sb.$g = function(t, e, i) { return i = this.yb(i), e = this.Tb(e), t = gn(i.gb(t), this.j), 1 == e ? t : fn(t, e, this.j) }, sb.Ba = function() { this.a.clear(), this.u() }, sb.bi = v, m(go, dt), m(yo, uo), sb = yo.prototype, sb.zb = function() { return this.tileLoadFunction }, sb.Ab = function() { return this.tileUrlFunction }, sb.Bb = function() { return this.urls }, sb.ak = function(t) {
        switch (t = t.target, t.W()) {
            case 1:
                this.b(new go("tileloadstart", t));
                break;
            case 2:
                this.b(new go("tileloadend", t));
                break;
            case 3:
                this.b(new go("tileloaderror", t))
        }
    }, sb.Eb = function(t) { this.a.clear(), this.tileLoadFunction = t, this.u() }, sb.kb = function(t, e) { this.tileUrlFunction = t, "undefined" != typeof e ? co(this, e) : this.u() }, sb.rb = function(t) {
        var e = this.urls = lo(t);
        this.kb(this.hd ? this.hd.bind(this) : so(e, this.tileGrid), t)
    }, sb.lb = function(t) {
        this.urls = t;
        var e = t.join("\n");
        this.kb(this.hd ? this.hd.bind(this) : so(t, this.tileGrid), e)
    }, sb.bi = function(t, e, i) { t = this.fc(t, e, i), this.a.b.hasOwnProperty(t) && this.a.get(t) }, m(mo, yo), sb = mo.prototype, sb.$j = function() {
        if (Zr(this.a)) return !0;
        for (var t in this.i)
            if (Zr(this.i[t])) return !0;
        return !1
    }, sb.zd = function(t, e) {
        var i = this.te(t);
        this.a.zd(this.a == i ? e : {});
        for (var n in this.i) {
            var r = this.i[n];
            r.zd(r == i ? e : {})
        }
    }, sb.hf = function(t) { return this.f && t && !Vt(this.f, t) ? 0 : this.Wg() }, sb.Wg = function() { return 0 }, sb.Yg = function(t) {
        return !(this.f && t && !Vt(this.f, t)) && yo.prototype.Yg.call(this, t);
    }, sb.yb = function(t) { var e = this.f; return !this.tileGrid || e && !Vt(e, t) ? (e = b(t).toString(), e in this.s || (this.s[e] = Ln(t)), this.s[e]) : this.tileGrid }, sb.te = function(t) { var e = this.f; return !e || Vt(e, t) ? this.a : (t = b(t).toString(), t in this.i || (this.i[t] = new $r), this.i[t]) }, sb.Ic = function(t, e, i, n, r) {
        if (this.f && r && !Vt(this.f, r)) {
            var o = this.te(r);
            i = [t, e, i];
            var s;
            if (t = this.fc.apply(this, i), o.b.hasOwnProperty(t) && (s = o.get(t)), e = this.Rc, s && s.key == e) return s;
            var a = this.f,
                h = this.yb(a),
                l = this.yb(r),
                u = fo(this, i, r);
            return n = new ro(a, h, r, l, i, u, this.Tb(n), this.Wg(), function(t, e, i, n) { return bo(this, t, e, i, n, a) }.bind(this), this.ra, this.C), n.key = e, s ? (n.a = s, o.replace(t, n)) : o.set(t, n), n
        }
        return bo(this, t, e, i, n, r)
    }, sb.Wb = function(t) {
        if (this.C != t) {
            this.C = t;
            for (var e in this.i) this.i[e].clear();
            this.u()
        }
    }, sb.Zb = function(t, e) {
        var i = qt(t);
        i && (i = b(i).toString(), i in this.s || (this.s[i] = e))
    }, m(No, mo), sb = No.prototype, sb.sq = function(t, e, i, n) {
        i = qt(i);
        var r = this.tileGrid;
        if (r || (r = this.yb(i)), e = r.nf(t, e), !(r.b.length <= e[0])) {
            var o = r.aa(e[0]),
                s = r.Na(e, this.X),
                r = gn(r.gb(e[0]), this.j),
                a = this.A;
            return 0 !== a && (r = cn(r, a, this.j), s = S(s, o * a, s)), a = { SERVICE: "WMS", VERSION: "1.3.0", REQUEST: "GetFeatureInfo", FORMAT: "image/png", TRANSPARENT: !0, QUERY_LAYERS: this.c.LAYERS }, db(a, this.c, n), n = Math.floor((s[3] - t[1]) / o), a[this.o ? "I" : "X"] = Math.floor((t[0] - s[0]) / o), a[this.o ? "J" : "Y"] = n, Lo(this, e, r, s, 1, i, a)
        }
    }, sb.Wg = function() { return this.A }, sb.fc = function(t, e, i) { return this.P + mo.prototype.fc.call(this, t, e, i) }, sb.Lf = function() { return this.c }, sb.Tb = function(t) { return this.U && void 0 !== this.v ? t : 1 }, sb.hd = function(t, e, i) {
        var n = this.tileGrid;
        if (n || (n = this.yb(i)), !(n.b.length <= t[0])) {
            1 == e || this.U && void 0 !== this.v || (e = 1);
            var r = n.aa(t[0]),
                o = n.Na(t, this.X),
                n = gn(n.gb(t[0]), this.j),
                s = this.A;
            return 0 !== s && (n = cn(n, s, this.j), o = S(o, r * s, o)), 1 != e && (n = fn(n, e, this.j)), r = { SERVICE: "WMS", VERSION: "1.3.0", REQUEST: "GetMap", FORMAT: "image/png", TRANSPARENT: !0 }, db(r, this.c), Lo(this, t, n, o, e, i, r)
        }
    }, sb.lb = function(t) { mo.prototype.lb.call(this, t), Co(this) }, sb.Mf = function(t) { db(this.c, t), Co(this), Io(this), co(this, Mo(this)) }, m(ko, vt), ko.prototype.H = function() { return this.extent }, ko.prototype.aa = function() { return this.resolution }, ko.prototype.W = function() { return this.state }, m(Ao, ko), Ao.prototype.a = function(t) { if (void 0 !== t) { var e; return t = b(t), t in this.i ? this.i[t] : (e = nt(this.i) ? this.g : this.g.cloneNode(!1), this.i[t] = e) } return this.g }, Ao.prototype.s = function() { this.state = 3, this.c.forEach(ct), this.c = null, To(this) }, Ao.prototype.A = function() { void 0 === this.resolution && (this.resolution = V(this.extent) / this.g.height), this.state = 2, this.c.forEach(ct), this.c = null, To(this) }, Ao.prototype.load = function() { 0 != this.state && 3 != this.state || (this.state = 1, To(this), this.c = [ut(this.g, "error", this.s, this), ut(this.g, "load", this.A, this)], this.j(this, this.o)) }, m(Ro, ko), Ro.prototype.pa = function() { 1 == this.state && (ct(this.Ke), this.Ke = null), ko.prototype.pa.call(this) }, Ro.prototype.a = function() { return this.i }, Ro.prototype.Ie = function() {
        var t = this.Lb.W();
        2 == t && (this.i = to(Y(this.g) / this.c, V(this.g) / this.c, this.o, this.Lb.aa(), 0, this.c, this.g, this.j, [{ extent: this.Lb.H(), image: this.Lb.a() }], 0)), this.state = t, To(this)
    }, Ro.prototype.load = function() {
        if (0 == this.state) {
            this.state = 1, To(this);
            var t = this.Lb.W();
            2 == t || 3 == t ? this.Ie() : (this.Ke = lt(this.Lb, "change", function() {
                var t = this.Lb.W();
                2 != t && 3 != t || (ct(this.Ke), this.Ke = null, this.Ie())
            }, this), this.Lb.load())
        }
    }, m(_o, wr), _o.prototype.v = function(t, e, i, n) {
        var r = this.f;
        if (r && n && !Vt(r, n)) {
            if (this.a) {
                if (this.ra == this.g && Vt(this.a.A, n) && this.a.aa() == e && this.a.f == i && P(this.a.H(), t)) return this.a;
                this.a.Pa(), this.a = null
            }
            return this.a = new Ro(r, n, t, e, i, function(t, e, i) { return this.Cd(t, e, i, r) }.bind(this)), this.ra = this.g, this.a
        }
        return r && (n = r), this.Cd(t, e, i, n)
    }, _o.prototype.o = function(t) {
        switch (t = t.target, t.W()) {
            case 1:
                this.b(new Do(Ww, t));
                break;
            case 2:
                this.b(new Do(Xw, t));
                break;
            case 3:
                this.b(new Do(Hw, t))
        }
    }, m(Do, dt);
    var Ww = "imageloadstart",
        Xw = "imageloadend",
        Hw = "imageloaderror";
    m(Fo, _o);
    var Yw = [101, 101];
    sb = Fo.prototype, sb.hq = function(t, e, i, n) {
        if (void 0 !== this.j) {
            var r = q(t, e, 0, Yw),
                o = { SERVICE: "WMS", VERSION: "1.3.0", REQUEST: "GetFeatureInfo", FORMAT: "image/png", TRANSPARENT: !0, QUERY_LAYERS: this.i.LAYERS };
            return db(o, this.i, n), n = Math.floor((r[3] - t[1]) / e), o[this.A ? "I" : "X"] = Math.floor((t[0] - r[0]) / e), o[this.A ? "J" : "Y"] = n, Uo(this, r, Yw, 1, qt(i), o)
        }
    }, sb.Lf = function() { return this.i }, sb.Cd = function(t, e, i, n) {
        if (void 0 === this.j) return null;
        e = Po(this, e), 1 == i || this.xa && void 0 !== this.fa || (i = 1), t = t.slice();
        var r = (t[0] + t[2]) / 2,
            o = (t[1] + t[3]) / 2,
            s = e / i,
            a = Y(t) / s,
            s = V(t) / s,
            h = this.c;
        if (h && this.X == this.g && h.aa() == e && h.f == i && M(h.H(), t)) return h;
        if (1 != this.s) {
            var h = this.s * Y(t) / 2,
                l = this.s * V(t) / 2;
            t[0] = r - h, t[1] = o - l, t[2] = r + h, t[3] = o + l
        }
        return r = { SERVICE: "WMS", VERSION: "1.3.0", REQUEST: "GetMap", FORMAT: "image/png", TRANSPARENT: !0 }, db(r, this.i), this.U[0] = Math.ceil(a * this.s), this.U[1] = Math.ceil(s * this.s), n = Uo(this, t, this.U, i, n, r), this.c = new Ao(t, e, i, this.l, n, this.qa, this.P), this.X = this.g, lt(this.c, "change", this.o, this), this.c
    }, sb.iq = function() { return this.P }, sb.jq = function() { return this.j }, sb.kq = function(t) { this.c = null, this.P = t, this.u() }, sb.lq = function(t) { t != this.j && (this.j = t, this.c = null, this.u()) }, sb.Mf = function(t) { db(this.i, t), Bo(this), this.c = null, this.u() }, m(jo, mn), jo.prototype.o = function() { return this.j }, m(Go, mo), sb = Go.prototype, sb.Cm = function() { return this.c }, sb.tq = function() { return this.A }, sb.uq = function() { return this.v }, sb.Nm = function() { return this.o }, sb.Zm = function() { return this.X }, sb.vq = function() { return this.P }, sb.fn = function() { return this.U }, sb.fl = function(t) { db(this.c, t), co(this, qo(this)) };
    var Kw, $w = window.GeoAdmin ? window.GeoAdmin.getConfig() : {},
        Zw = {},
        Jw = [4e3, 3750, 3500, 3250, 3e3, 2750, 2500, 2250, 2e3, 1750, 1500, 1250, 1e3, 750, 650, 500, 250, 100, 50, 20, 10, 5, 2.5, 2, 1.5, 1, .5],
        Qw = !Hb || 9 <= Number(ow),
        tx = !Kb && !Hb || Hb && 9 <= Number(ow) || Kb && Li("1.9.1");
    Hb && Li("9");
    var ex = { area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 };
    Ko.prototype.md = !0, Ko.prototype.Jc = function() { return "" }, Ko.prototype.toString = function() { return "Const{}" };
    var ix = {};
    Zo.prototype.md = !0;
    var nx = {};
    Zo.prototype.Jc = function() { return this.b };
    var rx = Jo(""),
        ox = /^([-,."'%_!# a-zA-Z0-9]+|(?:rgb|hsl)a?\([0-9.%, ]+\))$/;
    Qo.prototype.md = !0, Qo.prototype.Jc = function() { return this.b }, Qo.prototype.mh = !0, Qo.prototype.oe = function() { return 1 };
    var sx = /^(?:(?:https?|mailto|ftp):|[^&:\/?#]*(?:[\/?#]|$))/i,
        ax = {};
    ts("about:blank"), es.prototype.md = !0, es.prototype.Jc = function() { return "" }, es.prototype.mh = !0, es.prototype.oe = function() { return 1 };
    var hx = {};
    is.prototype.mh = !0, is.prototype.oe = function() { return this.a }, is.prototype.md = !0, is.prototype.Jc = function() { return this.b };
    var lx = /^[a-zA-Z0-9-]+$/,
        ux = { action: !0, cite: !0, data: !0, formaction: !0, href: !0, manifest: !0, poster: !0, src: !0 },
        px = { APPLET: !0, BASE: !0, EMBED: !0, IFRAME: !0, LINK: !0, MATH: !0, META: !0, OBJECT: !0, SCRIPT: !0, STYLE: !0, SVG: !0, TEMPLATE: !0 },
        cx = {};
    os("<!DOCTYPE html>", 0);
    var fx = os("", 0);
    os("<br>", 0), sb = ss.prototype, sb.clone = function() { return new ss(this.x, this.y) }, sb.ceil = function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, sb.floor = function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, sb.round = function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, sb.translate = function(t, e) { return t instanceof ss ? (this.x += t.x, this.y += t.y) : (this.x += Number(t), a(e) && (this.y += e)), this }, sb.scale = function(t, e) { var i = a(e) ? e : t; return this.x *= t, this.y *= i, this }, sb = as.prototype, sb.clone = function() { return new as(this.width, this.height) }, sb.ceil = function() { return this.width = Math.ceil(this.width), this.height = Math.ceil(this.height), this }, sb.floor = function() { return this.width = Math.floor(this.width), this.height = Math.floor(this.height), this }, sb.round = function() { return this.width = Math.round(this.width), this.height = Math.round(this.height), this }, sb.scale = function(t, e) { var i = a(e) ? e : t; return this.width *= t, this.height *= i, this };
    var gx = { cellpadding: "cellPadding", cellspacing: "cellSpacing", colspan: "colSpan", frameborder: "frameBorder", height: "height", maxlength: "maxLength", nonce: "nonce", role: "role", rowspan: "rowSpan", type: "type", usemap: "useMap", valign: "vAlign", width: "width" };
    sb = Ms.prototype, sb.V = function(t) { return s(t) ? this.b.getElementById(t) : t }, sb.G = ls, sb.tb = function(t, e, i) { return ys(this.b, arguments) }, sb.createElement = function(t) { return this.b.createElement(String(t)) }, sb.appendChild = function(t, e) { t.appendChild(e) }, sb.lj = bs, sb.Zi = ws, sb.hn = xs;
    var dx = !Hb || 9 <= Number(ow),
        yx = !Hb || 9 <= Number(ow),
        mx = Hb && !Li("9");
    !$b || Li("528"), Kb && Li("1.9b") || Hb && Li("8") || Xb && Li("9.5") || $b && Li("528"), Kb && !Li("8") || Hb && Li("9");
    var vx = 0,
        bx = {};
    Fs.prototype.o = !1, Fs.prototype.Pa = function() {
        if (!this.o && (this.o = !0, this.Ga(), 0 != vx)) {
            var t = u(this);
            delete bx[t]
        }
    }, Fs.prototype.Ga = function() {
        if (this.A)
            for (; this.A.length;) this.A.shift()()
    }, js.prototype.stopPropagation = function() { this.f = !0 }, js.prototype.preventDefault = function() { this.Jk = !1 }, zs[" "] = e, y(Gs, js);
    var wx = [1, 4, 2];
    Gs.prototype.stopPropagation = function() { Gs.ga.stopPropagation.call(this), this.a.stopPropagation ? this.a.stopPropagation() : this.a.cancelBubble = !0 }, Gs.prototype.preventDefault = function() {
        Gs.ga.preventDefault.call(this);
        var t = this.a;
        if (t.preventDefault) t.preventDefault();
        else if (t.returnValue = !1, mx) try {
            (t.ctrlKey || 112 <= t.keyCode && 123 >= t.keyCode) && (t.keyCode = -1)
        } catch (t) {}
    };
    var xx = "closure_listenable_" + (1e6 * Math.random() | 0),
        Ex = 0;
    Hs.prototype.add = function(t, e, i, n, r) {
        var o = t.toString();
        t = this.b[o], t || (t = this.b[o] = [], this.a++);
        var s = $s(t, e, n, r);
        return -1 < s ? (e = t[s], i || (e.dd = !1)) : (e = new Ws(e, this.src, o, !!n, r), e.dd = i, t.push(e)), e
    }, Hs.prototype.remove = function(t, e, i, n) { if (t = t.toString(), !(t in this.b)) return !1; var r = this.b[t]; return e = $s(r, e, i, n), -1 < e && (Xs(r[e]), Array.prototype.splice.call(r, e, 1), 0 == r.length && (delete this.b[t], this.a--), !0) };
    var Sx = "closure_lm_" + (1e6 * Math.random() | 0),
        Nx = {},
        Lx = 0,
        Cx = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
    y(fa, Fs);
    var Mx = [];
    fa.prototype.na = function(t, e, i, n) {
        r(e) || (e && (Mx[0] = e.toString()), e = Mx);
        for (var o = 0; o < e.length; o++) {
            var s = Zs(t, e[o], i || this.handleEvent, n || !1, this.a || this);
            if (!s) break;
            this.b[s.key] = s
        }
        return this
    }, fa.prototype.Gb = function(t, e, i, n, o) {
        if (r(e))
            for (var s = 0; s < e.length; s++) this.Gb(t, e[s], i, n, o);
        else i = i || this.handleEvent, o = o || this.a || this, i = ha(i), n = !!n, e = Vs(t) ? Ks(t.l, String(e), i, n, o) : t && (t = aa(t)) ? Ks(t, e, i, n, o) : null, e && (ia(e), delete this.b[e.key]);
        return this
    }, fa.prototype.Ga = function() { fa.ga.Ga.call(this), ga(this) }, fa.prototype.handleEvent = function() { throw Error("EventHandler.handleEvent not implemented") }, y(da, Fs), da.prototype[xx] = !0, sb = da.prototype, sb.kf = function() { return this.P }, sb.$h = function(t) { this.P = t }, sb.addEventListener = function(t, e, i, n) { Zs(this, t, e, i, n) }, sb.removeEventListener = function(t, e, i, n) { ea(this, t, e, i, n) }, sb.Ga = function() {
        if (da.ga.Ga.call(this), this.l) {
            var t, e = this.l,
                i = 0;
            for (t in e.b) {
                for (var n = e.b[t], r = 0; r < n.length; r++) ++i, Xs(n[r]);
                delete e.b[t], e.a--
            }
        }
        this.P = null
    }, sb.na = function(t, e, i, n) { return this.l.add(String(t), e, !1, i, n) }, sb.Gb = function(t, e, i, n) { return this.l.remove(String(t), e, i, n) }, sb = va.prototype, sb.clone = function() { return new va(this.top, this.right, this.bottom, this.left) }, sb.ceil = function() { return this.top = Math.ceil(this.top), this.right = Math.ceil(this.right), this.bottom = Math.ceil(this.bottom), this.left = Math.ceil(this.left), this }, sb.floor = function() { return this.top = Math.floor(this.top), this.right = Math.floor(this.right), this.bottom = Math.floor(this.bottom), this.left = Math.floor(this.left), this }, sb.round = function() { return this.top = Math.round(this.top), this.right = Math.round(this.right), this.bottom = Math.round(this.bottom), this.left = Math.round(this.left), this }, sb.translate = function(t, e) { return t instanceof ss ? (this.left += t.x, this.right += t.x, this.top += t.y, this.bottom += t.y) : (this.left += t, this.right += t, a(e) && (this.top += e, this.bottom += e)), this }, sb.scale = function(t, e) { var i = a(e) ? e : t; return this.left *= t, this.right *= t, this.top *= i, this.bottom *= i, this }, sb = ba.prototype, sb.clone = function() { return new ba(this.left, this.top, this.width, this.height) }, sb.distance = function(t) { var e = t.x < this.left ? this.left - t.x : Math.max(t.x - (this.left + this.width), 0); return t = t.y < this.top ? this.top - t.y : Math.max(t.y - (this.top + this.height), 0), Math.sqrt(e * e + t * t) }, sb.ceil = function() { return this.left = Math.ceil(this.left), this.top = Math.ceil(this.top), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height), this }, sb.floor = function() { return this.left = Math.floor(this.left), this.top = Math.floor(this.top), this.width = Math.floor(this.width), this.height = Math.floor(this.height), this }, sb.round = function() { return this.left = Math.round(this.left), this.top = Math.round(this.top), this.width = Math.round(this.width), this.height = Math.round(this.height), this }, sb.translate = function(t, e) { return t instanceof ss ? (this.left += t.x, this.top += t.y) : (this.left += t, a(e) && (this.top += e)), this }, sb.scale = function(t, e) { var i = a(e) ? e : t; return this.left *= t, this.width *= t, this.top *= i, this.height *= i, this };
    var Ix = Kb ? "MozUserSelect" : $b || Yb ? "WebkitUserSelect" : null,
        kx = { thin: 2, medium: 4, thick: 6 };
    y(_a, da);
    var Tx = ab.document && ab.document.documentElement && !!ab.document.documentElement.setCapture;
    sb = _a.prototype, sb.Je = function(t) { this.j = t }, sb.Ga = function() { _a.ga.Ga.call(this), ea(this.handle, ["touchstart", "mousedown"], this.al, !1, this), ga(this.b), Tx && this.c.releaseCapture(), this.handle = this.target = null }, sb.al = function(t) {
        var e = "mousedown" == t.type;
        if (!this.j || this.a || e && !qs(t)) ya(this, "earlycancel");
        else if (ya(this, new Ua("start", this, t.clientX, t.clientY))) {
            this.a = !0, e && t.preventDefault();
            var e = this.c,
                i = e.documentElement,
                n = !Tx;
            this.b.na(e, ["touchmove", "mousemove"], this.Sn, n), this.b.na(e, ["touchend", "mouseup"], this.ef, n), Tx ? (i.setCapture(!1), this.b.na(i, "losecapture", this.ef)) : this.b.na(fs(e), "blur", this.ef), this.C && this.b.na(this.C, "scroll", this.cr, n), this.clientX = this.T = t.clientX, this.clientY = this.v = t.clientY, this.screenX = t.screenX, this.screenY = t.screenY, this.g = this.target.offsetLeft, this.f = this.target.offsetTop, this.s = ps(hs(this.c).b)
        }
    }, sb.ef = function(t) { ga(this.b), Tx && this.c.releaseCapture(), this.a ? (this.a = !1, ya(this, new Ua("end", this, t.clientX, t.clientY, 0, Da(this, this.g), Fa(this, this.f)))) : ya(this, "earlycancel") }, sb.Sn = function(t) {
        if (this.j) {
            var e = 1 * (t.clientX - this.clientX),
                i = t.clientY - this.clientY;
            if (this.clientX = t.clientX, this.clientY = t.clientY, this.screenX = t.screenX, this.screenY = t.screenY, !this.a) {
                var n = this.T - this.clientX,
                    r = this.v - this.clientY;
                if (0 < n * n + r * r) {
                    if (!ya(this, new Ua("start", this, t.clientX, t.clientY))) return void(this.o || this.ef(t));
                    this.a = !0
                }
            }
            i = Pa(this, e, i), e = i.x, i = i.y, this.a && ya(this, new Ua("beforedrag", this, t.clientX, t.clientY, 0, e, i)) && (Oa(this, t, e, i), t.preventDefault())
        }
    }, sb.cr = function(t) {
        var e = Pa(this, 0, 0);
        t.clientX = this.clientX, t.clientY = this.clientY, Oa(this, t, e.x, e.y)
    }, y(Ua, js), sb = Ba.prototype, sb.clear = function() { this.oc = {}, this.b = this.hb.length = 0 }, sb.remove = function(t) { return !!Object.prototype.hasOwnProperty.call(this.oc, t) && (delete this.oc[t], this.b--, this.hb.length > 2 * this.b && za(this), !0) }, sb.get = function(t, e) { return Object.prototype.hasOwnProperty.call(this.oc, t) ? this.oc[t] : e }, sb.set = function(t, e) { Object.prototype.hasOwnProperty.call(this.oc, t) || (this.b++, this.hb.push(t)), this.oc[t] = e }, sb.forEach = function(t, e) {
        for (var i = ja(this), n = 0; n < i.length; n++) {
            var r = i[n],
                o = this.get(r);
            t.call(e, o, r, this)
        }
    }, sb.clone = function() { return new Ba(this) };
    var Ax, Rx = Hb ? 'javascript:""' : "about:blank";
    y(Wa, da), Wa.prototype.handleEvent = function(t) {
        var e = new Gs(t.a);
        e.type = "focusin" == t.type || "focus" == t.type ? "focusin" : "focusout", ya(this, e)
    }, Wa.prototype.Ga = function() { Wa.ga.Ga.call(this), ia(this.a), ia(this.g), delete this.b }, i(Xa), Xa.prototype.b = 0, y(Ha, da), Ha.prototype.Xa = Xa.Ec();
    var _x = null;
    sb = Ha.prototype, sb.Ja = function() { return this.T || (this.T = ":" + (this.Xa.b++).toString(36)) }, sb.ic = function(t) {
        if (this.f && this.f.c) {
            var e = this.f.c,
                i = this.T;
            i in e && delete e[i], Ei(this.f.c, t, this)
        }
        this.T = t
    }, sb.V = function() { return this.a }, sb.Mc = function() { return this.f }, sb.$h = function(t) {
        if (this.f && this.f != t) throw Error("Method not supported");
        Ha.ga.$h.call(this, t)
    }, sb.Lc = function() { this.a = this.b.createElement("DIV") }, sb.render = function(t) { Za(this, t) }, sb.xb = function() { this.Fa = !0, ih(this, function(t) {!t.Fa && t.V() && t.xb() }) }, sb.Pb = function() { ih(this, function(t) { t.Fa && t.Pb() }), this.j && ga(this.j), this.Fa = !1 }, sb.Ga = function() { this.Fa && this.Pb(), this.j && (this.j.Pa(), delete this.j), ih(this, function(t) { t.Pa() }), this.a && ws(this.a), this.f = this.sh = this.a = this.c = this.g = null, Ha.ga.Ga.call(this) }, sb.xg = function(t, e) { this.yg(t, Qa(this), e) }, sb.yg = function(t, e, i) {
        if (t.Fa && (i || !this.Fa)) throw Error("Component already rendered");
        if (0 > e || e > Qa(this)) throw Error("Child component index out of bounds");
        if (this.c && this.g || (this.c = {}, this.g = []), t.Mc() == this) {
            var n = t.Ja();
            this.c[n] = t, di(this.g, t)
        } else Ei(this.c, t.Ja(), t);
        $a(t, this), vi(this.g, e, 0, t), t.Fa && this.Fa && t.Mc() == this ? (i = this.ve(), e = i.childNodes[e] || null, e != t.V() && i.insertBefore(t.V(), e)) : i ? (this.a || this.Lc(), e = eh(this, e + 1), Za(t, this.ve(), e ? e.a : null)) : this.Fa && !t.Fa && t.a && t.a.parentNode && 1 == t.a.parentNode.nodeType && t.xb()
    }, sb.ve = function() { return this.a }, sb.removeChild = function(t, e) {
        if (t) {
            var i = s(t) ? t : t.Ja();
            if (t = th(this, i), i && t) {
                var n = this.c;
                i in n && delete n[i], di(this.g, t), e && (t.Pb(), t.a && ws(t.a)), $a(t, null)
            }
        }
        if (!t) throw Error("Child is not in parent component");
        return t
    }, y(oh, Ha), sb = oh.prototype, sb.Sg = null, sb.ld = !1, sb.wb = null, sb.eb = null, sb.ac = null, sb.Dg = !1, sb.Ma = function() { return "goog-modalpopup" }, sb.ff = function() { return this.wb }, sb.Lc = function() {
        oh.ga.Lc.call(this);
        var t = this.V(),
            e = Tb(this.Ma()).split(" ");
        Ps(t, e), Ss(t, !0), Ta(t, !1), this.fa && !this.eb && (this.eb = this.b.tb("iframe", { frameborder: 0, style: "border:0;vertical-align:bottom;", src: Rx }), this.eb.className = this.Ma() + "-bg", Ta(this.eb, !1), ka(this.eb, 0)), this.wb || (this.wb = this.b.tb("DIV", this.Ma() + "-bg"), Ta(this.wb, !1)), this.ac || (this.ac = this.b.createElement("SPAN"), Ta(this.ac, !1), Ss(this.ac, !0), this.ac.style.position = "absolute")
    }, sb.Hk = function() { this.Dg = !1 }, sb.xb = function() {
        this.eb && bs(this.eb, this.V()), bs(this.wb, this.V()), oh.ga.xb.call(this);
        var t = this.V();
        t.parentNode && t.parentNode.insertBefore(this.ac, t.nextSibling), this.Sg = new Wa(this.b.b), Ka(this).na(this.Sg, "focusin", this.ar), sh(this, !1)
    }, sb.Pb = function() { this.ld && this.gc(!1), Bs(this.Sg), oh.ga.Pb.call(this), ws(this.eb), ws(this.wb), ws(this.ac) }, sb.gc = function(t) {
        if (t != this.ld)
            if (this.D && this.D.stop(), this.sa && this.sa.stop(), this.C && this.C.stop(), this.O && this.O.stop(), this.Fa && sh(this, t), t) {
                if (ya(this, "beforeshow")) {
                    try { this.v = this.b.b.activeElement } catch (t) {}
                    this.Xh();
                    var e = fs(this.b.b) || window;
                    if ("fixed" == xa(this.V(), "position")) var i = t = 0;
                    else i = ps(this.b.b), t = i.x, i = i.y;
                    var n = Ma(this.V()),
                        e = us(e || window);
                    t = Math.max(t + e.width / 2 - n.width / 2, 0), i = Math.max(i + e.height / 2 - n.height / 2, 0), Ea(this.V(), t, i), Ea(this.ac, t, i), Ka(this).na(gs(this.b.b), "resize", this.Xh), ah(this, !0), this.focus(), this.ld = !0, this.D && this.sa ? (ta(this.D, "end", this.uf, !1, this), this.sa.play(), this.D.play()) : this.uf()
                }
            } else if (ya(this, "beforehide")) {
            Ka(this).Gb(gs(this.b.b), "resize", this.Xh), this.ld = !1, this.C && this.O ? (ta(this.C, "end", this.tf, !1, this), this.O.play(), this.C.play()) : this.tf();
            t: {
                try { if (i = this.b, n = i.b.body, e = i.b.activeElement || n, !this.v || this.v == n) { this.v = null; break t }(e == n || i.hn(this.V(), e)) && this.v.focus() } catch (t) {}
                this.v = null
            }
        }
    }, sb.uf = function() { ya(this, "show") }, sb.tf = function() { ah(this, !1), ya(this, "hide") }, sb.focus = function() { this.Bi() }, sb.Xh = function() {
        this.eb && Ta(this.eb, !1), this.wb && Ta(this.wb, !1);
        var t = this.b.b,
            e = us(fs(t) || window || window),
            i = Math.max(e.width, Math.max(t.body.scrollWidth, t.documentElement.scrollWidth)),
            t = Math.max(e.height, Math.max(t.body.scrollHeight, t.documentElement.scrollHeight));
        this.eb && (Ta(this.eb, !0), La(this.eb, i, t)), this.wb && (Ta(this.wb, !0), La(this.wb, i, t))
    }, sb.ar = function(t) { this.Dg ? this.Hk() : t.target == this.ac && Va(this.Bi, this) }, sb.Bi = function() { try { Hb && this.b.b.body.focus(), this.V().focus() } catch (t) {} }, sb.Ga = function() { Bs(this.D), this.D = null, Bs(this.C), this.C = null, Bs(this.sa), this.sa = null, Bs(this.O), this.O = null, oh.ga.Ga.call(this) }, y(hh, oh), sb = hh.prototype, sb.rh = !0, sb.Cg = .5, sb.dl = "", sb.hh = null, sb.Pc = null, sb.Ud = null, sb.vd = null, sb.cl = null, sb.zc = null, sb.de = null, sb.dc = null, sb.Ma = function() { return this.s }, sb.ve = function() { return this.V() || this.render(), this.de }, sb.ff = function() { return this.V() || this.render(), hh.ga.ff.call(this) }, sb.Lc = function() {
        hh.ga.Lc.call(this);
        var t = this.V(),
            e = this.b;
        this.Ud = e.tb("DIV", this.s + "-title", this.vd = e.tb("SPAN", { className: this.s + "-title-text", id: this.Ja() }, this.dl), this.zc = e.tb("SPAN", this.s + "-title-close")), vs(t, this.Ud, this.de = e.tb("DIV", this.s + "-content"), this.dc = e.tb("DIV", this.s + "-buttons")), ks(this.vd, "heading"), ks(this.zc, "button"), Ss(this.zc, !0), Ts(this.zc, "label", Fx), this.cl = this.vd.id, ks(t, "dialog"), Ts(t, "labelledby", this.cl || ""), this.hh && (this.de.innerHTML = ns(this.hh)), Ta(this.zc, !0), this.i && (t = this.i, t.Oc = this.dc, t.render()), Ta(this.dc, !!this.i), this.Cg = this.Cg, this.V() && (t = this.ff()) && ka(t, this.Cg)
    }, sb.xb = function() {
        hh.ga.xb.call(this), Ka(this).na(this.V(), "keydown", this.kk).na(this.V(), "keypress", this.kk), Ka(this).na(this.dc, "click", this.$q), uh(this, !0), Ka(this).na(this.zc, "click", this.dr);
        var t = this.V();
        ks(t, "dialog"), "" !== this.vd.id && Ts(t, "labelledby", this.vd.id), this.rh || lh(this, !1)
    }, sb.Pb = function() { this.ld && this.gc(!1), uh(this, !1), hh.ga.Pb.call(this) }, sb.gc = function(t) { t != this.ld && (this.Fa || this.render(), hh.ga.gc.call(this, t)) }, sb.uf = function() { hh.ga.uf.call(this), ya(this, Dx) }, sb.tf = function() { hh.ga.tf.call(this), ya(this, Ox) }, sb.$r = function() {
        var t = this.b.b,
            e = us(fs(t) || window || window),
            i = Math.max(t.body.scrollWidth, e.width),
            t = Math.max(t.body.scrollHeight, e.height),
            n = Ma(this.V());
        "fixed" == xa(this.V(), "position") ? this.Pc.i = new ba(0, 0, Math.max(0, e.width - n.width), Math.max(0, e.height - n.height)) : this.Pc.i = new ba(0, 0, i - n.width, t - n.height)
    }, sb.dr = function() { ph(this) }, sb.Ga = function() { this.dc = this.zc = null, hh.ga.Ga.call(this) }, sb.$q = function(t) {
        t: {
            for (t = t.target; null != t && t != this.dc;) {
                if ("BUTTON" == t.tagName) break t;
                t = t.parentNode
            }
            t = null
        }
        if (t && !t.disabled) {
            t = t.name;
            var e = this.i.get(t);
            ya(this, new ch(t, e)) && this.gc(!1)
        }
    }, sb.kk = function(t) {
        var e = !1,
            i = !1,
            n = this.i,
            r = t.target;
        if ("keydown" == t.type) {
            if (27 == t.b) {
                var o = n && n.Fg,
                    r = "SELECT" == r.tagName && !r.disabled;
                o && !r ? (i = !0, e = n.get(o), e = ya(this, new ch(o, e))) : r || (e = !0)
            } else if (9 == t.b && t.shiftKey && r == this.V()) {
                this.Dg = !0;
                try { this.ac.focus() } catch (t) {}
                Va(this.Hk, this)
            }
        } else if (13 == t.b) {
            if ("BUTTON" != r.tagName || r.disabled) {
                if (r == this.zc) ph(this);
                else if (n) {
                    var s, a = n.Lg;
                    if (s = a) t: {
                        s = n.Oc.getElementsByTagName("BUTTON");
                        for (var h, l = 0; h = s[l]; l++)
                            if (h.name == a || h.id == a) { s = h; break t }
                        s = null
                    }
                    r = ("TEXTAREA" == r.tagName || "SELECT" == r.tagName || "A" == r.tagName) && !r.disabled, !s || s.disabled || r || (o = a)
                }
            } else o = r.name;
            o && n && (i = !0, e = ya(this, new ch(o, String(n.get(o)))))
        } else r == this.zc && 32 == t.b && ph(this);
        (e || i) && (t.stopPropagation(), t.preventDefault()), e && this.gc(!1)
    }, y(ch, js);
    var Px = "dialogselect",
        Ox = "afterhide",
        Dx = "aftershow";
    y(fh, Ba), sb = fh.prototype, sb.Lg = null, sb.Oc = null, sb.Fg = null, sb.set = function(t, e, i, n) { return Ba.prototype.set.call(this, t, e), i && (this.Lg = t), n && (this.Fg = t), this }, sb.render = function() {
        if (this.Oc) {
            this.Oc.innerHTML = ns(fx);
            var t = hs(this.Oc);
            this.forEach(function(e, i) {
                var n = t.tb("BUTTON", { name: i }, e);
                i == this.Lg && (n.className = "goog-buttonset-default"), this.Oc.appendChild(n)
            }, this)
        }
    }, sb.V = function() { return this.Oc };
    var Fx = "Close",
        Ux = { key: "ok", caption: "OK" },
        Bx = { key: "cancel", caption: "Cancel" },
        jx = { key: "yes", caption: "Yes" },
        zx = { key: "no", caption: "No" },
        Gx = { key: "save", caption: "Save" },
        qx = { key: "continue", caption: "Continue" };
    "undefined" != typeof document && (gh(new fh, Ux, !0, !0), gh(gh(new fh, Ux, !0), Bx, !1, !0), gh(gh(new fh, jx, !0), zx, !1, !0), gh(gh(gh(new fh, jx), zx, !0), Bx, !1, !0), gh(gh(gh(new fh, qx), Gx), Bx, !0, !0)), y(dh, da), sb = dh.prototype, sb.Ed = null, sb.Bf = null, sb.nh = null, sb.Cf = null, sb.Jb = -1, sb.Qc = -1, sb.Ag = !1;
    var Vx = { 3: 13, 12: 144, 63232: 38, 63233: 40, 63234: 37, 63235: 39, 63236: 112, 63237: 113, 63238: 114, 63239: 115, 63240: 116, 63241: 117, 63242: 118, 63243: 119, 63244: 120, 63245: 121, 63246: 122, 63247: 123, 63248: 44, 63272: 46, 63273: 36, 63275: 35, 63276: 33, 63277: 34, 63289: 144, 63302: 45 },
        Wx = { Up: 38, Down: 40, Left: 37, Right: 39, Enter: 13, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, "U+007F": 46, Home: 36, End: 35, PageUp: 33, PageDown: 34, Insert: 45 },
        Xx = Hb || Yb || $b && Li("525"),
        Hx = Zb && Kb;
    sb = dh.prototype, sb.In = function(t) {
        ($b || Yb) && (17 == this.Jb && !t.ctrlKey || 18 == this.Jb && !t.altKey || Zb && 91 == this.Jb && !t.metaKey) && (this.Qc = this.Jb = -1), -1 == this.Jb && (t.ctrlKey && 17 != t.b ? this.Jb = 17 : t.altKey && 18 != t.b ? this.Jb = 18 : t.metaKey && 91 != t.b && (this.Jb = 91)), Xx && !la(t.b, this.Jb, t.shiftKey, t.ctrlKey, t.altKey) ? this.handleEvent(t) : (this.Qc = pa(t.b), Hx && (this.Ag = t.altKey))
    }, sb.Jn = function(t) { this.Qc = this.Jb = -1, this.Ag = t.altKey }, sb.handleEvent = function(t) {
        var e, i, n = t.a,
            r = n.altKey;
        Hb && "keypress" == t.type ? e = this.Qc : ($b || Yb) && "keypress" == t.type ? e = this.Qc : Xb && !$b ? e = this.Qc : (e = n.keyCode || this.Qc, i = n.charCode || 0, Hx && (r = this.Ag), Zb && 63 == i && 224 == e && (e = 191)), i = e = pa(e);
        var o = n.keyIdentifier;
        e ? 63232 <= e && e in Vx ? i = Vx[e] : 25 == e && t.shiftKey && (i = 9) : o && o in Wx && (i = Wx[o]), this.Jb = i, t = new vh(i, 0, 0, n), t.altKey = r, ya(this, t)
    }, sb.V = function() { return this.Ed }, sb.Ga = function() { dh.ga.Ga.call(this), mh(this) }, y(vh, Gs);
    var Yx = {};
    i(wh), wh.prototype.b = function(t) {
        t = t.V(), Aa(t, Kb), Hb && (t.hideFocus = !0);
        var e = this.a;
        e && ks(t, e)
    }, wh.prototype.Ma = function() { return "goog-container" };
    var Kx;
    i(Sh);
    var $x = { button: "pressed", checkbox: "checked", menuitem: "selected", menuitemcheckbox: "checked", menuitemradio: "checked", radio: "checked", tab: "selected", treeitem: "selected" };
    if (sb = Sh.prototype, sb.bj = function() {}, sb.eh = function(t) { return t.b.tb("DIV", kh(this, t).join(" "), t.qf) }, sb.pf = function(t) { return t }, sb.Ma = function() { return "goog-control" }, sb.gf = function(t) {
            if (!this.b) {
                var e = this.Ma();
                e.replace(/\xa0|\s/g, " "), this.b = { 1: e + "-disabled", 2: e + "-hover", 4: e + "-active", 8: e + "-selected", 16: e + "-checked", 32: e + "-focused", 64: e + "-open" }
            }
            return this.b[t]
        }, y(Ah, Ha), sb = Ah.prototype, sb.qf = null, sb.Oa = 0, sb.Sa = 39, sb.Le = 0, sb.Ai = null, sb.ye = !0, sb.Lc = function() {
            var t = this.i.eh(this);
            this.a = t, Lh(this.i, t, this.rf()), Aa(t, !Hb && !Xb)
        }, sb.rf = function() { return null }, sb.ve = function() { return this.i.pf(this.V()) }, sb.xb = function() {
            Ah.ga.xb.call(this), Ch(this, this.a);
            var t = this.i;
            if (Ja(this)) {
                var e = this.V();
                Nh(e, t.Ma() + "-rtl", !0)
            }
            this.isEnabled() && Mh(this, !0), this.Sa & -2 && (this.ye && Rh(this, !0), 32 & this.Sa && (t = this.V())) && (e = this.s || (this.s = new dh), yh(e, t), Ka(this).na(e, "key", this.pc).na(t, "focus", this.kn).na(t, "blur", this.cj))
        }, sb.Pb = function() { Ah.ga.Pb.call(this), this.s && mh(this.s), this.isEnabled() && Mh(this, !1) }, sb.Ga = function() { Ah.ga.Ga.call(this), this.s && (this.s.Pa(), delete this.s), delete this.i, this.v = this.Ai = this.qf = null }, sb.isEnabled = function() { return !(1 & this.Oa) }, sb.Je = function(t) {
            var e = this.Mc();
            e && "function" == typeof e.isEnabled && !e.isEnabled() || !Uh(this, 1, !t) || (t || (Ph(this, !1), _h(this, !1)), Mh(this, t), Dh(this, 1, !t, !0))
        }, sb.W = function() { return this.Oa }, sb.Yb = function(t, e) { if (this.Fa && this.Oa & t && !e) throw Error("Component already rendered");!e && this.Oa & t && Dh(this, t, !1), this.Sa = e ? this.Sa | t : this.Sa & ~t }, sb.jh = function(t) {!Bh(t, this.V()) && ya(this, "enter") && this.isEnabled() && Fh(this, 2) && _h(this, !0) }, sb.gh = function(t) {!Bh(t, this.V()) && ya(this, "leave") && (Fh(this, 4) && Ph(this, !1), Fh(this, 2) && _h(this, !1)) }, sb.xe = e, sb.sf = function(t) {
            if (this.isEnabled() && (Fh(this, 2) && _h(this, !0), qs(t))) {
                Fh(this, 4) && Ph(this, !0);
                var e;
                if (e = this.i) {
                    var i;
                    e = !!(32 & this.Sa && (i = this.V())) && (Ns(i) && Ls(i))
                }
                e && this.V().focus()
            }
            qs(t) && t.preventDefault()
        }, sb.Gd = function(t) { this.isEnabled() && (Fh(this, 2) && _h(this, !0), 4 & this.Oa && jh(this, t) && Fh(this, 4) && Ph(this, !1)) }, sb.dj = function(t) { this.isEnabled() && jh(this, t) }, sb.kn = function() { Fh(this, 32) && Uh(this, 32, !0) && Dh(this, 32, !0) }, sb.cj = function() { Fh(this, 4) && Ph(this, !1), Fh(this, 32) && Uh(this, 32, !1) && Dh(this, 32, !1) }, sb.pc = function(t) { return !(!this.isEnabled() || !this.fh(t)) && (t.preventDefault(), t.stopPropagation(), !0) }, sb.fh = function(t) { return 13 == t.b && jh(this, t) }, !h(Ah)) throw Error("Invalid component class " + Ah);
    if (!h(Sh)) throw Error("Invalid renderer class " + Sh);
    var Zx = u(Ah);
    Yx[Zx] = Sh, bh("goog-control", function() { return new Ah(null) }), y(zh, Fs);
    var Jx = !Hb || 9 <= Number(ow);
    zh.prototype.c = function() { this.b = !1 }, zh.prototype.i = function() { this.b = !0 }, zh.prototype.f = function(t) {
        if (this.b) this.b = !1;
        else {
            var e = t.a,
                i = e.button,
                n = e.type,
                r = Gh(e, "mousedown");
            this.a.sf(new Gs(r, t.g)), r = Gh(e, "mouseup"), this.a.Gd(new Gs(r, t.g)), Jx || (e.button = i, e.type = n)
        }
    }, zh.prototype.Ga = function() { this.a = null, zh.ga.Ga.call(this) }, y(qh, Ha);
    var Qx = "horizontal",
        tE = "vertical";
    sb = qh.prototype, sb.oh = null, sb.kd = null, sb.we = null, sb.Od = null, sb.Nc = !0, sb.jd = !0, sb.Bd = !0, sb.Ha = -1, sb.Va = null, sb.Jd = !1, sb.kc = null, sb.Lc = function() { this.a = this.b.tb("DIV", Eh(this.we, this).join(" ")) }, sb.ve = function() { return this.V() }, sb.xb = function() {
        qh.ga.xb.call(this), ih(this, function(t) { t.Fa && Xh(this, t) }, this);
        var t = this.V();
        this.we.b(this), this.dh(this.Nc, !0), Ka(this).na(this, "enter", this.ih).na(this, "highlight", this.An).na(this, "unhighlight", this.io).na(this, "open", this.Un).na(this, "close", this.nn).na(t, "mousedown", this.jn).na(Es(t), "mouseup", this.rn).na(t, ["mousedown", "mouseup", "mouseover", "mouseout", "contextmenu"], this.mn), this.Bd && Wh(this, !0)
    }, sb.Pb = function() { this.Sd(-1), this.Va && Oh(this.Va, !1), this.Jd = !1, qh.ga.Pb.call(this) }, sb.Ga = function() { qh.ga.Ga.call(this), this.kd && (this.kd.Pa(), this.kd = null), this.we = this.Va = this.kc = this.oh = null }, sb.ih = function() { return !0 }, sb.An = function(t) {
        var e = nh(this, t.target);
        if (-1 < e && e != this.Ha) {
            var i = eh(this, this.Ha);
            i && _h(i, !1), this.Ha = e, i = eh(this, this.Ha), this.Jd && Ph(i, !0), this.Va && i != this.Va && (64 & i.Sa ? Oh(i, !0) : Oh(this.Va, !1))
        }
        e = this.V(), null != t.target.V() && Ts(e, "activedescendant", t.target.V().id)
    }, sb.io = function(t) { t.target == eh(this, this.Ha) && (this.Ha = -1), this.V().removeAttribute("aria-activedescendant") }, sb.Un = function(t) {
        (t = t.target) && t != this.Va && t.Mc() == this && (this.Va && Oh(this.Va, !1), this.Va = t)
    }, sb.nn = function(t) {
        t.target == this.Va && (this.Va = null);
        var e = this.V(),
            i = t.target.V();
        e && 2 & t.target.Oa && i && (t = "", i && (t = i.id), Ts(e, "activedescendant", t))
    }, sb.jn = function(t) {
        this.jd && (this.Jd = !0);
        var e = Vh(this);
        e && Ns(e) && Ls(e) ? e.focus() : t.preventDefault()
    }, sb.rn = function() { this.Jd = !1 }, sb.mn = function(t) {
        var e;
        t: {
            if (e = t.target, this.kc)
                for (var i = this.V(); e && e !== i;) {
                    var n = e.id;
                    if (n in this.kc) { e = this.kc[n]; break t }
                    e = e.parentNode
                }
            e = null
        }
        if (e) switch (t.type) {
            case "mousedown":
                e.sf(t);
                break;
            case "mouseup":
                e.Gd(t);
                break;
            case "mouseover":
                e.jh(t);
                break;
            case "mouseout":
                e.gh(t);
                break;
            case "contextmenu":
                e.xe(t)
        }
    }, sb.aj = function() {}, sb.$i = function() { this.Sd(-1), this.Jd = !1, this.Va && Oh(this.Va, !1) }, sb.pc = function(t) { return !(!this.isEnabled() || !this.Nc || 0 == Qa(this) && !this.oh || !this.bh(t)) && (t.preventDefault(), t.stopPropagation(), !0) }, sb.bh = function(t) {
        var e = eh(this, this.Ha);
        if (e && "function" == typeof e.pc && e.pc(t) || this.Va && this.Va != e && "function" == typeof this.Va.pc && this.Va.pc(t)) return !0;
        if (t.shiftKey || t.ctrlKey || t.metaKey || t.altKey) return !1;
        switch (t.b) {
            case 27:
                if (!this.Bd) return !1;
                Vh(this).blur();
                break;
            case 36:
                Hh(this);
                break;
            case 35:
                Yh(this);
                break;
            case 38:
                if (this.Od != tE) return !1;
                $h(this);
                break;
            case 37:
                if (this.Od != Qx) return !1;
                Ja(this) ? Kh(this) : $h(this);
                break;
            case 40:
                if (this.Od != tE) return !1;
                Kh(this);
                break;
            case 39:
                if (this.Od != Qx) return !1;
                Ja(this) ? $h(this) : Kh(this);
                break;
            default:
                return !1
        }
        return !0
    }, sb.xg = function(t, e) { qh.ga.xg.call(this, t, e) }, sb.yg = function(t, e, i) {
        t.Le |= 2, t.Le |= 64, t.Yb(32, !1), t.Fa && 0 != t.ye && Rh(t, !1), t.ye = !1;
        var n = t.Mc() == this ? nh(this, t) : -1;
        qh.ga.yg.call(this, t, e, i), t.Fa && this.Fa && Xh(this, t), t = n, -1 == t && (t = Qa(this)), t == this.Ha ? this.Ha = Math.min(Qa(this) - 1, e) : t > this.Ha && e <= this.Ha ? this.Ha++ : t < this.Ha && e > this.Ha && this.Ha--
    }, sb.removeChild = function(t, e) {
        if (t = s(t) ? th(this, t) : t) {
            var i = nh(this, t); - 1 != i && (i == this.Ha ? (_h(t, !1), this.Ha = -1) : i < this.Ha && this.Ha--);
            var n = t.V();
            n && n.id && this.kc && (i = this.kc, n = n.id, n in i && delete i[n])
        }
        return i = t = qh.ga.removeChild.call(this, t, e), i.Fa && 1 != i.ye && Rh(i, !0), i.ye = !0, t
    }, sb.dh = function(t, e) { if (e || this.Nc != t && ya(this, t ? "show" : "hide")) { this.Nc = t; var i = this.V(); return i && (Ta(i, t), this.Bd && xh(Vh(this), this.jd && this.Nc), e || ya(this, this.Nc ? "aftershow" : "afterhide")), !0 } return !1 }, sb.isEnabled = function() {
        return this.jd
    }, sb.Je = function(t) { this.jd != t && ya(this, t ? "enable" : "disable") && (t ? (this.jd = !0, ih(this, function(t) { t.il ? delete t.il : t.Je(!0) })) : (ih(this, function(t) { t.isEnabled() ? t.Je(!1) : t.il = !0 }), this.Jd = this.jd = !1), this.Bd && xh(Vh(this), t && this.Nc)) }, sb.Sd = function(t) {
        (t = eh(this, t)) ? _h(t, !0): -1 < this.Ha && _h(eh(this, this.Ha), !1)
    }, sb.ui = function(t) { return t.isEnabled() && !!(2 & t.Sa) }, y(Jh, Sh), i(Jh), Jh.prototype.Ma = function() { return "goog-menuheader" }, y(Qh, Ah), bh("goog-menuheader", function() { return new Qh(null) }), y(tl, Sh), i(tl), sb = tl.prototype, sb.bj = function() { return "menuitem" }, sb.eh = function(t) { var e = t.b.tb("DIV", kh(this, t).join(" "), il(this, t.qf, t.b)); return nl(this, t, e, !!(8 & t.Sa) || !!(16 & t.Sa)), e }, sb.pf = function(t) { return t && t.firstChild }, sb.gf = function(t) {
        switch (t) {
            case 2:
                return el(this, 0);
            case 16:
            case 8:
                return "goog-option-selected";
            default:
                return tl.ga.gf.call(this, t)
        }
    }, sb.Ma = function() { return "goog-menuitem" }, y(rl, Ah), rl.prototype.Yb = function(t, e) {
        switch (rl.ga.Yb.call(this, t, e), t) {
            case 8:
                16 & this.Oa && !e && Uh(this, 16, !1) && Dh(this, 16, !1);
                var i = this.V();
                i && this && i && nl(this.i, this, i, e);
                break;
            case 16:
                (i = this.V()) && this && i && nl(this.i, this, i, e)
        }
    }, rl.prototype.Gd = function(t) {
        var e = this.Mc();
        if (e) { var i = e.i; if (e.i = null, (e = i && a(t.clientX)) && (e = new ss(t.clientX, t.clientY), e = i == e || !(!i || !e) && (i.x == e.x && i.y == e.y)), e) return }
        rl.ga.Gd.call(this, t)
    }, rl.prototype.fh = function(t) { return !(t.b != this.tj || !jh(this, t)) || rl.ga.fh.call(this, t) }, rl.prototype.Qm = function() { return this.tj }, bh("goog-menuitem", function() { return new rl(null) }), rl.prototype.rf = function() { return 16 & this.Sa ? "menuitemcheckbox" : 8 & this.Sa ? "menuitemradio" : rl.ga.rf.call(this) }, rl.prototype.Mc = function() { return Ah.prototype.Mc.call(this) }, rl.prototype.kf = function() { return Ah.prototype.kf.call(this) }, y(ol, Sh), i(ol), ol.prototype.eh = function(t) { return t.b.tb("DIV", this.Ma()) }, ol.prototype.Ma = function() { return "goog-menuseparator" }, y(sl, Ah), sl.prototype.xb = function() {
        sl.ga.xb.call(this);
        var t = this.V();
        ks(t, "separator")
    }, bh("goog-menuseparator", function() { return new sl }), y(al, wh), i(al), al.prototype.Ma = function() { return "goog-menu" }, al.prototype.b = function(t) { al.ga.b.call(this, t), t = t.V(), Ts(t, "haspopup", "true") }, bh("goog-menuseparator", function() { return new sl }), y(hl, qh), sb = hl.prototype, sb.Ma = function() { return this.we.Ma() }, sb.dh = function(t, e, i) { return (e = hl.ga.dh.call(this, t, e)) && t && this.Fa && Vh(this).focus(), t && i && a(i.clientX) ? this.i = new ss(i.clientX, i.clientY) : this.i = null, e }, sb.ih = function(t) { return Vh(this).focus(), hl.ga.ih.call(this, t) }, sb.ui = function(t) { return t.isEnabled() && !0 && !!(2 & t.Sa) }, sb.bh = function(t) { var e = hl.ga.bh.call(this, t); return e || ih(this, function(i) {!e && i.Qm && i.tj == t.b && (this.isEnabled() && this.Sd(nh(this, i)), e = i.pc(t)) }, this), e }, sb.Sd = function(t) {
        if (hl.ga.Sd.call(this, t), t = eh(this, t)) {
            var e, i = t.V(),
                n = (t = this.V() || cs(document)) || cs(document),
                r = Na(i),
                o = Na(n);
            if (!Hb || 9 <= Number(ow)) s = wa(n, "borderLeftWidth"), e = wa(n, "borderRightWidth"), a = wa(n, "borderTopWidth"), h = wa(n, "borderBottomWidth"), e = new va(parseFloat(a), parseFloat(e), parseFloat(h), parseFloat(s));
            else {
                var s = Ra(n, "borderLeft");
                e = Ra(n, "borderRight");
                var a = Ra(n, "borderTop"),
                    h = Ra(n, "borderBottom");
                e = new va(a, e, h, s)
            }
            n == cs(document) ? (s = r.x - n.scrollLeft, r = r.y - n.scrollTop, !Hb || 10 <= Number(ow) || (s += e.left, r += e.top)) : (s = r.x - o.x - e.left, r = r.y - o.y - e.top), o = n.clientHeight - i.offsetHeight, e = n.scrollLeft, a = n.scrollTop, e += Math.min(s, Math.max(s - (n.clientWidth - i.offsetWidth), 0)), a += Math.min(r, Math.max(r - o, 0)), i = new ss(e, a), t.scrollLeft = i.x, t.scrollTop = i.y
        }
    }, m(ll, dt), m(pl, ul), sb = pl.prototype, sb.vo = function(t) {
        if (!cl(this, t)) {
            if (1..toString() in this.a) {
                var e = fl(t);
                Al(this.b, lE, e, t), delete this.a[1..toString()]
            }
            e = fl(t), this.a[1..toString()] = t, Al(this.b, nE, e, t)
        }
    }, sb.wo = function(t) {
        if (!cl(this, t)) {
            var e = fl(t);
            Al(this.b, iE, e, t)
        }
    }, sb.zo = function(t) {
        if (!cl(this, t)) {
            var e = this.a[1..toString()];
            e && e.button === t.button && (e = fl(t), Al(this.b, rE, e, t), delete this.a[1..toString()])
        }
    }, sb.yo = function(t) {
        if (!cl(this, t)) {
            var e = fl(t);
            Tl(this.b, e, t)
        }
    }, sb.xo = function(t) {
        if (!cl(this, t)) {
            var e = fl(t);
            kl(this.b, e, t)
        }
    }, m(gl, ul), sb = gl.prototype, sb.Eo = function(t) {
        this.a[t.pointerId.toString()] = t;
        var e = dl(this, t);
        Al(this.b, nE, e, t)
    }, sb.Fo = function(t) {
        var e = dl(this, t);
        Al(this.b, iE, e, t)
    }, sb.Io = function(t) {
        var e = dl(this, t);
        Al(this.b, rE, e, t), delete this.a[t.pointerId.toString()]
    }, sb.Go = function(t) {
        var e = dl(this, t);
        kl(this.b, e, t)
    }, sb.Ho = function(t) {
        var e = dl(this, t);
        Tl(this.b, e, t)
    }, sb.Do = function(t) {
        var e = dl(this, t);
        Al(this.b, lE, e, t), delete this.a[t.pointerId.toString()]
    }, sb.Co = function(t) { this.b.b(new ml("lostpointercapture", t, t)) }, sb.Bo = function(t) { this.b.b(new ml("gotpointercapture", t, t)) }, m(yl, ul), sb = yl.prototype, sb.mr = function(t) { Rl(this.b, t) }, sb.nr = function(t) { Rl(this.b, t) }, sb.qr = function(t) { Rl(this.b, t) }, sb.or = function(t) { Rl(this.b, t) }, sb.pr = function(t) { Rl(this.b, t) }, sb.lr = function(t) { Rl(this.b, t) }, sb.uo = function(t) { Rl(this.b, t) }, sb.ln = function(t) { Rl(this.b, t) }, m(ml, dt);
    var eE = !1;
    try { eE = 1 === new MouseEvent("click", { buttons: 1 }).buttons } catch (t) {}
    m(wl, ul), sb = wl.prototype, sb.Ik = function() { this.i = 0, this.f = void 0 }, sb.qs = function(t) {
        var e = t.touches,
            i = Object.keys(this.a),
            n = i.length;
        if (n >= e.length) {
            var r, o, s, a = [];
            for (r = 0; r < n; ++r) {
                o = i[r], s = this.a[o];
                var h;
                if (!(h = 1 == o)) t: {
                    h = e.length;
                    for (var l, u = 0; u < h; u++)
                        if (l = e[u], l.identifier === o - 2) { h = !0; break t }
                    h = !1
                }
                h || a.push(s.out)
            }
            for (r = 0; r < a.length; ++r) this.Gg(t, a[r])
        }
        e = t.changedTouches[0], i = Object.keys(this.a).length, (0 === i || 1 === i && 1..toString() in this.a) && (this.g = e.identifier, e = gb, void 0 !== this.f && e.clearTimeout(this.f)), Sl(this, t), this.i++, El(this, t, this.gr)
    }, sb.gr = function(t, e) {
        this.a[e.pointerId] = { target: e.target, out: e, lk: e.target };
        var i = this.b;
        e.bubbles = !0, Al(i, oE, e, t), i = this.b, e.bubbles = !1, Al(i, aE, e, t), Al(this.b, nE, e, t)
    }, sb.ps = function(t) { t.preventDefault(), El(this, t, this.Ao) }, sb.Ao = function(t, e) {
        var i = this.a[e.pointerId];
        if (i) {
            var n = i.out,
                r = i.lk;
            Al(this.b, iE, e, t), n && r !== e.target && (n.relatedTarget = e.target, e.relatedTarget = r, n.target = r, e.target ? (kl(this.b, n, t), Tl(this.b, e, t)) : (e.target = r, e.relatedTarget = null, this.Gg(t, e))), i.out = e, i.lk = e.target
        }
    }, sb.os = function(t) { Sl(this, t), El(this, t, this.rs) }, sb.rs = function(t, e) {
        Al(this.b, rE, e, t), this.b.out(e, t);
        var i = this.b;
        e.bubbles = !1, Al(i, hE, e, t), delete this.a[e.pointerId], e.isPrimary && (this.g = void 0, this.f = gb.setTimeout(this.Ik.bind(this), 200))
    }, sb.ns = function(t) { El(this, t, this.Gg) }, sb.Gg = function(t, e) {
        Al(this.b, lE, e, t), this.b.out(e, t);
        var i = this.b;
        e.bubbles = !1, Al(i, hE, e, t), delete this.a[e.pointerId], e.isPrimary && (this.g = void 0, this.f = gb.setTimeout(this.Ik.bind(this), 200))
    }, m(Nl, vt), Nl.prototype.i = function(t) {
        var e = this.f[t.type];
        e && e(t)
    }, Nl.prototype.out = function(t, e) { t.bubbles = !0, Al(this, sE, t, e) }, Nl.prototype.pa = function() {
        for (var t, e = this.a.length, i = 0; i < e; i++) t = this.a[i], Ml(this, Object.keys(t.c));
        vt.prototype.pa.call(this)
    };
    var iE = "pointermove",
        nE = "pointerdown",
        rE = "pointerup",
        oE = "pointerover",
        sE = "pointerout",
        aE = "pointerenter",
        hE = "pointerleave",
        lE = "pointercancel",
        uE = [
            ["bubbles", !1],
            ["cancelable", !1],
            ["view", null],
            ["detail", null],
            ["screenX", 0],
            ["screenY", 0],
            ["clientX", 0],
            ["clientY", 0],
            ["ctrlKey", !1],
            ["altKey", !1],
            ["shiftKey", !1],
            ["metaKey", !1],
            ["button", 0],
            ["relatedTarget", null],
            ["buttons", 0],
            ["pointerId", 0],
            ["width", 0],
            ["height", 0],
            ["pressure", 0],
            ["tiltX", 0],
            ["tiltY", 0],
            ["pointerType", ""],
            ["hwTimestamp", 0],
            ["isPrimary", !1],
            ["type", ""],
            ["target", null],
            ["currentTarget", null],
            ["which", 0]
        ];
    m(_l, ll), _l.prototype.preventDefault = function() { ll.prototype.preventDefault.call(this), this.originalEvent.preventDefault() }, _l.prototype.stopPropagation = function() { ll.prototype.stopPropagation.call(this), this.originalEvent.stopPropagation() }, m(Pl, _l), m(Ol, vt), sb = Ol.prototype, sb.hj = function(t) {
        Fl(this, t);
        var e = new Pl(mE, this.f, t);
        this.b(e), !this.j && 0 === t.button && Dl(this, this.g), 0 === this.T && (this.c.forEach(ct), this.c.length = 0, this.j = !1, this.g = null, this.a.Pa(), this.a = null)
    }, sb.Vn = function(t) {
        Fl(this, t);
        var e = new Pl(yE, this.f, t);
        this.b(e), this.g = t, 0 === this.c.length && (this.a = new Nl(document), this.c.push(lt(this.a, dE, this.Wo, this), lt(this.a, mE, this.hj, this), lt(this.i, vE, this.hj, this)))
    }, sb.Wo = function(t) {
        if (t.clientX != this.g.clientX || t.clientY != this.g.clientY) {
            this.j = !0;
            var e = new Pl(gE, this.f, t, this.j);
            this.b(e)
        }
        t.preventDefault()
    }, sb.Qr = function(t) { this.b(new Pl(t.type, this.f, t, !(!this.g || t.clientX == this.g.clientX && t.clientY == this.g.clientY))) }, sb.pa = function() { this.s && (ct(this.s), this.s = null), this.o && (ct(this.o), this.o = null), this.c.forEach(ct), this.c.length = 0, this.a && (this.a.Pa(), this.a = null), this.i && (this.i.Pa(), this.i = null), vt.prototype.pa.call(this) };
    var pE = "singleclick",
        cE = "click",
        fE = "dblclick",
        gE = "pointerdrag",
        dE = "pointermove",
        yE = "pointerdown",
        mE = "pointerup",
        vE = "pointercancel",
        bE = { Js: pE, ys: cE, zs: fE, Cs: gE, Fs: dE, Bs: yE, Is: mE, Hs: "pointerover", Gs: "pointerout", Ds: "pointerenter", Es: "pointerleave", As: vE },
        wE = Array(6);
    m(Kl, gt), sb = Kl.prototype, sb.pa = function() { for (var t in this.g) this.g[t].Pa() }, sb.ya = function(t, e, i, n, r, o) {
        function s(t, r) {
            var o = b(t).toString(),
                s = e.layerStates[b(r)].Id;
            if (!(o in e.skippedFeatureUids) || s) return i.call(n, t, s ? r : null)
        }
        var a, h = e.viewState,
            l = h.resolution,
            u = h.projection,
            h = t;
        if (u.a) {
            var u = u.H(),
                p = Y(u),
                c = t[0];
            (c < u[0] || c > u[2]) && (h = [c + p * Math.ceil((u[0] - c) / p), t[1]])
        }
        for (u = e.layerStatesArray, p = u.length - 1; 0 <= p; --p) {
            var f = u[p],
                c = f.layer;
            if (Gr(f, l) && r.call(o, c) && (f = Jl(this, c), c.ja() && (a = f.ya(c.ja().D ? h : t, e, s, n)), a)) return a
        }
    }, sb.Rj = function(t, e, i, n, r, o) {
        var s, a, h = e.viewState.resolution,
            l = e.layerStatesArray;
        for (a = l.length - 1; 0 <= a; --a) { s = l[a]; var u = s.layer; if (Gr(s, h) && r.call(o, u) && (s = Jl(this, u).qd(t, e, i, n))) return s }
    }, sb.Sj = function(t, e, i, n) { return void 0 !== this.ya(t, e, Q, this, i, n) }, sb.Ln = function() { this.i.render() }, sb.fg = v, sb.Sr = function(t, e) {
        for (var i in this.g)
            if (!(e && i in e.layerStates)) {
                var n = i,
                    r = this.g[n];
                delete this.g[n], ct(this.s[n]), delete this.s[n], r.Pa()
            }
    }, eu.prototype.clear = function() { this.b.length = 0, this.g.length = 0, et(this.a) }, eu.prototype.c = function(t) { x(!(this.f(t) in this.a), 31); var e = this.o(t); return 1 / 0 != e && (this.b.push(t), this.g.push(e), this.a[this.f(t)] = !0, ru(this, 0, this.b.length - 1), !0) }, m(su, eu), su.prototype.c = function(t) { var e = eu.prototype.c.call(this, t); return e && lt(t[0], "change", this.j, this), e }, su.prototype.j = function(t) {
        t = t.target;
        var e = t.W();
        2 !== e && 3 !== e && 4 !== e && 5 !== e || (pt(t, "change", this.j, this), t = t.pb(), t in this.i && (delete this.i[t], --this.l), this.s())
    }, m(Cu, St), sb = Cu.prototype, sb.ce = function(t) { return this.o.center(t) }, sb.constrainResolution = function(t, e, i) { return this.o.resolution(t, e || 0, i || 0) }, sb.constrainRotation = function(t, e) { return this.o.rotation(t, e || 0) }, sb.cb = function() { return this.get(xE) }, sb.Cc = function(t) {
        var e = this.cb();
        x(e, 1);
        var i = this.aa();
        x(void 0 !== i, 2);
        var n = this.Ra();
        return x(void 0 !== n, 3), q(e, i, n, t)
    }, sb.Cj = function() { return this.a }, sb.Dj = function() { return this.i }, sb.Ej = function() { return this.j }, sb.aa = function() { return this.get(EE) }, sb.Fj = function() { return this.f }, sb.Ra = function() { return this.get(SE) }, sb.W = function() {
        var t = this.cb(),
            e = this.j,
            i = this.aa(),
            n = this.Ra();
        return { center: t.slice(), projection: void 0 !== e ? e : null, resolution: i, rotation: n }
    }, sb.ah = function() {
        var t, e = this.aa();
        if (void 0 !== e && e >= this.i && e <= this.a) {
            t = this.l || 0;
            var i, n;
            if (this.f) {
                if (n = le(this.f, e, 1), t += n, n == this.f.length - 1) return t;
                i = this.f[n], n = i / this.f[n + 1]
            } else i = this.a, n = this.s;
            t += Math.log(i / e) / Math.log(n)
        }
        return t
    }, sb.Ad = function(t, e, i) {
        t instanceof Qt || (x(Array.isArray(t), 24), x(!$(t), 25), t = ti(t));
        var n = i || {};
        i = void 0 !== n.padding ? n.padding : [0, 0, 0, 0];
        var r, o = void 0 === n.constrainResolution || n.constrainResolution,
            s = void 0 !== n.nearest && n.nearest;
        r = void 0 !== n.minResolution ? n.minResolution : void 0 !== n.maxZoom ? this.constrainResolution(this.a, n.maxZoom - this.l, 0) : 0;
        var a = t.oa(),
            h = this.Ra(),
            n = Math.cos(-h),
            h = Math.sin(-h),
            l = 1 / 0,
            u = 1 / 0,
            p = -(1 / 0),
            c = -(1 / 0);
        t = t.Aa();
        for (var f = 0, g = a.length; f < g; f += t) var d = a[f] * n - a[f + 1] * h,
            y = a[f] * h + a[f + 1] * n,
            l = Math.min(l, d),
            u = Math.min(u, y),
            p = Math.max(p, d),
            c = Math.max(c, y);
        e = Iu([l, u, p, c], [e[0] - i[1] - i[3], e[1] - i[0] - i[2]]), e = isNaN(e) ? r : Math.max(e, r), o && (r = this.constrainResolution(e, 0, 0), !s && r < e && (r = this.constrainResolution(r, -1, 0)), e = r), this.Xb(e), h = -h, s = (l + p) / 2 + (i[1] - i[3]) / 2 * e, i = (u + c) / 2 + (i[0] - i[2]) / 2 * e, this.qb([s * n - i * h, i * n + s * h])
    }, sb.wi = function(t, e, i) {
        var n = this.Ra(),
            r = Math.cos(-n),
            n = Math.sin(-n),
            o = t[0] * r - t[1] * n;
        t = t[1] * r + t[0] * n;
        var s = this.aa(),
            o = o + (e[0] / 2 - i[0]) * s;
        t += (i[1] - e[1] / 2) * s, n = -n, this.qb([o * r - t * n, t * r + o * n])
    }, sb.rotate = function(t, e) {
        if (void 0 !== e) {
            var i, n = this.cb();
            void 0 !== n && (i = [n[0] - e[0], n[1] - e[1]], Eu(i, t - this.Ra()), mu(i, e)), this.qb(i)
        }
        this.Ld(t)
    }, sb.qb = function(t) { this.set(xE, t) }, sb.Xb = function(t) { this.set(EE, t) }, sb.Ld = function(t) { this.set(SE, t) }, sb.ig = function(t) { t = this.constrainResolution(this.a, t - this.l, 0), this.Xb(t) };
    var xE = "center",
        EE = "resolution",
        SE = "rotation";
    m(_u, St), _u.prototype.pa = function() { Ri(this.element), St.prototype.pa.call(this) }, _u.prototype.i = function() { return this.a }, _u.prototype.setMap = function(t) {
        this.a && Ri(this.element);
        for (var e = 0, i = this.s.length; e < i; ++e) ct(this.s[e]);
        this.s.length = 0, (this.a = t) && ((this.P ? this.P : t.D).appendChild(this.element), this.render !== v && this.s.push(lt(t, "postrender", this.render, this)), t.render())
    }, _u.prototype.c = function(t) { this.P = "string" == typeof t ? document.getElementById(t) : t }, m(Pu, _u), sb = Pu.prototype, sb.$o = function(t) { t.preventDefault(), Du(this) }, sb.Zo = function() { return this.j }, sb.bp = function(t) { this.j !== t && (this.j = t, this.element.classList.toggle("ol-uncollapsible"), !t && this.f && Du(this)) }, sb.ap = function(t) { this.j && this.f !== t && Du(this) }, sb.Yo = function() { return this.f }, m(Wu, _u), Wu.prototype.v = function(t) {
        if (t.preventDefault(), void 0 !== this.l) this.l();
        else {
            t = this.a;
            var e = t.$();
            if (e) {
                var i = e.Ra();
                void 0 !== i && (0 < this.o && (i %= 2 * Math.PI, i < -Math.PI && (i += 2 * Math.PI), i > Math.PI && (i -= 2 * Math.PI), t.mb(qu({ rotation: i, duration: this.o, easing: Uu }))), e.Ld(0))
            }
        }
    }, m(Hu, _u), Hu.prototype.l = function(t, e) {
        e.preventDefault();
        var i = this.a,
            n = i.$();
        if (n) {
            var r = n.aa();
            r && (0 < this.f && i.mb(Vu({ resolution: r, duration: this.f, easing: Uu })), i = n.constrainResolution(r, t), n.Xb(i))
        }
    }, m(Zu, St), Zu.prototype.f = function() { return this.get("active") }, Zu.prototype.l = function() { return this.A }, Zu.prototype.i = function(t) { this.set("active", t) }, Zu.prototype.setMap = function(t) { this.A = t }, m(ep, Zu), m(cp, Zu), cp.prototype.ud = function(t) { return t }, m(dp, cp), dp.prototype.ud = tt, m(bp, cp), bp.prototype.ud = tt, m(Sp, gt), Sp.prototype.pa = function() { this.setMap(null) }, Sp.prototype.setMap = function(t) {
        if (this.b) {
            this.b.O.removeChild(this.a);
            var e = this.a.style;
            e.left = e.top = e.width = e.height = "inherit"
        }(this.b = t) && this.b.O.appendChild(this.a)
    }, Sp.prototype.Y = function() { return this.f }, m(Cp, dt), m(Mp, cp), Mp.prototype.Y = function() { return this.a.Y() }, Mp.prototype.s = v, m(Rp, Mp), Rp.prototype.s = function() {
        var t = this.A,
            e = t.$(),
            i = t.bb(),
            n = this.Y().H();
        if (this.O) {
            var r, o, s = e.Cc(i),
                n = [t.Qa(j(n)), t.Qa(H(n))],
                a = A(1 / 0, 1 / 0, -(1 / 0), -(1 / 0), void 0);
            for (r = 0, o = n.length; r < o; ++r) D(a, n[r]);
            Z(s, 1 / Iu(a, i)), n = s
        }
        i = e.constrainResolution(Iu(n, i)), s = e.aa(), a = e.cb(), t.mb(Vu({ resolution: s, duration: this.o, easing: Uu })), t.mb(Gu({ source: a, duration: this.o, easing: Uu })), e.qb(G(n)), e.Xb(i)
    }, m(_p, Zu), m(Op, Zu), m(Fp, Zu), Fp.prototype.v = function(t) {
        var e = Ct(this.c, -1, 1),
            i = t.$();
        Qu(t, i, -e, this.a, this.C), this.c = 0, this.a = null, this.o = this.j = void 0
    }, Fp.prototype.D = function(t) { this.s = t, t || (this.a = null) }, m(Bp, cp), Bp.prototype.ud = tt, m(qp, cp), qp.prototype.ud = tt, m(Yp, Pt), Yp.prototype.getPointResolution = function(t, e) { return t / mb(e[1] / 6378137) };
    var NE = 6378137 * Math.PI,
        LE = [-NE, -NE, NE, NE],
        CE = [-180, -85, 180, 85],
        ME = "EPSG:3857 EPSG:102100 EPSG:102113 EPSG:900913 urn:ogc:def:crs:EPSG:6.18:3:3857 urn:ogc:def:crs:EPSG::3857 http://www.opengis.net/gml/srs/epsg.xml#3857".split(" ").map(function(t) { return new Yp(t) }),
        IE = new _t(6378137);
    m(Zp, Pt), Zp.prototype.getPointResolution = function(t) { return t };
    var kE = [-180, -90, 180, 90],
        TE = Math.PI * IE.radius / 180,
        AE = [new Zp("CRS:84"), new Zp("EPSG:4326", "neu"), new Zp("urn:ogc:def:crs:EPSG::4326", "neu"), new Zp("urn:ogc:def:crs:EPSG:6.6:4326", "neu"), new Zp("urn:ogc:def:crs:OGC:1.3:CRS84"), new Zp("urn:ogc:def:crs:OGC:2:84"), new Zp("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"), new Zp("urn:x-ogc:def:crs:EPSG:4326", "neu")];
    m(Qp, Wr), Qp.prototype.f = function() { return this.get("preload") }, Qp.prototype.c = function() { return this.get("useInterimTilesOnError") }, Qp.prototype.X = function(t) { this.set("preload", t) }, Qp.prototype.fa = function(t) { this.set("useInterimTilesOnError", t) }, m(ec, tc), sb = ec.prototype, sb.df = function(t) {
        if (K(this.c, t.H())) {
            if (this.a || this.b) {
                this.a && sc(this, this.a), this.b && ac(this, this.b);
                var e;
                e = this.C;
                var i = this.T,
                    n = t.oa();
                e = n ? Jt(n, 0, n.length, t.Aa(), e, i) : null, i = e[2] - e[0], n = e[3] - e[1], i = Math.sqrt(i * i + n * n), n = this.f, n.beginPath(), n.arc(e[0], e[1], i, 0, 2 * Math.PI), this.a && n.fill(), this.b && n.stroke()
            }
            "" !== this.g && nc(this, t.Ae(), 2, 2)
        }
    }, sb.Be = function(t) { this.wc(t.c, t.f), this.xc(t.a), this.yc(t.Wa()) }, sb.ed = function(t) {
        switch (t.Z()) {
            case "Point":
                this.gd(t);
                break;
            case "LineString":
                this.le(t);
                break;
            case "Polygon":
                this.Qg(t);
                break;
            case "MultiPoint":
                this.fd(t);
                break;
            case "MultiLineString":
                this.Og(t);
                break;
            case "MultiPolygon":
                this.Pg(t);
                break;
            case "GeometryCollection":
                this.Ng(t);
                break;
            case "Circle":
                this.df(t)
        }
    }, sb.Mg = function(t, e) {
        var i = (0, e.g)(t);
        i && K(this.c, i.H()) && (this.Be(e), this.ed(i))
    }, sb.Ng = function(t) { t = t.f; var e, i; for (e = 0, i = t.length; e < i; ++e) this.ed(t[e]) }, sb.gd = function(t) {
        var e = t.oa();
        t = t.Aa(), this.i && ic(this, e, e.length), "" !== this.g && nc(this, e, e.length, t)
    }, sb.fd = function(t) {
        var e = t.oa();
        t = t.Aa(), this.i && ic(this, e, e.length), "" !== this.g && nc(this, e, e.length, t)
    }, sb.le = function(t) {
        if (K(this.c, t.H())) {
            if (this.b) {
                ac(this, this.b);
                var e = this.f,
                    i = t.oa();
                e.beginPath(), rc(this, i, 0, i.length, t.Aa(), !1), e.stroke()
            }
            "" !== this.g && (t = Ue(t), nc(this, t, 2, 2))
        }
    }, sb.Og = function(t) {
        var e = t.H();
        if (K(this.c, e)) {
            if (this.b) {
                ac(this, this.b);
                var e = this.f,
                    i = t.oa(),
                    n = 0,
                    r = t.ec(),
                    o = t.Aa();
                e.beginPath();
                var s, a;
                for (s = 0, a = r.length; s < a; ++s) n = rc(this, i, n, r[s], o, !1);
                e.stroke()
            }
            "" !== this.g && (t = je(t), nc(this, t, t.length, 2))
        }
    }, sb.Qg = function(t) {
        if (K(this.c, t.H())) {
            if (this.b || this.a) {
                this.a && sc(this, this.a), this.b && ac(this, this.b);
                var e = this.f;
                e.beginPath(), oc(this, t.qc(), 0, t.ec(), t.Aa()), this.a && e.fill(), this.b && e.stroke()
            }
            "" !== this.g && (t = Je(t), nc(this, t, 2, 2))
        }
    }, sb.Pg = function(t) {
        if (K(this.c, t.H())) {
            if (this.b || this.a) {
                this.a && sc(this, this.a), this.b && ac(this, this.b);
                var e, i, n = this.f,
                    r = oi(t),
                    o = 0,
                    s = t.c,
                    a = t.Aa();
                for (e = 0, i = s.length; e < i; ++e) {
                    var h = s[e];
                    n.beginPath(), o = oc(this, r, o, h, a), this.a && n.fill(), this.b && n.stroke()
                }
            }
            "" !== this.g && (t = ri(t), nc(this, t, t.length, 2))
        }
    }, sb.wc = function(t, e) {
        if (t) {
            var i = t.b;
            this.a = { fillStyle: pi(i ? i : Lw) }
        } else this.a = null;
        if (e) {
            var i = e.b,
                n = e.f,
                r = e.g,
                o = e.c,
                s = e.a,
                a = e.i;
            this.b = { lineCap: void 0 !== n ? n : "round", lineDash: r ? r : Cw, lineJoin: void 0 !== o ? o : "round", lineWidth: this.v * (void 0 !== s ? s : 1), miterLimit: void 0 !== a ? a : 10, strokeStyle: li(i ? i : Mw) }
        } else this.b = null
    }, sb.xc = function(t) {
        if (t) {
            var e = t.Dc(),
                i = t.Yc(1),
                n = t.$a(),
                r = t.hc();
            this.D = e[0], this.O = e[1], this.sa = r[1], this.i = i, this.A = t.A, this.fa = n[0], this.vb = n[1], this.ra = t.T, this.qa = t.o, this.l = t.i, this.xa = t.C, this.za = r[0]
        } else this.i = null
    }, sb.yc = function(t) {
        if (t) {
            var e = t.b;
            e ? (e = e.b, this.j = { fillStyle: pi(e ? e : Lw) }) : this.j = null;
            var i = t.l;
            if (i) {
                var e = i.b,
                    n = i.f,
                    r = i.g,
                    o = i.c,
                    s = i.a,
                    i = i.i;
                this.s = { lineCap: void 0 !== n ? n : "round", lineDash: r ? r : Cw, lineJoin: void 0 !== o ? o : "round", lineWidth: void 0 !== s ? s : 1, miterLimit: void 0 !== i ? i : 10, strokeStyle: li(e ? e : Mw) }
            } else this.s = null;
            var e = t.g,
                n = t.f,
                r = t.c,
                o = t.s,
                s = t.i,
                i = t.a,
                a = t.Wa(),
                h = t.j;
            t = t.o, this.P = { font: void 0 !== e ? e : "10px sans-serif", textAlign: void 0 !== h ? h : "center", textBaseline: void 0 !== t ? t : "middle" }, this.g = void 0 !== a ? a : "", this.Ta = void 0 !== n ? this.v * n : 0, this.Ua = void 0 !== r ? this.v * r : 0, this.sb = void 0 !== o && o, this.Hb = void 0 !== s ? s : 0, this.o = this.v * (void 0 !== i ? i : 1)
        } else this.g = ""
    }, m(hc, wt), sb = hc.prototype, sb.ya = v, sb.qd = function(t, e, i, n) { if (t = ql(e.pixelToCoordinateTransform, t.slice()), this.ya(t, e, Q, this)) return i.call(n, this.a, null) }, sb.Kf = tt, sb.cf = function(t, e, i) { return function(n, r) { return po(t, e, n, r, function(t) { i[n] || (i[n] = {}), i[n][t.ta.toString()] = t }) } }, sb.Op = function(t) { 2 === t.target.W() && uc(this) }, m(mc, hc), mc.prototype.i = function(t, e, i) {
        bc(this, "precompose", i, t, void 0);
        var n = this.f ? this.f.a() : null;
        if (n) {
            var r = e.extent,
                o = void 0 !== r;
            o && vc(i, t, r);
            var r = this.s,
                s = i.globalAlpha;
            i.globalAlpha = e.opacity, i.drawImage(n, 0, 0, +n.width, +n.height, Math.round(r[4]), Math.round(r[5]), Math.round(n.width * r[0]), Math.round(n.height * r[3])), i.globalAlpha = s, o && i.restore()
        }
        wc(this, i, t)
    };
    var RE = ["Polygon", "LineString", "Image", "Text"];
    m(Sc, tc), Sc.prototype.jb = function(t, e, i, n, r) { Cc(this, t, e, i, n, r, this.a, void 0, void 0) }, Sc.prototype.Jf = v, Sc.prototype.Tg = function() { return this.U }, m(kc, Sc), kc.prototype.gd = function(t, e) {
        if (this.j) {
            Lc(this, e);
            var i = t.oa(),
                n = this.coordinates.length,
                i = Nc(this, i, 0, i.length, t.Aa(), !1);
            this.a.push([4, n, i, this.j, this.g, this.i, this.l, this.o, this.s, this.A, this.T, this.v, this.C, this.D, this.O]), this.b.push([4, n, i, this.P, this.g, this.i, this.l, this.o, this.s, this.A, this.T, this.v, this.C, this.D, this.O]), Ic(this, e)
        }
    }, kc.prototype.fd = function(t, e) {
        if (this.j) {
            Lc(this, e);
            var i = t.oa(),
                n = this.coordinates.length,
                i = Nc(this, i, 0, i.length, t.Aa(), !1);
            this.a.push([4, n, i, this.j, this.g, this.i, this.l, this.o, this.s, this.A, this.T, this.v, this.C, this.D, this.O]), this.b.push([4, n, i, this.P, this.g, this.i, this.l, this.o, this.s, this.A, this.T, this.v, this.C, this.D, this.O]), Ic(this, e)
        }
    }, kc.prototype.Jf = function() { Mc(this), this.i = this.g = void 0, this.j = this.P = null, this.O = this.D = this.v = this.T = this.A = this.s = this.o = this.C = this.l = void 0 }, kc.prototype.xc = function(t) {
        var e = t.Dc(),
            i = t.hc(),
            n = t.Qf(1),
            r = t.Yc(1),
            o = t.$a();
        this.g = e[0], this.i = e[1], this.P = n, this.j = r, this.l = i[1], this.o = t.A, this.s = o[0], this.A = o[1], this.T = t.T, this.v = t.o, this.C = t.i, this.D = t.C, this.O = i[0]
    }, m(Tc, Sc), sb = Tc.prototype, sb.Tg = function() { return this.f || (this.f = N(this.U), 0 < this.c && S(this.f, this.resolution * (this.c + 1) / 2, this.f)), this.f }, sb.le = function(t, e) {
        var i = this.g,
            n = i.lineWidth;
        void 0 !== i.strokeStyle && void 0 !== n && (Rc(this), Lc(this, e), this.b.push([10, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash], [1]), i = t.oa(), Ac(this, i, 0, i.length, t.Aa()), this.b.push([12]), Ic(this, e))
    }, sb.Og = function(t, e) {
        var i = this.g,
            n = i.lineWidth;
        if (void 0 !== i.strokeStyle && void 0 !== n) {
            Rc(this), Lc(this, e), this.b.push([10, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash], [1]);
            var r, o, i = t.ec(),
                n = t.oa(),
                s = t.Aa(),
                a = 0;
            for (r = 0, o = i.length; r < o; ++r) a = Ac(this, n, a, i[r], s);
            this.b.push([12]), Ic(this, e)
        }
    }, sb.Jf = function() { this.g.ph != this.coordinates.length && this.a.push([12]), Mc(this), this.g = null }, sb.wc = function(t, e) {
        var i = e.b;
        this.g.strokeStyle = li(i ? i : Mw), i = e.f, this.g.lineCap = void 0 !== i ? i : "round", i = e.g, this.g.lineDash = i ? i : Cw, i = e.c, this.g.lineJoin = void 0 !== i ? i : "round", i = e.a, this.g.lineWidth = void 0 !== i ? i : 1, i = e.i, this.g.miterLimit = void 0 !== i ? i : 10, this.g.lineWidth > this.c && (this.c = this.g.lineWidth, this.f = null)
    }, m(_c, Sc), sb = _c.prototype, sb.df = function(t, e) {
        var i = this.g,
            n = i.strokeStyle;
        if (void 0 !== i.fillStyle || void 0 !== n) {
            Oc(this), Lc(this, e), this.b.push([9, li(Lw)]), void 0 !== i.strokeStyle && this.b.push([10, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash]);
            var r = t.oa(),
                n = this.coordinates.length;
            Nc(this, r, 0, r.length, t.Aa(), !1), r = [1], n = [2, n], this.a.push(r, n), this.b.push(r, n), n = [7], this.b.push(n), void 0 !== i.fillStyle && this.a.push(n), void 0 !== i.strokeStyle && (i = [12], this.a.push(i), this.b.push(i)), Ic(this, e)
        }
    }, sb.Qg = function(t, e) {
        var i = this.g,
            n = i.strokeStyle;
        void 0 === i.fillStyle && void 0 === n || (Oc(this), Lc(this, e), this.b.push([9, li(Lw)]), void 0 !== i.strokeStyle && this.b.push([10, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash]), i = t.ec(), n = t.qc(), Pc(this, n, 0, i, t.Aa()), Ic(this, e))
    }, sb.Pg = function(t, e) {
        var i = this.g,
            n = i.strokeStyle;
        if (void 0 !== i.fillStyle || void 0 !== n) {
            Oc(this), Lc(this, e), this.b.push([9, li(Lw)]), void 0 !== i.strokeStyle && this.b.push([10, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash]);
            var r, o, i = t.c,
                n = oi(t),
                s = t.Aa(),
                a = 0;
            for (r = 0, o = i.length; r < o; ++r) a = Pc(this, n, a, i[r], s);
            Ic(this, e)
        }
    }, sb.Jf = function() { Mc(this), this.g = null; var t = this.ra; if (0 !== t) { var e, i, n = this.coordinates; for (e = 0, i = n.length; e < i; ++e) n[e] = t * Math.round(n[e] / t) } }, sb.Tg = function() { return this.f || (this.f = N(this.U), 0 < this.c && S(this.f, this.resolution * (this.c + 1) / 2, this.f)), this.f }, sb.wc = function(t, e) {
        var i = this.g;
        if (t) {
            var n = t.b;
            i.fillStyle = pi(n ? n : Lw)
        } else i.fillStyle = void 0;
        e ? (n = e.b, i.strokeStyle = li(n ? n : Mw), n = e.f, i.lineCap = void 0 !== n ? n : "round", n = e.g, i.lineDash = n ? n.slice() : Cw, n = e.c, i.lineJoin = void 0 !== n ? n : "round", n = e.a, i.lineWidth = void 0 !== n ? n : 1, n = e.i, i.miterLimit = void 0 !== n ? n : 10, i.lineWidth > this.c && (this.c = i.lineWidth, this.f = null)) : (i.strokeStyle = void 0, i.lineCap = void 0, i.lineDash = null, i.lineJoin = void 0, i.lineWidth = void 0, i.miterLimit = void 0)
    }, m(Dc, Sc), Dc.prototype.yc = function(t) {
        if (t) {
            var e = t.b;
            e ? (e = e.b, e = pi(e ? e : Lw), this.g ? this.g.fillStyle = e : this.g = { fillStyle: e }) : this.g = null;
            var i = t.l;
            if (i) {
                var e = i.b,
                    n = i.f,
                    r = i.g,
                    o = i.c,
                    s = i.a,
                    i = i.i,
                    n = void 0 !== n ? n : "round",
                    r = r ? r.slice() : Cw,
                    o = void 0 !== o ? o : "round",
                    s = void 0 !== s ? s : 1,
                    i = void 0 !== i ? i : 10,
                    e = li(e ? e : Mw);
                if (this.i) {
                    var a = this.i;
                    a.lineCap = n, a.lineDash = r, a.lineJoin = o, a.lineWidth = s, a.miterLimit = i, a.strokeStyle = e
                } else this.i = { lineCap: n, lineDash: r, lineJoin: o, lineWidth: s, miterLimit: i, strokeStyle: e }
            } else this.i = null;
            var h = t.g,
                e = t.f,
                n = t.c,
                r = t.s,
                s = t.i,
                i = t.a,
                o = t.Wa(),
                a = t.j,
                l = t.o;
            t = void 0 !== h ? h : "10px sans-serif", a = void 0 !== a ? a : "center", l = void 0 !== l ? l : "middle", this.l ? (h = this.l, h.font = t, h.textAlign = a, h.textBaseline = l) : this.l = { font: t, textAlign: a, textBaseline: l }, this.j = void 0 !== o ? o : "", this.o = void 0 !== e ? e : 0, this.s = void 0 !== n ? n : 0, this.A = void 0 !== r && r, this.T = void 0 !== s ? s : 0, this.v = void 0 !== i ? i : 1
        } else this.j = ""
    }, m(Uc, Ec), Uc.prototype.ya = function(t, e, i, n, r) {
        var o = Hl(this.l, .5, .5, 1 / e, -1 / e, -i, -t[0], -t[1]),
            s = this.i;
        s.clearRect(0, 0, 1, 1);
        var a;
        return void 0 !== this.c && (a = T(), D(a, t), S(a, e * this.c, a)), jc(this, s, o, i, n, function(t) {
            if (0 < s.getImageData(0, 0, 1, 1).data[3]) {
                if (t = r(t)) return t;
                s.clearRect(0, 0, 1, 1)
            }
        }, a)
    }, Uc.prototype.b = function(t, e) {
        var i = void 0 !== t ? t.toString() : "0",
            n = this.a[i];
        return void 0 === n && (n = {}, this.a[i] = n), i = n[e], void 0 === i && (i = new _E[e](this.s, this.f, this.o, this.j), n[e] = i), i
    }, Uc.prototype.g = function() { return nt(this.a) }, Uc.prototype.jb = function(t, e, i, n, r, o) {
        var s = Object.keys(this.a).map(Number);
        s.sort(ae);
        var a = this.f,
            h = a[0],
            l = a[1],
            u = a[2],
            a = a[3],
            h = [h, l, h, a, u, a, u, l];
        Jt(h, 0, 8, 2, i, h), t.save(), t.beginPath(), t.moveTo(h[0], h[1]), t.lineTo(h[2], h[3]), t.lineTo(h[4], h[5]), t.lineTo(h[6], h[7]), t.clip(), o = o ? o : RE;
        for (var p, c, h = 0, l = s.length; h < l; ++h)
            for (p = this.a[s[h].toString()], u = 0, a = o.length; u < a; ++u) c = p[o[u]], void 0 !== c && c.jb(t, e, i, n, r);
        t.restore()
    };
    var _E = { Image: kc, LineString: Tc, Polygon: _c, Text: Dc },
        PE = {
            Point: function(t, e, i, n) {
                var r = i.a;
                if (r) {
                    if (2 != r.Ce()) return;
                    var o = t.b(i.b, "Image");
                    o.xc(r), o.gd(e, n)
                }(r = i.Wa()) && (t = t.b(i.b, "Text"), t.yc(r), Fc(t, e.oa(), 2, 2, n))
            },
            LineString: function(t, e, i, n) {
                var r = i.f;
                if (r) {
                    var o = t.b(i.b, "LineString");
                    o.wc(null, r), o.le(e, n)
                }(r = i.Wa()) && (t = t.b(i.b, "Text"), t.yc(r), Fc(t, Ue(e), 2, 2, n))
            },
            Polygon: function(t, e, i, n) {
                var r = i.c,
                    o = i.f;
                if (r || o) {
                    var s = t.b(i.b, "Polygon");
                    s.wc(r, o), s.Qg(e, n)
                }(r = i.Wa()) && (t = t.b(i.b, "Text"), t.yc(r), Fc(t, Je(e), 2, 2, n))
            },
            MultiPoint: function(t, e, i, n) {
                var r = i.a;
                if (r) {
                    if (2 != r.Ce()) return;
                    var o = t.b(i.b, "Image");
                    o.xc(r), o.fd(e, n)
                }(r = i.Wa()) && (t = t.b(i.b, "Text"), t.yc(r), i = e.oa(), Fc(t, i, i.length, e.Aa(), n))
            },
            MultiLineString: function(t, e, i, n) {
                var r = i.f;
                if (r) {
                    var o = t.b(i.b, "LineString");
                    o.wc(null, r), o.Og(e, n)
                }(r = i.Wa()) && (t = t.b(i.b, "Text"), t.yc(r), e = je(e), Fc(t, e, e.length, 2, n))
            },
            MultiPolygon: function(t, e, i, n) {
                var r = i.c,
                    o = i.f;
                if (o || r) {
                    var s = t.b(i.b, "Polygon");
                    s.wc(r, o), s.Pg(e, n)
                }(r = i.Wa()) && (t = t.b(i.b, "Text"), t.yc(r), e = ri(e), Fc(t, e, e.length, 2, n))
            },
            GeometryCollection: function(t, e, i, n) { e = e.f; var r, o; for (r = 0, o = e.length; r < o; ++r)(0, PE[e[r].Z()])(t, e[r], i, n) },
            Circle: function(t, e, i, n) {
                var r = i.c,
                    o = i.f;
                if (r || o) {
                    var s = t.b(i.b, "Polygon");
                    s.wc(r, o), s.df(e, n)
                }(r = i.Wa()) && (t = t.b(i.b, "Text"), t.yc(r), Fc(t, e.Ae(), 2, 2, n))
            }
        };
    m(Vc, ko), Vc.prototype.i = function(t) { this.state = t ? 3 : 2, To(this) }, Vc.prototype.load = function() { 0 == this.state && (this.state = 1, To(this), this.c(this.i.bind(this))) }, Vc.prototype.a = function() { return this.g }, m(Wc, _o), Wc.prototype.Cd = function(t, e, i, n) { e = Po(this, e); var r = this.U; return r && this.X == this.g && r.aa() == e && r.f == i && M(r.H(), t) ? r : (t = t.slice(), Z(t, this.qa), (n = this.fa(t, e, i, [Y(t) / e * i, V(t) / e * i], n)) && (r = new Vc(t, e, i, this.l, n)), this.U = r, this.X = this.g, r) }, m(Xc, Wc), sb = Xc.prototype, sb.hm = function(t, e, i, n, r) {
        var o = new Uc(.5 * e / i, t, e, this.c.X, this.xa);
        this.c.Hd(t, e, r);
        var s = !1;
        return this.c.Rb(t, function(t) {
            var n;
            if (!(n = s)) {
                var r;
                if ((n = t.Tc()) ? r = n.call(t, e) : this.s && (r = this.s(t, e)), r) {
                    var a, h = !1;
                    for (Array.isArray(r) || (r = [r]), n = 0, a = r.length; n < a; ++n) h = qc(o, t, r[n], Gc(e, i), this.fq, this) || h;
                    n = h
                } else n = !1
            }
            s = n
        }, this), Bc(o), s ? null : (this.j[0] != n[0] || this.j[1] != n[1] ? (this.i.canvas.width = n[0], this.i.canvas.height = n[1], this.j[0] = n[0], this.j[1] = n[1]) : this.i.clearRect(0, 0, n[0], n[1]), t = Hc(this, G(t), e, i, n), o.jb(this.i, i, t, 0, {}), this.A = o, this.i.canvas)
    }, sb.ya = function(t, e, i, n, r) { if (this.A) { var o = {}; return this.A.ya(t, e, 0, n, function(t) { var e = b(t).toString(); if (!(e in o)) return o[e] = !0, r(t) }) } }, sb.bq = function() { return this.c }, sb.cq = function() { return this.P }, sb.eq = function() { return this.s }, sb.fq = function() { this.u() }, sb.gq = function() { Er(this, this.c.W()) }, sb.Xj = function(t) { this.P = void 0 !== t ? t : Yi, this.s = t ? Hi(this.P) : void 0, this.u() }, m(Yc, mc), Yc.prototype.ya = function(t, e, i, n) { var r = this.a; return r.ja().ya(t, e.viewState.resolution, e.viewState.rotation, e.skippedFeatureUids, function(t) { return i.call(n, t, r) }) }, Yc.prototype.qd = function(t, e, i, n) {
        if (this.f && this.f.a())
            if (this.a.ja() instanceof Xc) { if (t = ql(e.pixelToCoordinateTransform, t.slice()), this.ya(t, e, Q, this)) return i.call(n, this.a, null) } else if (this.j || (this.j = Yl(this.s.slice())), e = ql(this.j, t.slice()), this.c || (this.c = Ii(1, 1)), this.c.clearRect(0, 0, 1, 1), this.c.drawImage(this.f ? this.f.a() : null, e[0], e[1], 1, 1, 0, 0, 1, 1), e = this.c.getImageData(0, 0, 1, 1).data, 0 < e[3]) return i.call(n, this.a, e)
    }, Yc.prototype.l = function(t, e) {
        var i = t.pixelRatio,
            n = t.viewState,
            r = n.center,
            o = n.resolution,
            s = this.a.ja(),
            a = t.viewHints,
            h = t.extent;
        if (void 0 !== e.extent && (h = W(h, e.extent)), a[0] || a[1] || $(h) || (n = s.v(h, o, i, n.projection)) && lc(this, n) && (this.f = n), this.f) {
            var n = this.f,
                a = n.H(),
                h = n.aa(),
                l = n.f,
                o = i * h / (o * l),
                u = Bl(this.s);
            Xl(u, i * t.size[0] / 2, i * t.size[1] / 2), Wl(u, o, o), Xl(u, l * (a[0] - r[0]) / h, l * (r[1] - a[3]) / h), this.j = null, cc(t.attributions, n.l), fc(t, s)
        }
        return !!this.f
    }, m(Kc, mc), Kc.prototype.i = function(t, e, i) {
        var n = xc(this, t, 0);
        bc(this, "precompose", i, t, n), $c(this, i, t, e), wc(this, i, t, n)
    }, Kc.prototype.l = function(t, e) {
        function i(t) { return t = t.W(), 2 == t || 4 == t || 3 == t && !m }
        var n = t.pixelRatio,
            r = t.viewState,
            o = r.projection,
            s = this.a,
            a = s.ja(),
            h = a.yb(o),
            l = h.Kc(r.resolution, this.C),
            u = h.aa(l),
            p = r.center;
        if (u == r.resolution ? (p = dc(p, u, t.size), r = q(p, u, r.rotation, t.size)) : r = t.extent, void 0 !== e.extent && (r = W(r, e.extent)), $(r)) return !1;
        u = wn(h, r, u), p = {}, p[l] = {};
        var c, f, g, d, y = this.cf(a, o, p),
            m = s.c(),
            v = T(),
            b = new hn(0, 0, 0, 0);
        for (g = u.da; g <= u.ha; ++g)
            for (d = u.ia; d <= u.ka; ++d) c = a.Ic(l, g, d, n, o), !i(c) && c.a && (c = c.a), i(c) ? p[l][c.ta.toString()] = c : (f = vn(h, c.ta, y, b, v), f || (c = bn(h, c.ta, b, v)) && y(l + 1, c));
        y = Object.keys(p).map(Number), y.sort(ae);
        var w, v = [],
            b = 0;
        for (g = y.length; b < g; ++b)
            for (w in c = y[b], d = p[c]) c = d[w], 2 == c.W() && v.push(c);
        return this.j = v, gc(t.usedTiles, a, l, u), yc(t, a, h, n, o, r, l, s.f()), pc(t, a), fc(t, a), !0
    }, Kc.prototype.qd = function(t, e, i, n) {
        var r = this.c.canvas,
            o = e.size,
            s = e.pixelRatio;
        if (r.width = o[0] * s, r.height = o[1] * s, this.i(e, Ur(this.a), this.c), t = this.c.getImageData(t[0], t[1], 1, 1).data, 0 < t[3]) return i.call(n, this.a, t)
    }, m(Zc, mc), Zc.prototype.i = function(t, e, i) {
        var n = t.extent,
            r = t.pixelRatio,
            o = e.Id ? t.skippedFeatureUids : {},
            s = t.viewState,
            a = s.projection,
            s = s.rotation,
            h = a.H(),
            l = this.a.ja(),
            u = xc(this, t, 0);
        bc(this, "precompose", i, t, u);
        var p = e.extent,
            c = void 0 !== p;
        if (c && vc(i, t, p), (p = this.j) && !p.g()) {
            var f, g = 0,
                d = 0;
            if (bt(this.a, "render")) {
                f = i.canvas.width;
                var y = i.canvas.height;
                if (s) {
                    var m = Math.round(Math.sqrt(f * f + y * y)),
                        g = (m - f) / 2,
                        d = (m - y) / 2;
                    f = y = m
                }
                this.o.canvas.width = f, this.o.canvas.height = y, f = this.o
            } else f = i;
            if (y = f.globalAlpha, f.globalAlpha = e.opacity, f != i && f.translate(g, d), e = t.size[0] * r, m = t.size[1] * r, Oi(f, -s, e / 2, m / 2), p.jb(f, r, u, s, o), l.D && a.a && !M(h, n)) {
                for (var a = n[0], l = Y(h), v = 0; a < h[0];) --v, u = l * v, u = xc(this, t, u), p.jb(f, r, u, s, o), a += l;
                for (v = 0,
                    a = n[2]; a > h[2];) ++v, u = l * v, u = xc(this, t, u), p.jb(f, r, u, s, o), a -= l;
                u = xc(this, t, 0)
            }
            Oi(f, s, e / 2, m / 2), f != i && (bc(this, "render", f, t, u), i.drawImage(f.canvas, -g, -d), f.translate(-g, -d)), f.globalAlpha = y
        }
        c && i.restore(), wc(this, i, t, u)
    }, Zc.prototype.ya = function(t, e, i, n) {
        if (this.j) {
            var r = this.a,
                o = {};
            return this.j.ya(t, e.viewState.resolution, e.viewState.rotation, {}, function(t) { var e = b(t).toString(); if (!(e in o)) return o[e] = !0, i.call(n, t, r) })
        }
    }, Zc.prototype.D = function() { uc(this) }, Zc.prototype.l = function(t) {
        function e(t) {
            var e, n = t.Tc();
            if (n ? e = n.call(t, l) : (n = i.i) && (e = n(t, l)), e) {
                if (e) {
                    if (n = !1, Array.isArray(e))
                        for (var r = 0, o = e.length; r < o; ++r) n = qc(c, t, e[r], Gc(l, u), this.D, this) || n;
                    else n = qc(c, t, e, Gc(l, u), this.D, this) || n;
                    t = n
                } else t = !1;
                this.c = this.c || t
            }
        }
        var i = this.a,
            n = i.ja();
        cc(t.attributions, n.l), fc(t, n);
        var r = t.viewHints[0],
            o = t.viewHints[1],
            s = i.P,
            a = i.U;
        if (!this.c && !s && r || !a && o) return !0;
        var h = t.extent,
            a = t.viewState,
            r = a.projection,
            l = a.resolution,
            u = t.pixelRatio,
            o = i.g,
            p = i.a,
            s = Xr(i);
        if (void 0 === s && (s = zc), h = S(h, p * l), p = a.projection.H(), n.D && a.projection.a && !M(p, t.extent) && (t = Math.max(Y(h) / 2, Y(p)), h[0] = p[0] - t, h[2] = p[2] + t), !this.c && this.v == l && this.C == o && this.T == s && M(this.A, h)) return !0;
        this.j = null, this.c = !1;
        var c = new Uc(.5 * l / u, h, l, n.X, i.a);
        if (n.Hd(h, l, r), s) {
            var f = [];
            n.Rb(h, function(t) { f.push(t) }, this), f.sort(s), f.forEach(e, this)
        } else n.Rb(h, e, this);
        return Bc(c), this.v = l, this.C = o, this.T = s, this.A = h, this.j = c, !0
    };
    var OE = { image: RE, hybrid: ["Polygon", "LineString"] },
        DE = { hybrid: ["Image", "Text"], vector: RE };
    m(Jc, Kc), Jc.prototype.i = function(t, e, i) {
        var n = xc(this, t, 0);
        bc(this, "precompose", i, t, n);
        var r = e.extent,
            o = void 0 !== r;
        if (o && vc(i, t, r), r = this.a.s, "vector" !== r && $c(this, i, t, e), "image" !== r) {
            var s = this.a,
                r = DE[s.s],
                a = t.pixelRatio,
                h = e.Id ? t.skippedFeatureUids : {},
                l = t.viewState,
                u = l.center,
                p = l.rotation,
                c = t.size,
                l = a / l.resolution,
                f = s.ja(),
                g = f.Tb(),
                d = xc(this, t, 0);
            bt(s, "render") ? (this.c.canvas.width = i.canvas.width, this.c.canvas.height = i.canvas.height, s = this.c) : s = i;
            var y = s.globalAlpha;
            s.globalAlpha = e.opacity, e = this.j;
            var m, v, b, w, x, E, S, N, f = f.tileGrid;
            for (v = 0, b = e.length; v < b; ++v) w = e[v], S = w.f, x = f.Na(w.ta, this.o), m = w.ta[0], E = "tile-pixels" == w.j.Ub(), m = f.aa(m), N = m / g, m = Math.round(a * c[0] / 2), w = Math.round(a * c[1] / 2), E ? (x = X(x), Bl(this.A), x = Hl(this.A, m, w, l * N, l * N, p, (x[0] - u[0]) / N, (u[1] - x[1]) / N)) : x = d, Oi(s, -p, m, w), S.He.jb(s, a, x, p, h, r), Oi(s, p, m, w);
            s != i && (bc(this, "render", s, t, d), i.drawImage(s.canvas, 0, 0)), s.globalAlpha = y
        }
        o && i.restore(), wc(this, i, t, n)
    }, Jc.prototype.ya = function(t, e, i, n) {
        var r = e.viewState.resolution;
        e = e.viewState.rotation;
        var o, s, a, h, l, u, p = this.a,
            c = {},
            f = this.j,
            g = p.ja(),
            d = g.tileGrid;
        for (a = 0, h = f.length; a < h; ++a) u = f[a], s = u.ta, l = g.tileGrid.Na(s, this.o), C(l, t) && ("tile-pixels" === u.j.Ub() ? (l = X(l), r = g.Tb(), s = d.aa(s[0]) / r, s = [(t[0] - l[0]) / s, (l[1] - t[1]) / s]) : s = t, u = u.f.He, o = o || u.ya(s, r, e, {}, function(t) { var e = b(t).toString(); if (!(e in c)) return c[e] = !0, i.call(n, t, p) }));
        return o
    }, Jc.prototype.v = function() { uc(this) }, Jc.prototype.l = function(t, e) {
        var i = Kc.prototype.l.call(this, t, e);
        if (i)
            for (var n = Object.keys(t.jg || {}), r = 0, o = this.j.length; r < o; ++r) {
                var s = this.j[r];
                Qc(this, s, t);
                var a = s,
                    s = t,
                    h = this.a,
                    l = OE[h.s];
                if (l) {
                    var u = s.pixelRatio,
                        p = a.f,
                        c = h.g;
                    if (!ge(p.$k, n) || p.Wh !== c) {
                        p.$k = n, p.Wh = c;
                        var c = a.g,
                            f = h.ja(),
                            g = f.tileGrid,
                            d = a.ta[0],
                            y = g.aa(d),
                            h = gn(g.gb(d)),
                            d = g.aa(d),
                            m = d / y,
                            v = h[0] * u * m,
                            b = h[1] * u * m;
                        c.canvas.width = v / m + .5, c.canvas.height = b / m + .5, c.scale(1 / m, 1 / m), c.translate(v / 2, b / 2), m = "tile-pixels" == a.j.Ub(), y = u / y, f = f.Tb(), d /= f, g = g.Na(a.ta, this.o), a = Bl(this.A), m ? (Wl(a, y * d, y * d), Xl(a, -h[0] * f / 2, -h[1] * f / 2)) : (h = G(g), Wl(a, y, -y), Xl(a, -h[0], -h[1])), p.He.jb(c, u, a, 0, s.skippedFeatureUids || {}, l)
                    }
                }
            }
        return i
    }, m(tf, Kl), tf.prototype.Jg = function(t) { return t instanceof Vr ? new Yc(t) : t instanceof qr ? new Kc(t) : t instanceof Qp ? new Jc(t) : t instanceof Wr ? new Zc(t) : null }, tf.prototype.Z = function() { return "canvas" }, tf.prototype.fg = function(t) {
        if (t) {
            var e = this.f,
                i = t.pixelRatio,
                n = Math.round(t.size[0] * i),
                i = Math.round(t.size[1] * i);
            this.b.width != n || this.b.height != i ? (this.b.width = n, this.b.height = i) : e.clearRect(0, 0, n, i);
            var r = t.viewState.rotation;
            $l(t), ef(this, "precompose", t);
            var o = t.layerStatesArray;
            de(o), Oi(e, r, n / 2, i / 2);
            var s, a, h, l, u = t.viewState.resolution;
            for (s = 0, a = o.length; s < a; ++s) l = o[s], h = l.layer, h = Jl(this, h), Gr(l, u) && "ready" == l.O && h.l(t, l) && h.i(t, l, e);
            Oi(e, -r, n / 2, i / 2), ef(this, "postcompose", t), this.a || (this.b.style.display = "", this.a = !0), Ql(this, t), t.postRenderFunctions.push(Zl)
        } else this.a && (this.b.style.display = "none", this.a = !1)
    }, m(nf, hc), nf.prototype.af = v, nf.prototype.Tj = v, m(rf, nf), rf.prototype.ya = function(t, e, i, n) { var r = this.a; return r.ja().ya(t, e.viewState.resolution, e.viewState.rotation, e.skippedFeatureUids, function(t) { return i.call(n, t, r) }) }, rf.prototype.af = function() { _i(this.target), this.f = null }, rf.prototype.Ah = function(t, e) {
        var i = t.viewState,
            n = i.center,
            r = i.resolution,
            o = i.rotation,
            s = this.f,
            a = this.a.ja(),
            h = t.viewHints,
            l = t.extent;
        return void 0 !== e.extent && (l = W(l, e.extent)), h[0] || h[1] || $(l) || (i = a.v(l, r, t.pixelRatio, i.projection)) && lc(this, i) && (s = i), s && (h = s.H(), l = s.aa(), i = Ul(), Hl(i, t.size[0] / 2, t.size[1] / 2, l / r, l / r, o, (h[0] - n[0]) / l, (n[1] - h[3]) / l), s != this.f && (n = s.a(this), n.style.maxWidth = "none", n.style.position = "absolute", _i(this.target), this.target.appendChild(n), this.f = s), ge(i, this.c) || (Ti(this.target, i), Gl(this.c, i)), cc(t.attributions, s.l), fc(t, a)), !0
    }, m(of, nf), of.prototype.af = function() { _i(this.target), this.i = 0 }, of.prototype.Ah = function(t, e) {
        if (!e.visible) return this.c && (this.target.style.display = "none", this.c = !1), !0;
        var i, n = t.pixelRatio,
            r = t.viewState,
            o = r.projection,
            s = this.a,
            a = s.ja(),
            h = a.yb(o),
            l = n * a.hf(o),
            u = h.Kc(r.resolution),
            p = h.aa(u),
            c = r.center;
        p == r.resolution ? (c = dc(c, p, t.size), i = q(c, p, r.rotation, t.size)) : i = t.extent, void 0 !== e.extent && (i = W(i, e.extent));
        var p = wn(h, i, p),
            f = {};
        f[u] = {};
        var g, d, y, m, v = this.cf(a, o, f),
            b = s.c(),
            w = T(),
            x = new hn(0, 0, 0, 0);
        for (y = p.da; y <= p.ha; ++y)
            for (m = p.ia; m <= p.ka; ++m) g = a.Ic(u, y, m, n, o), d = g.W(), d = 2 == d || 4 == d || 3 == d && !b, !d && g.a && (g = g.a), d = g.W(), 2 == d ? f[u][g.ta.toString()] = g : 4 == d || 3 == d && !b || (d = vn(h, g.ta, v, x, w), d || (g = bn(h, g.ta, x, w)) && v(u + 1, g));
        var E;
        if (this.i != a.g) {
            for (E in this.f) b = this.f[+E], Ri(b.target);
            this.f = {}, this.i = a.g
        }
        w = Object.keys(f).map(Number), w.sort(ae);
        var S, v = {};
        for (y = 0, m = w.length; y < m; ++y) {
            E = w[y], E in this.f ? b = this.f[E] : (b = h.ue(c, E), b = new sf(h, b), v[E] = !0, this.f[E] = b), E = f[E];
            for (S in E) {
                g = b, d = E[S];
                var N = l,
                    L = d.ta,
                    C = L[0],
                    M = L[1],
                    I = L[2],
                    L = L.toString();
                if (!(L in g.a)) {
                    var C = gn(g.c.gb(C), g.j),
                        k = d.ub(g),
                        A = k.style;
                    A.maxWidth = "none";
                    var R, _;
                    0 < N ? (R = document.createElement("DIV"), _ = R.style, _.overflow = "hidden", _.width = C[0] + "px", _.height = C[1] + "px", A.position = "absolute", A.left = -N + "px", A.top = -N + "px", A.width = C[0] + 2 * N + "px", A.height = C[1] + 2 * N + "px", R.appendChild(k)) : (A.width = C[0] + "px", A.height = C[1] + "px", R = k, _ = A), _.position = "absolute", _.left = (M - g.g[1]) * C[0] + "px", _.top = (g.g[2] - I) * C[1] + "px", g.b || (g.b = document.createDocumentFragment()), g.b.appendChild(R), g.a[L] = d
                }
            }
            b.b && (b.target.appendChild(b.b), b.b = null)
        }
        for (l = Object.keys(this.f).map(Number), l.sort(ae), y = Ul(), S = 0, w = l.length; S < w; ++S)
            if (E = l[S], b = this.f[E], E in f) {
                if (g = b.aa(), m = b.$a(), Hl(y, t.size[0] / 2, t.size[1] / 2, g / r.resolution, g / r.resolution, r.rotation, (m[0] - c[0]) / g, (c[1] - m[1]) / g), b.setTransform(y), E in v) {
                    for (--E; 0 <= E; --E)
                        if (E in this.f) { this.f[E].target.parentNode && this.f[E].target.parentNode.insertBefore(b.target, this.f[E].target.nextSibling); break }
                    0 > E && this.target.insertBefore(b.target, this.target.childNodes[0] || null)
                } else if (!t.viewHints[0] && !t.viewHints[1]) { d = xn(b.c, i, b.g[0], x), E = [], g = void 0; for (g in b.a) m = b.a[g], N = m.ta, ln(d, N[1], N[2]) || E.push(m); for (d = 0, N = E.length; d < N; ++d) m = E[d], g = m.ta.toString(), Ri(m.ub(b)), delete b.a[g] }
            } else Ri(b.target), delete this.f[E];
        return e.opacity != this.l && (this.l = this.target.style.opacity = e.opacity), e.visible && !this.c && (this.target.style.display = "", this.c = !0), gc(t.usedTiles, a, u, p), yc(t, a, h, n, o, i, u, s.f()), pc(t, a), fc(t, a), !0
    }, sf.prototype.$a = function() { return this.i }, sf.prototype.aa = function() { return this.l }, sf.prototype.setTransform = function(t) { ge(t, this.f) || (Ti(this.target, t), Gl(this.f, t)) }, m(af, nf), sb = af.prototype, sb.af = function() {
        var t = this.i.canvas;
        t.width = t.width, this.l = 0
    }, sb.Tj = function(t, e) {
        var i = t.viewState,
            n = i.center,
            r = i.rotation,
            o = i.resolution,
            i = t.pixelRatio,
            s = t.size[0],
            a = t.size[1],
            h = s * i,
            l = a * i,
            n = Hl(this.T, i * s / 2, i * a / 2, i / o, -i / o, -r, -n[0], -n[1]),
            o = this.i;
        o.canvas.width = h, o.canvas.height = l;
        var u = Bl(this.A);
        Wl(u, 1 / i, 1 / i), Xl(u, -(h - s) / 2 * i, -(l - a) / 2 * i), Ti(o.canvas, u), hf(this, "precompose", t, n), (s = this.c) && !s.g() && (o.globalAlpha = e.opacity, s.jb(o, i, n, r, e.Id ? t.skippedFeatureUids : {}), hf(this, "render", t, n)), hf(this, "postcompose", t, n)
    }, sb.ya = function(t, e, i, n) {
        if (this.c) {
            var r = this.a,
                o = {};
            return this.c.ya(t, e.viewState.resolution, e.viewState.rotation, {}, function(t) { var e = b(t).toString(); if (!(e in o)) return o[e] = !0, i.call(n, t, r) })
        }
    }, sb.Uj = function() { uc(this) }, sb.Ah = function(t) {
        function e(t) {
            var e, n = t.Tc();
            if (n ? e = n.call(t, h) : (n = i.i) && (e = n(t, h)), e) {
                if (e) {
                    if (n = !1, Array.isArray(e))
                        for (var r = 0, o = e.length; r < o; ++r) n = qc(u, t, e[r], Gc(h, l), this.Uj, this) || n;
                    else n = qc(u, t, e, Gc(h, l), this.Uj, this) || n;
                    t = n
                } else t = !1;
                this.f = this.f || t
            }
        }
        var i = this.a,
            n = i.ja();
        cc(t.attributions, n.l), fc(t, n);
        var r = t.viewHints[0],
            o = t.viewHints[1],
            s = i.P,
            a = i.U;
        if (!this.f && !s && r || !a && o) return !0;
        var o = t.extent,
            s = t.viewState,
            r = s.projection,
            h = s.resolution,
            l = t.pixelRatio;
        if (t = i.g, a = i.a, s = Xr(i), void 0 === s && (s = zc), o = S(o, a * h), !this.f && this.s == h && this.l == t && this.o == s && M(this.j, o)) return !0;
        this.c = null, this.f = !1;
        var u = new Uc(.5 * h / l, o, h, n.X, i.a);
        if (n.Hd(o, h, r), s) {
            var p = [];
            n.Rb(o, function(t) { p.push(t) }, this), p.sort(s), p.forEach(e, this)
        } else n.Rb(o, e, this);
        return Bc(u), this.s = h, this.l = t, this.o = s, this.j = o, this.c = u, !0
    }, m(lf, Kl), lf.prototype.pa = function() { Ri(this.b), Kl.prototype.pa.call(this) }, lf.prototype.Jg = function(t) {
        if (t instanceof Vr) t = new rf(t);
        else if (t instanceof qr) t = new of(t);
        else {
            if (!(t instanceof Wr)) return null;
            t = new af(t)
        }
        return t
    }, lf.prototype.Z = function() { return "dom" }, lf.prototype.fg = function(t) {
        if (t) {
            var e = this.i;
            if (bt(e, "precompose") || bt(e, "postcompose")) {
                var e = this.f.canvas,
                    i = t.pixelRatio;
                e.width = t.size[0] * i, e.height = t.size[1] * i
            }
            uf(this, "precompose", t), e = t.layerStatesArray, de(e);
            var n, r, o, s, i = t.viewState.resolution;
            for (n = 0, r = e.length; n < r; ++n) s = e[n], o = s.layer, o = Jl(this, o), this.b.insertBefore(o.target, this.b.childNodes[n] || null), Gr(s, i) && "ready" == s.O ? o.Ah(t, s) && o.Tj(t, s) : o.af();
            var a, e = t.layerStates;
            for (a in this.g) a in e || (o = this.g[a], Ri(o.target));
            this.a || (this.b.style.display = "", this.a = !0), $l(t), Ql(this, t), t.postRenderFunctions.push(Zl), uf(this, "postcompose", t)
        } else this.a && (this.b.style.display = "none", this.a = !1)
    }, m(cf, pf), cf.prototype.Z = function() { return 35632 }, m(ff, pf), ff.prototype.Z = function() { return 35633 }, m(gf, cf);
    var FE = new gf;
    m(df, ff);
    var UE = new df,
        BE = 35044;
    m(vf, gt), sb = vf.prototype, sb.pa = function() {
        ft(this.l);
        var t = this.b;
        if (!t.isContextLost()) {
            for (var e in this.a) t.deleteBuffer(this.a[e].buffer);
            for (e in this.f) t.deleteProgram(this.f[e]);
            for (e in this.c) t.deleteShader(this.c[e]);
            t.deleteFramebuffer(this.i), t.deleteRenderbuffer(this.o), t.deleteTexture(this.s)
        }
    }, sb.Xq = function() { return this.b }, sb.Yq = function() { et(this.a), et(this.c), et(this.f), this.o = this.s = this.i = this.j = null }, sb.Zq = function() {}, sb.Yf = function(t) { return t != this.j && (this.b.useProgram(t), this.j = t, !0) }, m(Mf, tc), Mf.prototype.fd = function(t, e) {
        this.g.push(this.a.length), this.s.push(e);
        var i = t.oa();
        kf(this, i, i.length, t.Aa())
    }, Mf.prototype.gd = function(t, e) {
        this.g.push(this.a.length), this.s.push(e);
        var i = t.oa();
        kf(this, i, i.length, t.Aa())
    }, Mf.prototype.jb = function(t, e, i, n, r, o, s, a, h, l, u) {
        o = t.b, bf(t, 34962, this.A), bf(t, 34963, this.j);
        var p, c = Sf(t, FE, UE);
        this.D ? p = this.D : this.D = p = new yf(o, c), t.Yf(c), o.enableVertexAttribArray(p.f), o.vertexAttribPointer(p.f, 2, 5126, !1, 32, 0), o.enableVertexAttribArray(p.b), o.vertexAttribPointer(p.b, 2, 5126, !1, 32, 8), o.enableVertexAttribArray(p.c), o.vertexAttribPointer(p.c, 2, 5126, !1, 32, 16), o.enableVertexAttribArray(p.a), o.vertexAttribPointer(p.a, 1, 5126, !1, 32, 24), o.enableVertexAttribArray(p.g), o.vertexAttribPointer(p.g, 1, 5126, !1, 32, 28), c = Bl(this.sb), Wl(c, 2 / (i * r[0]), 2 / (i * r[1])), Vl(c, -n), Xl(c, -(e[0] - this.o[0]), -(e[1] - this.o[1])), e = Bl(this.Ua), Wl(e, 2 / r[0], 2 / r[1]), r = Bl(this.Ta), 0 !== n && Vl(r, -n), o.uniformMatrix4fv(p.l, !1, Mi(this.ra, c)), o.uniformMatrix4fv(p.o, !1, Mi(this.ra, e)), o.uniformMatrix4fv(p.j, !1, Mi(this.ra, r)), o.uniform1f(p.i, s);
        var f;
        if (void 0 === h) Rf(this, o, t, a, this.xa, this.T);
        else {
            if (l) t: {
                for (n = t.g ? 5125 : 5123, t = t.g ? 4 : 2, r = this.g.length - 1, s = this.l.length - 1; 0 <= s; --s)
                    for (o.bindTexture(3553, this.l[s]), l = 0 < s ? this.i[s - 1] : 0, e = this.i[s]; 0 <= r && this.g[r] >= l;) {
                        if (f = this.g[r], i = this.s[r], c = b(i).toString(), void 0 === a[c] && i.Y() && (void 0 === u || K(u, i.Y().H())) && (o.clear(o.COLOR_BUFFER_BIT | o.DEPTH_BUFFER_BIT), o.drawElements(4, e - f, n, f * t), e = h(i))) { a = e; break t }
                        e = f, r--
                    }
                a = void 0
            }
            else o.clear(o.COLOR_BUFFER_BIT | o.DEPTH_BUFFER_BIT), Rf(this, o, t, a, this.l, this.i), a = (a = h(null)) ? a : void 0;
            f = a
        }
        return o.disableVertexAttribArray(p.f), o.disableVertexAttribArray(p.b), o.disableVertexAttribArray(p.c), o.disableVertexAttribArray(p.a), o.disableVertexAttribArray(p.g), f
    }, Mf.prototype.xc = function(t) {
        var e = t.Dc(),
            i = t.Yc(1),
            n = t.qe(),
            r = t.Qf(1),
            o = t.A,
            s = t.$a(),
            a = t.T,
            h = t.o,
            l = t.hc();
        t = t.i;
        var u;
        0 === this.c.length ? this.c.push(i) : (u = this.c[this.c.length - 1], b(u) != b(i) && (this.T.push(this.a.length), this.c.push(i))), 0 === this.f.length ? this.f.push(r) : (u = this.f[this.f.length - 1], b(u) != b(r) && (this.i.push(this.a.length), this.f.push(r))), this.v = e[0], this.C = e[1], this.O = l[1], this.sa = n[1], this.za = n[0], this.P = o, this.U = s[0], this.X = s[1], this.fa = h, this.Xa = a, this.vb = t, this.qa = l[0]
    }, m(_f, Ec), _f.prototype.b = function(t, e) { var i = this.a[e]; return void 0 === i && (i = new jE[e](this.i, this.c), this.a[e] = i), i }, _f.prototype.g = function() { return nt(this.a) }, _f.prototype.jb = function(t, e, i, n, r, o, s, a) { var h, l, u; for (h = 0, l = RE.length; h < l; ++h) u = this.a[RE[h]], void 0 !== u && u.jb(t, e, i, n, r, o, s, a, void 0, !1) }, _f.prototype.ya = function(t, e, i, n, r, o, s, a, h, l) {
        var u = e.b;
        u.bindFramebuffer(u.FRAMEBUFFER, xf(e));
        var p;
        return void 0 !== this.f && (p = S(R(t), n * this.f)), Df(this, e, t, n, r, s, a, h, function(t) { var e = new Uint8Array(4); if (u.readPixels(0, 0, 1, 1, u.RGBA, u.UNSIGNED_BYTE, e), 0 < e[3] && (t = l(t))) return t }, !0, p)
    };
    var jE = { Image: Mf },
        zE = [1, 1];
    m(Uf, tc), sb = Uf.prototype, sb.Be = function(t) { this.xc(t.a) }, sb.ed = function(t) {
        switch (t.Z()) {
            case "Point":
                this.gd(t, null);
                break;
            case "MultiPoint":
                this.fd(t, null);
                break;
            case "GeometryCollection":
                this.Ng(t, null)
        }
    }, sb.Mg = function(t, e) {
        var i = (0, e.g)(t);
        i && K(this.g, i.H()) && (this.Be(e), this.ed(i))
    }, sb.Ng = function(t) { t = t.f; var e, i; for (e = 0, i = t.length; e < i; ++e) this.ed(t[e]) }, sb.gd = function(t, e) {
        var i = this.b,
            n = new _f(1, this.g).b(0, "Image");
        n.xc(this.a), n.gd(t, e), Tf(n, i), n.jb(this.b, this.f, this.i, this.l, this.j, this.c, 1, {}, void 0, !1), If(n, i)()
    }, sb.fd = function(t, e) {
        var i = this.b,
            n = new _f(1, this.g).b(0, "Image");
        n.xc(this.a), n.fd(t, e), Tf(n, i), n.jb(this.b, this.f, this.i, this.l, this.j, this.c, 1, {}, void 0, !1), If(n, i)()
    }, sb.xc = function(t) { this.a = t }, m(Bf, cf);
    var GE = new Bf;
    m(jf, ff);
    var qE = new jf;
    m(Gf, hc), Gf.prototype.Vj = function(t, e, i) {
        Vf(this, "precompose", i, t), bf(i, 34962, this.U);
        var n, r = i.b,
            o = Sf(i, GE, qE);
        this.A ? n = this.A : this.A = n = new zf(r, o), i.Yf(o) && (r.enableVertexAttribArray(n.b), r.vertexAttribPointer(n.b, 2, 5126, !1, 16, 0), r.enableVertexAttribArray(n.a), r.vertexAttribPointer(n.a, 2, 5126, !1, 16, 8), r.uniform1i(n.c, 0)), r.uniformMatrix4fv(n.i, !1, Mi(this.C, this.s)), r.uniformMatrix4fv(n.f, !1, Mi(this.C, this.T)), r.uniform1f(n.g, e.opacity), r.bindTexture(3553, this.Mb), r.drawArrays(5, 0, 4), Vf(this, "postcompose", i, t)
    }, Gf.prototype.Bh = function() { this.i = this.Mb = null, this.l = void 0 }, m(Wf, Gf), Wf.prototype.ya = function(t, e, i, n) { var r = this.a; return r.ja().ya(t, e.viewState.resolution, e.viewState.rotation, e.skippedFeatureUids, function(t) { return i.call(n, t, r) }) }, Wf.prototype.Ch = function(t, e) {
        var i = this.f.f,
            n = t.pixelRatio,
            r = t.viewState,
            o = r.center,
            s = r.resolution,
            a = r.rotation,
            h = this.c,
            l = this.Mb,
            u = this.a.ja(),
            p = t.viewHints,
            c = t.extent;
        return void 0 !== e.extent && (c = W(c, e.extent)), p[0] || p[1] || $(c) || (r = u.v(c, s, n, r.projection)) && lc(this, r) && (h = r, l = Xf(this, r), this.Mb && t.postRenderFunctions.push(function(t, e) { t.isContextLost() || t.deleteTexture(e) }.bind(null, i, this.Mb))), h && (i = this.f.c.l, Hf(this, i.width, i.height, n, o, s, a, h.H()), this.o = null, n = this.s, Bl(n), Wl(n, 1, -1), Xl(n, 0, -1), this.c = h, this.Mb = l, cc(t.attributions, h.l), fc(t, u)), !0
    }, Wf.prototype.Kf = function(t, e) { return void 0 !== this.ya(t, e, Q, this) }, Wf.prototype.qd = function(t, e, i, n) {
        if (this.c && this.c.a())
            if (this.a.ja() instanceof Xc) { var r = ql(e.pixelToCoordinateTransform, t.slice()); if (this.ya(r, e, Q, this)) return i.call(n, this.a, null) } else {
                if (r = [this.c.a().width, this.c.a().height], !this.o) {
                    var o = e.size;
                    e = Ul(), Xl(e, -1, -1), Wl(e, 2 / o[0], 2 / o[1]), Xl(e, 0, o[1]), Wl(e, 1, -1);
                    var o = Yl(this.T.slice()),
                        s = Ul();
                    Xl(s, 0, r[1]), Wl(s, 1, -1), Wl(s, r[0] / 2, r[1] / 2), Xl(s, 1, 1), jl(s, o), jl(s, e), this.o = s
                }
                if (t = ql(this.o, t.slice()), !(0 > t[0] || t[0] > r[0] || 0 > t[1] || t[1] > r[1]) && (this.j || (this.j = Ii(1, 1)), this.j.clearRect(0, 0, 1, 1), this.j.drawImage(this.c.a(), t[0], t[1], 1, 1, 0, 0, 1, 1), r = this.j.getImageData(0, 0, 1, 1).data, 0 < r[3])) return i.call(n, this.a, r)
            }
    }, m(Yf, cf);
    var VE = new Yf;
    m(Kf, ff);
    var WE = new Kf;
    m(Zf, Gf), sb = Zf.prototype, sb.pa = function() { wf(this.f.c, this.D), Gf.prototype.pa.call(this) }, sb.cf = function(t, e, i) { var n = this.f; return function(r, o) { return po(t, e, r, o, function(t) { var e = n.a.b.hasOwnProperty(t.pb()); return e && (i[r] || (i[r] = {}), i[r][t.ta.toString()] = t), e }) } }, sb.Bh = function() { Gf.prototype.Bh.call(this), this.c = null }, sb.Ch = function(t, e, i) {
        var n, r = this.f,
            o = i.b,
            s = t.viewState,
            a = s.projection,
            h = this.a,
            l = h.ja(),
            u = l.yb(a),
            p = u.Kc(s.resolution),
            c = u.aa(p),
            f = l.$g(p, t.pixelRatio, a),
            g = f[0] / gn(u.gb(p), this.P)[0],
            d = c / g,
            y = t.pixelRatio * l.hf(a),
            m = s.center;
        if (c == s.resolution ? (m = dc(m, c, t.size), n = q(m, c, s.rotation, t.size)) : n = t.extent, c = wn(u, n, c), this.j && un(this.j, c) && this.o == l.g) d = this.v;
        else {
            var v = [c.ha - c.da + 1, c.ka - c.ia + 1],
                b = Mt(Math.max(v[0] * f[0], v[1] * f[1])),
                v = d * b,
                w = u.$a(p),
                x = w[0] + c.da * f[0] * d,
                d = w[1] + c.ia * f[1] * d,
                d = [x, d, x + v, d + v];
            qf(this, t, b), o.viewport(0, 0, b, b), o.clearColor(0, 0, 0, 0), o.clear(16384), o.disable(3042), b = Sf(i, this.O, this.X), i.Yf(b), this.c || (this.c = new $f(o, b)), bf(i, 34962, this.D), o.enableVertexAttribArray(this.c.b), o.vertexAttribPointer(this.c.b, 2, 5126, !1, 16, 0), o.enableVertexAttribArray(this.c.a), o.vertexAttribPointer(this.c.a, 2, 5126, !1, 16, 8), o.uniform1i(this.c.g, 0), i = {}, i[p] = {};
            var E, S, N, L = this.cf(l, a, i),
                C = h.c(),
                b = !0,
                x = T(),
                M = new hn(0, 0, 0, 0);
            for (S = c.da; S <= c.ha; ++S)
                for (N = c.ia; N <= c.ka; ++N)
                    if (w = l.Ic(p, S, N, g, a), void 0 === e.extent || (E = u.Na(w.ta, x), K(E, e.extent))) {
                        if (E = w.W(), E = 2 == E || 4 == E || 3 == E && !C, !E && w.a && (w = w.a), E = w.W(), 2 == E) { if (r.a.b.hasOwnProperty(w.pb())) { i[p][w.ta.toString()] = w; continue } } else if (4 == E || 3 == E && !C) continue;
                        b = !1, E = vn(u, w.ta, L, M, x), E || (w = bn(u, w.ta, M, x)) && L(p + 1, w)
                    }
            e = Object.keys(i).map(Number), e.sort(ae);
            for (var I, L = new Float32Array(4), C = 0, M = e.length; C < M; ++C)
                for (I in S = i[e[C]]) w = S[I], E = u.Na(w.ta, x), L[0] = 2 * (E[2] - E[0]) / v, L[1] = 2 * (E[3] - E[1]) / v, L[2] = 2 * (E[0] - d[0]) / v - 1, L[3] = 2 * (E[1] - d[1]) / v - 1, o.uniform4fv(this.c.f, L), tg(r, w, f, y * g), o.drawArrays(5, 0, 4);
            b ? (this.j = c, this.v = d, this.o = l.g) : (this.v = this.j = null, this.o = -1, t.animate = !0)
        }
        gc(t.usedTiles, l, p, c);
        var k = r.j;
        return yc(t, l, u, g, a, n, p, h.f(), function(t) { 2 != t.W() || r.a.b.hasOwnProperty(t.pb()) || t.pb() in k.a || k.c([t, En(u, t.ta), u.aa(t.ta[0]), f, y * g]) }, this), pc(t, l), fc(t, l), o = this.s, Bl(o), Xl(o, (m[0] - d[0]) / (d[2] - d[0]), (m[1] - d[1]) / (d[3] - d[1])), 0 !== s.rotation && Vl(o, s.rotation), Wl(o, t.size[0] * s.resolution / (d[2] - d[0]), t.size[1] * s.resolution / (d[3] - d[1])), Xl(o, -.5, -.5), !0
    }, sb.qd = function(t, e, i, n) { if (this.i) { t = ql(this.s, [t[0] / e.size[0], (e.size[1] - t[1]) / e.size[1]].slice()), t = [t[0] * this.l, t[1] * this.l], e = this.f.c.b, e.bindFramebuffer(e.FRAMEBUFFER, this.i); var r = new Uint8Array(4); if (e.readPixels(t[0], t[1], 1, 1, e.RGBA, e.UNSIGNED_BYTE, r), 0 < r[3]) return i.call(n, this.a, r) } }, m(Jf, Gf), sb = Jf.prototype, sb.Vj = function(t, e, i) {
        this.j = e;
        var n = t.viewState,
            r = this.c;
        r && !r.g() && r.jb(i, n.center, n.resolution, n.rotation, t.size, t.pixelRatio, e.opacity, e.Id ? t.skippedFeatureUids : {})
    }, sb.pa = function() {
        var t = this.c;
        t && (Pf(t, this.f.c)(), this.c = null), Gf.prototype.pa.call(this)
    }, sb.ya = function(t, e, i, n) {
        if (this.c && this.j) {
            var r = e.viewState,
                o = this.a,
                s = {};
            return this.c.ya(t, this.f.c, r.center, r.resolution, r.rotation, e.size, e.pixelRatio, this.j.opacity, {}, function(t) { var e = b(t).toString(); if (!(e in s)) return s[e] = !0, i.call(n, t, o) })
        }
    }, sb.Kf = function(t, e) { if (this.c && this.j) { var i = e.viewState; return Ff(this.c, t, this.f.c, i.resolution, i.rotation, e.pixelRatio, this.j.opacity, e.skippedFeatureUids) } return !1 }, sb.qd = function(t, e, i, n) { if (t = ql(e.pixelToCoordinateTransform, t.slice()), this.Kf(t, e)) return i.call(n, this.a, null) }, sb.Wj = function() { uc(this) }, sb.Ch = function(t, e, i) {
        function n(t) {
            var e, i = t.Tc();
            if (i ? e = i.call(t, l) : (i = r.i) && (e = i(t, l)), e) {
                if (e) {
                    if (i = !1, Array.isArray(e))
                        for (var n = 0, o = e.length; n < o; ++n) i = qc(c, t, e[n], Gc(l, u), this.Wj, this) || i;
                    else i = qc(c, t, e, Gc(l, u), this.Wj, this) || i;
                    t = i
                } else t = !1;
                this.o = this.o || t
            }
        }
        var r = this.a;
        e = r.ja(), cc(t.attributions, e.l), fc(t, e);
        var o = t.viewHints[0],
            s = t.viewHints[1],
            a = r.P,
            h = r.U;
        if (!this.o && !a && o || !h && s) return !0;
        var s = t.extent,
            a = t.viewState,
            o = a.projection,
            l = a.resolution,
            u = t.pixelRatio,
            a = r.g,
            p = r.a,
            h = Xr(r);
        if (void 0 === h && (h = zc), s = S(s, p * l), !this.o && this.O == l && this.P == a && this.D == h && M(this.v, s)) return !0;
        this.c && t.postRenderFunctions.push(Pf(this.c, i)), this.o = !1;
        var c = new _f(.5 * l / u, s, r.a);
        if (e.Hd(s, l, o), h) {
            var f = [];
            e.Rb(s, function(t) { f.push(t) }, this), f.sort(h), f.forEach(n, this)
        } else e.Rb(s, n, this);
        return Of(c, i), this.O = l, this.P = a, this.D = h, this.v = s, this.c = c, !0
    }, m(Qf, Kl), sb = Qf.prototype, sb.Jg = function(t) { return t instanceof Vr ? new Wf(this, t) : t instanceof qr ? new Zf(this, t) : t instanceof Wr ? new Jf(this, t) : null }, sb.pa = function() {
        var t = this.f;
        t.isContextLost() || this.a.forEach(function(e) { e && t.deleteTexture(e.Mb) }), this.c.Pa(), Kl.prototype.pa.call(this)
    }, sb.mm = function(t, e) {
        for (var i, n = this.f; 1024 < this.a.f - this.l;) {
            if (i = this.a.a.xd) n.deleteTexture(i.Mb);
            else { if (+this.a.a.Rc == e.index) break;--this.l }
            this.a.pop()
        }
    }, sb.Z = function() { return "webgl" }, sb.Pp = function(t) { t.preventDefault(), this.a.clear(), this.l = 0, t = this.g; for (var e in t) t[e].Bh() }, sb.Qp = function() { ig(this), this.i.render() }, sb.fg = function(t) {
        var e = this.c,
            i = this.f;
        if (i.isContextLost()) return !1;
        if (!t) return this.o && (this.b.style.display = "none", this.o = !1), !1;
        this.A = t.focus, this.a.set((-t.index).toString(), null), ++this.l, eg(this, "precompose", t);
        var n = [],
            r = t.layerStatesArray;
        de(r);
        var o, s, a, h, l = t.viewState.resolution;
        for (o = 0, s = r.length; o < s; ++o) h = r[o], Gr(h, l) && "ready" == h.O && (a = Jl(this, h.layer), a.Ch(t, h, e) && n.push(h));
        for (r = t.size[0] * t.pixelRatio, l = t.size[1] * t.pixelRatio, this.b.width == r && this.b.height == l || (this.b.width = r, this.b.height = l), i.bindFramebuffer(36160, null), i.clearColor(0, 0, 0, 0), i.clear(16384), i.enable(3042), i.viewport(0, 0, this.b.width, this.b.height), o = 0, s = n.length; o < s; ++o) h = n[o], a = Jl(this, h.layer), a.Vj(t, h, e);
        this.o || (this.b.style.display = "", this.o = !0), $l(t), 1024 < this.a.f - this.l && t.postRenderFunctions.push(this.mm.bind(this)), 0 !== this.j.b.length && (t.postRenderFunctions.push(this.D), t.animate = !0), eg(this, "postcompose", t), Ql(this, t), t.postRenderFunctions.push(Zl)
    }, sb.ya = function(t, e, i, n, r, o) {
        var s;
        if (this.f.isContextLost()) return !1;
        var a, h = e.viewState,
            l = e.layerStatesArray;
        for (a = l.length - 1; 0 <= a; --a) { s = l[a]; var u = s.layer; if (Gr(s, h.resolution) && r.call(o, u) && (s = Jl(this, u).ya(t, e, i, n))) return s }
    }, sb.Sj = function(t, e, i, n) {
        var r = !1;
        if (this.f.isContextLost()) return !1;
        var o, s = e.viewState,
            a = e.layerStatesArray;
        for (o = a.length - 1; 0 <= o; --o) {
            var h = a[o],
                l = h.layer;
            if (Gr(h, s.resolution) && i.call(n, l) && (r = Jl(this, l).Kf(t, e))) return !0
        }
        return r
    }, sb.Rj = function(t, e, i, n, r) {
        if (this.f.isContextLost()) return !1;
        var o, s, a = e.viewState,
            h = e.layerStatesArray;
        for (s = h.length - 1; 0 <= s; --s) { o = h[s]; var l = o.layer; if (Gr(o, a.resolution) && r.call(n, l) && (o = Jl(this, l).qd(t, e, i, n))) return o }
    };
    var XE = ["canvas", "webgl", "dom"];
    m(ng, St), sb = ng.prototype, sb.zg = function(t) { this.j.push(t) }, sb.oi = function(t) { this.l.push(t) }, sb.$d = function(t) { this.Fc().Md().push(t) }, sb.ae = function(t) { this.A.push(t) }, sb.pi = function(t) {
        var e = t.Ja();
        void 0 !== e && (this.Eh[e.toString()] = t), t.setMap(this)
    }, sb.mb = function(t) { this.render(), Array.prototype.push.apply(this.fa, arguments) }, sb.pa = function() { this.Hb.Pa(), this.C.Pa(), pt(this.a, "wheel", this.Fd, this), pt(this.a, "mousewheel", this.Fd, this), void 0 !== this.c && (gb.removeEventListener("resize", this.c, !1), this.c = void 0), this.i && (gb.cancelAnimationFrame(this.i), this.i = void 0), this.wh(null), St.prototype.pa.call(this) }, sb.ne = function(t, e, i, n, r) { if (this.f) return t = this.Za(t), this.C.ya(t, this.f, e, void 0 !== i ? i : null, void 0 !== n ? n : Q, void 0 !== r ? r : null) }, sb.zj = function(t, e, i, n, r) { if (this.f) return this.C.Rj(t, this.f, e, void 0 !== i ? i : null, void 0 !== n ? n : Q, void 0 !== r ? r : null) }, sb.jj = function(t, e, i) { return !!this.f && (t = this.Za(t), this.C.Sj(t, this.f, void 0 !== e ? e : Q, void 0 !== i ? i : null)) }, sb.Ki = function(t) { return this.Za(this.pe(t)) }, sb.pe = function(t) { var e = this.a.getBoundingClientRect(); return t = t.changedTouches ? t.changedTouches[0] : t, [t.clientX - e.left, t.clientY - e.top] }, sb.Ff = function() { return this.get("target") }, sb.Hc = function() { var t = this.Ff(); return void 0 !== t ? "string" == typeof t ? document.getElementById(t) : t : null }, sb.Za = function(t) { var e = this.f; return e ? ql(e.pixelToCoordinateTransform, t.slice()) : null }, sb.Hi = function() { return this.j }, sb.Vi = function() { return this.A }, sb.Ui = function(t) { return t = this.Eh[t.toString()], void 0 !== t ? t : null }, sb.Pi = function() { return this.l }, sb.Fc = function() { return this.get("layergroup") }, sb.ze = function() { return this.Fc().Md() }, sb.Qa = function(t) { var e = this.f; return e ? ql(e.coordinateToPixelTransform, t.slice(0, 2)) : null }, sb.bb = function() { return this.get("size") }, sb.$ = function() { return this.get("view") }, sb.Yi = function() { return this.a }, sb.en = function(t, e, i, n) { var r = this.f; return r && e in r.wantedTiles && r.wantedTiles[e][t.pb()] ? (t = i[0] - r.focus[0], i = i[1] - r.focus[1], 65536 * Math.log(n) + Math.sqrt(t * t + i * i) / n) : 1 / 0 }, sb.Fd = function(t, e) {
        var i = new _l(e || t.type, this, t);
        this.gj(i)
    }, sb.gj = function(t) {
        if (this.f) {
            this.Ta = t.coordinate, t.frameState = this.f;
            var e, i = this.l.a;
            if (!1 !== this.b(t))
                for (e = i.length - 1; 0 <= e; e--) { var n = i[e]; if (n.f() && !n.handleEvent(t)) break }
        }
    }, sb.Yn = function() {
        var t = this.f,
            e = this.bc;
        if (0 !== e.b.length) {
            var i = 16,
                n = i;
            if (t) {
                var r = t.viewHints;
                r[0] && (i = this.Bg ? 8 : 0, n = 2), r[1] && (i = this.Eg ? 8 : 0, n = 2)
            }
            e.l < i && (ou(e), au(e, i, n))
        }
        for (e = this.Se, i = 0, n = e.length; i < n; ++i) e[i](this, t);
        e.length = 0
    }, sb.co = function() { this.render() }, sb.fo = function() {
        var t;
        if (this.Ff() && (t = this.Hc()), this.v) {
            for (var e = 0, i = this.v.length; e < i; ++e) ct(this.v[e]);
            this.v = null
        }
        t ? (t.appendChild(this.a), t = this.sb ? this.sb : t, this.v = [lt(t, "keydown", this.Fd, this), lt(t, "keypress", this.Fd, this)], this.c || (this.c = this.wd.bind(this), gb.addEventListener("resize", this.c, !1))) : (Ri(this.a), void 0 !== this.c && (gb.removeEventListener("resize", this.c, !1), this.c = void 0)), this.wd()
    }, sb.ho = function() { this.render() }, sb.ko = function() { this.render() }, sb.jo = function() {
        this.ra && (ct(this.ra), this.ra = null);
        var t = this.$();
        t && (this.ra = lt(t, "propertychange", this.ko, this)), this.render()
    }, sb.Kn = function() {
        this.X && (this.X.forEach(ct), this.X = null);
        var t = this.Fc();
        t && (this.X = [lt(t, "propertychange", this.render, this), lt(t, "change", this.render, this)]), this.render()
    }, sb.Fk = function() { this.i && gb.cancelAnimationFrame(this.i), this.Ua() }, sb.render = function() { void 0 === this.i && (this.i = gb.requestAnimationFrame(this.Ua)) }, sb.Ck = function(t) { return this.j.remove(t) }, sb.Dk = function(t) { return this.l.remove(t) }, sb.dg = function(t) { return this.Fc().Md().remove(t) }, sb.eg = function(t) { return this.A.remove(t) }, sb.Tr = function(t) {
        var e, i, n, r = this.bb(),
            o = this.$(),
            s = T(),
            a = null;
        if (void 0 !== r && 0 < r[0] && 0 < r[1] && o && Au(o)) {
            var a = Mu(o, this.f ? this.f.viewHints : void 0),
                h = this.Fc().Xg(),
                l = {};
            for (e = 0, i = h.length; e < i; ++e) l[b(h[e].layer)] = h[e];
            n = o.W(), a = { animate: !1, attributions: {}, coordinateToPixelTransform: this.qg, extent: s, focus: this.Ta ? this.Ta : n.center, index: this.wg++, layerStates: l, layerStatesArray: h, logos: db({}, this.Kg), pixelRatio: this.Rg, pixelToCoordinateTransform: this.om, postRenderFunctions: [], size: r, skippedFeatureUids: this.jg, tileQueue: this.bc, time: t, usedTiles: {}, viewState: n, viewHints: a, wantedTiles: {} }
        }
        if (a) {
            for (t = this.fa, e = r = 0, i = t.length; e < i; ++e) o = t[e], o(this, a) && (t[r++] = o);
            t.length = r, a.extent = q(n.center, n.resolution, n.rotation, a.size, s)
        }
        this.f = a, this.C.fg(a), a && (a.animate && this.render(), Array.prototype.push.apply(this.Se, a.postRenderFunctions), 0 !== this.fa.length || a.viewHints[0] || a.viewHints[1] || P(a.extent, this.Te) || (this.b(new ll("moveend", this, a)), N(a.extent, this.Te))), this.b(new ll("postrender", this, a)), Ga(this.Yn, this)
    }, sb.Zh = function(t) { this.set("layergroup", t) }, sb.hg = function(t) { this.set("size", t) }, sb.wh = function(t) { this.set("target", t) }, sb.Yk = function(t) { this.set("view", t) }, sb.Zk = function(t) { t = b(t).toString(), this.jg[t] = !0, this.render() }, sb.wd = function() {
        var t = this.Hc();
        if (t) {
            var e = gb.getComputedStyle(t);
            this.hg([t.offsetWidth - parseFloat(e.borderLeftWidth) - parseFloat(e.paddingLeft) - parseFloat(e.paddingRight) - parseFloat(e.borderRightWidth), t.offsetHeight - parseFloat(e.borderTopWidth) - parseFloat(e.paddingTop) - parseFloat(e.paddingBottom) - parseFloat(e.borderBottomWidth)])
        } else this.hg(void 0)
    }, sb.el = function(t) { t = b(t).toString(), delete this.jg[t], this.render() }, Jp(), m(og, _u);
    var HE = [1, 2, 5];
    og.prototype.Ub = function() { return this.get(YE) }, og.prototype.O = function() { ag(this) }, og.prototype.D = function(t) { this.set(YE, t) };
    var YE = "units",
        KE = "degrees",
        $E = "imperial",
        ZE = "nautical",
        JE = "metric",
        QE = "us";
    m(lg, St), sb = lg.prototype, sb.V = function() { return this.get("element") }, sb.Ja = function() { return this.o }, sb.Gf = function() { return this.get("map") }, sb.Ti = function() { return this.get("offset") }, sb.Aj = function() { return this.get("position") }, sb.Wi = function() { return this.get("positioning") }, sb.tn = function() {
        _i(this.f);
        var t = this.V();
        t && this.f.appendChild(t)
    }, sb.Pn = function() {
        this.c && (Ri(this.f), ct(this.c), this.c = null);
        var t = this.Gf();
        t && (this.c = lt(t, "postrender", this.render, this), cg(this), t = this.s ? t.D : t.O, this.j ? t.insertBefore(this.f, t.childNodes[0] || null) : t.appendChild(this.f))
    }, sb.render = function() { cg(this) }, sb.Tn = function() { cg(this) }, sb.Wn = function() {
        if (cg(this), void 0 !== this.get("position") && this.autoPan) {
            var t = this.Gf();
            if (void 0 !== t && t.Hc()) {
                var e = ug(t.Hc(), t.bb()),
                    i = this.V(),
                    n = i.offsetWidth,
                    r = i.currentStyle || gb.getComputedStyle(i),
                    n = n + (parseInt(r.marginLeft, 10) + parseInt(r.marginRight, 10)),
                    r = i.offsetHeight,
                    o = i.currentStyle || gb.getComputedStyle(i),
                    r = r + (parseInt(o.marginTop, 10) + parseInt(o.marginBottom, 10)),
                    s = ug(i, [n, r]),
                    i = this.l;
                M(e, s) || (n = s[0] - e[0], r = e[2] - s[2], o = s[1] - e[1], s = e[3] - s[3], e = [0, 0], 0 > n ? e[0] = n - i : 0 > r && (e[0] = Math.abs(r) + i), 0 > o ? e[1] = o - i : 0 > s && (e[1] = Math.abs(s) + i), 0 === e[0] && 0 === e[1]) || (i = t.$().cb(), n = t.Qa(i), e = [n[0] + e[0], n[1] + e[1]], this.i && (this.i.source = i, t.mb(Gu(this.i))), t.$().qb(t.Za(e)))
            }
        }
    }, sb.Xn = function() { cg(this) }, sb.Bj = function(t) { this.set("element", t) }, sb.setMap = function(t) { this.set("map", t) }, sb.Rk = function(t) { this.set("offset", t) }, sb.Hf = function(t) { this.set("position", t) }, sb.Uk = function(t) { this.set("positioning", t) }, y(fg, gt), sb = fg.prototype, sb.pa = function() { this.setMap(null) }, sb.um = function(t) {
        yg(this), t = t.coordinate, this.c.Hf(t);
        for (var e, i = this.b.bb(), n = this.b.$().Cc(i), r = [], o = 0, s = this.b.ze().a.length; o < s; o++) e = this.b.ze().a[o], e.ro && e.Ib() && e.nj && r.push(e.nj);
        0 < r.length && this.j && hg(window.GeoAdmin.serviceUrl + "/rest/services/api/MapServer/identify?geometryType=esriGeometryPoint&geometry=" + t[0] + "," + t[1] + "&geometryFormat=geojson&imageDisplay=" + i[0] + "," + i[1] + ",96&mapExtent=" + n.join(",") + "&tolerance=10&layers=all:" + r.join(",") + "&lang=" + (window.GeoAdmin && window.GeoAdmin.lang ? window.GeoAdmin.lang : "de"), this.Fn.bind(this), this.En.bind(this), "callback")
    }, sb.Fn = function(t) { this.f && (this.i.clear(), this.b.dg(this.f)), this.i = new kr, this.f = new Wr({ style: function() { return [new Xi({ fill: new Ui({ color: "#ffff00" }), stroke: new Vi({ color: "#ff8000", width: 3 }), image: new Fi({ radius: 9, fill: new Ui({ color: [255, 255, 0, .5] }), stroke: new Vi({ color: "#ff8000", width: 3 }) }) })] }, source: this.i }), this.b.$d(this.f), 0 < t.results.length && this.i.Bc(dg(t)); for (var e = 0, i = t.results.length; e < i; e++) hg(window.GeoAdmin.serviceUrl + "/rest/services/api/MapServer/" + t.results[e].layerBodId + "/" + t.results[e].featureId + "/htmlPopup?lang=" + (window.GeoAdmin && window.GeoAdmin.lang ? window.GeoAdmin.lang : "de"), this.Dn.bind(this), this.Cn.bind(this), "callback") }, sb.Dn = function(t) { this.a.innerHTML = this.a.innerHTML + t, this.g.style.display = "block" }, sb.En = function() {
        alert("Unfortunately an error occured in tooltip identify. Sorry for inconvenience.")
    }, sb.Cn = function() { alert("Unfortunately an error occured in tooltip html popup. Sorry for inconvenience.") }, sb.pn = function() { yg(this) }, sb.lo = function(t) { t.stopPropagation() }, sb.setMap = function(t) { null !== this.l && (xt(this.l), this.l = null), null !== this.b && this.b.eg(this.c), null !== t && (this.l = t.I("singleclick", this.um, this), t.ae(this.c)), this.b = t }, y(mg, ng), sb = mg.prototype, sb.vm = function(t) { hg(this.qa + "/rest/services/api/SearchServer?searchText=" + t + "&type=locations&lang=" + ub.Ya() + "&returnGeometry=true", this.wn.bind(this), this.vn.bind(this)) }, sb.wn = function(t) {
        if (0 == t.results.length && alert("Geocoding failed. No result has been found."), 1 == t.results.length && vg(this, t.results[0].attrs), 1 < t.results.length) {
            t = t.results;
            var e, i = this.s;
            if (!lx.test("div")) throw Error("Invalid tag name <div>.");
            if ("DIV" in px) throw Error("Tag name <div> is not allowed for SafeHtml.");
            e = { id: "geocoderList" };
            var o, a = null,
                h = "";
            if (e)
                for (o in e) {
                    if (!lx.test(o)) throw Error('Invalid attribute name "' + o + '".');
                    var u = e[o];
                    if (null != u) {
                        var p;
                        if (p = o, u instanceof Ko) u = $o(u);
                        else if ("style" == p.toLowerCase()) {
                            if (!l(u)) throw Error('The "style" attribute requires goog.html.SafeStyle or map of style properties, ' + typeof u + " given: " + u);
                            if (!(u instanceof Zo)) {
                                var c = "",
                                    f = void 0;
                                for (f in u) {
                                    if (!/^[-_a-zA-Z0-9]+$/.test(f)) throw Error("Name allows only [-_a-zA-Z0-9], got: " + f);
                                    var g = u[f];
                                    if (null != g) {
                                        if (g instanceof Ko) g = $o(g);
                                        else if (ox.test(g)) {
                                            for (var d = !0, y = !0, m = 0; m < g.length; m++) { var v = g.charAt(m); "'" == v && y ? d = !d : '"' == v && d && (y = !y) }
                                            d && y || (g = "zClosurez")
                                        } else g = "zClosurez";
                                        c += f + ":" + g + ";"
                                    }
                                }
                                u = c ? Jo(c) : rx
                            }
                            u instanceof Zo && u.constructor === Zo && u.a === nx ? u = u.b : (n(u), u = "type_error:SafeStyle")
                        } else {
                            if (/^on/i.test(p)) throw Error('Attribute "' + p + '" requires goog.string.Const value, "' + u + '" given.');
                            if (p.toLowerCase() in ux)
                                if (u instanceof es) u instanceof es && u.constructor === es && u.b === hx ? u = "" : (n(u), u = "type_error:TrustedResourceUrl");
                                else if (u instanceof Qo) u instanceof Qo && u.constructor === Qo && u.a === ax ? u = u.b : (n(u), u = "type_error:SafeUrl");
                            else {
                                if (!s(u)) throw Error('Attribute "' + p + '" on tag "div" requires goog.html.SafeUrl, goog.string.Const, or string, value "' + u + '" given.');
                                u instanceof Qo || (u = u.md ? u.Jc() : String(u), sx.test(u) || (u = "about:invalid#zClosurez"), u = ts(u)), u = u.Jc()
                            }
                        }
                        u.md && (u = u.Jc()), p = p + '="' + ci(String(u)) + '"', h += " " + p
                    }
                }
            o = "<div" + h, h = void 0, null != h ? r(h) || (h = [h]) : h = [], !0 === ex.div ? o += ">" : (a = rs(h), o += ">" + ns(a) + "</div>", a = a.oe()), (e = e && e.dir) && (a = /^(ltr|rtl|auto)$/i.test(e) ? 0 : null), e = os(o, a), i.hh = e, i.de && (i.de.innerHTML = ns(e)), this.s.gc(!0), this.P = new hl;
            var b, i = s("geocoderList") ? document.getElementById("geocoderList") : "geocoderList";
            for (b in t) this.P.xg(new rl(t[b].attrs.label.replace("<b>", "").replace("</b>", ""), t[b].attrs), !0);
            this.P.na("action", this.bo, !0, this), this.P.render(i)
        }
    }, sb.vn = function() { alert("Geocoding failed. Sorry for inconvenience.") }, sb.Pr = function(t, e) { hg(this.qa + "/rest/services/api/MapServer/" + t + "/" + e + "?geometryFormat=geojson", this.$n.bind(this), this.Zn.bind(this)) }, sb.$n = function(t) { t = t.feature.bbox, this.$().Ad(t, this.bb()), 7 < this.$().ah() && this.$().ig(7) }, sb.Zn = function() { alert("Recentering failed. No feature found. Sorry for inconvenience.") }, sb.mo = function(t, e) { hg(this.qa + "/rest/services/api/MapServer/" + t + "/" + e + "?geometryFormat=geojson", this.Bn.bind(this), this.zn.bind(this)) }, sb.Bn = function(t) {
        t = [t.feature];
        var e = new Gn;
        t = new kr({ projection: "EPSG:21781", features: e.Ia({ type: "FeatureCollection", features: t }) }), t = new Wr({ opacity: .75, source: t, style: function() { return [new Xi({ fill: new Ui({ color: "#ffff00" }), stroke: new Vi({ color: "#ff8000", width: 3 }), image: new Fi({ radius: 10, fill: new Ui({ color: "#ffff00" }), stroke: new Vi({ color: "#ff8000", width: 3 }) }) })] } }), this.$d(t)
    }, sb.zn = function() { alert("Highlighting failed. No feature found. Sorry for inconvenience.") }, sb.bo = function(t) { vg(this, t.target.sh), this.s.gc(!1) }, sb.lm = function() { null !== this.o && (this.o.j = !0) }, sb.jm = function() {
        if (null !== this.o) {
            var t = this.o;
            t.j = !1, yg(t)
        }
    }, y(bg, Cu), m(wg, _u), wg.prototype.C = function(t) { t.preventDefault(), xg() && (t = this.a) && (Eg() ? document.exitFullscreen ? document.exitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen() : (t = this.l ? "string" == typeof this.l ? document.getElementById(this.l) : this.l : t.Hc(), this.v ? t.mozRequestFullScreenWithKeys ? t.mozRequestFullScreenWithKeys() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT) : Sg(t) : Sg(t))) }, wg.prototype.A = function() {
        var t = this.element.firstElementChild,
            e = this.a;
        Eg() ? (t.className = this.f + "-true", Ai(this.o, this.j)) : (t.className = this.f + "-false", Ai(this.j, this.o)), e && e.wd()
    }, wg.prototype.setMap = function(t) { _u.prototype.setMap.call(this, t), t && this.s.push(lt(gb.document, tS(), this.A, this)) };
    var tS = function() {
        var t;
        return function() {
            if (!t) {
                var e = document.body;
                e.webkitRequestFullscreen ? t = "webkitfullscreenchange" : e.mozRequestFullScreen ? t = "mozfullscreenchange" : e.msRequestFullscreen ? t = "MSFullscreenChange" : e.requestFullscreen && (t = "fullscreenchange")
            }
            return t
        }
    }();
    m(Ng, _u), sb = Ng.prototype, sb.ep = function() { this.l = null }, sb.Ji = function() { return this.get("coordinateFormat") }, sb.Gj = function() { return this.get("projection") }, sb.Rn = function(t) { this.j = this.a.pe(t), Cg(this, this.j) }, sb.cp = function() { Cg(this, null), this.j = null }, sb.setMap = function(t) { _u.prototype.setMap.call(this, t), t && (t = t.a, this.s.push(lt(t, "mousemove", this.Rn, this), lt(t, "mouseout", this.cp, this))) }, sb.Mk = function(t) { this.set("coordinateFormat", t) }, sb.Hj = function(t) { this.set("projection", t) }, m(Mg, _u), sb = Mg.prototype, sb.setMap = function(t) {
        var e = this.a;
        t !== e && (e && (e = e.$()) && pt(e, Nt(SE), this.yf, this), _u.prototype.setMap.call(this, t), t && (this.s.push(lt(t, "propertychange", this.Qn, this)), 0 === this.f.ze().Sc() && this.f.Zh(t.Fc()), t = t.$())) && (lt(t, Nt(SE), this.yf, this), Au(t) && (this.f.wd(), kg(this)))
    }, sb.Qn = function(t) { "view" === t.key && ((t = t.oldValue) && pt(t, Nt(SE), this.yf, this), t = this.a.$(), lt(t, Nt(SE), this.yf, this)) }, sb.yf = function() { this.f.$().Ld(this.a.$().Ra()) }, sb.hp = function(t) { t.preventDefault(), Ag(this) }, sb.gp = function() { return this.j }, sb.jp = function(t) { this.j !== t && (this.j = t, this.element.classList.toggle("ol-uncollapsible"), !t && this.l && Ag(this)) }, sb.ip = function(t) { this.j && this.l !== t && Ag(this) }, sb.fp = function() { return this.l }, sb.Tm = function() { return this.f }, m(Rg, _u), Rg.prototype.pa = function() { this.A.Pa(), _u.prototype.pa.call(this) };
    var eS = 0;
    sb = Rg.prototype, sb.setMap = function(t) { _u.prototype.setMap.call(this, t), t && t.render() }, sb.qn = function(t) {
        var e = this.a,
            i = e.$(),
            n = i.aa();
        e.mb(Vu({ resolution: n, duration: this.X, easing: Uu })), t = Og(this, Ct(1 === this.l ? (t.offsetX - this.U[0] / 2) / this.C : (t.offsetY - this.U[1] / 2) / this.j, 0, 1)), i.Xb(i.constrainResolution(t))
    }, sb.sn = function(t) {
        if (!this.v && t.b.target === this.element.firstElementChild && (Ru(this.a.$(), 1), this.D = t.clientX, this.O = t.clientY, this.v = !0, 0 === this.o.length)) {
            t = this.ej;
            var e = this.fj;
            this.o.push(lt(document, "mousemove", t, this), lt(document, "touchmove", t, this), lt(document, iE, t, this), lt(document, "mouseup", e, this), lt(document, "touchend", e, this), lt(document, rE, e, this))
        }
    }, sb.ej = function(t) {
        if (this.v) {
            var e = this.element.firstElementChild;
            this.f = Og(this, Ct(1 === this.l ? (t.clientX - this.D + parseInt(e.style.left, 10)) / this.C : (t.clientY - this.O + parseInt(e.style.top, 10)) / this.j, 0, 1)), this.a.$().Xb(this.f), Pg(this, this.f), this.D = t.clientX, this.O = t.clientY
        }
    }, sb.fj = function() {
        if (this.v) {
            var t = this.a,
                e = t.$();
            Ru(e, -1), t.mb(Vu({ resolution: this.f, duration: this.X, easing: Uu })), t = e.constrainResolution(this.f), e.Xb(t), this.v = !1, this.O = this.D = void 0, this.o.forEach(ct), this.o.length = 0
        }
    }, m(Dg, _u), Dg.prototype.l = function(t) {
        t.preventDefault();
        var e = this.a;
        t = e.$();
        var i = this.f ? this.f : t.j.H(),
            e = e.bb();
        t.Ad(i, e)
    }, m(Fg, St), sb = Fg.prototype, sb.pa = function() { this.uh(!1), St.prototype.pa.call(this) }, sb.er = function(t) {
        if (null !== t.alpha) {
            var e = Tt(t.alpha);
            this.set("alpha", e), "boolean" == typeof t.absolute && t.absolute ? this.set("heading", e) : "number" == typeof t.webkitCompassHeading && -1 != t.webkitCompassAccuracy && this.set("heading", Tt(t.webkitCompassHeading))
        }
        null !== t.beta && this.set("beta", Tt(t.beta)), null !== t.gamma && this.set("gamma", Tt(t.gamma)), this.u()
    }, sb.ym = function() { return this.get("alpha") }, sb.Bm = function() { return this.get("beta") }, sb.Em = function() { return this.get("gamma") }, sb.Lo = function() { return this.get("heading") }, sb.vj = function() { return this.get("tracking") }, sb.Mo = function() {
        if (mw) {
            var t = this.vj();
            t && !this.a ? this.a = lt(gb, "deviceorientation", this.er, this) : t || null === this.a || (ct(this.a), this.a = null)
        }
    }, sb.uh = function(t) { this.set("tracking", t) }, m(Ug, Dn);
    var iS = { Point: function(t) { return void 0 !== t.m && void 0 !== t.z ? new se([t.x, t.y, t.z, t.m], "XYZM") : void 0 !== t.z ? new se([t.x, t.y, t.z], "XYZ") : void 0 !== t.m ? new se([t.x, t.y, t.m], "XYM") : new se([t.x, t.y]) }, LineString: function(t) { return new Fe(t.paths[0], jg(t)) }, Polygon: function(t) { return new Ze(t.rings, jg(t)) }, MultiPoint: function(t) { return new we(t.points, jg(t)) }, MultiLineString: function(t) { return new Be(t.paths, jg(t)) }, MultiPolygon: function(t) { return new ni(t.rings, jg(t)) } },
        nS = {
            Point: function(t) { var e, i = t.ba(); return t = t.ma, "XYZ" === t ? e = { x: i[0], y: i[1], z: i[2] } : "XYM" === t ? e = { x: i[0], y: i[1], m: i[2] } : "XYZM" === t ? e = { x: i[0], y: i[1], z: i[2], m: i[3] } : "XY" === t ? e = { x: i[0], y: i[1] } : x(!1, 34), e },
            LineString: function(t) { var e = zg(t); return { hasZ: e.hasZ, hasM: e.hasM, paths: [t.ba()] } },
            Polygon: function(t) { var e = zg(t); return { hasZ: e.hasZ, hasM: e.hasM, rings: t.ba(!1) } },
            MultiPoint: function(t) { var e = zg(t); return { hasZ: e.hasZ, hasM: e.hasM, points: t.ba() } },
            MultiLineString: function(t) { var e = zg(t); return { hasZ: e.hasZ, hasM: e.hasM, paths: t.ba() } },
            MultiPolygon: function(t) {
                var e = zg(t);
                t = t.ba(!1);
                for (var i = [], n = 0; n < t.length; n++)
                    for (var r = t[n].length - 1; 0 <= r; r--) i.push(t[n][r]);
                return { hasZ: e.hasZ, hasM: e.hasM, rings: i }
            }
        };
    sb = Ug.prototype, sb.Pd = function(t, e) {
        var i = Bg(t.geometry, e),
            n = new Tn;
        return this.b && n.sd(this.b), n.ob(i), e && e.lh && t.attributes[e.lh] && n.ic(t.attributes[e.lh]), t.attributes && n.G(t.attributes), n
    }, sb.Lh = function(t, e) {
        var i = e ? e : {};
        if (t.features) {
            var n, r, o = [],
                s = t.features;
            for (i.lh = t.objectIdFieldName, n = 0, r = s.length; n < r; ++n) o.push(this.Pd(s[n], i));
            return o
        }
        return [this.Pd(t, i)]
    }, sb.sk = function(t, e) { return Bg(t, e) }, sb.zk = function(t) { return t.spatialReference && t.spatialReference.wkid ? qt("EPSG:" + t.spatialReference.wkid) : null }, sb.og = function(t, e) { return Gg(t, Pn(this, e)) }, sb.Vd = function(t, e) {
        e = Pn(this, e);
        var i = {},
            n = t.Y();
        return n && (i.geometry = Gg(n, e)), n = t.N(), delete n[t.a], i.attributes = nt(n) ? {} : n, e && e.featureProjection && (i.spatialReference = { wkid: qt(e.featureProjection).Ya().split(":").pop() }), i
    }, sb.ng = function(t, e) { e = Pn(this, e); var i, n, r = []; for (i = 0, n = t.length; i < n; ++i) r.push(this.Vd(t[i], e)); return { features: r } }, m(qg, Rn), sb = qg.prototype, sb.Z = function() { return "xml" }, sb.vc = function(t, e) { if (Qn(t)) return Vg(this, t, e); if (tr(t)) return this.qk(t, e); if ("string" == typeof t) { var i = er(t); return Vg(this, i, e) } return null }, sb.Ia = function(t, e) { if (Qn(t)) return Wg(this, t, e); if (tr(t)) return this.Zc(t, e); if ("string" == typeof t) { var i = er(t); return Wg(this, i, e) } return [] }, sb.Qd = function(t, e) { if (Qn(t)) return this.A(t, e); if (tr(t)) { var i = this.$f(t, [_n(this, t, e ? e : {})]); return i ? i : null } return "string" == typeof t ? (i = er(t), this.A(i, e)) : null }, sb.ib = function(t) { return Qn(t) ? this.Rh(t) : tr(t) ? this.cg(t) : "string" == typeof t ? (t = er(t), this.Rh(t)) : null }, sb.Rh = function() { return this.defaultDataProjection }, sb.cg = function() { return this.defaultDataProjection }, sb.Oe = function(t, e) { var i = this.v(t, e); return this.f.serializeToString(i) }, sb.Ac = function(t, e) { var i = this.a(t, e); return this.f.serializeToString(i) }, sb.Wd = function(t, e) { var i = this.s(t, e); return this.f.serializeToString(i) }, m(Xg, qg);
    var rS = /^[\s\xa0]*$/;
    sb = Xg.prototype, sb.Ee = function(t, e) {
        var i = t.localName,
            n = null;
        if ("FeatureCollection" == i) n = "http://www.opengis.net/wfs" === t.namespaceURI ? fr([], this.b, t, e, this) : fr(null, this.b, t, e, this);
        else if ("featureMembers" == i || "featureMember" == i) {
            var r, o, s = e[0],
                a = s.featureType,
                h = s.featureNS;
            if (!a && t.childNodes) {
                for (a = [], h = {}, r = 0, o = t.childNodes.length; r < o; ++r) {
                    var l = t.childNodes[r];
                    if (1 === l.nodeType) {
                        var u = l.nodeName.split(":").pop();
                        if (-1 === a.indexOf(u)) {
                            var p, c = "",
                                f = 0,
                                l = l.namespaceURI;
                            for (p in h) { if (h[p] === l) { c = p; break }++f }
                            c || (c = "p" + f, h[c] = l), a.push(c + ":" + u)
                        }
                    }
                }
                "featureMember" != i && (s.featureType = a, s.featureNS = h)
            }
            "string" == typeof h && (r = h, h = {}, h.p0 = r);
            var g, s = {},
                a = Array.isArray(a) ? a : [a];
            for (g in h) {
                for (u = {}, r = 0, o = a.length; r < o; ++r)(-1 === a[r].indexOf(":") ? "p0" : a[r].split(":")[0]) === g && (u[a[r].split(":").pop()] = "featureMembers" == i ? nr(this.Kh, this) : rr(this.Kh, this));
                s[h[g]] = u
            }
            n = "featureMember" == i ? fr(void 0, s, t, e) : fr([], s, t, e)
        }
        return null === n && (n = []), n
    }, sb.$f = function(t, e) {
        var i = e[0];
        i.srsName = t.firstElementChild.getAttribute("srsName");
        var n = fr(null, this.fi, t, e, this);
        if (n) return On(n, !1, i)
    }, sb.Kh = function(t, e) {
        var i, n;
        (n = t.getAttribute("fid")) || (n = t.getAttributeNS("http://www.opengis.net/gml", "id") || "");
        var r, o = {};
        for (i = t.firstElementChild; i; i = i.nextElementSibling) {
            var s = i.localName;
            if (0 === i.childNodes.length || 1 === i.childNodes.length && (3 === i.firstChild.nodeType || 4 === i.firstChild.nodeType)) {
                var a = Zn(i, !1);
                rS.test(a) && (a = void 0), o[s] = a
            } else "boundedBy" !== s && (r = s), o[s] = this.$f(i, e)
        }
        return i = new Tn(o), r && i.sd(r), n && i.ic(n), i
    }, sb.yk = function(t, e) { var i = this.Zf(t, e); if (i) { var n = new se(null); return n.ca("XYZ", i), n } }, sb.wk = function(t, e) { var i = fr([], this.Dl, t, e, this); if (i) return new we(i) }, sb.vk = function(t, e) { var i = fr([], this.Cl, t, e, this); if (i) { var n = new Be(null); return ze(n, i), n } }, sb.xk = function(t, e) { var i = fr([], this.El, t, e, this); if (i) { var n = new ni(null); return ai(n, i), n } }, sb.mk = function(t, e) { cr(this.Hl, t, e, this) }, sb.oj = function(t, e) { cr(this.Al, t, e, this) }, sb.nk = function(t, e) { cr(this.Il, t, e, this) }, sb.ag = function(t, e) { var i = this.Zf(t, e); if (i) { var n = new Fe(null); return n.ca("XYZ", i), n } }, sb.Ar = function(t, e) { var i = fr(null, this.Qe, t, e, this); if (i) return i }, sb.uk = function(t, e) { var i = this.Zf(t, e); if (i) { var n = new Ve(null); return We(n, "XYZ", i), n } }, sb.bg = function(t, e) {
        var i = fr([null], this.rg, t, e, this);
        if (i && i[0]) {
            var n, r, o = new Ze(null),
                s = i[0],
                a = [s.length];
            for (n = 1, r = i.length; n < r; ++n) pe(s, i[n]), a.push(s.length);
            return o.ca("XYZ", s, a), o
        }
    }, sb.Zf = function(t, e) { return fr(null, this.Qe, t, e, this) }, sb.Dl = { "http://www.opengis.net/gml": { pointMember: nr(Xg.prototype.mk), pointMembers: nr(Xg.prototype.mk) } }, sb.Cl = { "http://www.opengis.net/gml": { lineStringMember: nr(Xg.prototype.oj), lineStringMembers: nr(Xg.prototype.oj) } }, sb.El = { "http://www.opengis.net/gml": { polygonMember: nr(Xg.prototype.nk), polygonMembers: nr(Xg.prototype.nk) } }, sb.Hl = { "http://www.opengis.net/gml": { Point: nr(Xg.prototype.Zf) } }, sb.Al = { "http://www.opengis.net/gml": { LineString: nr(Xg.prototype.ag) } }, sb.Il = { "http://www.opengis.net/gml": { Polygon: nr(Xg.prototype.bg) } }, sb.Re = { "http://www.opengis.net/gml": { LinearRing: rr(Xg.prototype.Ar) } }, sb.Zc = function(t, e) { var i = { featureType: this.featureType, featureNS: this.featureNS }; return e && db(i, _n(this, t, e)), this.Ee(t, [i]) || [] }, sb.cg = function(t) { return qt(this.srsName ? this.srsName : t.firstElementChild.getAttribute("srsName")) }, m(od, Xg), sb = od.prototype, sb.Er = function(t, e) { var i = fr([], this.Bl, t, e, this); if (i) { var n = new Be(null); return ze(n, i), n } }, sb.Fr = function(t, e) { var i = fr([], this.Fl, t, e, this); if (i) { var n = new ni(null); return ai(n, i), n } }, sb.zi = function(t, e) { cr(this.xl, t, e, this) }, sb.bl = function(t, e) { cr(this.Ml, t, e, this) }, sb.Ir = function(t, e) { return fr([null], this.Gl, t, e, this) }, sb.Kr = function(t, e) { return fr([null], this.Ll, t, e, this) }, sb.Jr = function(t, e) { return fr([null], this.rg, t, e, this) }, sb.Dr = function(t, e) { return fr([null], this.Qe, t, e, this) }, sb.qo = function(t, e) {
        var i = fr(void 0, this.Re, t, e, this);
        i && e[e.length - 1].push(i)
    }, sb.nm = function(t, e) {
        var i = fr(void 0, this.Re, t, e, this);
        i && (e[e.length - 1][0] = i)
    }, sb.Ak = function(t, e) {
        var i = fr([null], this.Nl, t, e, this);
        if (i && i[0]) {
            var n, r, o = new Ze(null),
                s = i[0],
                a = [s.length];
            for (n = 1, r = i.length; n < r; ++n) pe(s, i[n]), a.push(s.length);
            return o.ca("XYZ", s, a), o
        }
    }, sb.pk = function(t, e) { var i = fr([null], this.yl, t, e, this); if (i) { var n = new Fe(null); return n.ca("XYZ", i), n } }, sb.zr = function(t, e) { var i = fr([null], this.zl, t, e, this); return A(i[1][0], i[1][1], i[2][0], i[2][1]) }, sb.Br = function(t, e) {
        for (var i, n = Zn(t, !1), r = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, o = []; i = r.exec(n);) o.push(parseFloat(i[1])), n = n.substr(i[0].length);
        if ("" === n) {
            if (n = e[0].srsName, r = "enu", n && (r = qt(n).b), "neu" === r)
                for (n = 0, r = o.length; n < r; n += 3) i = o[n], o[n] = o[n + 1], o[n + 1] = i;
            return n = o.length, 2 == n && o.push(0), 0 === n ? void 0 : o
        }
    }, sb.Oh = function(t, e) {
        var i = Zn(t, !1).replace(/^\s*|\s*$/g, ""),
            n = e[0].srsName,
            r = t.parentNode.getAttribute("srsDimension"),
            o = "enu";
        n && (o = qt(n).b), i = i.split(/\s+/), n = 2, t.getAttribute("srsDimension") ? n = Qg(t.getAttribute("srsDimension")) : t.getAttribute("dimension") ? n = Qg(t.getAttribute("dimension")) : r && (n = Qg(r));
        for (var s, a, h = [], l = 0, u = i.length; l < u; l += n) r = parseFloat(i[l]), s = parseFloat(i[l + 1]), a = 3 === n ? parseFloat(i[l + 2]) : 0, "en" === o.substr(0, 2) ? h.push(r, s, a) : h.push(s, r, a);
        return h
    }, sb.Qe = { "http://www.opengis.net/gml": { pos: rr(od.prototype.Br), posList: rr(od.prototype.Oh) } }, sb.rg = { "http://www.opengis.net/gml": { interior: od.prototype.qo, exterior: od.prototype.nm } }, sb.fi = { "http://www.opengis.net/gml": { Point: rr(Xg.prototype.yk), MultiPoint: rr(Xg.prototype.wk), LineString: rr(Xg.prototype.ag), MultiLineString: rr(Xg.prototype.vk), LinearRing: rr(Xg.prototype.uk), Polygon: rr(Xg.prototype.bg), MultiPolygon: rr(Xg.prototype.xk), Surface: rr(od.prototype.Ak), MultiSurface: rr(od.prototype.Fr), Curve: rr(od.prototype.pk), MultiCurve: rr(od.prototype.Er), Envelope: rr(od.prototype.zr) } }, sb.Bl = { "http://www.opengis.net/gml": { curveMember: nr(od.prototype.zi), curveMembers: nr(od.prototype.zi) } }, sb.Fl = { "http://www.opengis.net/gml": { surfaceMember: nr(od.prototype.bl), surfaceMembers: nr(od.prototype.bl) } }, sb.xl = { "http://www.opengis.net/gml": { LineString: nr(Xg.prototype.ag), Curve: nr(od.prototype.pk) } }, sb.Ml = { "http://www.opengis.net/gml": { Polygon: nr(Xg.prototype.bg), Surface: nr(od.prototype.Ak) } }, sb.Nl = { "http://www.opengis.net/gml": { patches: rr(od.prototype.Ir) } }, sb.yl = { "http://www.opengis.net/gml": { segments: rr(od.prototype.Kr) } }, sb.zl = { "http://www.opengis.net/gml": { lowerCorner: nr(od.prototype.Oh), upperCorner: nr(od.prototype.Oh) } }, sb.Gl = { "http://www.opengis.net/gml": { PolygonPatch: rr(od.prototype.Jr) } }, sb.Ll = { "http://www.opengis.net/gml": { LineStringSegment: rr(od.prototype.Dr) } }, sb.tl = function(t, e, i) {
        var n = i[i.length - 1].srsName;
        n && t.setAttribute("srsName", n), n = $n(t.namespaceURI, "pos"), t.appendChild(n), i = i[i.length - 1].srsName, t = "enu", i && (t = qt(i).b), e = e.ba(), rd(n, "en" === t.substr(0, 2) ? e[0] + " " + e[1] : e[1] + " " + e[0])
    };
    var oS = { "http://www.opengis.net/gml": { lowerCorner: ar(rd), upperCorner: ar(rd) } };
    sb = od.prototype, sb.us = function(t, e, i) {
        var n = i[i.length - 1].srsName;
        n && t.setAttribute("srsName", n), dr({ node: t }, oS, Dw, [e[0] + " " + e[1], e[2] + " " + e[3]], i, ["lowerCorner", "upperCorner"], this)
    }, sb.ql = function(t, e, i) {
        var n = i[i.length - 1].srsName;
        n && t.setAttribute("srsName", n), n = $n(t.namespaceURI, "posList"), t.appendChild(n), sd(n, e, i)
    }, sb.Kl = function(t, e) {
        var i = e[e.length - 1],
            n = i.node,
            r = i.exteriorWritten;
        return void 0 === r && (i.exteriorWritten = !0), $n(n.namespaceURI, void 0 !== r ? "interior" : "exterior")
    }, sb.pg = function(t, e, i) { var n = i[i.length - 1].srsName; "PolygonPatch" !== t.nodeName && n && t.setAttribute("srsName", n), "Polygon" === t.nodeName || "PolygonPatch" === t.nodeName ? (e = e.jf(), dr({ node: t, srsName: n }, lS, this.Kl, e, i, void 0, this)) : "Surface" === t.nodeName && (n = $n(t.namespaceURI, "patches"), t.appendChild(n), t = $n(n.namespaceURI, "PolygonPatch"), n.appendChild(t), this.pg(t, e, i)) }, sb.lg = function(t, e, i) { var n = i[i.length - 1].srsName; "LineStringSegment" !== t.nodeName && n && t.setAttribute("srsName", n), "LineString" === t.nodeName || "LineStringSegment" === t.nodeName ? (n = $n(t.namespaceURI, "posList"), t.appendChild(n), sd(n, e, i)) : "Curve" === t.nodeName && (n = $n(t.namespaceURI, "segments"), t.appendChild(n), t = $n(n.namespaceURI, "LineStringSegment"), n.appendChild(t), this.lg(t, e, i)) }, sb.sl = function(t, e, i) {
        var n = i[i.length - 1],
            r = n.srsName,
            n = n.surface;
        r && t.setAttribute("srsName", r), e = e.lf(), dr({ node: t, srsName: r, surface: n }, sS, this.c, e, i, void 0, this)
    }, sb.vs = function(t, e, i) {
        var n = i[i.length - 1].srsName;
        n && t.setAttribute("srsName", n), e = e.If(), dr({ node: t, srsName: n }, aS, lr("pointMember"), e, i, void 0, this)
    }, sb.rl = function(t, e, i) {
        var n = i[i.length - 1],
            r = n.srsName,
            n = n.curve;
        r && t.setAttribute("srsName", r), e = e.re(), dr({ node: t, srsName: r, curve: n }, hS, this.c, e, i, void 0, this)
    }, sb.ul = function(t, e, i) {
        var n = $n(t.namespaceURI, "LinearRing");
        t.appendChild(n), this.ql(n, e, i)
    }, sb.vl = function(t, e, i) {
        var n = this.g(e, i);
        n && (t.appendChild(n), this.pg(n, e, i))
    }, sb.ws = function(t, e, i) {
        var n = $n(t.namespaceURI, "Point");
        t.appendChild(n), this.tl(n, e, i)
    }, sb.pl = function(t, e, i) {
        var n = this.g(e, i);
        n && (t.appendChild(n), this.lg(n, e, i))
    }, sb.Xd = function(t, e, i) {
        var n = i[i.length - 1],
            r = db({}, n);
        r.node = t;
        var o;
        o = Array.isArray(e) ? n.dataProjection ? $t(e, n.featureProjection, n.dataProjection) : e : On(e, !0, n), dr(r, uS, this.g, [o], i, void 0, this)
    }, sb.ll = function(t, e, i) {
        var n = e.Ja();
        n && t.setAttribute("fid", n);
        var n = i[i.length - 1],
            r = n.featureNS,
            o = e.a;
        n.rd || (n.rd = {}, n.rd[r] = {});
        var s = e.N();
        e = [];
        var a, h = [];
        for (a in s) {
            var l = s[a];
            null !== l && (e.push(a), h.push(l), a == o || l instanceof Zt ? a in n.rd[r] || (n.rd[r][a] = ar(this.Xd, this)) : a in n.rd[r] || (n.rd[r][a] = ar(rd)))
        }
        a = db({}, n), a.node = t, dr(a, n.rd, lr(void 0, r), h, i, e)
    };
    var sS = { "http://www.opengis.net/gml": { surfaceMember: ar(od.prototype.vl), polygonMember: ar(od.prototype.vl) } },
        aS = { "http://www.opengis.net/gml": { pointMember: ar(od.prototype.ws) } },
        hS = { "http://www.opengis.net/gml": { lineStringMember: ar(od.prototype.pl), curveMember: ar(od.prototype.pl) } },
        lS = { "http://www.opengis.net/gml": { exterior: ar(od.prototype.ul), interior: ar(od.prototype.ul) } },
        uS = { "http://www.opengis.net/gml": { Curve: ar(od.prototype.lg), MultiCurve: ar(od.prototype.rl), Point: ar(od.prototype.tl), MultiPoint: ar(od.prototype.vs), LineString: ar(od.prototype.lg), MultiLineString: ar(od.prototype.rl), LinearRing: ar(od.prototype.ql), Polygon: ar(od.prototype.pg), MultiPolygon: ar(od.prototype.sl), Surface: ar(od.prototype.pg), MultiSurface: ar(od.prototype.sl), Envelope: ar(od.prototype.us) } },
        pS = { MultiLineString: "lineStringMember", MultiCurve: "curveMember", MultiPolygon: "polygonMember", MultiSurface: "surfaceMember" };
    od.prototype.c = function(t, e) { return $n("http://www.opengis.net/gml", pS[e[e.length - 1].node.nodeName]) }, od.prototype.g = function(t, e) {
        var i, n = e[e.length - 1],
            r = n.multiSurface,
            o = n.surface,
            s = n.curve,
            n = n.multiCurve;
        return Array.isArray(t) ? i = "Envelope" : (i = t.Z(), "MultiPolygon" === i && !0 === r ? i = "MultiSurface" : "Polygon" === i && !0 === o ? i = "Surface" : "LineString" === i && !0 === s ? i = "Curve" : "MultiLineString" === i && !0 === n && (i = "MultiCurve")), $n("http://www.opengis.net/gml", i)
    }, od.prototype.s = function(t, e) {
        e = Pn(this, e);
        var i = $n("http://www.opengis.net/gml", "geom"),
            n = { node: i, srsName: this.srsName, curve: this.i, surface: this.o, multiSurface: this.j, multiCurve: this.l };
        return e && db(n, e), this.Xd(i, t, [n]), i
    }, od.prototype.a = function(t, e) {
        e = Pn(this, e);
        var i = $n("http://www.opengis.net/gml", "featureMembers");
        i.setAttributeNS("http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation", this.schemaLocation);
        var n = { srsName: this.srsName, curve: this.i, surface: this.o, multiSurface: this.j, multiCurve: this.l, featureNS: this.featureNS, featureType: this.featureType };
        e && db(n, e);
        var n = [n],
            r = n[n.length - 1],
            o = r.featureType,
            s = r.featureNS,
            a = {};
        return a[s] = {}, a[s][o] = ar(this.ll, this), r = db({}, r), r.node = i, dr(r, a, lr(o, s), t, n), i
    }, m(ad, Xg), sb = ad.prototype, sb.rk = function(t, e) {
        var i = Zn(t, !1).replace(/^\s*|\s*$/g, ""),
            n = e[0].srsName,
            r = t.parentNode.getAttribute("srsDimension"),
            o = "enu";
        n && (n = qt(n)) && (o = n.b), i = i.split(/[\s,]+/), n = 2, t.getAttribute("srsDimension") ? n = Qg(t.getAttribute("srsDimension")) : t.getAttribute("dimension") ? n = Qg(t.getAttribute("dimension")) : r && (n = Qg(r));
        for (var s, a, h = [], l = 0, u = i.length; l < u; l += n) r = parseFloat(i[l]), s = parseFloat(i[l + 1]), a = 3 === n ? parseFloat(i[l + 2]) : 0, "en" === o.substr(0, 2) ? h.push(r, s, a) : h.push(s, r, a);
        return h
    }, sb.xr = function(t, e) { var i = fr([null], this.wl, t, e, this); return A(i[1][0], i[1][1], i[1][3], i[1][4]) }, sb.oo = function(t, e) {
        var i = fr(void 0, this.Re, t, e, this);
        i && e[e.length - 1].push(i)
    }, sb.fr = function(t, e) {
        var i = fr(void 0, this.Re, t, e, this);
        i && (e[e.length - 1][0] = i)
    }, sb.Qe = { "http://www.opengis.net/gml": { coordinates: rr(ad.prototype.rk) } }, sb.rg = { "http://www.opengis.net/gml": { innerBoundaryIs: ad.prototype.oo, outerBoundaryIs: ad.prototype.fr } }, sb.wl = { "http://www.opengis.net/gml": { coordinates: nr(ad.prototype.rk) } }, sb.fi = { "http://www.opengis.net/gml": { Point: rr(Xg.prototype.yk), MultiPoint: rr(Xg.prototype.wk), LineString: rr(Xg.prototype.ag), MultiLineString: rr(Xg.prototype.vk), LinearRing: rr(Xg.prototype.uk), Polygon: rr(Xg.prototype.bg), MultiPolygon: rr(Xg.prototype.xk), Box: rr(ad.prototype.xr) } }, m(hd, qg);
    var cS = [null, "http://www.topografix.com/GPX/1/0", "http://www.topografix.com/GPX/1/1"],
        fS = { rte: cd, trk: fd, wpt: gd },
        gS = pr(cS, { rte: nr(cd), trk: nr(fd), wpt: nr(gd) }),
        dS = pr(cS, { text: sr(td, "linkText"), type: sr(td, "linkType") }),
        yS = pr(cS, {
            name: sr(td),
            cmt: sr(td),
            desc: sr(td),
            src: sr(td),
            link: ud,
            number: sr(Jg),
            extensions: pd,
            type: sr(td),
            rtept: function(t, e) {
                var i = fr({}, mS, t, e);
                i && ld(e[e.length - 1].flatCoordinates, t, i)
            }
        }),
        mS = pr(cS, { ele: sr($g), time: sr(Kg) }),
        vS = pr(cS, {
            name: sr(td),
            cmt: sr(td),
            desc: sr(td),
            src: sr(td),
            link: ud,
            number: sr(Jg),
            type: sr(td),
            extensions: pd,
            trkseg: function(t, e) {
                var i = e[e.length - 1];
                cr(bS, t, e), i.ends.push(i.flatCoordinates.length)
            }
        }),
        bS = pr(cS, {
            trkpt: function(t, e) {
                var i = fr({}, wS, t, e);
                i && ld(e[e.length - 1].flatCoordinates, t, i)
            }
        }),
        wS = pr(cS, { ele: sr($g), time: sr(Kg) }),
        xS = pr(cS, { ele: sr($g), time: sr(Kg), magvar: sr($g), geoidheight: sr($g), name: sr(td), cmt: sr(td), desc: sr(td), src: sr(td), link: ud, sym: sr(td), type: sr(td), fix: sr(td), sat: sr(Jg), hdop: sr($g), vdop: sr($g), pdop: sr($g), ageofdgpsdata: sr($g), dgpsid: sr(Jg), extensions: pd });
    hd.prototype.qk = function(t, e) { if (!he(cS, t.namespaceURI)) return null; var i = fS[t.localName]; return i && (i = i(t, [_n(this, t, e)])) ? (dd(this, [i]), i) : null }, hd.prototype.Zc = function(t, e) { if (!he(cS, t.namespaceURI)) return []; if ("gpx" == t.localName) { var i = fr([], gS, t, [_n(this, t, e)]); if (i) return dd(this, i), i } return [] };
    var ES = ["text", "type"],
        SS = pr(cS, { text: ar(rd), type: ar(rd) }),
        NS = pr(cS, "name cmt desc src link number type rtept".split(" ")),
        LS = pr(cS, { name: ar(rd), cmt: ar(rd), desc: ar(rd), src: ar(rd), link: ar(yd), number: ar(nd), type: ar(rd), rtept: hr(ar(md)) }),
        CS = pr(cS, ["ele", "time"]),
        MS = pr(cS, "name cmt desc src link number type trkseg".split(" ")),
        IS = pr(cS, { name: ar(rd), cmt: ar(rd), desc: ar(rd), src: ar(rd), link: ar(yd), number: ar(nd), type: ar(rd), trkseg: hr(ar(function(t, e, i) { dr({ node: t, geometryLayout: e.ma, properties: {} }, TS, kS, e.ba(), i) })) }),
        kS = lr("trkpt"),
        TS = pr(cS, { trkpt: ar(md) }),
        AS = pr(cS, "ele time magvar geoidheight name cmt desc src link sym type fix sat hdop vdop pdop ageofdgpsdata dgpsid".split(" ")),
        RS = pr(cS, {
            ele: ar(id),
            time: ar(function(t, e) {
                var i = new Date(1e3 * e);
                t.appendChild(Ow.createTextNode(i.getUTCFullYear() + "-" + xo(i.getUTCMonth() + 1) + "-" + xo(i.getUTCDate()) + "T" + xo(i.getUTCHours()) + ":" + xo(i.getUTCMinutes()) + ":" + xo(i.getUTCSeconds()) + "Z"))
            }),
            magvar: ar(id),
            geoidheight: ar(id),
            name: ar(rd),
            cmt: ar(rd),
            desc: ar(rd),
            src: ar(rd),
            link: ar(yd),
            sym: ar(rd),
            type: ar(rd),
            fix: ar(rd),
            sat: ar(nd),
            hdop: ar(id),
            vdop: ar(id),
            pdop: ar(id),
            ageofdgpsdata: ar(id),
            dgpsid: ar(nd)
        }),
        _S = { Point: "wpt", LineString: "rte", MultiLineString: "trk" },
        PS = pr(cS, {
            rte: ar(function(t, e, i) {
                var n = i[0],
                    r = e.N();
                t = { node: t, properties: r }, (e = e.Y()) && (e = On(e, !0, n), t.geometryLayout = e.ma, r.rtept = e.ba()), n = NS[i[i.length - 1].node.namespaceURI], r = ur(r, n), dr(t, LS, Dw, r, i, n)
            }),
            trk: ar(function(t, e, i) {
                var n = i[0],
                    r = e.N();
                t = { node: t, properties: r }, (e = e.Y()) && (e = On(e, !0, n), r.trkseg = e.re()), n = MS[i[i.length - 1].node.namespaceURI], r = ur(r, n), dr(t, IS, Dw, r, i, n)
            }),
            wpt: ar(function(t, e, i) {
                var n = i[0],
                    r = i[i.length - 1];
                r.properties = e.N(), (e = e.Y()) && (e = On(e, !0, n), r.geometryLayout = e.ma, md(t, e.ba(), i))
            })
        });
    hd.prototype.a = function(t, e) { e = Pn(this, e); var i = $n("http://www.topografix.com/GPX/1/1", "gpx"); return i.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance"), i.setAttributeNS("http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation", "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd"), i.setAttribute("version", "1.1"), i.setAttribute("creator", "OpenLayers 3"), dr({ node: i }, PS, vd, t, [e]), i }, m(bd, Rn), sb = bd.prototype, sb.Z = function() { return "text" }, sb.vc = function(t, e) { return this.De(wd(t), Pn(this, e)) }, sb.Ia = function(t, e) { return this.Mh(wd(t), Pn(this, e)) }, sb.Qd = function(t, e) { return this.Fe(wd(t), Pn(this, e)) }, sb.ib = function() { return this.defaultDataProjection }, sb.Oe = function(t, e) { return this.mg(t, Pn(this, e)) }, sb.Ac = function(t, e) { return this.ml(t, Pn(this, e)) }, sb.Wd = function(t, e) { return this.Pe(t, Pn(this, e)) }, m(xd, bd);
    var OS = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/,
        DS = /^H.([A-Z]{3}).*?:(.*)/,
        FS = /^HFDTE(\d{2})(\d{2})(\d{2})/,
        US = /\r\n|\r|\n/;
    xd.prototype.De = function(t, e) {
        var i, n, r = this.b,
            o = t.split(US),
            s = {},
            a = [],
            h = 2e3,
            l = 0,
            u = 1,
            p = -1;
        for (i = 0, n = o.length; i < n; ++i) {
            var c, f = o[i];
            if ("B" == f.charAt(0)) {
                if (c = OS.exec(f)) {
                    var f = parseInt(c[1], 10),
                        g = parseInt(c[2], 10),
                        d = parseInt(c[3], 10),
                        y = parseInt(c[4], 10) + parseInt(c[5], 10) / 6e4;
                    "S" == c[6] && (y = -y);
                    var m = parseInt(c[7], 10) + parseInt(c[8], 10) / 6e4;
                    "W" == c[9] && (m = -m), a.push(m, y), "none" != r && a.push("gps" == r ? parseInt(c[11], 10) : "barometric" == r ? parseInt(c[12], 10) : 0), c = Date.UTC(h, l, u, f, g, d), c < p && (c = Date.UTC(h, l, u + 1, f, g, d)), a.push(c / 1e3), p = c
                }
            } else "H" == f.charAt(0) && ((c = FS.exec(f)) ? (u = parseInt(c[1], 10), l = parseInt(c[2], 10) - 1, h = 2e3 + parseInt(c[3], 10)) : (c = DS.exec(f)) && (s[c[1]] = c[2].trim()))
        }
        return 0 === a.length ? null : (o = new Fe(null), o.ca("none" == r ? "XYM" : "XYZM", a), r = new Tn(On(o, !1, e)), r.G(s), r)
    }, xd.prototype.Mh = function(t, e) { var i = this.De(t, e); return i ? [i] : [] };
    var BS, jS, zS, GS, qS, VS, WS, XS, HS, YS, KS, $S, ZS, JS;
    m(Ed, qg);
    var QS = ["http://www.google.com/kml/ext/2.2"],
        tN = [null, "http://earth.google.com/kml/2.0", "http://earth.google.com/kml/2.1", "http://earth.google.com/kml/2.2", "http://www.opengis.net/kml/2.2"],
        eN = { fraction: "fraction", pixels: "pixels" },
        iN = pr(tN, { value: rr(td) }),
        nN = pr(tN, {
            Data: function(t, e) {
                var i = t.getAttribute("name");
                if (null !== i) {
                    var n = fr(void 0, iN, t, e);
                    n && (e[e.length - 1][i] = n)
                }
            },
            SchemaData: function(t, e) { cr(EN, t, e) }
        }),
        rN = pr(tN, { extrude: sr(Hg), altitudeMode: sr(td) }),
        oN = pr(tN, { coordinates: rr(Md) }),
        sN = pr(tN, {
            innerBoundaryIs: function(t, e) {
                var i = fr(void 0, pN, t, e);
                i && e[e.length - 1].push(i)
            },
            outerBoundaryIs: function(t, e) {
                var i = fr(void 0, vN, t, e);
                i && (e[e.length - 1][0] = i)
            }
        }),
        aN = pr(tN, {
            when: function(t, e) {
                var i = e[e.length - 1].jl,
                    n = Zn(t, !1),
                    n = Date.parse(n);
                i.push(isNaN(n) ? 0 : n)
            }
        }, pr(QS, {
            coord: function(t, e) {
                var i = e[e.length - 1].B,
                    n = Zn(t, !1);
                (n = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(n)) ? i.push(parseFloat(n[1]), parseFloat(n[2]), parseFloat(n[3]), 0): i.push(0, 0, 0, 0)
            }
        })),
        hN = pr(tN, { coordinates: rr(Md) }),
        lN = pr(tN, { href: sr(Id) }, pr(QS, { x: sr($g), y: sr($g), w: sr($g), h: sr($g) })),
        uN = pr(tN, {
            Icon: sr(function(t, e) { var i = fr({}, lN, t, e); return i ? i : null }),
            heading: sr($g),
            hotSpot: sr(function(t) {
                var e = t.getAttribute("xunits"),
                    i = t.getAttribute("yunits");
                return { x: parseFloat(t.getAttribute("x")), di: eN[e], y: parseFloat(t.getAttribute("y")), ei: eN[i] }
            }),
            scale: sr(kd)
        }),
        pN = pr(tN, { LinearRing: rr(Td) }),
        cN = pr(tN, { color: sr(Cd), scale: sr(kd) }),
        fN = pr(tN, { color: sr(Cd), width: sr($g) }),
        gN = pr(tN, { LineString: nr(Rd), LinearRing: nr(_d), MultiGeometry: nr(Pd), Point: nr(Od), Polygon: nr(Dd) }),
        dN = pr(QS, { Track: nr(Ad) }),
        yN = pr(tN, { ExtendedData: Bd, Link: function(t, e) { cr(mN, t, e) }, address: sr(td), description: sr(td), name: sr(td), open: sr(Hg), phoneNumber: sr(td), visibility: sr(Hg) }),
        mN = pr(tN, { href: sr(Id) }),
        vN = pr(tN, { LinearRing: rr(Td) }),
        bN = pr(tN, { Style: sr(Fd), key: sr(td), styleUrl: sr(Id) }),
        wN = pr(tN, {
            ExtendedData: Bd,
            MultiGeometry: sr(Pd, "geometry"),
            LineString: sr(Rd, "geometry"),
            LinearRing: sr(_d, "geometry"),
            Point: sr(Od, "geometry"),
            Polygon: sr(Dd, "geometry"),
            Style: sr(Fd),
            StyleMap: function(t, e) {
                var i = fr(void 0, NN, t, e);
                if (i) {
                    var n = e[e.length - 1];
                    Array.isArray(i) ? n.Style = i : "string" == typeof i ? n.styleUrl = i : x(!1, 38)
                }
            },
            address: sr(td),
            description: sr(td),
            name: sr(td),
            open: sr(Hg),
            phoneNumber: sr(td),
            styleUrl: sr(Id),
            visibility: sr(Hg)
        }, pr(QS, {
            MultiTrack: sr(function(t, e) {
                var i = fr([], dN, t, e);
                if (i) {
                    var n = new Be(null);
                    return ze(n, i),
                        n
                }
            }, "geometry"),
            Track: sr(Ad, "geometry")
        })),
        xN = pr(tN, { color: sr(Cd), fill: sr(Hg), outline: sr(Hg) }),
        EN = pr(tN, {
            SimpleData: function(t, e) {
                var i = t.getAttribute("name");
                if (null !== i) {
                    var n = td(t);
                    e[e.length - 1][i] = n
                }
            }
        }),
        SN = pr(tN, {
            IconStyle: function(t, e) {
                var i = fr({}, uN, t, e);
                if (i) {
                    var n, r = e[e.length - 1],
                        o = "Icon" in i ? i.Icon : {};
                    n = (n = o.href) ? n : XS;
                    var s, a, h, l = i.hotSpot;
                    l ? (s = [l.x, l.y], a = l.di, h = l.ei) : n === XS ? (s = GS, a = qS, h = VS) : /^http:\/\/maps\.(?:google|gstatic)\.com\//.test(n) && (s = [.5, 0], h = a = "fraction");
                    var u, l = o.x,
                        p = o.y;
                    void 0 !== l && void 0 !== p && (u = [l, p]);
                    var c, l = o.w,
                        o = o.h;
                    void 0 !== l && void 0 !== o && (c = [l, o]);
                    var f, o = i.heading;
                    void 0 !== o && (f = Tt(o)), i = i.scale, n == XS && (c = WS, void 0 === i && (i = HS)), s = new en({ anchor: s, anchorOrigin: "bottom-left", anchorXUnits: a, anchorYUnits: h, crossOrigin: "anonymous", offset: u, offsetOrigin: "bottom-left", rotation: f, scale: i, size: c, src: n }), r.imageStyle = s
                }
            },
            LabelStyle: function(t, e) {
                var i = fr({}, cN, t, e);
                i && (e[e.length - 1].textStyle = new Zi({ fill: new Ui({ color: "color" in i ? i.color : jS }), scale: i.scale }))
            },
            LineStyle: function(t, e) {
                var i = fr({}, fN, t, e);
                i && (e[e.length - 1].strokeStyle = new Vi({ color: "color" in i ? i.color : jS, width: "width" in i ? i.width : 1 }))
            },
            PolyStyle: function(t, e) {
                var i = fr({}, xN, t, e);
                if (i) {
                    var n = e[e.length - 1];
                    n.fillStyle = new Ui({ color: "color" in i ? i.color : jS });
                    var r = i.fill;
                    void 0 !== r && (n.fill = r), i = i.outline, void 0 !== i && (n.outline = i)
                }
            }
        }),
        NN = pr(tN, {
            Pair: function(t, e) {
                var i = fr({}, bN, t, e);
                if (i) {
                    var n = i.key;
                    n && "normal" == n && ((n = i.styleUrl) && (e[e.length - 1] = n), (i = i.Style) && (e[e.length - 1] = i))
                }
            }
        });
    sb = Ed.prototype, sb.Ih = function(t, e) { var i = pr(tN, { Document: ir(this.Ih, this), Folder: ir(this.Ih, this), Placemark: nr(this.Qh, this), Style: this.Mr.bind(this), StyleMap: this.Lr.bind(this) }); if (i = fr([], i, t, e, this)) return i }, sb.Qh = function(t, e) {
        var i = fr({ geometry: null }, wN, t, e);
        if (i) {
            var n = new Tn,
                r = t.getAttribute("id");
            null !== r && n.ic(r);
            var r = e[0],
                o = i.geometry;
            return o && On(o, !1, r), n.ob(o), delete i.geometry, this.c && n.vh(Nd(i.Style, i.styleUrl, this.g, this.b, this.i)), delete i.Style, n.G(i), n
        }
    }, sb.Mr = function(t, e) {
        var i = t.getAttribute("id");
        if (null !== i) {
            var n = Fd(t, e);
            n && (i = t.baseURI ? new URL("#" + i, t.baseURI).href : "#" + i, this.b[i] = n)
        }
    }, sb.Lr = function(t, e) {
        var i = t.getAttribute("id");
        if (null !== i) {
            var n = fr(void 0, NN, t, e);
            n && (i = t.baseURI ? new URL("#" + i, t.baseURI).href : "#" + i, this.b[i] = n)
        }
    }, sb.qk = function(t, e) { if (!he(tN, t.namespaceURI)) return null; var i = this.Qh(t, [_n(this, t, e)]); return i ? i : null }, sb.Zc = function(t, e) {
        if (!he(tN, t.namespaceURI)) return [];
        var i;
        if (i = t.localName, "Document" == i || "Folder" == i) return (i = this.Ih(t, [_n(this, t, e)])) ? i : [];
        if ("Placemark" == i) return (i = this.Qh(t, [_n(this, t, e)])) ? [i] : [];
        if ("kml" == i) {
            i = [];
            var n;
            for (n = t.firstElementChild; n; n = n.nextElementSibling) {
                var r = this.Zc(n, e);
                r && pe(i, r)
            }
            return i
        }
        return []
    }, sb.Gr = function(t) { return Qn(t) ? jd(this, t) : tr(t) ? zd(this, t) : "string" == typeof t ? (t = er(t), jd(this, t)) : void 0 }, sb.Hr = function(t) { var e = []; return Qn(t) ? pe(e, Gd(this, t)) : tr(t) ? pe(e, qd(this, t)) : "string" == typeof t && (t = er(t), pe(e, Gd(this, t))), e };
    var LN = pr(tN, ["Document", "Placemark"]),
        CN = pr(tN, { Document: ar(function(t, e, i) { dr({ node: t }, MN, Jd, e, i, void 0, this) }), Placemark: ar(Hd) }),
        MN = pr(tN, { Placemark: ar(Hd) }),
        IN = { Point: "Point", LineString: "LineString", LinearRing: "LinearRing", Polygon: "Polygon", MultiPoint: "MultiGeometry", MultiLineString: "MultiGeometry", MultiPolygon: "MultiGeometry", GeometryCollection: "MultiGeometry" },
        kN = pr(tN, ["href"], pr(QS, ["x", "y", "w", "h"])),
        TN = pr(tN, { href: ar(rd) }, pr(QS, { x: ar(id), y: ar(id), w: ar(id), h: ar(id) })),
        AN = pr(tN, ["scale", "heading", "Icon", "hotSpot"]),
        RN = pr(tN, {
            Icon: ar(function(t, e, i) {
                t = { node: t };
                var n = kN[i[i.length - 1].node.namespaceURI],
                    r = ur(e, n);
                dr(t, TN, Dw, r, i, n), n = kN[QS[0]], r = ur(e, n), dr(t, TN, Zd, r, i, n)
            }),
            heading: ar(id),
            hotSpot: ar(function(t, e) { t.setAttribute("x", e.x), t.setAttribute("y", e.y), t.setAttribute("xunits", e.di), t.setAttribute("yunits", e.ei) }),
            scale: ar($d)
        }),
        _N = pr(tN, ["color", "scale"]),
        PN = pr(tN, { color: ar(Vd), scale: ar($d) }),
        ON = pr(tN, ["color", "width"]),
        DN = pr(tN, { color: ar(Vd), width: ar(id) }),
        FN = pr(tN, { LinearRing: ar(Yd) }),
        UN = pr(tN, { LineString: ar(Yd), Point: ar(Yd), Polygon: ar(Kd), GeometryCollection: ar(Wd) }),
        BN = pr(tN, "name open visibility address phoneNumber description styleUrl Style".split(" ")),
        jN = pr(tN, {
            MultiGeometry: ar(Wd),
            LineString: ar(Yd),
            LinearRing: ar(Yd),
            Point: ar(Yd),
            Polygon: ar(Kd),
            Style: ar(function(t, e, i) {
                t = { node: t };
                var n = {},
                    r = e.c,
                    o = e.f,
                    s = e.a;
                e = e.Wa(), s instanceof en && (n.IconStyle = s), e && (n.LabelStyle = e), o && (n.LineStyle = o), r && (n.PolyStyle = r), e = VN[i[i.length - 1].node.namespaceURI], n = ur(n, e), dr(t, WN, Dw, n, i, e)
            }),
            address: ar(rd),
            description: ar(rd),
            name: ar(rd),
            open: ar(ed),
            phoneNumber: ar(rd),
            styleUrl: ar(rd),
            visibility: ar(ed)
        }),
        zN = pr(tN, {
            coordinates: ar(function(t, e, i) {
                i = i[i.length - 1];
                var n = i.layout;
                i = i.stride;
                var r;
                "XY" == n || "XYM" == n ? r = 2 : "XYZ" == n || "XYZM" == n ? r = 3 : x(!1, 34);
                var o, s = e.length,
                    a = "";
                if (0 < s) {
                    for (a += e[0], n = 1; n < r; ++n) a += "," + e[n];
                    for (o = i; o < s; o += i)
                        for (a += " " + e[o], n = 1; n < r; ++n) a += "," + e[o + n]
                }
                rd(t, a)
            })
        }),
        GN = pr(tN, { outerBoundaryIs: ar(Xd), innerBoundaryIs: ar(Xd) }),
        qN = pr(tN, { color: ar(Vd) }),
        VN = pr(tN, ["IconStyle", "LabelStyle", "LineStyle", "PolyStyle"]),
        WN = pr(tN, {
            IconStyle: ar(function(t, e, i) {
                t = { node: t };
                var n = {},
                    r = e.hc(),
                    o = e.qe(),
                    s = { href: e.b.o };
                if (r) {
                    s.w = r[0], s.h = r[1];
                    var a = e.Dc(),
                        h = e.$a();
                    h && o && 0 !== h[0] && h[1] !== r[1] && (s.x = h[0], s.y = o[1] - (h[1] + r[1])), a && 0 !== a[0] && a[1] !== r[1] && (n.hotSpot = { x: a[0], di: "pixels", y: r[1] - a[1], ei: "pixels" })
                }
                n.Icon = s, r = e.i, 1 !== r && (n.scale = r), e = e.o, 0 !== e && (n.heading = e), e = AN[i[i.length - 1].node.namespaceURI], n = ur(n, e), dr(t, RN, Dw, n, i, e)
            }),
            LabelStyle: ar(function(t, e, i) {
                t = { node: t };
                var n = {},
                    r = e.b;
                r && (n.color = r.b), (e = e.a) && 1 !== e && (n.scale = e), e = _N[i[i.length - 1].node.namespaceURI], n = ur(n, e), dr(t, PN, Dw, n, i, e)
            }),
            LineStyle: ar(function(t, e, i) {
                t = { node: t };
                var n = ON[i[i.length - 1].node.namespaceURI];
                e = ur({ color: e.b, width: e.a }, n), dr(t, DN, Dw, e, i, n)
            }),
            PolyStyle: ar(function(t, e, i) { dr({ node: t }, qN, XN, [e.b], i) })
        }),
        XN = lr("color"),
        HN = lr("coordinates"),
        YN = lr("innerBoundaryIs"),
        KN = lr("Point"),
        $N = lr("LineString"),
        ZN = lr("LinearRing"),
        JN = lr("Polygon"),
        QN = lr("outerBoundaryIs");
    Ed.prototype.a = function(t, e) {
            e = Pn(this, e);
            var i = $n(tN[4], "kml");
            i.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:gx", QS[0]), i.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance"), i.setAttributeNS("http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation", "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd");
            var n = { node: i },
                r = {};
            1 < t.length ? r.Document = t : 1 == t.length && (r.Placemark = t[0]);
            var o = LN[i.namespaceURI],
                r = ur(r, o);
            return dr(n, CN, Dw, r, [e], o, this), i
        },
        function() {
            var t = {},
                e = { la: t };
            ! function(i) {
                if ("object" == typeof t && "undefined" != typeof e) e.la = i();
                else {
                    var n;
                    n = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, n.Rs = i()
                }
            }(function() {
                return function t(e, i, n) {
                    function r(s, a) {
                        if (!i[s]) {
                            if (!e[s]) { var h = "function" == typeof require && require; if (!a && h) return h(s, !0); if (o) return o(s, !0); throw h = Error("Cannot find module '" + s + "'"), h.code = "MODULE_NOT_FOUND", h }
                            h = i[s] = { la: {} }, e[s][0].call(h.la, function(t) { var i = e[s][1][t]; return r(i ? i : t) }, h, h.la, t, e, i, n)
                        }
                        return i[s].la
                    }
                    for (var o = "function" == typeof require && require, s = 0; s < n.length; s++) r(n[s]);
                    return r
                }({
                    1: [function(t, e) {
                        function i(t) { var e; return t && t.length && (e = t, t = e.length), t = new Uint8Array(t || 0), e && t.set(e), t.Bk = r.Bk, t.ci = r.ci, t.tk = r.tk, t.ol = r.ol, t.Ph = r.Ph, t.nl = r.nl, t.Jh = r.Jh, t.kl = r.kl, t.toString = r.toString, t.write = r.write, t.slice = r.slice, t.xi = r.xi, t.Xl = !0, t }

                        function n(t) {
                            for (var e, i, n = t.length, r = [], o = 0; o < n; o++) {
                                if (e = t.charCodeAt(o), 55295 < e && 57344 > e) {
                                    if (!i) { 56319 < e || o + 1 === n ? r.push(239, 191, 189) : i = e; continue }
                                    if (56320 > e) { r.push(239, 191, 189), i = e; continue }
                                    e = i - 55296 << 10 | e - 56320 | 65536, i = null
                                } else i && (r.push(239, 191, 189), i = null);
                                128 > e ? r.push(e) : 2048 > e ? r.push(e >> 6 | 192, 63 & e | 128) : 65536 > e ? r.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128) : r.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128)
                            }
                            return r
                        }
                        e.la = i;
                        var r, o, s, a = t("ieee754");
                        r = {
                            Bk: function(t) { return (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] },
                            ci: function(t, e) { this[e] = t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24 },
                            tk: function(t) { return (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + (this[t + 3] << 24) },
                            Ph: function(t) { return a.read(this, t, !0, 23, 4) },
                            Jh: function(t) { return a.read(this, t, !0, 52, 8) },
                            nl: function(t, e) { return a.write(this, t, e, !0, 23, 4) },
                            kl: function(t, e) { return a.write(this, t, e, !0, 52, 8) },
                            toString: function(t, e, i) {
                                var n = t = "";
                                for (i = Math.min(this.length, i || this.length), e = e || 0; e < i; e++) {
                                    var r = this[e];
                                    127 >= r ? (t += decodeURIComponent(n) + String.fromCharCode(r), n = "") : n += "%" + r.toString(16)
                                }
                                return t += decodeURIComponent(n)
                            },
                            write: function(t, e) { for (var i = t === o ? s : n(t), r = 0; r < i.length; r++) this[e + r] = i[r] },
                            slice: function(t, e) { return this.subarray(t, e) },
                            xi: function(t, e) { e = e || 0; for (var i = 0; i < this.length; i++) t[e + i] = this[i] }
                        }, r.ol = r.ci, i.byteLength = function(t) { return o = t, s = n(t), s.length }, i.isBuffer = function(t) { return !(!t || !t.Xl) }
                    }, { ieee754: 3 }],
                    2: [function(t, e) {
                        (function(i) {
                            function n(t) { this.cc = o.isBuffer(t) ? t : new o(t || 0), this.ea = 0, this.length = this.cc.length }

                            function r(t, e) { var i, n = e.cc; if (i = n[e.ea++], t += 268435456 * (127 & i), 128 > i) return t; if (i = n[e.ea++], t += 34359738368 * (127 & i), 128 > i) return t; if (i = n[e.ea++], t += 4398046511104 * (127 & i), 128 > i) return t; if (i = n[e.ea++], t += 562949953421312 * (127 & i), 128 > i) return t; if (i = n[e.ea++], t += 72057594037927940 * (127 & i), 128 > i) return t; if (i = n[e.ea++], 128 > i) return t + 0x8000000000000000 * (127 & i); throw Error("Expected varint not more than 10 bytes") }
                            e.la = n;
                            var o = i.xs || t("./buffer");
                            n.f = 0, n.g = 1, n.b = 2, n.a = 5;
                            var s = Math.pow(2, 63);
                            n.prototype = {
                                Nh: function(t, e, i) {
                                    for (i = i || this.length; this.ea < i;) {
                                        var n = this.La(),
                                            r = this.ea;
                                        t(n >> 3, e, this), this.ea === r && this.ms(n)
                                    }
                                    return e
                                },
                                Cr: function() { var t = this.cc.Ph(this.ea); return this.ea += 4, t },
                                yr: function() { var t = this.cc.Jh(this.ea); return this.ea += 8, t },
                                La: function() { var t, e, i = this.cc; return e = i[this.ea++], t = 127 & e, 128 > e ? t : (e = i[this.ea++], t |= (127 & e) << 7, 128 > e ? t : (e = i[this.ea++], t |= (127 & e) << 14, 128 > e ? t : (e = i[this.ea++], t |= (127 & e) << 21, 128 > e ? t : r(t, this)))) },
                                Nr: function() {
                                    var t = this.ea,
                                        e = this.La();
                                    if (e < s) return e;
                                    for (var i = this.ea - 2; 255 === this.cc[i];) i--;
                                    i < t && (i = t);
                                    for (var n = e = 0; n < i - t + 1; n++) var r = 127 & ~this.cc[t + n],
                                        e = e + (4 > n ? r << 7 * n : r * Math.pow(2, 7 * n));
                                    return -e - 1
                                },
                                Ge: function() { var t = this.La(); return 1 === t % 2 ? (t + 1) / -2 : t / 2 },
                                wr: function() { return !!this.La() },
                                Sh: function() {
                                    var t = this.La() + this.ea,
                                        e = this.cc.toString("utf8", this.ea, t);
                                    return this.ea = t, e
                                },
                                ms: function(t) {
                                    if (t &= 7, t === n.f)
                                        for (; 127 < this.cc[this.ea++];);
                                    else if (t === n.b) this.ea = this.La() + this.ea;
                                    else if (t === n.a) this.ea += 4;
                                    else {
                                        if (t !== n.g) throw Error("Unimplemented type: " + t);
                                        this.ea += 8
                                    }
                                }
                            }
                        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
                    }, { "./buffer": 1 }],
                    3: [function(t, e, i) {
                        i.read = function(t, e, i, n, r) {
                            var o;
                            o = 8 * r - n - 1;
                            var s = (1 << o) - 1,
                                a = s >> 1,
                                h = -7;
                            r = i ? r - 1 : 0;
                            var l = i ? -1 : 1,
                                u = t[e + r];
                            for (r += l, i = u & (1 << -h) - 1, u >>= -h, h += o; 0 < h; i = 256 * i + t[e + r], r += l, h -= 8);
                            for (o = i & (1 << -h) - 1, i >>= -h, h += n; 0 < h; o = 256 * o + t[e + r], r += l, h -= 8);
                            if (0 === i) i = 1 - a;
                            else {
                                if (i === s) return o ? NaN : 1 / 0 * (u ? -1 : 1);
                                o += Math.pow(2, n), i -= a
                            }
                            return (u ? -1 : 1) * o * Math.pow(2, i - n)
                        }, i.write = function(t, e, i, n, r, o) {
                            var s, a = 8 * o - r - 1,
                                h = (1 << a) - 1,
                                l = h >> 1,
                                u = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                            o = n ? 0 : o - 1;
                            var p = n ? 1 : -1,
                                c = 0 > e || 0 === e && 0 > 1 / e ? 1 : 0;
                            for (e = Math.abs(e), isNaN(e) || 1 / 0 === e ? (e = isNaN(e) ? 1 : 0, n = h) : (n = Math.floor(Math.log(e) / Math.LN2), 1 > e * (s = Math.pow(2, -n)) && (n--, s *= 2), e = 1 <= n + l ? e + u / s : e + u * Math.pow(2, 1 - l), 2 <= e * s && (n++, s /= 2), n + l >= h ? (e = 0, n = h) : 1 <= n + l ? (e = (e * s - 1) * Math.pow(2, r), n += l) : (e = e * Math.pow(2, l - 1) * Math.pow(2, r), n = 0)); 8 <= r; t[i + o] = 255 & e, o += p, e /= 256, r -= 8);
                            for (n = n << r | e, a += r; 0 < a; t[i + o] = 255 & n, o += p, n /= 256, a -= 8);
                            t[i + o - p] |= 128 * c
                        }
                    }, {}]
                }, {}, [2])(2)
            }), Uw = e.la
        }(),
        function() {
            var t = {},
                e = { la: t };
            ! function(i) {
                if ("object" == typeof t && "undefined" != typeof e) e.la = i();
                else {
                    var n;
                    n = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, n.Zs = i()
                }
            }(function() {
                return function t(e, i, n) {
                    function r(s, a) {
                        if (!i[s]) {
                            if (!e[s]) { var h = "function" == typeof require && require; if (!a && h) return h(s, !0); if (o) return o(s, !0); throw h = Error("Cannot find module '" + s + "'"), h.code = "MODULE_NOT_FOUND", h }
                            h = i[s] = { la: {} }, e[s][0].call(h.la, function(t) { var i = e[s][1][t]; return r(i ? i : t) }, h, h.la, t, e, i, n)
                        }
                        return i[s].la
                    }
                    for (var o = "function" == typeof require && require, s = 0; s < n.length; s++) r(n[s]);
                    return r
                }({
                    1: [function(t, e) { e.la.Ol = t("./lib/vectortile.js"), e.la.Ms = t("./lib/vectortilefeature.js"), e.la.Ns = t("./lib/vectortilelayer.js") }, { "./lib/vectortile.js": 2, "./lib/vectortilefeature.js": 3, "./lib/vectortilelayer.js": 4 }],
                    2: [function(t, e) {
                        function i(t, e, i) { 3 === t && (t = new n(i, i.La() + i.ea), t.length && (e[t.name] = t)) }
                        var n = t("./vectortilelayer");
                        e.la = function(t, e) { this.layers = t.Nh(i, {}, e) }
                    }, { "./vectortilelayer": 4 }],
                    3: [function(t, e) {
                        function i(t, e, i, r, o) { this.properties = {}, this.extent = i, this.type = 0, this.bd = t, this.sg = -1, this.Ve = r, this.Xe = o, t.Nh(n, this, e) }

                        function n(t, e, i) {
                            if (1 == t) e.id = i.La();
                            else if (2 == t)
                                for (t = i.La() + i.ea; i.ea < t;) {
                                    var n = e.Ve[i.La()],
                                        r = e.Xe[i.La()];
                                    e.properties[n] = r
                                } else 3 == t ? e.type = i.La() : 4 == t && (e.sg = i.ea)
                        }
                        var r = t("point-geometry");
                        e.la = i, i.b = ["Unknown", "Point", "LineString", "Polygon"], i.prototype.pj = function() {
                            var t = this.bd;
                            t.ea = this.sg;
                            for (var e, i = t.La() + t.ea, n = 1, o = 0, s = 0, a = 0, h = []; t.ea < i;)
                                if (o || (o = t.La(), n = 7 & o, o >>= 3), o--, 1 === n || 2 === n) s += t.Ge(), a += t.Ge(), 1 === n && (e && h.push(e), e = []), e.push(new r(s, a));
                                else {
                                    if (7 !== n) throw Error("unknown command " + n);
                                    e && e.push(e[0].clone())
                                }
                            return e && h.push(e), h
                        }, i.prototype.bbox = function() {
                            var t = this.bd;
                            t.ea = this.sg;
                            for (var e = t.La() + t.ea, i = 1, n = 0, r = 0, o = 0, s = 1 / 0, a = -(1 / 0), h = 1 / 0, l = -(1 / 0); t.ea < e;)
                                if (n || (n = t.La(), i = 7 & n, n >>= 3), n--, 1 === i || 2 === i) r += t.Ge(), o += t.Ge(), r < s && (s = r), r > a && (a = r), o < h && (h = o), o > l && (l = o);
                                else if (7 !== i) throw Error("unknown command " + i);
                            return [s, h, a, l]
                        }
                    }, { "point-geometry": 5 }],
                    4: [function(t, e) {
                        function i(t, e) { this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this.bd = t, this.Ve = [], this.Xe = [], this.Ue = [], t.Nh(n, this, e), this.length = this.Ue.length }

                        function n(t, e, i) { 15 === t ? e.version = i.La() : 1 === t ? e.name = i.Sh() : 5 === t ? e.extent = i.La() : 2 === t ? e.Ue.push(i.ea) : 3 === t ? e.Ve.push(i.Sh()) : 4 === t && e.Xe.push(r(i)) }

                        function r(t) { for (var e = null, i = t.La() + t.ea; t.ea < i;) e = t.La() >> 3, e = 1 === e ? t.Sh() : 2 === e ? t.Cr() : 3 === e ? t.yr() : 4 === e ? t.Nr() : 5 === e ? t.La() : 6 === e ? t.Ge() : 7 === e ? t.wr() : null; return e }
                        var o = t("./vectortilefeature.js");
                        e.la = i, i.prototype.feature = function(t) { if (0 > t || t >= this.Ue.length) throw Error("feature index out of bounds"); return this.bd.ea = this.Ue[t], t = this.bd.La() + this.bd.ea, new o(this.bd, t, this.extent, this.Ve, this.Xe) }
                    }, { "./vectortilefeature.js": 3 }],
                    5: [function(t, e) {
                        function i(t, e) { this.x = t, this.y = e }
                        e.la = i, i.prototype = {
                            clone: function() { return new i(this.x, this.y) },
                            add: function(t) { return this.clone().Pl(t) },
                            rotate: function(t) { return this.clone().$l(t) },
                            round: function() { return this.clone().am() },
                            angle: function() { return Math.atan2(this.y, this.x) },
                            Pl: function(t) { return this.x += t.x, this.y += t.y, this },
                            $l: function(t) {
                                var e = Math.cos(t);
                                t = Math.sin(t);
                                var i = t * this.x + e * this.y;
                                return this.x = e * this.x - t * this.y, this.y = i, this
                            },
                            am: function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }
                        }, i.b = function(t) { return t instanceof i ? t : Array.isArray(t) ? new i(t[0], t[1]) : t }
                    }, {}]
                }, {}, [1])(1)
            }), Bw = e.la
        }(), sb = ty.prototype, sb.get = function(t) { return this.f[t] }, sb.ec = function() { return this.c }, sb.H = function() { return this.a || (this.a = "Point" === this.g ? R(this.b) : _(this.b, 0, this.b.length, 2)), this.a }, sb.qc = function() { return this.b }, sb.oa = ty.prototype.qc, sb.Y = function() { return this }, sb.Np = function() { return this.f }, sb.se = ty.prototype.Y, sb.Aa = function() { return 2 }, sb.Tc = v, sb.Z = function() { return this.g }, m(ey, Rn), ey.prototype.Z = function() { return "arraybuffer" }, ey.prototype.Ia = function(t, e) {
            var i, n, r, o = this.f,
                s = new Uw(t),
                s = new Bw.Ol(s),
                a = [],
                h = this.b;
            for (r in s.layers)
                if (!o || -1 != o.indexOf(r)) {
                    i = s.layers[r];
                    for (var l = 0, u = i.length; l < u; ++l) {
                        if (h === ty) {
                            var p = i.feature(l);
                            n = r;
                            var c = p.pj(),
                                f = [],
                                g = [];
                            iy(c, g, f);
                            var d = p.type,
                                y = void 0;
                            1 === d ? y = 1 === c.length ? "Point" : "MultiPoint" : 2 === d ? y = 1 === c.length ? "LineString" : "MultiLineString" : 3 === d && (y = "Polygon"), p = p.properties, p[this.a] = n, n = new this.b(y, g, f, p)
                        } else {
                            if (c = i.feature(l), p = r, y = e, n = new this.b, f = c.id, g = c.properties, g[this.a] = p, p = c.type, 0 === p) p = null;
                            else {
                                var c = c.pj(),
                                    d = [],
                                    m = [];
                                iy(c, m, d);
                                var v = void 0;
                                1 === p ? v = 1 === c.length ? new se(null) : new we(null) : 2 === p ? v = 1 === c.length ? new Fe(null) : new Be(null) : 3 === p && (v = new Ze(null)), v.ca("XY", m, d), p = v
                            }(y = On(p, !1, Pn(this, y))) && (g[this.g] = y), n.ic(f), n.G(g), n.sd(this.g)
                        }
                        a.push(n)
                    }
                }
            return a
        }, ey.prototype.ib = function() { return this.defaultDataProjection }, ey.prototype.c = function(t) { this.f = t }, m(ry, ny), m(oy, ry), m(sy, oy), m(ay, ny), m(hy, ny), m(ly, hy), m(uy, ly), m(py, ly), m(cy, ly), m(fy, ny), m(gy, fy), m(dy, hy), m(yy, hy), m(my, hy), m(vy, ly), m(by, ly), m(wy, ry), m(xy, ly), m(Ey, oy), m(Sy, fy), m(Cy, qg);
    var tL = [null],
        eL = pr(tL, { nd: function(t, e) { e[e.length - 1].Kd.push(t.getAttribute("ref")) }, tag: My }),
        iL = pr(tL, {
            node: function(t, e) {
                var i = e[0],
                    n = e[e.length - 1],
                    r = t.getAttribute("id"),
                    o = [parseFloat(t.getAttribute("lon")), parseFloat(t.getAttribute("lat"))];
                n.uj[r] = o;
                var s = fr({ Ne: {} }, nL, t, e);
                nt(s.Ne) || (o = new se(o), On(o, !1, i), i = new Tn(o), i.ic(r), i.G(s.Ne), n.features.push(i))
            },
            way: function(t, e) {
                for (var i = e[0], n = t.getAttribute("id"), r = fr({ Kd: [], Ne: {} }, eL, t, e), o = e[e.length - 1], s = [], a = 0, h = r.Kd.length; a < h; a++) pe(s, o.uj[r.Kd[a]]);
                r.Kd[0] == r.Kd[r.Kd.length - 1] ? (a = new Ze(null), a.ca("XY", s, [s.length])) : (a = new Fe(null), a.ca("XY", s)), On(a, !1, i), i = new Tn(a), i.ic(n), i.G(r.Ne), o.features.push(i)
            }
        }),
        nL = pr(tL, { tag: My });
    Cy.prototype.Zc = function(t, e) { var i = _n(this, t, e); return "osm" == t.localName && (i = fr({ uj: {}, features: [] }, iL, t, [i]), i.features) ? i.features : [] }, ky.prototype.read = function(t) { return Qn(t) ? this.a(t) : tr(t) ? this.b(t) : "string" == typeof t ? (t = er(t), this.a(t)) : null }, m(Ty, ky), Ty.prototype.a = function(t) {
        for (t = t.firstChild; t; t = t.nextSibling)
            if (t.nodeType == Node.ELEMENT_NODE) return this.b(t);
        return null
    }, Ty.prototype.b = function(t) { return (t = fr({}, oL, t, [])) ? t : null };
    var rL = [null, "http://www.opengis.net/ows/1.1"],
        oL = pr(rL, { ServiceIdentification: sr(function(t, e) { return fr({}, mL, t, e) }), ServiceProvider: sr(function(t, e) { return fr({}, vL, t, e) }), OperationsMetadata: sr(function(t, e) { return fr({}, fL, t, e) }) }),
        sL = pr(rL, { DeliveryPoint: sr(td), City: sr(td), AdministrativeArea: sr(td), PostalCode: sr(td), Country: sr(td), ElectronicMailAddress: sr(td) }),
        aL = pr(rL, { Value: or(function(t) { return td(t) }) }),
        hL = pr(rL, { AllowedValues: sr(function(t, e) { return fr({}, aL, t, e) }) }),
        lL = pr(rL, { Phone: sr(function(t, e) { return fr({}, gL, t, e) }), Address: sr(function(t, e) { return fr({}, sL, t, e) }) }),
        uL = pr(rL, { HTTP: sr(function(t, e) { return fr({}, pL, t, e) }) }),
        pL = pr(rL, { Get: or(function(t, e) { var i = Iy(t); return i ? fr({ href: i }, dL, t, e) : void 0 }), Post: void 0 }),
        cL = pr(rL, { DCP: sr(function(t, e) { return fr({}, uL, t, e) }) }),
        fL = pr(rL, {
            Operation: function(t, e) {
                var i = t.getAttribute("name"),
                    n = fr({}, cL, t, e);
                n && (e[e.length - 1][i] = n)
            }
        }),
        gL = pr(rL, { Voice: sr(td), Facsimile: sr(td) }),
        dL = pr(rL, { Constraint: or(function(t, e) { var i = t.getAttribute("name"); return i ? fr({ name: i }, hL, t, e) : void 0 }) }),
        yL = pr(rL, { IndividualName: sr(td), PositionName: sr(td), ContactInfo: sr(function(t, e) { return fr({}, lL, t, e) }) }),
        mL = pr(rL, { Title: sr(td), ServiceTypeVersion: sr(td), ServiceType: sr(td) }),
        vL = pr(rL, { ProviderName: sr(td), ProviderSite: sr(Iy), ServiceContact: sr(function(t, e) { return fr({}, yL, t, e) }) });
    m(Ry, bd), sb = Ry.prototype, sb.De = function(t, e) { var i = this.Fe(t, e); return new Tn(i) }, sb.Mh = function(t, e) { return [this.De(t, e)] }, sb.Fe = function(t, e) {
        var i = te(this.a),
            n = Py(t, i, this.b);
        return Ay(n, n.length, i, n), i = ve(n, 0, n.length, i), On(new Fe(i, this.a), !1, Pn(this, e))
    }, sb.mg = function(t, e) { var i = t.Y(); return i ? this.Pe(i, e) : (x(!1, 40), "") }, sb.ml = function(t, e) { return this.mg(t[0], e) }, sb.Pe = function(t, e) {
        t = On(t, !0, Pn(this, e));
        var i = t.oa(),
            n = t.Aa();
        return Ay(i, i.length, n, i), _y(i, n, this.b)
    }, m(Fy, Dn), Fy.prototype.Lh = function(t, e) {
        if ("Topology" == t.type) {
            var i, n = null,
                r = null;
            t.transform && (i = t.transform, n = i.scale, r = i.translate);
            var o = t.arcs;
            if (i) {
                i = n;
                var s, a, h = r;
                for (s = 0, a = o.length; s < a; ++s) {
                    var l, u, p, c = o[s],
                        f = i,
                        g = h,
                        d = 0,
                        y = 0;
                    for (u = 0, p = c.length; u < p; ++u) l = c[u], d += l[0], y += l[1], l[0] = d, l[1] = y, zy(l, f, g)
                }
            }
            for (i = [], h = it(t.objects), s = 0, a = h.length; s < a; ++s) "GeometryCollection" === h[s].type ? (c = h[s], i.push.apply(i, By(c, o, n, r, e))) : (c = h[s], i.push(jy(c, o, n, r, e)));
            return i
        }
        return []
    }, Fy.prototype.ib = function() { return this.defaultDataProjection };
    var bL = {
        Point: function(t, e, i) { return t = t.coordinates, e && i && zy(t, e, i), new se(t) },
        LineString: function(t, e) { var i = Uy(t.arcs, e); return new Fe(i) },
        Polygon: function(t, e) { var i, n, r = []; for (i = 0, n = t.arcs.length; i < n; ++i) r[i] = Uy(t.arcs[i], e); return new Ze(r) },
        MultiPoint: function(t, e, i) {
            t = t.coordinates;
            var n, r;
            if (e && i)
                for (n = 0, r = t.length; n < r; ++n) zy(t[n], e, i);
            return new we(t)
        },
        MultiLineString: function(t, e) { var i, n, r = []; for (i = 0, n = t.arcs.length; i < n; ++i) r[i] = Uy(t.arcs[i], e); return new Be(r) },
        MultiPolygon: function(t, e) {
            var i, n, r, o, s, a, h = [];
            for (s = 0, a = t.arcs.length; s < a; ++s) {
                for (i = t.arcs[s], n = [], r = 0, o = i.length; r < o; ++r) n[r] = Uy(i[r], e);
                h[s] = n
            }
            return new ni(h)
        }
    };
    m(Gy, qg), Gy.prototype.Zc = function(t, e) { var i = { featureType: this.i, featureNS: this.g }; return db(i, _n(this, t, e ? e : {})), i = [i], this.b.b["http://www.opengis.net/gml"].featureMember = nr(Xg.prototype.Ee), (i = fr([], this.b.b, t, i, this.b)) || (i = []), i }, Gy.prototype.j = function(t) { return Qn(t) ? Wy(t) : tr(t) ? fr({}, NL, t, []) : "string" == typeof t ? (t = er(t), Wy(t)) : void 0 }, Gy.prototype.l = function(t) { return Qn(t) ? qy(this, t) : tr(t) ? Vy(this, t) : "string" == typeof t ? (t = er(t), qy(this, t)) : void 0 };
    var wL = { "http://www.opengis.net/gml": { boundedBy: sr(Xg.prototype.$f, "bounds") } },
        xL = { "http://www.opengis.net/wfs": { totalInserted: sr(Jg), totalUpdated: sr(Jg), totalDeleted: sr(Jg) } },
        EL = { "http://www.opengis.net/ogc": { FeatureId: nr(function(t) { return t.getAttribute("fid") }) } },
        SL = { "http://www.opengis.net/wfs": { Feature: function(t, e) { cr(EL, t, e) } } },
        NL = { "http://www.opengis.net/wfs": { TransactionSummary: sr(function(t, e) { return fr({}, xL, t, e) }, "transactionSummary"), InsertResults: sr(function(t, e) { return fr([], SL, t, e) }, "insertIds") } },
        LL = { "http://www.opengis.net/wfs": { PropertyName: ar(rd) } },
        CL = {
            "http://www.opengis.net/wfs": {
                Insert: ar(function(t, e, i) {
                    var n = i[i.length - 1],
                        n = $n(n.featureNS, n.featureType);
                    t.appendChild(n), od.prototype.ll(n, e, i)
                }),
                Update: ar(function(t, e, i) {
                    var n = i[i.length - 1];
                    x(void 0 !== e.Ja(), 27);
                    var r = n.featureType,
                        o = n.featurePrefix,
                        o = o ? o : "feature",
                        s = n.featureNS;
                    if (t.setAttribute("typeName", o + ":" + r), t.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:" + o, s), r = e.Ja(), void 0 !== r) {
                        for (var o = e.R(), s = [], a = 0, h = o.length; a < h; a++) {
                            var l = e.get(o[a]);
                            void 0 !== l && s.push({ name: o[a], value: l })
                        }
                        dr({ node: t, srsName: n.srsName }, CL, lr("Property"), s, i), Xy(t, r)
                    }
                }),
                Delete: ar(function(t, e, i) {
                    var n = i[i.length - 1];
                    x(void 0 !== e.Ja(), 26), i = n.featureType;
                    var r = n.featurePrefix,
                        r = r ? r : "feature",
                        n = n.featureNS;
                    t.setAttribute("typeName", r + ":" + i), t.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:" + r, n), e = e.Ja(), void 0 !== e && Xy(t, e)
                }),
                Property: ar(function(t, e, i) {
                    var n = $n("http://www.opengis.net/wfs", "Name");
                    t.appendChild(n), rd(n, e.name), void 0 !== e.value && null !== e.value && (n = $n("http://www.opengis.net/wfs", "Value"), t.appendChild(n), e.value instanceof Zt ? od.prototype.Xd(n, e.value, i) : rd(n, e.value))
                }),
                Native: ar(function(t, e) { e.ts && t.setAttribute("vendorId", e.ts), void 0 !== e.Xr && t.setAttribute("safeToIgnore", e.Xr), void 0 !== e.value && rd(t, e.value) })
            }
        },
        ML = {
            "http://www.opengis.net/wfs": {
                Query: ar(function(t, e, i) {
                    var n = i[i.length - 1],
                        r = n.featurePrefix,
                        o = n.featureNS,
                        s = n.propertyNames,
                        a = n.srsName;
                    t.setAttribute("typeName", (r ? r + ":" : "") + e), a && t.setAttribute("srsName", a), o && t.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:" + r, o), e = db({}, n), e.node = t, dr(e, LL, lr("PropertyName"), s, i), (n = n.filter) && (s = $n("http://www.opengis.net/ogc", "Filter"), t.appendChild(s), dr({ node: s }, ML, lr(n.jc), [n], i))
                })
            },
            "http://www.opengis.net/ogc": { And: ar(Hy), Or: ar(Hy), Not: ar(function(t, e, i) { e = e.condition, dr({ node: t }, ML, lr(e.jc), [e], i) }), BBOX: ar(function(t, e, i) { i[i.length - 1].srsName = e.srsName, $y(t, e.geometryName), od.prototype.Xd(t, e.extent, i) }), Intersects: ar(function(t, e, i) { i[i.length - 1].srsName = e.srsName, $y(t, e.geometryName), od.prototype.Xd(t, e.geometry, i) }), Within: ar(function(t, e, i) { i[i.length - 1].srsName = e.srsName, $y(t, e.geometryName), od.prototype.Xd(t, e.geometry, i) }), PropertyIsEqualTo: ar(Yy), PropertyIsNotEqualTo: ar(Yy), PropertyIsLessThan: ar(Yy), PropertyIsLessThanOrEqualTo: ar(Yy), PropertyIsGreaterThan: ar(Yy), PropertyIsGreaterThanOrEqualTo: ar(Yy), PropertyIsNull: ar(function(t, e) { $y(t, e.b) }), PropertyIsBetween: ar(function(t, e) { $y(t, e.b), Ky("LowerBoundary", t, "" + e.a), Ky("UpperBoundary", t, "" + e.g) }), PropertyIsLike: ar(function(t, e) { t.setAttribute("wildCard", e.i), t.setAttribute("singleChar", e.c), t.setAttribute("escapeChar", e.g), void 0 !== e.a && t.setAttribute("matchCase", e.a.toString()), $y(t, e.b), Ky("Literal", t, "" + e.f) }) }
        };
    Gy.prototype.o = function(t) {
        var e = $n("http://www.opengis.net/wfs", "GetFeature");
        e.setAttribute("service", "WFS"), e.setAttribute("version", "1.1.0");
        var i;
        if (t && (t.handle && e.setAttribute("handle", t.handle), t.outputFormat && e.setAttribute("outputFormat", t.outputFormat), void 0 !== t.maxFeatures && e.setAttribute("maxFeatures", t.maxFeatures), t.resultType && e.setAttribute("resultType", t.resultType), void 0 !== t.startIndex && e.setAttribute("startIndex", t.startIndex), void 0 !== t.count && e.setAttribute("count", t.count), i = t.filter, t.bbox)) {
            x(t.geometryName, 12);
            var n = Ly(t.geometryName, t.bbox, t.srsName);
            i = i ? Ny(i, n) : n
        }
        return e.setAttributeNS("http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation", this.c), i = { node: e, srsName: t.srsName, featureNS: t.featureNS ? t.featureNS : this.g, featurePrefix: t.featurePrefix, geometryName: t.geometryName, filter: i, propertyNames: t.propertyNames ? t.propertyNames : [] }, x(Array.isArray(t.featureTypes), 11), t = t.featureTypes, i = [i], n = db({}, i[i.length - 1]), n.node = e, dr(n, ML, lr("Query"), t, i), e
    }, Gy.prototype.T = function(t, e, i, n) {
        var r = [],
            o = $n("http://www.opengis.net/wfs", "Transaction");
        o.setAttribute("service", "WFS"), o.setAttribute("version", "1.1.0");
        var s, a;
        return n && (s = n.gmlOptions ? n.gmlOptions : {}, n.handle && o.setAttribute("handle", n.handle)), o.setAttributeNS("http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation", this.c), t && (a = { node: o, featureNS: n.featureNS, featureType: n.featureType, featurePrefix: n.featurePrefix, srsName: n.srsName }, db(a, s), dr(a, CL, lr("Insert"), t, r)), e && (a = { node: o, featureNS: n.featureNS, featureType: n.featureType, featurePrefix: n.featurePrefix, srsName: n.srsName }, db(a, s), dr(a, CL, lr("Update"), e, r)), i && dr({ node: o, featureNS: n.featureNS, featureType: n.featureType, featurePrefix: n.featurePrefix, srsName: n.srsName }, CL, lr("Delete"), i, r), n.nativeElements && dr({ node: o, featureNS: n.featureNS, featureType: n.featureType, featurePrefix: n.featurePrefix, srsName: n.srsName }, CL, lr("Native"), n.nativeElements, r), o
    }, Gy.prototype.Rh = function(t) {
        for (t = t.firstChild; t; t = t.nextSibling)
            if (t.nodeType == Node.ELEMENT_NODE) return this.cg(t);
        return null
    }, Gy.prototype.cg = function(t) {
        if (t.firstElementChild && t.firstElementChild.firstElementChild)
            for (t = t.firstElementChild.firstElementChild, t = t.firstElementChild; t; t = t.nextElementSibling)
                if (0 !== t.childNodes.length && (1 !== t.childNodes.length || 3 !== t.firstChild.nodeType)) { var e = [{}]; return this.b.$f(t, e), qt(e.pop().srsName) }
        return null
    }, m(Zy, bd);
    var IL = {
        Point: Jy,
        LineString: Qy,
        Polygon: tm,
        MultiPoint: function(t) {
            var e = [];
            t = t.If();
            for (var i = 0, n = t.length; i < n; ++i) e.push("(" + Jy(t[i]) + ")");
            return e.join(",")
        },
        MultiLineString: function(t) {
            var e = [];
            t = t.re();
            for (var i = 0, n = t.length; i < n; ++i) e.push("(" + Qy(t[i]) + ")");
            return e.join(",")
        },
        MultiPolygon: function(t) {
            var e = [];
            t = t.lf();
            for (var i = 0, n = t.length; i < n; ++i) e.push("(" + tm(t[i]) + ")");
            return e.join(",")
        },
        GeometryCollection: function(t) {
            var e = [];
            t = t.Vg();
            for (var i = 0, n = t.length; i < n; ++i) e.push(em(t[i]));
            return e.join(",")
        }
    };
    sb = Zy.prototype, sb.De = function(t, e) { var i = this.Fe(t, e); if (i) { var n = new Tn; return n.ob(i), n } return null }, sb.Mh = function(t, e) {
        var i = [],
            n = this.Fe(t, e);
        i = this.b && "GeometryCollection" == n.Z() ? n.f : [n];
        for (var r = [], o = 0, s = i.length; o < s; ++o) n = new Tn, n.ob(i[o]), r.push(n);
        return r
    }, sb.Fe = function(t, e) { var i; return i = new rm(new im(t)), i.b = nm(i.a), (i = om(i)) ? On(i, !1, e) : null }, sb.mg = function(t, e) { var i = t.Y(); return i ? this.Pe(i, e) : "" }, sb.ml = function(t, e) { if (1 == t.length) return this.mg(t[0], e); for (var i = [], n = 0, r = t.length; n < r; ++n) i.push(t[n].Y()); return i = new Un(i), this.Pe(i, e) }, sb.Pe = function(t, e) { return em(On(t, !0, e)) }, sb = rm.prototype, sb.match = function(t) { return (t = this.b.type == t) && (this.b = nm(this.a)), t }, sb.Gh = function() { if (this.match(2)) { var t = sm(this); if (this.match(3)) return t } else if (lm(this)) return null; throw Error(um(this)) }, sb.Fh = function() { if (this.match(2)) { var t = am(this); if (this.match(3)) return t } else if (lm(this)) return []; throw Error(um(this)) }, sb.Hh = function() { if (this.match(2)) { var t = hm(this); if (this.match(3)) return t } else if (lm(this)) return []; throw Error(um(this)) }, sb.jr = function() {
        if (this.match(2)) {
            var t;
            if (2 == this.b.type)
                for (t = [this.Gh()]; this.match(5);) t.push(this.Gh());
            else t = am(this);
            if (this.match(3)) return t
        } else if (lm(this)) return [];
        throw Error(um(this))
    }, sb.ir = function() { if (this.match(2)) { var t = hm(this); if (this.match(3)) return t } else if (lm(this)) return []; throw Error(um(this)) }, sb.kr = function() { if (this.match(2)) { for (var t = [this.Hh()]; this.match(5);) t.push(this.Hh()); if (this.match(3)) return t } else if (lm(this)) return []; throw Error(um(this)) };
    var kL = { POINT: se, LINESTRING: Fe, POLYGON: Ze, MULTIPOINT: we, MULTILINESTRING: Be, MULTIPOLYGON: ni },
        TL = { POINT: rm.prototype.Gh, LINESTRING: rm.prototype.Fh, POLYGON: rm.prototype.Hh, MULTIPOINT: rm.prototype.jr, MULTILINESTRING: rm.prototype.ir, MULTIPOLYGON: rm.prototype.kr };
    m(pm, ky), pm.prototype.a = function(t) {
        for (t = t.firstChild; t; t = t.nextSibling)
            if (t.nodeType == Node.ELEMENT_NODE) return this.b(t);
        return null
    }, pm.prototype.b = function(t) { return this.version = t.getAttribute("version").trim(), (t = fr({ version: this.version }, RL, t, [])) ? t : null };
    var AL = [null, "http://www.opengis.net/wms"],
        RL = pr(AL, { Service: sr(function(t, e) { return fr({}, PL, t, e) }), Capability: sr(function(t, e) { return fr({}, _L, t, e) }) }),
        _L = pr(AL, { Request: sr(function(t, e) { return fr({}, GL, t, e) }), Exception: sr(function(t, e) { return fr([], UL, t, e) }), Layer: sr(function(t, e) { return fr({}, BL, t, e) }) }),
        PL = pr(AL, { Name: sr(td), Title: sr(td), Abstract: sr(td), KeywordList: sr(dm), OnlineResource: sr(Iy), ContactInformation: sr(function(t, e) { return fr({}, OL, t, e) }), Fees: sr(td), AccessConstraints: sr(td), LayerLimit: sr(Jg), MaxWidth: sr(Jg), MaxHeight: sr(Jg) }),
        OL = pr(AL, { ContactPersonPrimary: sr(function(t, e) { return fr({}, DL, t, e) }), ContactPosition: sr(td), ContactAddress: sr(function(t, e) { return fr({}, FL, t, e) }), ContactVoiceTelephone: sr(td), ContactFacsimileTelephone: sr(td), ContactElectronicMailAddress: sr(td) }),
        DL = pr(AL, { ContactPerson: sr(td), ContactOrganization: sr(td) }),
        FL = pr(AL, { AddressType: sr(td), Address: sr(td), City: sr(td), StateOrProvince: sr(td), PostCode: sr(td), Country: sr(td) }),
        UL = pr(AL, { Format: nr(td) }),
        BL = pr(AL, {
            Name: sr(td),
            Title: sr(td),
            Abstract: sr(td),
            KeywordList: sr(dm),
            CRS: or(td),
            EX_GeographicBoundingBox: sr(function(t, e) {
                var i = fr({}, zL, t, e);
                if (i) {
                    var n = i.westBoundLongitude,
                        r = i.southBoundLatitude,
                        o = i.eastBoundLongitude,
                        i = i.northBoundLatitude;
                    return void 0 === n || void 0 === r || void 0 === o || void 0 === i ? void 0 : [n, r, o, i]
                }
            }),
            BoundingBox: or(function(t) {
                var e = [Zg(t.getAttribute("minx")), Zg(t.getAttribute("miny")), Zg(t.getAttribute("maxx")), Zg(t.getAttribute("maxy"))],
                    i = [Zg(t.getAttribute("resx")), Zg(t.getAttribute("resy"))];
                return { crs: t.getAttribute("CRS"), extent: e, res: i }
            }),
            Dimension: or(function(t) { return { name: t.getAttribute("name"), units: t.getAttribute("units"), unitSymbol: t.getAttribute("unitSymbol"), default: t.getAttribute("default"), multipleValues: Yg(t.getAttribute("multipleValues")), nearestValue: Yg(t.getAttribute("nearestValue")), current: Yg(t.getAttribute("current")), values: td(t) } }),
            Attribution: sr(function(t, e) { return fr({}, jL, t, e) }),
            AuthorityURL: or(function(t, e) { var i = cm(t, e); if (i) return i.name = t.getAttribute("name"), i }),
            Identifier: or(td),
            MetadataURL: or(function(t, e) { var i = cm(t, e); if (i) return i.type = t.getAttribute("type"), i }),
            DataURL: or(cm),
            FeatureListURL: or(cm),
            Style: or(function(t, e) { return fr({}, XL, t, e) }),
            MinScaleDenominator: sr($g),
            MaxScaleDenominator: sr($g),
            Layer: or(function(t, e) {
                var i = e[e.length - 1],
                    n = fr({}, BL, t, e);
                if (n) {
                    var r = Yg(t.getAttribute("queryable"));
                    return void 0 === r && (r = i.queryable), n.queryable = void 0 !== r && r, r = Qg(t.getAttribute("cascaded")), void 0 === r && (r = i.cascaded), n.cascaded = r,
                        r = Yg(t.getAttribute("opaque")), void 0 === r && (r = i.opaque), n.opaque = void 0 !== r && r, r = Yg(t.getAttribute("noSubsets")), void 0 === r && (r = i.noSubsets), n.noSubsets = void 0 !== r && r, (r = Zg(t.getAttribute("fixedWidth"))) || (r = i.fixedWidth), n.fixedWidth = r, (r = Zg(t.getAttribute("fixedHeight"))) || (r = i.fixedHeight), n.fixedHeight = r, ["Style", "CRS", "AuthorityURL"].forEach(function(t) { t in i && (n[t] = (n[t] || []).concat(i[t])) }), "EX_GeographicBoundingBox BoundingBox Dimension Attribution MinScaleDenominator MaxScaleDenominator".split(" ").forEach(function(t) { t in n || (n[t] = i[t]) }), n
                }
            })
        }),
        jL = pr(AL, { Title: sr(td), OnlineResource: sr(Iy), LogoURL: sr(gm) }),
        zL = pr(AL, { westBoundLongitude: sr($g), eastBoundLongitude: sr($g), southBoundLatitude: sr($g), northBoundLatitude: sr($g) }),
        GL = pr(AL, { GetCapabilities: sr(fm), GetMap: sr(fm), GetFeatureInfo: sr(fm) }),
        qL = pr(AL, { Format: or(td), DCPType: or(function(t, e) { return fr({}, VL, t, e) }) }),
        VL = pr(AL, { HTTP: sr(function(t, e) { return fr({}, WL, t, e) }) }),
        WL = pr(AL, { Get: sr(cm), Post: sr(cm) }),
        XL = pr(AL, { Name: sr(td), Title: sr(td), Abstract: sr(td), LegendURL: or(gm), StyleSheetURL: sr(cm), StyleURL: sr(cm) }),
        HL = pr(AL, { Format: sr(td), OnlineResource: sr(Iy) }),
        YL = pr(AL, { Keyword: nr(td) });
    m(ym, qg), ym.prototype.Zc = function(t, e) {
        var i = {};
        e && db(i, _n(this, t, e));
        var n = [i];
        t.setAttribute("namespaceURI", this.g);
        var r = t.localName,
            i = [];
        if (0 !== t.childNodes.length) {
            if ("msGMLOutput" == r)
                for (var o = 0, s = t.childNodes.length; o < s; o++) {
                    var a = t.childNodes[o];
                    if (a.nodeType === Node.ELEMENT_NODE) {
                        var h = n[0],
                            l = a.localName.replace("_layer", "");
                        if (!this.c || he(this.c, l)) {
                            l += "_feature", h.featureType = l, h.featureNS = this.g;
                            var u = {};
                            u[l] = nr(this.b.Kh, this.b), h = pr([h.featureNS, null], u), a.setAttribute("namespaceURI", this.g), (a = fr([], h, a, n, this.b)) && pe(i, a)
                        }
                    }
                }
            "FeatureCollection" == r && (n = fr([], this.b.b, t, [{}], this.b)) && (i = n)
        }
        return i
    }, m(mm, ky), mm.prototype.a = function(t) {
        for (t = t.firstChild; t; t = t.nextSibling)
            if (t.nodeType == Node.ELEMENT_NODE) return this.b(t);
        return null
    }, mm.prototype.b = function(t) {
        var e = t.getAttribute("version").trim(),
            i = this.g.b(t);
        return i ? (i.version = e, (i = fr(i, ZL, t, [])) ? i : null) : null
    };
    var KL = [null, "http://www.opengis.net/wmts/1.0"],
        $L = [null, "http://www.opengis.net/ows/1.1"],
        ZL = pr(KL, { Contents: sr(function(t, e) { return fr({}, JL, t, e) }) }),
        JL = pr(KL, { Layer: or(function(t, e) { return fr({}, QL, t, e) }), TileMatrixSet: or(function(t, e) { return fr({}, rC, t, e) }) }),
        QL = pr(KL, {
            Style: or(function(t, e) { var i = fr({}, tC, t, e); if (i) { var n = "true" === t.getAttribute("isDefault"); return i.isDefault = n, i } }),
            Format: or(td),
            TileMatrixSetLink: or(function(t, e) { return fr({}, eC, t, e) }),
            Dimension: or(function(t, e) { return fr({}, iC, t, e) }),
            ResourceURL: or(function(t) {
                var e = t.getAttribute("format"),
                    i = t.getAttribute("template");
                t = t.getAttribute("resourceType");
                var n = {};
                return e && (n.format = e), i && (n.template = i), t && (n.resourceType = t), n
            })
        }, pr($L, { Title: sr(td), Abstract: sr(td), WGS84BoundingBox: sr(function(t, e) { var i = fr([], nC, t, e); return 2 != i.length ? void 0 : E(i) }), Identifier: sr(td) })),
        tC = pr(KL, { LegendURL: or(function(t) { var e = {}; return e.format = t.getAttribute("format"), e.href = Iy(t), e }) }, pr($L, { Title: sr(td), Identifier: sr(td) })),
        eC = pr(KL, { TileMatrixSet: sr(td) }),
        iC = pr(KL, { Default: sr(td), Value: or(td) }, pr($L, { Identifier: sr(td) })),
        nC = pr($L, { LowerCorner: nr(vm), UpperCorner: nr(vm) }),
        rC = pr(KL, { WellKnownScaleSet: sr(td), TileMatrix: or(function(t, e) { return fr({}, oC, t, e) }) }, pr($L, { SupportedCRS: sr(td), Identifier: sr(td) })),
        oC = pr(KL, { TopLeftCorner: sr(vm), ScaleDenominator: sr($g), TileWidth: sr(Jg), TileHeight: sr(Jg), MatrixWidth: sr(Jg), MatrixHeight: sr(Jg) }, pr($L, { Identifier: sr(td) }));
    m(bm, St), sb = bm.prototype, sb.pa = function() { this.Ef(!1), St.prototype.pa.call(this) }, sb.Ro = function() {
        var t = this.wj();
        t && (this.c = Xt(qt("EPSG:4326"), t), this.a && this.set("position", this.c(this.a)))
    }, sb.So = function() {
        if (vw) {
            var t = this.xj();
            t && void 0 === this.f ? this.f = gb.navigator.geolocation.watchPosition(this.rr.bind(this), this.sr.bind(this), this.Xi()) : t || void 0 === this.f || (gb.navigator.geolocation.clearWatch(this.f), this.f = void 0)
        }
    }, sb.rr = function(t) {
        t = t.coords, this.set("accuracy", t.accuracy), this.set("altitude", null === t.altitude ? void 0 : t.altitude), this.set("altitudeAccuracy", null === t.altitudeAccuracy ? void 0 : t.altitudeAccuracy), this.set("heading", null === t.heading ? void 0 : Tt(t.heading)), this.a ? (this.a[0] = t.longitude, this.a[1] = t.latitude) : this.a = [t.longitude, t.latitude];
        var e = this.c(this.a);
        this.set("position", e), this.set("speed", null === t.speed ? void 0 : t.speed), t = Qe(IE, this.a, t.accuracy), t.cd(this.c), this.set("accuracyGeometry", t), this.u()
    }, sb.sr = function(t) { t.type = "error", this.Ef(!1), this.b(t) }, sb.wm = function() { return this.get("accuracy") }, sb.xm = function() { return this.get("accuracyGeometry") || null }, sb.zm = function() { return this.get("altitude") }, sb.Am = function() { return this.get("altitudeAccuracy") }, sb.Po = function() { return this.get("heading") }, sb.Qo = function() { return this.get("position") }, sb.wj = function() { return this.get("projection") }, sb.$m = function() { return this.get("speed") }, sb.xj = function() { return this.get("tracking") }, sb.Xi = function() { return this.get("trackingOptions") }, sb.yj = function(t) { this.set("projection", t) }, sb.Ef = function(t) { this.set("tracking", t) }, sb.Xk = function(t) { this.set("trackingOptions", t) }, m(wm, Qt), sb = wm.prototype, sb.clone = function() {
        var t = new wm(null),
            e = this.B.slice();
        return ee(t, this.ma, e), t.u(), t
    }, sb.Ob = function(t, e, i, n) {
        var r = this.B;
        t -= r[0];
        var o = e - r[1];
        if (e = t * t + o * o, e < n) {
            if (0 === e)
                for (n = 0; n < this.a; ++n) i[n] = r[n];
            else
                for (n = this.yh() / Math.sqrt(e), i[0] = r[0] + n * t, i[1] = r[1] + n * o, n = 2; n < this.a; ++n) i[n] = r[n];
            return i.length = this.a, e
        }
        return n
    }, sb.pd = function(t, e) {
        var i = this.B,
            n = t - i[0],
            i = e - i[1];
        return n * n + i * i <= xm(this)
    }, sb.Ae = function() { return this.B.slice(0, this.a) }, sb.bf = function(t) {
        var e = this.B,
            i = e[this.a] - e[0];
        return A(e[0] - i, e[1] - i, e[0] + i, e[1] + i, t)
    }, sb.yh = function() { return Math.sqrt(xm(this)) }, sb.Z = function() { return "Circle" }, sb.ab = function(t) { var e = this.H(); return !!K(t, e) && (e = this.Ae(), t[0] <= e[0] && t[2] >= e[0] || t[1] <= e[1] && t[3] >= e[1] || U(t, this.Cb, this)) }, sb.kp = function(t) {
        var e = this.a,
            i = this.B[e] - this.B[0],
            n = t.slice();
        for (n[e] = n[0] + i, i = 1; i < e; ++i) n[e + i] = t[i];
        ee(this, this.ma, n), this.u()
    }, sb.Yh = function(t, e, i) {
        if (t) {
            ie(this, i, t, 0), this.B || (this.B = []), i = this.B, t = ne(i, t), i[t++] = i[0] + e;
            var n;
            for (e = 1, n = this.a; e < n; ++e) i[t++] = i[e];
            i.length = t
        } else ee(this, "XY", null);
        this.u()
    }, sb.lp = function(t) { this.B[this.a] = this.B[0] + t, this.u() };
    var sC = new Vi({ color: "rgba(0,0,0,0.2)" }),
        aC = [90, 45, 30, 20, 10, 5, 2, 1, .5, .2, .1, .05, .01, .005, .002, .001];
    sb = Lm.prototype, sb.To = function() { return this.j }, sb.Om = function() { return this.b }, sb.Um = function() { return this.a }, sb.ij = function(t) {
        var e = t.vectorContext,
            i = t.frameState,
            n = i.extent;
        t = i.viewState;
        var r = t.center,
            o = t.projection,
            s = t.resolution;
        if (t = i.pixelRatio, t = s * s / (4 * t * t), !this.c || !Vt(this.c, o)) {
            var a = qt("EPSG:4326"),
                h = o.H(),
                l = o.i,
                u = $t(l, a, o),
                p = l[2],
                c = l[1],
                f = l[0],
                g = u[3],
                d = u[2],
                y = u[1],
                u = u[0];
            this.i = l[3], this.g = p, this.l = c, this.f = f, this.T = g, this.v = d, this.C = y, this.D = u, this.o = Wt(a, o), this.A = Wt(o, a), this.s = this.A(G(h)), this.c = o
        }
        for (o.a && (o = o.H(), a = Y(o), i = i.focus[0], i < o[0] || i > o[2]) && (i = a * Math.ceil((o[0] - i) / a), n = [n[0] + i, n[1], n[2] + i, n[3]]), i = this.s[0], o = this.s[1], a = -1, l = Math.pow(this.za * s, 2), p = [], c = [], s = 0, h = aC.length; s < h && (f = aC[s] / 2, p[0] = i - f, p[1] = o - f, c[0] = i + f, c[1] = o + f, this.o(p, p), this.o(c, c), f = Math.pow(c[0] - p[0], 2) + Math.pow(c[1] - p[1], 2), !(f <= l)); ++s) a = aC[s];
        if (s = a, -1 == s) this.b.length = this.a.length = 0;
        else {
            for (i = this.A(r), r = i[0], i = i[1], o = this.O, a = [Math.max(n[0], this.D), Math.max(n[1], this.C), Math.min(n[2], this.v), Math.min(n[3], this.T)], a = $t(a, this.c, "EPSG:4326"), l = a[3], c = a[1], r = Math.floor(r / s) * s, p = Ct(r, this.f, this.g), h = Cm(this, p, c, l, t, n, 0), a = 0; p != this.f && a++ < o;) p = Math.max(p - s, this.f), h = Cm(this, p, c, l, t, n, h);
            for (p = Ct(r, this.f, this.g), a = 0; p != this.g && a++ < o;) p = Math.min(p + s, this.g), h = Cm(this, p, c, l, t, n, h);
            for (this.b.length = h, i = Math.floor(i / s) * s, r = Ct(i, this.l, this.i), h = Mm(this, r, t, n, 0), a = 0; r != this.l && a++ < o;) r = Math.max(r - s, this.l), h = Mm(this, r, t, n, h);
            for (r = Ct(i, this.l, this.i), a = 0; r != this.i && a++ < o;) r = Math.min(r + s, this.i), h = Mm(this, r, t, n, h);
            this.a.length = h
        }
        for (e.wc(null, this.sa), t = 0, r = this.b.length; t < r; ++t) s = this.b[t], e.le(s, null);
        for (t = 0, r = this.a.length; t < r; ++t) s = this.a[t], e.le(s, null)
    }, sb.setMap = function(t) { this.j && (this.j.J("postcompose", this.ij, this), this.j.render()), t && (t.I("postcompose", this.ij, this), t.render()), this.j = t }, m(Im, Zu), Im.prototype.j = function(t, e) {
        var i = e.target.result,
            n = this.A,
            r = this.o;
        r || (r = n.$().j);
        var o, s, n = this.c,
            a = [];
        for (o = 0, s = n.length; o < s; ++o) {
            var h = new n[o],
                l = { featureProjection: r };
            try { a = h.Ia(i, l) } catch (t) { a = null }
            if (a && 0 < a.length) break
        }
        this.b(new Am(hC, t, a, r))
    }, Im.prototype.setMap = function(t) { this.a && (this.a.forEach(ct), this.a = null), Zu.prototype.setMap.call(this, t), t && (t = this.target ? this.target : t.a, this.a = [lt(t, "drop", km, this), lt(t, "dragenter", Tm, this), lt(t, "dragover", Tm, this), lt(t, "drop", Tm, this)]) };
    var hC = "addfeatures";
    m(Am, dt), m(Rm, cp), m(Dm, dt), m(Fm, cp), sb = Fm.prototype, sb.setMap = function(t) { cp.prototype.setMap.call(this, t), this.hl() }, sb.Rr = function() {
        var t, e, i = this.o.Y();
        this.c === uC ? (t = this.a, t.splice(-2, 1), this.D(t, i)) : this.c === pC && (t = this.a[0], t.splice(-2, 1), e = this.v.Y(), e.wa(t), this.D(this.a, i)), 0 === t.length && (this.s = null), Hm(this)
    }, sb.me = function() {
        var t = Xm(this),
            e = this.a,
            i = t.Y();
        this.c === uC ? (e.pop(), this.D(e, i)) : this.c === pC && (e[0].pop(), e[0].push(e[0][0]), this.D(e, i)), "MultiPoint" === this.X ? t.ob(new we([e])) : "MultiLineString" === this.X ? t.ob(new Be([e])) : "MultiPolygon" === this.X && t.ob(new ni([e])), this.b(new Dm("drawend", t)), this.sb && this.sb.push(t), this.bc && this.bc.Nb(t)
    }, sb.sp = function(t) {
        var e = t.Y();
        this.o = t, this.a = e.ba(), t = this.a[this.a.length - 1], this.s = t.slice(), this.a.push(t.slice()), Hm(this), this.b(new Dm("drawstart", this.o))
    }, sb.ud = tt, sb.hl = function() {
        var t = this.A,
            e = this.f();
        t && e || Xm(this), this.qa.setMap(e ? t : null)
    };
    var lC = "Point",
        uC = "LineString",
        pC = "Polygon",
        cC = "Circle";
    m(Km, dt), m($m, cp), sb = $m.prototype, sb.zh = function(t) {
        var e = t.Y();
        e && e.Z() in this.ra && this.ra[e.Z()].call(this, t, e), (e = this.A) && sv(this, this.qa, e), lt(t, "change", this.Ij, this)
    }, sb.setMap = function(t) { this.P.setMap(t), cp.prototype.setMap.call(this, t) }, sb.tp = function(t) { this.zh(t.element) }, sb.Ij = function(t) { this.s || (t = t.target, Jm(this, t), this.zh(t)) }, sb.up = function(t) { Jm(this, t.element) }, sb.zp = function(t, e) {
        var i = e.ba(),
            i = { feature: t, geometry: e, ua: [i, i] };
        this.a.Ka(e.H(), i)
    }, sb.xp = function(t, e) { var i, n, r, o = e.ba(); for (n = 0, r = o.length; n < r; ++n) i = o[n], i = { feature: t, geometry: e, depth: [n], index: n, ua: [i, i] }, this.a.Ka(e.H(), i) }, sb.Jj = function(t, e) { var i, n, r, o, s = e.ba(); for (i = 0, n = s.length - 1; i < n; ++i) r = s.slice(i, i + 2), o = { feature: t, geometry: e, index: i, ua: r }, this.a.Ka(E(r), o) }, sb.wp = function(t, e) {
        var i, n, r, o, s, a, h, l = e.ba();
        for (o = 0, s = l.length; o < s; ++o)
            for (i = l[o], n = 0, r = i.length - 1; n < r; ++n) a = i.slice(n, n + 2), h = { feature: t, geometry: e, depth: [o], index: n, ua: a }, this.a.Ka(E(a), h)
    }, sb.Ap = function(t, e) {
        var i, n, r, o, s, a, h, l = e.ba();
        for (o = 0, s = l.length; o < s; ++o)
            for (i = l[o], n = 0, r = i.length - 1; n < r; ++n) a = i.slice(n, n + 2), h = { feature: t, geometry: e, depth: [o], index: n, ua: a }, this.a.Ka(E(a), h)
    }, sb.yp = function(t, e) {
        var i, n, r, o, s, a, h, l, u, p, c = e.ba();
        for (a = 0, h = c.length; a < h; ++a)
            for (l = c[a], o = 0, s = l.length; o < s; ++o)
                for (i = l[o], n = 0, r = i.length - 1; n < r; ++n) u = i.slice(n, n + 2), p = { feature: t, geometry: e, depth: [o, a], index: n, ua: u }, this.a.Ka(E(u), p)
    }, sb.vp = function(t, e) { var i, n = e.f; for (i = 0; i < n.length; ++i) this.ra[n[i].Z()].call(this, t, n[i]) }, sb.po = function(t, e) {
        for (var i, n = t.ua, r = t.feature, o = t.geometry, s = t.depth, a = t.index; e.length < o.Aa();) e.push(0);
        switch (o.Z()) {
            case "MultiLineString":
                i = o.ba(), i[s[0]].splice(a + 1, 0, e);
                break;
            case "Polygon":
                i = o.ba(), i[s[0]].splice(a + 1, 0, e);
                break;
            case "MultiPolygon":
                i = o.ba(), i[s[1]][s[0]].splice(a + 1, 0, e);
                break;
            case "LineString":
                i = o.ba(), i.splice(a + 1, 0, e);
                break;
            default:
                return
        }
        this.s = !0, o.wa(i), this.s = !1, i = this.a, i.remove(t), av(this, o, a, s, 1);
        var h = { ua: [n[0], e], feature: r, geometry: o, depth: s, index: a };
        i.Ka(E(h.ua), h), this.o.push([h, 1]), n = { ua: [e, n[1]], feature: r, geometry: o, depth: s, index: a + 1 }, i.Ka(E(n.ua), n), this.o.push([n, 0]), this.U = !0
    }, sb.Ek = function() {
        var t = !1;
        if (this.X && this.X.type != gE) {
            var e = this.X;
            Zm(this, e);
            var i, n, r, o, s, a, h, l, u = this.o,
                t = {},
                p = !1;
            for (o = u.length - 1; 0 <= o; --o) r = u[o], h = r[0], l = b(h.feature), h.depth && (l += "-" + h.depth.join("-")), l in t || (t[l] = {}), 0 === r[1] ? (t[l].right = h, t[l].index = h.index) : 1 == r[1] && (t[l].left = h, t[l].index = h.index + 1);
            for (l in t) {
                switch (a = t[l].right, o = t[l].left, r = t[l].index, s = r - 1, h = void 0 !== o ? o : a, 0 > s && (s = 0), u = h.geometry, i = n = u.ba(), p = !1, u.Z()) {
                    case "MultiLineString":
                        2 < n[h.depth[0]].length && (n[h.depth[0]].splice(r, 1), p = !0);
                        break;
                    case "LineString":
                        2 < n.length && (n.splice(r, 1), p = !0);
                        break;
                    case "MultiPolygon":
                        i = i[h.depth[1]];
                    case "Polygon":
                        i = i[h.depth[0]], 4 < i.length && (r == i.length - 1 && (r = 0), i.splice(r, 1), p = !0, 0 === r && (i.pop(), i.push(i[0]), s = i.length - 1))
                }
                p && (i = u, this.s = !0, i.wa(n), this.s = !1, n = [], void 0 !== o && (this.a.remove(o), n.push(o.ua[0])), void 0 !== a && (this.a.remove(a), n.push(a.ua[1])), void 0 !== o && void 0 !== a && (o = { depth: h.depth, feature: h.feature, geometry: h.geometry, index: s, ua: n }, this.a.Ka(E(o.ua), o)), av(this, u, r, h.depth, -1), this.c && (this.P.ja().Kb(this.c), this.c = null))
            }
            t = p, this.b(new Km("modifyend", this.v, e)), this.D = !1
        }
        return t
    }, m(lv, dt), m(uv, Zu), sb = uv.prototype, sb.Cp = function() { return this.c.ja().c }, sb.Dp = function(t) { return x(t instanceof Tn, 42), t = b(t), this.a[t] }, sb.setMap = function(t) {
        var e = this.A,
            i = this.c.ja().c;
        e && i.forEach(e.el, e), Zu.prototype.setMap.call(this, t), this.c.setMap(t), t && i.forEach(t.Zk, t)
    }, sb.Bp = function(t) {
        var e = this.A;
        e && e.Zk(t.element)
    }, sb.Ep = function(t) {
        var e = this.A;
        e && e.el(t.element)
    }, m(fv, cp), sb = fv.prototype, sb.Nb = function(t, e) {
        var i = void 0 === e || e,
            n = b(t),
            r = t.Y();
        if (r) {
            var o = this.ra[r.Z()];
            o && (this.X[n] = r.H(T()), o.call(this, t, r), i && (this.O[n] = lt(r, "change", this.xn.bind(this, t), this)))
        }
        i && (this.D[n] = lt(t, Nt(t.a), this.Fp, this))
    }, sb.qm = function(t) { this.Nb(t) }, sb.rm = function(t) { this.Kb(t) }, sb.Kj = function(t) {
        var e;
        t instanceof Dr ? e = t.feature : t instanceof Hn && (e = t.element), this.Nb(e)
    }, sb.Lj = function(t) {
        var e;
        t instanceof Dr ? e = t.feature : t instanceof Hn && (e = t.element), this.Kb(e)
    }, sb.Fp = function(t) { t = t.target, this.Kb(t, !0), this.Nb(t, !0) }, sb.xn = function(t) {
        if (this.C) {
            var e = b(t);
            e in this.v || (this.v[e] = t)
        } else this.gl(t)
    }, sb.Kb = function(t, e) {
        var i = void 0 === e || e,
            n = b(t),
            r = this.X[n];
        if (r) {
            var o = this.a,
                s = [];
            for (Mr(o, r, function(e) { t === e.feature && s.push(e) }), r = s.length - 1; 0 <= r; --r) o.remove(s[r]);
            i && (xt(this.O[n]), delete this.O[n])
        }
        i && (xt(this.D[n]), delete this.D[n])
    }, sb.setMap = function(t) {
        var e, i = this.A,
            n = this.xa;
        this.o ? e = this.o : this.s && (e = this.s.Pf()), i && (n.forEach(xt), n.length = 0, e.forEach(this.rm, this)), cp.prototype.setMap.call(this, t), t && (this.o ? n.push(lt(this.o, _w, this.Kj, this), lt(this.o, Pw, this.Lj, this)) : this.s && n.push(lt(this.s, "addfeature", this.Kj, this), lt(this.s, "removefeature", this.Lj, this)), e.forEach(this.qm, this))
    }, sb.ud = tt, sb.gl = function(t) { this.Kb(t, !1), this.Nb(t, !1) }, sb.Gp = function(t, e) { var i, n = e.f; for (i = 0; i < n.length; ++i) this.ra[n[i].Z()].call(this, t, n[i]) }, sb.Mj = function(t, e) { var i, n, r, o, s = e.ba(); for (i = 0, n = s.length - 1; i < n; ++i) r = s.slice(i, i + 2), o = { feature: t, ua: r }, this.a.Ka(E(r), o) }, sb.Hp = function(t, e) {
        var i, n, r, o, s, a, h, l = e.ba();
        for (o = 0, s = l.length; o < s; ++o)
            for (i = l[o], n = 0, r = i.length - 1; n < r; ++n) a = i.slice(n, n + 2), h = { feature: t, ua: a }, this.a.Ka(E(a), h)
    }, sb.Ip = function(t, e) { var i, n, r, o = e.ba(); for (n = 0, r = o.length; n < r; ++n) i = o[n], i = { feature: t, ua: [i, i] }, this.a.Ka(e.H(), i) }, sb.Jp = function(t, e) {
        var i, n, r, o, s, a, h, l, u, p, c = e.ba();
        for (a = 0, h = c.length; a < h; ++a)
            for (l = c[a], o = 0, s = l.length; o < s; ++o)
                for (i = l[o], n = 0, r = i.length - 1; n < r; ++n) u = i.slice(n, n + 2), p = { feature: t, ua: u }, this.a.Ka(E(u), p)
    }, sb.Kp = function(t, e) {
        var i = e.ba(),
            i = { feature: t, ua: [i, i] };
        this.a.Ka(e.H(), i)
    }, sb.Lp = function(t, e) {
        var i, n, r, o, s, a, h, l = e.ba();
        for (o = 0, s = l.length; o < s; ++o)
            for (i = l[o], n = 0, r = i.length - 1; n < r; ++n) a = i.slice(n, n + 2), h = { feature: t, ua: a }, this.a.Ka(E(a), h)
    }, m(mv, dt), m(vv, cp), m(Nv, Wr);
    var fC = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
    sb = Nv.prototype, sb.Fi = function() { return this.get("blur") }, sb.Oi = function() { return this.get("gradient") }, sb.Oj = function() { return this.get("radius") }, sb.yn = function() {
        for (var t = this.Oi(), e = Ii(1, 256), i = e.createLinearGradient(0, 0, 1, 256), n = 1 / (t.length - 1), r = 0, o = t.length; r < o; ++r) i.addColorStop(r * n, t[r]);
        e.fillStyle = i, e.fillRect(0, 0, 1, 256), this.f = e.getImageData(0, 0, 1, 256).data
    }, sb.kh = function() {
        var t = this.Oj(),
            e = this.Fi(),
            i = t + e + 1,
            n = 2 * i,
            n = Ii(n, n);
        n.shadowOffsetX = n.shadowOffsetY = this.fa, n.shadowBlur = e, n.shadowColor = "#000", n.beginPath(), e = i - this.fa, n.arc(e, e, t, 0, 2 * Math.PI, !0), n.fill(), this.X = n.canvas.toDataURL(), this.c = Array(256), this.u()
    }, sb.ao = function(t) {
        t = t.context;
        var e, i, n, r = t.canvas,
            r = t.getImageData(0, 0, r.width, r.height),
            o = r.data;
        for (e = 0, i = o.length; e < i; e += 4)(n = 4 * o[e + 3]) && (o[e] = this.f[n], o[e + 1] = this.f[n + 1], o[e + 2] = this.f[n + 2]);
        t.putImageData(r, 0, 0)
    }, sb.Kk = function(t) { this.set("blur", t) }, sb.Pk = function(t) { this.set("gradient", t) }, sb.Pj = function(t) { this.set("radius", t) }, m(Lv, mo);
    var gC = new kn({ html: '<a class="ol-attribution-bing-tos" href="http://www.microsoft.com/maps/product/terms.html">Terms of Use</a>' });
    Lv.prototype.A = function(t) {
        if (200 != t.statusCode || "OK" != t.statusDescription || "ValidCredentials" != t.authenticationResultCode || 1 != t.resourceSets.length || 1 != t.resourceSets[0].resources.length) Er(this, "error");
        else {
            var e = t.brandLogoUri; - 1 == e.indexOf("https") && (e = e.replace("http", "https"));
            var i = t.resourceSets[0].resources[0],
                n = -1 == this.c ? i.zoomMax : this.c;
            t = In(this.f);
            var r = Cn({ extent: t, minZoom: i.zoomMin, maxZoom: n, tileSize: i.imageWidth == i.imageHeight ? i.imageWidth : [i.imageWidth, i.imageHeight] });
            this.tileGrid = r;
            var o = this.o;
            if (this.tileUrlFunction = ao(i.imageUrlSubdomains.map(function(t) {
                    var e = [0, 0, 0],
                        n = i.imageUrl.replace("{subdomain}", t).replace("{culture}", o);
                    return function(t) { if (t) return dn(t[0], t[1], -t[2] - 1, e), n.replace("{quadkey}", yn(e)) }
                })), i.imageryProviders) {
                var s = Xt(qt("EPSG:4326"), this.f);
                t = i.imageryProviders.map(function(t) {
                    var e = t.attribution,
                        i = {};
                    return t.coverageAreas.forEach(function(t) {
                        var e = t.zoomMin,
                            o = Math.min(t.zoomMax, n);
                        t = t.bbox, t = J([t[1], t[0], t[3], t[2]], s);
                        var a, h;
                        for (a = e; a <= o; ++a) h = a.toString(), e = xn(r, t, a), h in i ? i[h].push(e) : i[h] = [e]
                    }), new kn({ html: e, tileRanges: i })
                }), t.push(gC), this.va(t)
            }
            this.O = e, Er(this, "ready")
        }
    }, m(Cv, mo), m(Mv, Cv), sb = Mv.prototype, sb.getConfig = function() { return this.c }, sb.ss = function(t) { db(this.c, t), Iv(this) }, sb.Zr = function(t) { this.c = t || {}, Iv(this) }, sb.Hn = function(t, e) {
        var i = e.target;
        if (!i.status || 200 <= i.status && 300 > i.status) {
            var n;
            try { n = JSON.parse(i.responseText) } catch (t) { return void Er(this, "error") }
            kv(this, n), this.o[t] = n, Er(this, "ready")
        } else Er(this, "error")
    }, sb.Gn = function() { Er(this, "error") }, m(Tv, kr), Tv.prototype.sb = function() { return this.A }, Tv.prototype.Hd = function(t, e, i) { this.A.Hd(t, e, i), e !== this.C && (this.clear(), this.C = e, Av(this), this.Bc(this.v)) }, Tv.prototype.Hb = function(t) { this.ra = t, this.Ua() }, Tv.prototype.Ua = function() { this.clear(), Av(this), this.Bc(this.v), this.u() }, m(_v, _o), sb = _v.prototype, sb.Sp = function() { return this.A }, sb.Cd = function(t, e, i, n) {
        if (void 0 === this.i) return null;
        e = Po(this, e);
        var r = this.c;
        if (r && this.U == this.g && r.aa() == e && r.f == i && M(r.H(), t)) return r;
        r = { F: "image", FORMAT: "PNG32", TRANSPARENT: !0 }, db(r, this.A), t = t.slice();
        var o = (t[0] + t[2]) / 2,
            s = (t[1] + t[3]) / 2;
        if (1 != this.P) {
            var a = this.P * Y(t) / 2,
                h = this.P * V(t) / 2;
            t[0] = o - a, t[1] = s - h, t[2] = o + a, t[3] = s + h
        }
        var a = e / i,
            h = Math.ceil(Y(t) / a),
            l = Math.ceil(V(t) / a);
        return t[0] = o - a * h / 2, t[2] = o + a * h / 2, t[1] = s - a * l / 2, t[3] = s + a * l / 2, this.s[0] = h, this.s[1] = l, o = t, s = this.s, n = n.Ya().split(":").pop(), r.SIZE = s[0] + "," + s[1], r.BBOX = o.join(","), r.BBOXSR = n, r.IMAGESR = n, r.DPI = 90 * i, n = this.i, o = n.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage"), o == n && x(!1, 50), r = So(o, r), this.c = new Ao(t, e, i, this.l, r, this.X, this.j), this.U = this.g, lt(this.c, "change", this.o, this), this.c
    }, sb.Rp = function() { return this.j }, sb.Tp = function() { return this.i }, sb.Vp = function(t) { this.c = null, this.j = t, this.u() }, sb.Wp = function(t) { t != this.i && (this.i = t, this.c = null, this.u()) }, sb.Xp = function(t) { db(this.A, t), this.c = null, this.u() }, m(Pv, _o), sb = Pv.prototype, sb.Zp = function() { return this.j }, sb.Cd = function(t, e, i) {
        e = Po(this, e), i = this.fa ? i : 1;
        var n = this.i;
        if (n && this.P == this.g && n.aa() == e && n.f == i && M(n.H(), t)) return n;
        1 != this.A && (t = t.slice(), Z(t, this.A));
        var r = [Y(t) / e * i, V(t) / e * i];
        if (void 0 !== this.U) {
            var n = this.U,
                o = G(t),
                s = this.qa,
                a = Y(t),
                h = V(t),
                l = r[0],
                u = r[1],
                p = .0254 / this.s,
                r = { OPERATION: this.xa ? "GETDYNAMICMAPOVERLAYIMAGE" : "GETMAPIMAGE", VERSION: "2.0.0", LOCALE: "en", CLIENTAGENT: "ol.source.ImageMapGuide source", CLIP: "1", SETDISPLAYDPI: this.s, SETDISPLAYWIDTH: Math.round(r[0]), SETDISPLAYHEIGHT: Math.round(r[1]), SETVIEWSCALE: u * a > l * h ? a * s / (l * p) : h * s / (u * p), SETVIEWCENTERX: o[0], SETVIEWCENTERY: o[1] };
            db(r, this.j), n = So(n, r), n = new Ao(t, e, i, this.l, n, this.X, this.c), lt(n, "change", this.o, this)
        } else n = null;
        return this.i = n, this.P = this.g, n
    }, sb.Yp = function() { return this.c }, sb.aq = function(t) { db(this.j, t), this.u() }, sb.$p = function(t) { this.i = null, this.c = t, this.u() }, m(Ov, _o), Ov.prototype.Cd = function(t) { return K(t, this.c.H()) ? this.c : null }, Ov.prototype.o = function(t) {
        if (2 == this.c.W()) {
            var e, i, n = this.c.H(),
                r = this.c.a();
            if (this.i ? (e = this.i[0], i = this.i[1]) : (e = r.width, i = r.height), n = Math.ceil(Y(n) / (V(n) / i)), n != e) {
                var n = Ii(n, i),
                    o = n.canvas;
                n.drawImage(r, 0, 0, e, i, 0, 0, o.width, o.height), this.c.g = o
            }
        }
        _o.prototype.o.call(this, t)
    }, m(Dv, Cv);
    var dC = new kn({ html: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors.' });
    ! function() {
        var t = {},
            e = { la: t };
        ! function(i) {
            if ("object" == typeof t && "undefined" != typeof e) e.la = i();
            else {
                var n;
                n = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, n.Ss = i()
            }
        }(function() {
            return function t(e, i, n) {
                function r(s, a) {
                    if (!i[s]) {
                        if (!e[s]) { var h = "function" == typeof require && require; if (!a && h) return h(s, !0); if (o) return o(s, !0); throw h = Error("Cannot find module '" + s + "'"), h.code = "MODULE_NOT_FOUND", h }
                        h = i[s] = { la: {} }, e[s][0].call(h.la, function(t) { var i = e[s][1][t]; return r(i ? i : t) }, h, h.la, t, e, i, n)
                    }
                    return i[s].la
                }
                for (var o = "function" == typeof require && require, s = 0; s < n.length; s++) r(n[s]);
                return r
            }({
                1: [function(t, e, i) { t = t("./processor"), i.Jl = t }, { "./processor": 2 }],
                2: [function(t, e) {
                    function i(t) {
                        var e = !0;
                        try { new ImageData(10, 10) } catch (t) { e = !1 }
                        return function(i) {
                            var n = i.buffers,
                                r = i.meta,
                                o = i.width,
                                s = i.height,
                                a = n.length,
                                h = n[0].byteLength;
                            if (i.imageOps) {
                                for (h = Array(a), i = 0; i < a; ++i) {
                                    var l, u = h,
                                        p = i;
                                    l = new Uint8ClampedArray(n[i]);
                                    var c = o,
                                        f = s;
                                    l = e ? new ImageData(l, c, f) : { data: l, width: c, height: f }, u[p] = l
                                }
                                o = t(h, r).data
                            } else {
                                for (o = new Uint8ClampedArray(h), s = Array(a), u = Array(a), i = 0; i < a; ++i) s[i] = new Uint8ClampedArray(n[i]), u[i] = [0, 0, 0, 0];
                                for (n = 0; n < h; n += 4) {
                                    for (i = 0; i < a; ++i) p = s[i], u[i][0] = p[n], u[i][1] = p[n + 1], u[i][2] = p[n + 2], u[i][3] = p[n + 3];
                                    i = t(u, r), o[n] = i[0], o[n + 1] = i[1], o[n + 2] = i[2], o[n + 3] = i[3]
                                }
                            }
                            return o.buffer
                        }
                    }

                    function n(t, e) {
                        var n = Object.keys(t.lib || {}).map(function(e) { return "var " + e + " = " + t.lib[e].toString() + ";" }).concat(["var __minion__ = (" + i.toString() + ")(", t.operation.toString(), ");", 'self.addEventListener("message", function(event) {', "  var buffer = __minion__(event.data);", "  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);", "});"]),
                            n = URL.createObjectURL(new Blob(n, { type: "text/javascript" })),
                            n = new Worker(n);
                        return n.addEventListener("message", e), n
                    }

                    function r(t, e) { var n = i(t.operation); return { postMessage: function(t) { setTimeout(function() { e({ data: { buffer: n(t), meta: t.meta } }) }, 0) } } }

                    function o(t) {
                        this.tg = !!t.no;
                        var e;
                        e = 0 === t.threads ? 0 : this.tg ? 1 : t.threads || 1;
                        var i = [];
                        if (e)
                            for (var o = 0; o < e; ++o) i[o] = n(t, this.mi.bind(this, o));
                        else i[0] = r(t, this.mi.bind(this, 0));
                        this.Ye = i, this.Zd = [], this.Yl = t.vr || 1 / 0, this.We = 0, this.yd = {}, this.ug = null
                    }
                    var s = t("./util").Jo;
                    o.prototype.tr = function(t, e, i) { this.Vl({ od: t, rj: e, ti: i }), this.ji() }, o.prototype.Vl = function(t) { for (this.Zd.push(t); this.Zd.length > this.Yl;) this.Zd.shift().ti(null, null) }, o.prototype.ji = function() {
                        if (0 === this.We && 0 < this.Zd.length) {
                            var t = this.ug = this.Zd.shift(),
                                e = t.od[0].width,
                                i = t.od[0].height,
                                n = t.od.map(function(t) { return t.data.buffer }),
                                r = this.Ye.length;
                            if (this.We = r, 1 === r) this.Ye[0].postMessage({ buffers: n, meta: t.rj, imageOps: this.tg, width: e, height: i }, n);
                            else
                                for (var o = 4 * Math.ceil(t.od[0].data.length / 4 / r), s = 0; s < r; ++s) {
                                    for (var a = s * o, h = [], l = 0, u = n.length; l < u; ++l) h.push(n[s].slice(a, a + o));
                                    this.Ye[s].postMessage({ buffers: h, meta: t.rj, imageOps: this.tg, width: e, height: i }, h)
                                }
                        }
                    }, o.prototype.mi = function(t, e) { this.Os || (this.yd[t] = e.data, --this.We, 0 === this.We && this.Zl()) }, o.prototype.Zl = function() {
                        var t, e, i = this.ug,
                            n = this.Ye.length;
                        if (1 === n) t = new Uint8ClampedArray(this.yd[0].buffer), e = this.yd[0].meta;
                        else {
                            var r = i.od[0].data.length;
                            t = new Uint8ClampedArray(r), e = Array(r);
                            for (var r = 4 * Math.ceil(r / 4 / n), o = 0; o < n; ++o) {
                                var a = o * r;
                                t.set(new Uint8ClampedArray(this.yd[o].buffer), a), e[o] = this.yd[o].meta
                            }
                        }
                        this.ug = null, this.yd = {}, i.ti(null, s(t, i.od[0].width, i.od[0].height), e), this.ji()
                    }, e.la = o
                }, { "./util": 3 }],
                3: [function(t, e, i) {
                    var n = !0;
                    try { new ImageData(10, 10) } catch (t) { n = !1 }
                    var r = document.createElement("canvas").getContext("2d");
                    i.Jo = function(t, e, i) { return n ? new ImageData(t, e, i) : (e = r.createImageData(e, i), e.data.set(t), e) }
                }, {}]
            }, {}, [1])(1)
        }), jw = e.la
    }(), m(Fv, _o), Fv.prototype.A = function(t, e) { this.P = new jw.Jl({ operation: t, no: "image" === this.xa, vr: 1, lib: e, threads: this.Ua }), this.u() }, Fv.prototype.v = function(t, e, i, n) {
        i = !0;
        for (var r, o = 0, s = this.c.length; o < s; ++o)
            if (r = this.c[o].a.ja(), "ready" !== r.W()) { i = !1; break }
        if (!i) return null;
        if (t = t.slice(), !Uv(this, t, e)) return this.j;
        i = this.i.canvas, r = Math.round(Y(t) / e), o = Math.round(V(t) / e), r === i.width && o === i.height || (i.width = r, i.height = o), r = db({}, this.X), r.viewState = db({}, r.viewState);
        var o = G(t),
            s = Math.round(Y(t) / e),
            a = Math.round(V(t) / e);
        return r.extent = t, r.focus = G(t), r.size[0] = s, r.size[1] = a, s = r.viewState, s.center = o, s.projection = n, s.resolution = e, this.j = n = new Vc(t, e, 1, this.l, i, this.U.bind(this, r)), this.s = { extent: t, resolution: e, Vr: this.g }, n
    }, Fv.prototype.U = function(t, e) {
        for (var i = this.c.length, n = Array(i), r = 0; r < i; ++r) {
            var o;
            o = this.c[r];
            var s = t,
                a = t.layerStatesArray[r];
            if (o.l(s, a)) {
                var h = s.size[0],
                    l = s.size[1];
                if (yC) {
                    var u = yC.canvas;
                    u.width !== h || u.height !== l ? yC = Ii(h, l) : yC.clearRect(0, 0, h, l)
                } else yC = Ii(h, l);
                o.i(s, a, yC), o = yC.getImageData(0, 0, h, l)
            } else o = null;
            if (!o) return;
            n[r] = o
        }
        i = {}, this.b(new zv(mC, t, i)), this.P.tr(n, i, this.qa.bind(this, t, e)), au(t.tileQueue, 16, 16)
    }, Fv.prototype.qa = function(t, e, i, n, r) { i ? e(i) : n && (this.b(new zv(vC, t, r)), Uv(this, t.extent, t.viewState.resolution / t.pixelRatio) || this.i.putImageData(n, 0, 0), e(null)) };
    var yC = null;
    m(zv, dt);
    var mC = "beforeoperations",
        vC = "afteroperations",
        bC = { terrain: { Qb: "jpg", opaque: !0 }, "terrain-background": { Qb: "jpg", opaque: !0 }, "terrain-labels": { Qb: "png", opaque: !1 }, "terrain-lines": { Qb: "png", opaque: !1 }, "toner-background": { Qb: "png", opaque: !0 }, toner: { Qb: "png", opaque: !0 }, "toner-hybrid": { Qb: "png", opaque: !1 }, "toner-labels": { Qb: "png", opaque: !1 }, "toner-lines": { Qb: "png", opaque: !1 }, "toner-lite": { Qb: "png", opaque: !0 }, watercolor: { Qb: "jpg", opaque: !0 } },
        wC = { terrain: { minZoom: 4, maxZoom: 18 }, toner: { minZoom: 0, maxZoom: 20 }, watercolor: { minZoom: 1, maxZoom: 16 } };
    m(Gv, Cv);
    var xC = [new kn({ html: 'Map tiles by <a href="http://stamen.com/">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.' }), dC];
    m(qv, mo), qv.prototype.A = function() { return this.c }, qv.prototype.Tb = function(t) { return t }, qv.prototype.hd = function(t, e, i) {
        var n = this.tileGrid;
        if (n || (n = this.yb(i)), !(n.b.length <= t[0])) {
            var r = n.Na(t, this.o),
                o = gn(n.gb(t[0]), this.j);
            1 != e && (o = fn(o, e, this.j)), n = { F: "image", FORMAT: "PNG32", TRANSPARENT: !0 }, db(n, this.c);
            var s = this.urls;
            return s ? (i = i.Ya().split(":").pop(), n.SIZE = o[0] + "," + o[1], n.BBOX = r.join(","), n.BBOXSR = i, n.IMAGESR = i, n.DPI = Math.round(n.DPI ? n.DPI * e : 90 * e), t = 1 == s.length ? s[0] : s[At((t[1] << t[0]) + t[2], s.length)], e = t.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage"), e == t && x(!1, 50), n = So(e, n)) : n = void 0, n
        }
    }, qv.prototype.v = function(t) { db(this.c, t), this.u() }, m(Vv, Yn), Vv.prototype.ub = function(t) {
        if (t = void 0 !== t ? b(t) : -1, t in this.g) return this.g[t];
        var e = this.l,
            i = Ii(e[0], e[1]);
        return i.strokeStyle = "black", i.strokeRect(.5, .5, e[0] + .5, e[1] + .5), i.fillStyle = "black", i.textAlign = "center", i.textBaseline = "middle", i.font = "24px sans-serif", i.fillText(this.c, e[0] / 2, e[1] / 2), this.g[t] = i.canvas
    }, m(Wv, uo), Wv.prototype.Ic = function(t, e, i) { var n = this.fc(t, e, i); if (this.a.b.hasOwnProperty(n)) return this.a.get(n); var r = gn(this.tileGrid.gb(t)); return t = [t, e, i], e = (e = fo(this, t)) ? fo(this, e).toString() : "", r = new Vv(t, r, e), this.a.set(n, r), r }, m(Xv, mo), sb = Xv.prototype, sb.nq = function(t) {
        if (t = t.target, !t.status || 200 <= t.status && 300 > t.status) {
            var e;
            try { e = JSON.parse(t.responseText) } catch (t) { return void this.Nf() }
            this.Yj(e)
        } else this.Nf()
    }, sb.mq = function() { this.Nf() }, sb.dn = function() { return this.c }, sb.Yj = function(t) {
        var e, i = qt("EPSG:4326"),
            n = this.f;
        if (void 0 !== t.bounds) {
            var r = Xt(i, n);
            e = J(t.bounds, r)
        }
        var o = t.minzoom || 0,
            r = t.maxzoom || 22;
        if (this.tileGrid = n = Cn({ extent: In(n), maxZoom: r, minZoom: o }), this.tileUrlFunction = so(t.tiles, n), void 0 !== t.attribution && !this.l) {
            i = void 0 !== e ? e : i.H(), e = {};
            for (var s; o <= r; ++o) s = o.toString(), e[s] = [xn(n, i, o)];
            this.va([new kn({ html: t.attribution, tileRanges: e })])
        }
        this.c = t, Er(this, "ready")
    }, sb.Nf = function() { Er(this, "error") }, m(Hv, uo), sb = Hv.prototype, sb.rq = function(t) {
        if (t = t.target, !t.status || 200 <= t.status && 300 > t.status) {
            var e;
            try { e = JSON.parse(t.responseText) } catch (t) { return void this.Of() }
            this.Dh(e)
        } else this.Of()
    }, sb.qq = function() { this.Of() }, sb.an = function() { return this.i }, sb.pm = function(t, e, i, n, r) { this.tileGrid ? (e = this.tileGrid.nf(t, e), Kv(this.Ic(e[0], e[1], e[2], 1, this.f), t, i, n, r)) : !0 === r ? Ga(function() { i.call(n, null) }) : i.call(n, null) }, sb.Of = function() { Er(this, "error") }, sb.Dh = function(t) {
        var e, i = qt("EPSG:4326"),
            n = this.f;
        if (void 0 !== t.bounds) {
            var r = Xt(i, n);
            e = J(t.bounds, r)
        }
        var o = t.minzoom || 0,
            r = t.maxzoom || 22;
        this.tileGrid = n = Cn({ extent: In(n), maxZoom: r, minZoom: o }), this.i = t.template;
        var s = t.grids;
        if (s) {
            if (this.o = so(s, n), void 0 !== t.attribution) {
                for (i = void 0 !== e ? e : i.H(), e = {}; o <= r; ++o) s = o.toString(), e[s] = [xn(n, i, o)];
                this.va([new kn({ html: t.attribution, tileRanges: e })])
            }
            Er(this, "ready")
        } else Er(this, "error")
    }, sb.Ic = function(t, e, i, n, r) { var o = this.fc(t, e, i); return this.a.b.hasOwnProperty(o) ? this.a.get(o) : (t = [t, e, i], e = fo(this, t, r), n = this.o(e, n, r), n = new Yv(t, void 0 !== n ? 0 : 4, void 0 !== n ? n : "", this.tileGrid.Na(t), this.s, this.c), this.a.set(o, n), n) }, sb.bi = function(t, e, i) { t = this.fc(t, e, i), this.a.b.hasOwnProperty(t) && this.a.get(t) }, m(Yv, Yn), sb = Yv.prototype, sb.ub = function() { return null }, sb.getData = function(t) { if (!this.l || !this.o) return null; var e = this.l[Math.floor((1 - (t[1] - this.g[1]) / (this.g[3] - this.g[1])) * this.l.length)]; return "string" != typeof e ? null : (e = e.charCodeAt(Math.floor((t[0] - this.g[0]) / (this.g[2] - this.g[0]) * e.length)), 93 <= e && e--, 35 <= e && e--, e -= 32, t = null, e in this.o && (e = this.o[e], t = this.c && e in this.c ? this.c[e] : e), t) }, sb.pb = function() { return this.s }, sb.vf = function() { this.state = 3, Kn(this) }, sb.Zj = function(t) { this.l = t.grid, this.o = t.keys, this.c = t.data, this.state = 4, Kn(this) }, sb.pq = function(t) {
        if (t = t.target, !t.status || 200 <= t.status && 300 > t.status) {
            var e;
            try { e = JSON.parse(t.responseText) } catch (t) { return void this.vf() }
            this.Zj(e)
        } else this.vf()
    }, sb.oq = function() { this.vf() }, sb.load = function() { this.T && $v(this) }, m(Zv, Yn), sb = Zv.prototype, sb.ub = function() { return -1 == this.f.Wh ? null : this.g.canvas }, sb.Xo = function() { return this.l }, sb.pb = function() { return this.o }, sb.load = function() { 0 == this.state && (this.state = 1, Kn(this), this.A(this, this.o), this.s(null, NaN, null)) }, sb.Nk = function(t) { this.c = t, this.state = 2, Kn(this) }, sb.xh = function(t) { this.j = t }, sb.Qk = function(t) { this.s = t }, m(Jv, yo), Jv.prototype.Ic = function(t, e, i, n, r) { var o = this.fc(t, e, i); return this.a.b.hasOwnProperty(o) ? this.a.get(o) : (t = [t, e, i], n = (e = fo(this, t, r)) ? this.tileUrlFunction(e, n, r) : void 0, n = new this.tileClass(t, void 0 !== n ? 0 : 4, void 0 !== n ? n : "", this.c, this.tileLoadFunction), lt(n, "change", this.ak, this), this.a.set(o, n), n) }, Jv.prototype.Tb = function(t) { return void 0 == t ? yo.prototype.Tb.call(this, t) : t }, Jv.prototype.$g = function(t, e) { var i = gn(this.tileGrid.gb(t)); return [Math.round(i[0] * e), Math.round(i[1] * e)] }, m(tb, mo), m(eb, Hr), eb.prototype.ub = function(t) { var e = void 0 !== t ? b(t).toString() : ""; if (e in this.l) return this.l[e]; if (t = Hr.prototype.ub.call(this, t), 2 == this.state) { if (256 == t.width && 256 == t.height) return this.l[e] = t; var i = Ii(256, 256); return i.drawImage(t, 0, 0), this.l[e] = i.canvas } return t }, ib.prototype.add = function(t, e, i, n, r, o) {
        return e + this.b > this.g || i + this.b > this.g ? null : (n = nb(this, !1, t, e, i, n, o)) ? (t = nb(this, !0, t, e, i, void 0 !== r ? r : v, o), { offsetX: n.offsetX, offsetY: n.offsetY, image: n.image, kj: t.image }) : null
    }, rb.prototype.get = function(t) { return this.f[t] || null }, rb.prototype.add = function(t, e, i, n, r) {
        var o, s, a;
        for (s = 0, a = this.a.length; s < a; ++s)
            if (o = this.a[s], o.width >= e + this.b && o.height >= i + this.b) return a = { offsetX: o.x + this.b, offsetY: o.y + this.b, image: this.c }, this.f[t] = a, n.call(r, this.g, o.x + this.b, o.y + this.b), t = s, e += this.b, n = i + this.b, o.width - e > o.height - n ? (i = { x: o.x + e, y: o.y, width: o.width - e, height: o.height }, e = { x: o.x, y: o.y + n, width: e, height: o.height - n }, ob(this, t, i, e)) : (i = { x: o.x + e, y: o.y, width: o.width - e, height: n }, e = { x: o.x, y: o.y + n, width: o.width, height: o.height - n }, ob(this, t, i, e)), a;
        return null
    }, d("ol.animation.bounce", function(t) {
        var e = t.resolution,
            i = t.start ? t.start : Date.now(),
            n = void 0 !== t.duration ? t.duration : 1e3,
            r = t.easing ? t.easing : zu;
        return function(t, o) {
            if (o.time < i) return o.animate = !0, o.viewHints[0] += 1, !0;
            if (o.time < i + n) {
                var s = r((o.time - i) / n),
                    a = e - o.viewState.resolution;
                return o.animate = !0, o.viewState.resolution += s * a, o.viewHints[0] += 1, !0
            }
            return !1
        }
    }), d("ol.animation.pan", Gu), d("ol.animation.rotate", qu), d("ol.animation.zoom", Vu), w.prototype.code = w.prototype.code, d("ol.Attribution", kn), kn.prototype.getHTML = kn.prototype.g, d("ol.Collection", Wn), Wn.prototype.clear = Wn.prototype.clear, Wn.prototype.extend = Wn.prototype.th, Wn.prototype.forEach = Wn.prototype.forEach, Wn.prototype.getArray = Wn.prototype.Ko, Wn.prototype.item = Wn.prototype.item, Wn.prototype.getLength = Wn.prototype.Sc, Wn.prototype.insertAt = Wn.prototype.Af, Wn.prototype.pop = Wn.prototype.pop, Wn.prototype.push = Wn.prototype.push, Wn.prototype.remove = Wn.prototype.remove, Wn.prototype.removeAt = Wn.prototype.Th, Wn.prototype.setAt = Wn.prototype.Yr, Hn.prototype.element = Hn.prototype.element, d("ol.color.asArray", hi), d("ol.color.asString", li), d("ol.colorlike.asColorLike", pi), d("ol.coordinate.add", mu), d("ol.coordinate.createStringXY", function(t) { return function(e) { return Lu(e, t) } }), d("ol.coordinate.format", wu), d("ol.coordinate.rotate", Eu), d("ol.coordinate.toStringHDMS", function(t, e) { return t ? bu(t[1], "NS", e) + " " + bu(t[0], "EW", e) : "" }), d("ol.coordinate.toStringXY", Lu), d("ol.DeviceOrientation", Fg), Fg.prototype.getAlpha = Fg.prototype.ym, Fg.prototype.getBeta = Fg.prototype.Bm, Fg.prototype.getGamma = Fg.prototype.Em, Fg.prototype.getHeading = Fg.prototype.Lo, Fg.prototype.getTracking = Fg.prototype.vj, Fg.prototype.setTracking = Fg.prototype.uh, d("ol.easing.easeIn", Fu), d("ol.easing.easeOut", Uu), d("ol.easing.inAndOut", Bu), d("ol.easing.linear", ju), d("ol.easing.upAndDown", zu), d("ol.extent.boundingExtent", E), d("ol.extent.buffer", S), d("ol.extent.containsCoordinate", C), d("ol.extent.containsExtent", M), d("ol.extent.containsXY", I), d("ol.extent.createEmpty", T), d("ol.extent.equals", P), d("ol.extent.extend", O), d("ol.extent.getBottomLeft", j), d("ol.extent.getBottomRight", z), d("ol.extent.getCenter", G), d("ol.extent.getHeight", V), d("ol.extent.getIntersection", W), d("ol.extent.getSize", function(t) { return [t[2] - t[0], t[3] - t[1]] }), d("ol.extent.getTopLeft", X), d("ol.extent.getTopRight", H), d("ol.extent.getWidth", Y), d("ol.extent.intersects", K), d("ol.extent.isEmpty", $), d("ol.extent.applyTransform", J), d("ol.Feature", Tn), Tn.prototype.clone = Tn.prototype.clone, Tn.prototype.getGeometry = Tn.prototype.Y, Tn.prototype.getId = Tn.prototype.Ja, Tn.prototype.getGeometryName = Tn.prototype.Gm, Tn.prototype.getStyle = Tn.prototype.No, Tn.prototype.getStyleFunction = Tn.prototype.Tc, Tn.prototype.setGeometry = Tn.prototype.ob, Tn.prototype.setStyle = Tn.prototype.vh, Tn.prototype.setId = Tn.prototype.ic, Tn.prototype.setGeometryName = Tn.prototype.sd, d("ol.featureloader.tile", mr), d("ol.featureloader.xhr", vr), d("ol.Geolocation", bm), bm.prototype.getAccuracy = bm.prototype.wm, bm.prototype.getAccuracyGeometry = bm.prototype.xm, bm.prototype.getAltitude = bm.prototype.zm, bm.prototype.getAltitudeAccuracy = bm.prototype.Am, bm.prototype.getHeading = bm.prototype.Po, bm.prototype.getPosition = bm.prototype.Qo, bm.prototype.getProjection = bm.prototype.wj, bm.prototype.getSpeed = bm.prototype.$m, bm.prototype.getTracking = bm.prototype.xj, bm.prototype.getTrackingOptions = bm.prototype.Xi, bm.prototype.setProjection = bm.prototype.yj, bm.prototype.setTracking = bm.prototype.Ef, bm.prototype.setTrackingOptions = bm.prototype.Xk, d("ol.Graticule", Lm), Lm.prototype.getMap = Lm.prototype.To, Lm.prototype.getMeridians = Lm.prototype.Om, Lm.prototype.getParallels = Lm.prototype.Um, Lm.prototype.setMap = Lm.prototype.setMap, d("ol.has.DEVICE_PIXEL_RATIO", gw), d("ol.has.CANVAS", yw), d("ol.has.DEVICE_ORIENTATION", mw), d("ol.has.GEOLOCATION", vw), d("ol.has.TOUCH", bw), d("ol.has.WEBGL", ew), Ao.prototype.getImage = Ao.prototype.a, Ao.prototype.load = Ao.prototype.load, Hr.prototype.getImage = Hr.prototype.ub, Hr.prototype.load = Hr.prototype.load, d("ol.inherits", m), d("ol.Kinetic", Ku), d("ol.loadingstrategy.all", br), d("ol.loadingstrategy.bbox", function(t) { return [t] }), d("ol.loadingstrategy.tile", function(t) {
        return function(e, i) {
            var n = t.Kc(i),
                r = xn(t, e, n),
                o = [],
                n = [n, 0, 0];
            for (n[1] = r.da; n[1] <= r.ha; ++n[1])
                for (n[2] = r.ia; n[2] <= r.ka; ++n[2]) o.push(t.Na(n));
            return o
        }
    }), d("ol.Map", ng), ng.prototype.addControl = ng.prototype.zg, ng.prototype.addInteraction = ng.prototype.oi, ng.prototype.addLayer = ng.prototype.$d, ng.prototype.addOverlay = ng.prototype.ae, ng.prototype.beforeRender = ng.prototype.mb, ng.prototype.forEachFeatureAtPixel = ng.prototype.ne, ng.prototype.forEachLayerAtPixel = ng.prototype.zj, ng.prototype.hasFeatureAtPixel = ng.prototype.jj, ng.prototype.getEventCoordinate = ng.prototype.Ki, ng.prototype.getEventPixel = ng.prototype.pe, ng.prototype.getTarget = ng.prototype.Ff, ng.prototype.getTargetElement = ng.prototype.Hc, ng.prototype.getCoordinateFromPixel = ng.prototype.Za, ng.prototype.getControls = ng.prototype.Hi, ng.prototype.getOverlays = ng.prototype.Vi, ng.prototype.getOverlayById = ng.prototype.Ui, ng.prototype.getInteractions = ng.prototype.Pi, ng.prototype.getLayerGroup = ng.prototype.Fc, ng.prototype.getLayers = ng.prototype.ze, ng.prototype.getPixelFromCoordinate = ng.prototype.Qa, ng.prototype.getSize = ng.prototype.bb, ng.prototype.getView = ng.prototype.$, ng.prototype.getViewport = ng.prototype.Yi, ng.prototype.renderSync = ng.prototype.Fk, ng.prototype.render = ng.prototype.render, ng.prototype.removeControl = ng.prototype.Ck, ng.prototype.removeInteraction = ng.prototype.Dk, ng.prototype.removeLayer = ng.prototype.dg, ng.prototype.removeOverlay = ng.prototype.eg, ng.prototype.setLayerGroup = ng.prototype.Zh, ng.prototype.setSize = ng.prototype.hg, ng.prototype.setTarget = ng.prototype.wh, ng.prototype.setView = ng.prototype.Yk, ng.prototype.updateSize = ng.prototype.wd, _l.prototype.originalEvent = _l.prototype.originalEvent;
    _l.prototype.pixel = _l.prototype.pixel;
    _l.prototype.coordinate = _l.prototype.coordinate, _l.prototype.dragging = _l.prototype.dragging, ll.prototype.map = ll.prototype.map, ll.prototype.frameState = ll.prototype.frameState, Et.prototype.key = Et.prototype.key, Et.prototype.oldValue = Et.prototype.oldValue, d("ol.Object", St), St.prototype.get = St.prototype.get, St.prototype.getKeys = St.prototype.R, St.prototype.getProperties = St.prototype.N, St.prototype.set = St.prototype.set, St.prototype.setProperties = St.prototype.G, St.prototype.unset = St.prototype.S, d("ol.Observable", wt), d("ol.Observable.unByKey", xt), wt.prototype.changed = wt.prototype.u, wt.prototype.dispatchEvent = wt.prototype.b, wt.prototype.getRevision = wt.prototype.K, wt.prototype.on = wt.prototype.I, wt.prototype.once = wt.prototype.L, wt.prototype.un = wt.prototype.J, wt.prototype.unByKey = wt.prototype.M, d("ol.Overlay", lg), lg.prototype.getElement = lg.prototype.V, lg.prototype.getId = lg.prototype.Ja, lg.prototype.getMap = lg.prototype.Gf, lg.prototype.getOffset = lg.prototype.Ti, lg.prototype.getPosition = lg.prototype.Aj, lg.prototype.getPositioning = lg.prototype.Wi, lg.prototype.setElement = lg.prototype.Bj, lg.prototype.setMap = lg.prototype.setMap, lg.prototype.setOffset = lg.prototype.Rk, lg.prototype.setPosition = lg.prototype.Hf, lg.prototype.setPositioning = lg.prototype.Uk, d("ol.render.toContext", function(t, e) {
        var i = t.canvas,
            n = e ? e : {},
            r = n.pixelRatio || gw;
        return (n = n.size) && (i.width = n[0] * r, i.height = n[1] * r, i.style.width = n[0] + "px", i.style.height = n[1] + "px"), i = [0, 0, i.width, i.height], n = Wl(Ul(), r, r), new ec(t, r, i, n, 0)
    }), d("ol.size.toSize", gn), Yn.prototype.getTileCoord = Yn.prototype.i, Yn.prototype.load = Yn.prototype.load, Zv.prototype.getFormat = Zv.prototype.Xo, Zv.prototype.setFeatures = Zv.prototype.Nk, Zv.prototype.setProjection = Zv.prototype.xh, Zv.prototype.setLoader = Zv.prototype.Qk, d("ol.View", Cu), Cu.prototype.constrainCenter = Cu.prototype.ce, Cu.prototype.constrainResolution = Cu.prototype.constrainResolution, Cu.prototype.constrainRotation = Cu.prototype.constrainRotation, Cu.prototype.getCenter = Cu.prototype.cb, Cu.prototype.calculateExtent = Cu.prototype.Cc, Cu.prototype.getMaxResolution = Cu.prototype.Cj, Cu.prototype.getMinResolution = Cu.prototype.Dj, Cu.prototype.getProjection = Cu.prototype.Ej, Cu.prototype.getResolution = Cu.prototype.aa, Cu.prototype.getResolutions = Cu.prototype.Fj, Cu.prototype.getRotation = Cu.prototype.Ra, Cu.prototype.getZoom = Cu.prototype.ah, Cu.prototype.fit = Cu.prototype.Ad, Cu.prototype.centerOn = Cu.prototype.wi, Cu.prototype.rotate = Cu.prototype.rotate, Cu.prototype.setCenter = Cu.prototype.qb, Cu.prototype.setResolution = Cu.prototype.Xb, Cu.prototype.setRotation = Cu.prototype.Ld, Cu.prototype.setZoom = Cu.prototype.ig, d("ol.xml.getAllTextContent", Zn), d("ol.xml.parse", er), vf.prototype.getGL = vf.prototype.Xq, vf.prototype.useProgram = vf.prototype.Yf, d("ol.tilegrid.createXYZ", Cn), d("ol.tilegrid.TileGrid", mn), mn.prototype.forEachTileCoord = mn.prototype.Ei, mn.prototype.getMaxZoom = mn.prototype.Ri, mn.prototype.getMinZoom = mn.prototype.Si, mn.prototype.getOrigin = mn.prototype.$a, mn.prototype.getResolution = mn.prototype.aa, mn.prototype.getResolutions = mn.prototype.jk, mn.prototype.getTileCoordExtent = mn.prototype.Na, mn.prototype.getTileCoordForCoordAndResolution = mn.prototype.nf, mn.prototype.getTileCoordForCoordAndZ = mn.prototype.ue, mn.prototype.getTileSize = mn.prototype.gb, mn.prototype.getZForResolution = mn.prototype.Kc, d("ol.tilegrid.WMTS", jo), jo.prototype.getMatrixIds = jo.prototype.o, d("ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet", zo), d("ol.style.AtlasManager", ib), d("ol.style.Circle", Fi), Fi.prototype.getFill = Fi.prototype.wq, Fi.prototype.getImage = Fi.prototype.Yc, Fi.prototype.getRadius = Fi.prototype.xq, Fi.prototype.getStroke = Fi.prototype.yq, d("ol.style.Fill", Ui), Ui.prototype.getColor = Ui.prototype.g, Ui.prototype.setColor = Ui.prototype.f, d("ol.style.Icon", en), en.prototype.getAnchor = en.prototype.Dc, en.prototype.getImage = en.prototype.Yc, en.prototype.getOrigin = en.prototype.$a, en.prototype.getSrc = en.prototype.zq, en.prototype.getSize = en.prototype.hc, en.prototype.load = en.prototype.load, d("ol.style.Image", Di), Di.prototype.getOpacity = Di.prototype.Rf, Di.prototype.getRotateWithView = Di.prototype.Sf, Di.prototype.getRotation = Di.prototype.Tf, Di.prototype.getScale = Di.prototype.Uf, Di.prototype.getSnapToPixel = Di.prototype.mf, Di.prototype.setOpacity = Di.prototype.Vf, Di.prototype.setRotation = Di.prototype.Wf, Di.prototype.setScale = Di.prototype.Xf, d("ol.style.RegularShape", nn), nn.prototype.getAnchor = nn.prototype.Dc, nn.prototype.getAngle = nn.prototype.Aq, nn.prototype.getFill = nn.prototype.Bq, nn.prototype.getImage = nn.prototype.Yc, nn.prototype.getOrigin = nn.prototype.$a, nn.prototype.getPoints = nn.prototype.Cq, nn.prototype.getRadius = nn.prototype.Dq, nn.prototype.getRadius2 = nn.prototype.Ym, nn.prototype.getSize = nn.prototype.hc, nn.prototype.getStroke = nn.prototype.Eq, d("ol.style.Stroke", Vi), Vi.prototype.getColor = Vi.prototype.Fq, Vi.prototype.getLineCap = Vi.prototype.Jm, Vi.prototype.getLineDash = Vi.prototype.Gq, Vi.prototype.getLineJoin = Vi.prototype.Km, Vi.prototype.getMiterLimit = Vi.prototype.Pm, Vi.prototype.getWidth = Vi.prototype.Hq, Vi.prototype.setColor = Vi.prototype.Iq, Vi.prototype.setLineCap = Vi.prototype.es, Vi.prototype.setLineDash = Vi.prototype.Jq, Vi.prototype.setLineJoin = Vi.prototype.fs, Vi.prototype.setMiterLimit = Vi.prototype.gs, Vi.prototype.setWidth = Vi.prototype.ks, d("ol.style.Style", Xi), Xi.prototype.getGeometry = Xi.prototype.Y, Xi.prototype.getGeometryFunction = Xi.prototype.Fm, Xi.prototype.getFill = Xi.prototype.Kq, Xi.prototype.getImage = Xi.prototype.Lq, Xi.prototype.getStroke = Xi.prototype.Mq, Xi.prototype.getText = Xi.prototype.Wa, Xi.prototype.getZIndex = Xi.prototype.Nq, Xi.prototype.setGeometry = Xi.prototype.ik, Xi.prototype.setZIndex = Xi.prototype.Oq, d("ol.style.Text", Zi), Zi.prototype.getFont = Zi.prototype.Dm, Zi.prototype.getOffsetX = Zi.prototype.Rm, Zi.prototype.getOffsetY = Zi.prototype.Sm, Zi.prototype.getFill = Zi.prototype.Pq, Zi.prototype.getRotateWithView = Zi.prototype.Qq, Zi.prototype.getRotation = Zi.prototype.Rq, Zi.prototype.getScale = Zi.prototype.Sq, Zi.prototype.getStroke = Zi.prototype.Tq, Zi.prototype.getText = Zi.prototype.Wa, Zi.prototype.getTextAlign = Zi.prototype.bn, Zi.prototype.getTextBaseline = Zi.prototype.cn, Zi.prototype.setFont = Zi.prototype.bs, Zi.prototype.setOffsetX = Zi.prototype.Sk, Zi.prototype.setOffsetY = Zi.prototype.Tk, Zi.prototype.setFill = Zi.prototype.as, Zi.prototype.setRotation = Zi.prototype.Uq, Zi.prototype.setScale = Zi.prototype.Vq, Zi.prototype.setStroke = Zi.prototype.hs, Zi.prototype.setText = Zi.prototype.Vk, Zi.prototype.setTextAlign = Zi.prototype.Wk, Zi.prototype.setTextBaseline = Zi.prototype.js, d("ol.Sphere", _t), _t.prototype.geodesicArea = _t.prototype.a, _t.prototype.haversineDistance = _t.prototype.b, d("ol.source.BingMaps", Lv), d("ol.source.BingMaps.TOS_ATTRIBUTION", gC), d("ol.source.CartoDB", Mv), Mv.prototype.getConfig = Mv.prototype.getConfig, Mv.prototype.updateConfig = Mv.prototype.ss, Mv.prototype.setConfig = Mv.prototype.Zr, d("ol.source.Cluster", Tv), Tv.prototype.getSource = Tv.prototype.sb, Tv.prototype.setDistance = Tv.prototype.Hb, d("ol.source.Image", _o), Do.prototype.image = Do.prototype.image, d("ol.source.ImageArcGISRest", _v), _v.prototype.getParams = _v.prototype.Sp, _v.prototype.getImageLoadFunction = _v.prototype.Rp, _v.prototype.getUrl = _v.prototype.Tp, _v.prototype.setImageLoadFunction = _v.prototype.Vp, _v.prototype.setUrl = _v.prototype.Wp, _v.prototype.updateParams = _v.prototype.Xp, d("ol.source.ImageCanvas", Wc), d("ol.source.ImageMapGuide", Pv), Pv.prototype.getParams = Pv.prototype.Zp, Pv.prototype.getImageLoadFunction = Pv.prototype.Yp, Pv.prototype.updateParams = Pv.prototype.aq, Pv.prototype.setImageLoadFunction = Pv.prototype.$p, d("ol.source.ImageStatic", Ov), d("ol.source.ImageVector", Xc), Xc.prototype.getSource = Xc.prototype.bq, Xc.prototype.getStyle = Xc.prototype.cq, Xc.prototype.getStyleFunction = Xc.prototype.eq, Xc.prototype.setStyle = Xc.prototype.Xj, d("ol.source.ImageWMS", Fo), Fo.prototype.getGetFeatureInfoUrl = Fo.prototype.hq, Fo.prototype.getParams = Fo.prototype.Lf, Fo.prototype.getImageLoadFunction = Fo.prototype.iq;
    Fo.prototype.getUrl = Fo.prototype.jq;
    Fo.prototype.setImageLoadFunction = Fo.prototype.kq, Fo.prototype.setUrl = Fo.prototype.lq, Fo.prototype.updateParams = Fo.prototype.Mf, d("ol.source.OSM", Dv), d("ol.source.OSM.ATTRIBUTION", dC), d("ol.source.Raster", Fv), Fv.prototype.setOperation = Fv.prototype.A, zv.prototype.extent = zv.prototype.extent, zv.prototype.resolution = zv.prototype.resolution, zv.prototype.data = zv.prototype.data, d("ol.source.Source", wr), wr.prototype.getAttributions = wr.prototype.Da, wr.prototype.getLogo = wr.prototype.Ca, wr.prototype.getProjection = wr.prototype.Ea, wr.prototype.getState = wr.prototype.W, wr.prototype.refresh = wr.prototype.Ba, wr.prototype.setAttributions = wr.prototype.va, d("ol.source.Stamen", Gv), d("ol.source.Tile", uo), uo.prototype.getTileGrid = uo.prototype.fb, go.prototype.tile = go.prototype.tile, d("ol.source.TileArcGISRest", qv), qv.prototype.getParams = qv.prototype.A, qv.prototype.updateParams = qv.prototype.v, d("ol.source.TileDebug", Wv), d("ol.source.TileImage", mo), mo.prototype.setRenderReprojectionEdges = mo.prototype.Wb, mo.prototype.setTileGridForProjection = mo.prototype.Zb, d("ol.source.TileJSON", Xv), Xv.prototype.getTileJSON = Xv.prototype.dn, d("ol.source.TileUTFGrid", Hv), Hv.prototype.getTemplate = Hv.prototype.an, Hv.prototype.forDataAtCoordinateAndResolution = Hv.prototype.pm, d("ol.source.TileWMS", No), No.prototype.getGetFeatureInfoUrl = No.prototype.sq, No.prototype.getParams = No.prototype.Lf, No.prototype.updateParams = No.prototype.Mf, yo.prototype.getTileLoadFunction = yo.prototype.zb, yo.prototype.getTileUrlFunction = yo.prototype.Ab, yo.prototype.getUrls = yo.prototype.Bb, yo.prototype.setTileLoadFunction = yo.prototype.Eb, yo.prototype.setTileUrlFunction = yo.prototype.kb, yo.prototype.setUrl = yo.prototype.rb, yo.prototype.setUrls = yo.prototype.lb, d("ol.source.Vector", kr), kr.prototype.addFeature = kr.prototype.Nb, kr.prototype.addFeatures = kr.prototype.Bc, kr.prototype.clear = kr.prototype.clear, kr.prototype.forEachFeature = kr.prototype.Ci, kr.prototype.forEachFeatureInExtent = kr.prototype.Rb, kr.prototype.forEachFeatureIntersectingExtent = kr.prototype.Di, kr.prototype.getFeaturesCollection = kr.prototype.Ni, kr.prototype.getFeatures = kr.prototype.Pf, kr.prototype.getFeaturesAtCoordinate = kr.prototype.Mi, kr.prototype.getFeaturesInExtent = kr.prototype.Ug, kr.prototype.getClosestFeatureToCoordinate = kr.prototype.Gi, kr.prototype.getExtent = kr.prototype.H, kr.prototype.getFeatureById = kr.prototype.Li, kr.prototype.getFormat = kr.prototype.bk, kr.prototype.getUrl = kr.prototype.ck, kr.prototype.removeFeature = kr.prototype.Kb, Dr.prototype.feature = Dr.prototype.feature, d("ol.source.VectorTile", Jv), d("ol.source.WMTS", Go), Go.prototype.getDimensions = Go.prototype.Cm, Go.prototype.getFormat = Go.prototype.tq, Go.prototype.getLayer = Go.prototype.uq, Go.prototype.getMatrixSet = Go.prototype.Nm, Go.prototype.getRequestEncoding = Go.prototype.Zm, Go.prototype.getStyle = Go.prototype.vq, Go.prototype.getVersion = Go.prototype.fn, Go.prototype.updateDimensions = Go.prototype.fl, d("ol.source.WMTS.optionsFromCapabilities", function(t, e) {
        var i, n, r = fe(t.Contents.Layer, function(t) { return t.Identifier == e.layer }),
            o = t.Contents.TileMatrixSet;
        i = 1 < r.TileMatrixSetLink.length ? "projection" in e ? ye(r.TileMatrixSetLink, function(t) { return fe(o, function(e) { return e.Identifier == t.TileMatrixSet }).SupportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3") == e.projection }) : ye(r.TileMatrixSetLink, function(t) { return t.TileMatrixSet == e.matrixSet }) : 0, 0 > i && (i = 0), n = r.TileMatrixSetLink[i].TileMatrixSet;
        var s = r.Format[0];
        "format" in e && (s = e.format), i = ye(r.Style, function(t) { return "style" in e ? t.Title == e.style : t.isDefault }), 0 > i && (i = 0), i = r.Style[i].Identifier;
        var a = {};
        "Dimension" in r && r.Dimension.forEach(function(t) {
            var e = t.Identifier,
                i = t.Default;
            void 0 === i && (i = t.Value[0]), a[e] = i
        });
        var h, l = fe(t.Contents.TileMatrixSet, function(t) { return t.Identifier == n });
        h = qt("projection" in e ? e.projection : l.SupportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"));
        var u, p, c = r.WGS84BoundingBox;
        void 0 !== c && (p = qt("EPSG:4326").H(), p = c[0] == p[0] && c[2] == p[2], u = $t(c, "EPSG:4326", h), (c = h.H()) && (M(c, u) || (u = void 0)));
        var l = zo(l, u),
            f = [];
        if (u = e.requestEncoding, u = void 0 !== u ? u : "", "OperationsMetadata" in t && "GetTile" in t.OperationsMetadata)
            for (var c = t.OperationsMetadata.GetTile.DCP.HTTP.Get, g = 0, d = c.length; g < d; ++g) {
                var y = fe(c[g].Constraint, function(t) { return "GetEncoding" == t.name }).AllowedValues.Value;
                if ("" === u && (u = y[0]), "KVP" !== u) break;
                he(y, "KVP") && f.push(c[g].href)
            }
        return 0 === f.length && (u = "REST", r.ResourceURL.forEach(function(t) { "tile" === t.resourceType && (s = t.format, f.push(t.template)) })), { urls: f, layer: e.layer, matrixSet: n, format: s, projection: h, requestEncoding: u, tileGrid: l, style: i, dimensions: a, wrapX: p }
    }), d("ol.source.XYZ", Cv), d("ol.source.Zoomify", tb), jr.prototype.vectorContext = jr.prototype.vectorContext, jr.prototype.frameState = jr.prototype.frameState, jr.prototype.context = jr.prototype.context, jr.prototype.glContext = jr.prototype.glContext, ty.prototype.get = ty.prototype.get, ty.prototype.getExtent = ty.prototype.H, ty.prototype.getGeometry = ty.prototype.Y, ty.prototype.getProperties = ty.prototype.Np, ty.prototype.getType = ty.prototype.Z, d("ol.render.VectorContext", tc), Uf.prototype.setStyle = Uf.prototype.Be, Uf.prototype.drawGeometry = Uf.prototype.ed, Uf.prototype.drawFeature = Uf.prototype.Mg, ec.prototype.drawCircle = ec.prototype.df, ec.prototype.setStyle = ec.prototype.Be, ec.prototype.drawGeometry = ec.prototype.ed, ec.prototype.drawFeature = ec.prototype.Mg, d("ol.proj.common.add", Jp), d("ol.proj.METERS_PER_UNIT", bb), d("ol.proj.Projection", Pt), Pt.prototype.getCode = Pt.prototype.Ya, Pt.prototype.getExtent = Pt.prototype.H, Pt.prototype.getUnits = Pt.prototype.Ub, Pt.prototype.getMetersPerUnit = Pt.prototype.Gc, Pt.prototype.getWorldExtent = Pt.prototype.gn, Pt.prototype.isGlobal = Pt.prototype.so, Pt.prototype.setGlobal = Pt.prototype.ds, Pt.prototype.setExtent = Pt.prototype.Qj, Pt.prototype.setWorldExtent = Pt.prototype.ls, Pt.prototype.setGetPointResolution = Pt.prototype.cs, Pt.prototype.getPointResolution = Pt.prototype.getPointResolution, d("ol.proj.setProj4", function(t) { Eb = t }), d("ol.proj.addEquivalentProjections", Ot), d("ol.proj.addProjection", Ft), d("ol.proj.addCoordinateTransforms", zt), d("ol.proj.fromLonLat", function(t, e) { return Kt(t, "EPSG:4326", void 0 !== e ? e : "EPSG:3857") }), d("ol.proj.toLonLat", function(t, e) { return Kt(t, void 0 !== e ? e : "EPSG:3857", "EPSG:4326") }), d("ol.proj.get", qt), d("ol.proj.equivalent", Vt), d("ol.proj.getTransform", Wt), d("ol.proj.transform", Kt), d("ol.proj.transformExtent", $t), d("ol.layer.Base", Fr), Fr.prototype.getExtent = Fr.prototype.H, Fr.prototype.getMaxResolution = Fr.prototype.rc, Fr.prototype.getMinResolution = Fr.prototype.sc, Fr.prototype.getOpacity = Fr.prototype.tc, Fr.prototype.getVisible = Fr.prototype.Ib, Fr.prototype.getZIndex = Fr.prototype.uc, Fr.prototype.setExtent = Fr.prototype.Uc, Fr.prototype.setMaxResolution = Fr.prototype.$c, Fr.prototype.setMinResolution = Fr.prototype.ad, Fr.prototype.setOpacity = Fr.prototype.Vc, Fr.prototype.setVisible = Fr.prototype.Wc, Fr.prototype.setZIndex = Fr.prototype.Xc, d("ol.layer.Group", Br), Br.prototype.getLayers = Br.prototype.Md, Br.prototype.setLayers = Br.prototype.Nj, d("ol.layer.Heatmap", Nv), Nv.prototype.getBlur = Nv.prototype.Fi, Nv.prototype.getGradient = Nv.prototype.Oi, Nv.prototype.getRadius = Nv.prototype.Oj, Nv.prototype.setBlur = Nv.prototype.Kk, Nv.prototype.setGradient = Nv.prototype.Pk, Nv.prototype.setRadius = Nv.prototype.Pj, d("ol.layer.Image", Vr), Vr.prototype.getSource = Vr.prototype.ja, d("ol.layer.Layer", zr), zr.prototype.getSource = zr.prototype.ja, zr.prototype.setMap = zr.prototype.setMap, zr.prototype.setSource = zr.prototype.td, d("ol.layer.Tile", qr), qr.prototype.getPreload = qr.prototype.f, qr.prototype.getSource = qr.prototype.ja, qr.prototype.setPreload = qr.prototype.v, qr.prototype.getUseInterimTilesOnError = qr.prototype.c, qr.prototype.setUseInterimTilesOnError = qr.prototype.C, d("ol.layer.Vector", Wr), Wr.prototype.getSource = Wr.prototype.ja, Wr.prototype.getStyle = Wr.prototype.C, Wr.prototype.getStyleFunction = Wr.prototype.D, Wr.prototype.setStyle = Wr.prototype.l, d("ol.layer.VectorTile", Qp), Qp.prototype.getPreload = Qp.prototype.f, Qp.prototype.getUseInterimTilesOnError = Qp.prototype.c, Qp.prototype.setPreload = Qp.prototype.X, Qp.prototype.setUseInterimTilesOnError = Qp.prototype.fa, d("ol.interaction.DoubleClickZoom", ep), d("ol.interaction.DoubleClickZoom.handleEvent", ip), d("ol.interaction.DragAndDrop", Im), d("ol.interaction.DragAndDrop.handleEvent", Q), Am.prototype.features = Am.prototype.features, Am.prototype.file = Am.prototype.file, Am.prototype.projection = Am.prototype.projection, Cp.prototype.coordinate = Cp.prototype.coordinate, Cp.prototype.mapBrowserEvent = Cp.prototype.mapBrowserEvent, d("ol.interaction.DragBox", Mp), Mp.prototype.getGeometry = Mp.prototype.Y, d("ol.interaction.DragPan", dp), d("ol.interaction.DragRotate", bp), d("ol.interaction.DragRotateAndZoom", Rm), d("ol.interaction.DragZoom", Rp), Dm.prototype.feature = Dm.prototype.feature, d("ol.interaction.Draw", Fm), d("ol.interaction.Draw.handleEvent", Bm), Fm.prototype.removeLastPoint = Fm.prototype.Rr, Fm.prototype.finishDrawing = Fm.prototype.me, Fm.prototype.extend = Fm.prototype.sp, d("ol.interaction.Draw.createRegularPolygon", function(t, e) {
        return function(i, n) {
            var r = i[0],
                o = i[1],
                s = Math.sqrt(Su(r, o)),
                a = n ? n : ei(new wm(r), t);
            return ii(a, r, s, e ? e : Math.atan((o[1] - r[1]) / (o[0] - r[0]))), a
        }
    }), d("ol.interaction.defaults", Hp), d("ol.interaction.Interaction", Zu), Zu.prototype.getActive = Zu.prototype.f, Zu.prototype.getMap = Zu.prototype.l, Zu.prototype.setActive = Zu.prototype.i, d("ol.interaction.KeyboardPan", _p), d("ol.interaction.KeyboardPan.handleEvent", Pp), d("ol.interaction.KeyboardZoom", Op), d("ol.interaction.KeyboardZoom.handleEvent", Dp), Km.prototype.features = Km.prototype.features, Km.prototype.mapBrowserEvent = Km.prototype.mapBrowserEvent, d("ol.interaction.Modify", $m), d("ol.interaction.Modify.handleEvent", ov), $m.prototype.removePoint = $m.prototype.Ek, d("ol.interaction.MouseWheelZoom", Fp), d("ol.interaction.MouseWheelZoom.handleEvent", Up);
    Fp.prototype.setMouseAnchor = Fp.prototype.D;
    d("ol.interaction.PinchRotate", Bp), d("ol.interaction.PinchZoom", qp), d("ol.interaction.Pointer", cp), d("ol.interaction.Pointer.handleEvent", gp), lv.prototype.selected = lv.prototype.selected, lv.prototype.deselected = lv.prototype.deselected, lv.prototype.mapBrowserEvent = lv.prototype.mapBrowserEvent, d("ol.interaction.Select", uv), uv.prototype.getFeatures = uv.prototype.Cp, uv.prototype.getLayer = uv.prototype.Dp, d("ol.interaction.Select.handleEvent", pv), uv.prototype.setMap = uv.prototype.setMap, d("ol.interaction.Snap", fv), fv.prototype.addFeature = fv.prototype.Nb, fv.prototype.removeFeature = fv.prototype.Kb, mv.prototype.features = mv.prototype.features, mv.prototype.coordinate = mv.prototype.coordinate, d("ol.interaction.Translate", vv), d("ol.geom.Circle", wm), wm.prototype.clone = wm.prototype.clone, wm.prototype.getCenter = wm.prototype.Ae, wm.prototype.getRadius = wm.prototype.yh, wm.prototype.getType = wm.prototype.Z, wm.prototype.intersectsExtent = wm.prototype.ab, wm.prototype.setCenter = wm.prototype.kp, wm.prototype.setCenterAndRadius = wm.prototype.Yh, wm.prototype.setRadius = wm.prototype.lp, wm.prototype.transform = wm.prototype.Db, d("ol.geom.Geometry", Zt), Zt.prototype.getClosestPoint = Zt.prototype.Sb, Zt.prototype.intersectsCoordinate = Zt.prototype.Cb, Zt.prototype.getExtent = Zt.prototype.H, Zt.prototype.rotate = Zt.prototype.rotate, Zt.prototype.scale = Zt.prototype.scale, Zt.prototype.simplify = Zt.prototype.$b, Zt.prototype.transform = Zt.prototype.Db, d("ol.geom.GeometryCollection", Un), Un.prototype.clone = Un.prototype.clone, Un.prototype.getGeometries = Un.prototype.Vg, Un.prototype.getType = Un.prototype.Z, Un.prototype.intersectsExtent = Un.prototype.ab, Un.prototype.setGeometries = Un.prototype.Ok, Un.prototype.applyTransform = Un.prototype.cd, Un.prototype.translate = Un.prototype.translate, d("ol.geom.LinearRing", Ve), Ve.prototype.clone = Ve.prototype.clone, Ve.prototype.getArea = Ve.prototype.op, Ve.prototype.getCoordinates = Ve.prototype.ba, Ve.prototype.getType = Ve.prototype.Z, Ve.prototype.setCoordinates = Ve.prototype.wa, d("ol.geom.LineString", Fe), Fe.prototype.appendCoordinate = Fe.prototype.cm, Fe.prototype.clone = Fe.prototype.clone, Fe.prototype.forEachSegment = Fe.prototype.sm, Fe.prototype.getCoordinateAtM = Fe.prototype.mp, Fe.prototype.getCoordinates = Fe.prototype.ba, Fe.prototype.getCoordinateAt = Fe.prototype.Ii, Fe.prototype.getLength = Fe.prototype.np, Fe.prototype.getType = Fe.prototype.Z, Fe.prototype.intersectsExtent = Fe.prototype.ab, Fe.prototype.setCoordinates = Fe.prototype.wa, d("ol.geom.MultiLineString", Be), Be.prototype.appendLineString = Be.prototype.dm, Be.prototype.clone = Be.prototype.clone, Be.prototype.getCoordinateAtM = Be.prototype.pp, Be.prototype.getCoordinates = Be.prototype.ba, Be.prototype.getLineString = Be.prototype.Lm, Be.prototype.getLineStrings = Be.prototype.re, Be.prototype.getType = Be.prototype.Z, Be.prototype.intersectsExtent = Be.prototype.ab, Be.prototype.setCoordinates = Be.prototype.wa, d("ol.geom.MultiPoint", we), we.prototype.appendPoint = we.prototype.fm, we.prototype.clone = we.prototype.clone, we.prototype.getCoordinates = we.prototype.ba, we.prototype.getPoint = we.prototype.Vm, we.prototype.getPoints = we.prototype.If, we.prototype.getType = we.prototype.Z, we.prototype.intersectsExtent = we.prototype.ab, we.prototype.setCoordinates = we.prototype.wa, d("ol.geom.MultiPolygon", ni), ni.prototype.appendPolygon = ni.prototype.gm, ni.prototype.clone = ni.prototype.clone, ni.prototype.getArea = ni.prototype.qp, ni.prototype.getCoordinates = ni.prototype.ba, ni.prototype.getInteriorPoints = ni.prototype.Im, ni.prototype.getPolygon = ni.prototype.Xm, ni.prototype.getPolygons = ni.prototype.lf, ni.prototype.getType = ni.prototype.Z, ni.prototype.intersectsExtent = ni.prototype.ab, ni.prototype.setCoordinates = ni.prototype.wa, d("ol.geom.Point", se), se.prototype.clone = se.prototype.clone, se.prototype.getCoordinates = se.prototype.ba, se.prototype.getType = se.prototype.Z, se.prototype.intersectsExtent = se.prototype.ab, se.prototype.setCoordinates = se.prototype.wa, d("ol.geom.Polygon", Ze), Ze.prototype.appendLinearRing = Ze.prototype.em, Ze.prototype.clone = Ze.prototype.clone, Ze.prototype.getArea = Ze.prototype.rp, Ze.prototype.getCoordinates = Ze.prototype.ba, Ze.prototype.getInteriorPoint = Ze.prototype.Hm, Ze.prototype.getLinearRingCount = Ze.prototype.Mm, Ze.prototype.getLinearRing = Ze.prototype.Qi, Ze.prototype.getLinearRings = Ze.prototype.jf, Ze.prototype.getType = Ze.prototype.Z, Ze.prototype.intersectsExtent = Ze.prototype.ab, Ze.prototype.setCoordinates = Ze.prototype.wa, d("ol.geom.Polygon.circular", Qe), d("ol.geom.Polygon.fromExtent", ti), d("ol.geom.Polygon.fromCircle", ei), d("ol.geom.SimpleGeometry", Qt), Qt.prototype.getFirstCoordinate = Qt.prototype.lc, Qt.prototype.getLastCoordinate = Qt.prototype.mc, Qt.prototype.getLayout = Qt.prototype.nc, Qt.prototype.applyTransform = Qt.prototype.cd, Qt.prototype.translate = Qt.prototype.translate, d("ol.format.EsriJSON", Ug), Ug.prototype.readFeature = Ug.prototype.vc, Ug.prototype.readFeatures = Ug.prototype.Ia, Ug.prototype.readGeometry = Ug.prototype.Qd, Ug.prototype.readProjection = Ug.prototype.ib, Ug.prototype.writeGeometry = Ug.prototype.Wd, Ug.prototype.writeGeometryObject = Ug.prototype.og, Ug.prototype.writeFeature = Ug.prototype.Oe, Ug.prototype.writeFeatureObject = Ug.prototype.Vd, Ug.prototype.writeFeatures = Ug.prototype.Ac, Ug.prototype.writeFeaturesObject = Ug.prototype.ng, d("ol.format.Feature", Rn), d("ol.format.GeoJSON", Gn), Gn.prototype.readFeature = Gn.prototype.vc, Gn.prototype.readFeatures = Gn.prototype.Ia, Gn.prototype.readGeometry = Gn.prototype.Qd, Gn.prototype.readProjection = Gn.prototype.ib, Gn.prototype.writeFeature = Gn.prototype.Oe, Gn.prototype.writeFeatureObject = Gn.prototype.Vd, Gn.prototype.writeFeatures = Gn.prototype.Ac, Gn.prototype.writeFeaturesObject = Gn.prototype.ng, Gn.prototype.writeGeometry = Gn.prototype.Wd, Gn.prototype.writeGeometryObject = Gn.prototype.og, d("ol.format.GML", od), od.prototype.writeFeatures = od.prototype.Ac, od.prototype.writeFeaturesNode = od.prototype.a, d("ol.format.GML2", ad), d("ol.format.GML3", od), od.prototype.writeGeometryNode = od.prototype.s, od.prototype.writeFeatures = od.prototype.Ac, od.prototype.writeFeaturesNode = od.prototype.a, Xg.prototype.readFeatures = Xg.prototype.Ia, d("ol.format.GPX", hd), hd.prototype.readFeature = hd.prototype.vc, hd.prototype.readFeatures = hd.prototype.Ia, hd.prototype.readProjection = hd.prototype.ib, hd.prototype.writeFeatures = hd.prototype.Ac, hd.prototype.writeFeaturesNode = hd.prototype.a, d("ol.format.IGC", xd), xd.prototype.readFeature = xd.prototype.vc, xd.prototype.readFeatures = xd.prototype.Ia, xd.prototype.readProjection = xd.prototype.ib, d("ol.format.KML", Ed), Ed.prototype.readFeature = Ed.prototype.vc, Ed.prototype.readFeatures = Ed.prototype.Ia, Ed.prototype.readName = Ed.prototype.Gr, Ed.prototype.readNetworkLinks = Ed.prototype.Hr, Ed.prototype.readProjection = Ed.prototype.ib, Ed.prototype.writeFeatures = Ed.prototype.Ac, Ed.prototype.writeFeaturesNode = Ed.prototype.a, d("ol.format.MVT", ey), ey.prototype.readFeatures = ey.prototype.Ia, ey.prototype.readProjection = ey.prototype.ib, ey.prototype.setLayers = ey.prototype.c, d("ol.format.OSMXML", Cy), Cy.prototype.readFeatures = Cy.prototype.Ia, Cy.prototype.readProjection = Cy.prototype.ib, d("ol.format.Polyline", Ry), d("ol.format.Polyline.encodeDeltas", _y), d("ol.format.Polyline.decodeDeltas", Py), d("ol.format.Polyline.encodeFloats", Oy), d("ol.format.Polyline.decodeFloats", Dy), Ry.prototype.readFeature = Ry.prototype.vc, Ry.prototype.readFeatures = Ry.prototype.Ia, Ry.prototype.readGeometry = Ry.prototype.Qd, Ry.prototype.readProjection = Ry.prototype.ib, Ry.prototype.writeGeometry = Ry.prototype.Wd, d("ol.format.TopoJSON", Fy), Fy.prototype.readFeatures = Fy.prototype.Ia, Fy.prototype.readProjection = Fy.prototype.ib, d("ol.format.WFS", Gy), Gy.prototype.readFeatures = Gy.prototype.Ia, Gy.prototype.readTransactionResponse = Gy.prototype.j, Gy.prototype.readFeatureCollectionMetadata = Gy.prototype.l, Gy.prototype.writeGetFeature = Gy.prototype.o, Gy.prototype.writeTransaction = Gy.prototype.T,
        Gy.prototype.readProjection = Gy.prototype.ib, d("ol.format.WKT", Zy), Zy.prototype.readFeature = Zy.prototype.vc, Zy.prototype.readFeatures = Zy.prototype.Ia, Zy.prototype.readGeometry = Zy.prototype.Qd, Zy.prototype.writeFeature = Zy.prototype.Oe;
    Zy.prototype.writeFeatures = Zy.prototype.Ac;
    Zy.prototype.writeGeometry = Zy.prototype.Wd, d("ol.format.WMSCapabilities", pm), pm.prototype.read = pm.prototype.read, d("ol.format.WMSGetFeatureInfo", ym), ym.prototype.readFeatures = ym.prototype.Ia, d("ol.format.WMTSCapabilities", mm), mm.prototype.read = mm.prototype.read, d("ol.format.ogc.filter.And", sy), d("ol.format.ogc.filter.Bbox", ay), d("ol.format.ogc.filter.Comparison", hy), d("ol.format.ogc.filter.ComparisonBinary", ly), d("ol.format.ogc.filter.EqualTo", uy), d("ol.format.ogc.filter.Filter", ny), d("ol.format.ogc.filter.GreaterThan", py), d("ol.format.ogc.filter.GreaterThanOrEqualTo", cy), d("ol.format.ogc.filter.and", Ny), d("ol.format.ogc.filter.or", function(t, e) { return new Ey(t, e) }), d("ol.format.ogc.filter.not", function(t) { return new wy(t) }), d("ol.format.ogc.filter.bbox", Ly), d("ol.format.ogc.filter.intersects", function(t, e, i) { return new gy(t, e, i) }), d("ol.format.ogc.filter.within", function(t, e, i) { return new Sy(t, e, i) }), d("ol.format.ogc.filter.equalTo", function(t, e, i) { return new uy(t, e, i) }), d("ol.format.ogc.filter.notEqualTo", function(t, e, i) { return new xy(t, e, i) }), d("ol.format.ogc.filter.lessThan", function(t, e) { return new vy(t, e) }), d("ol.format.ogc.filter.lessThanOrEqualTo", function(t, e) { return new by(t, e) }), d("ol.format.ogc.filter.greaterThan", function(t, e) { return new py(t, e) }), d("ol.format.ogc.filter.greaterThanOrEqualTo", function(t, e) { return new cy(t, e) }), d("ol.format.ogc.filter.isNull", function(t) { return new my(t) }), d("ol.format.ogc.filter.between", function(t, e, i) { return new dy(t, e, i) }), d("ol.format.ogc.filter.like", function(t, e, i, n, r, o) { return new yy(t, e, i, n, r, o) }), d("ol.format.ogc.filter.Intersects", gy), d("ol.format.ogc.filter.IsBetween", dy), d("ol.format.ogc.filter.IsLike", yy), d("ol.format.ogc.filter.IsNull", my), d("ol.format.ogc.filter.LessThan", vy), d("ol.format.ogc.filter.LessThanOrEqualTo", by), d("ol.format.ogc.filter.Not", wy), d("ol.format.ogc.filter.NotEqualTo", xy), d("ol.format.ogc.filter.Or", Ey), d("ol.format.ogc.filter.Spatial", fy), d("ol.format.ogc.filter.Within", Sy), d("ol.events.condition.altKeyOnly", function(t) { return t = t.originalEvent, t.altKey && !(t.metaKey || t.ctrlKey) && !t.shiftKey }), d("ol.events.condition.altShiftKeysOnly", np), d("ol.events.condition.always", Q), d("ol.events.condition.click", function(t) { return t.type == cE }), d("ol.events.condition.never", tt), d("ol.events.condition.pointerMove", op), d("ol.events.condition.singleClick", sp), d("ol.events.condition.doubleClick", function(t) { return t.type == fE }), d("ol.events.condition.noModifierKeys", ap), d("ol.events.condition.platformModifierKeyOnly", function(t) { return t = t.originalEvent, !t.altKey && (fw ? t.metaKey : t.ctrlKey) && !t.shiftKey }), d("ol.events.condition.shiftKeyOnly", hp), d("ol.events.condition.targetNotEditable", lp), d("ol.events.condition.mouseOnly", up), d("ol.events.condition.primaryAction", pp), dt.prototype.type = dt.prototype.type, dt.prototype.target = dt.prototype.target, dt.prototype.preventDefault = dt.prototype.preventDefault, dt.prototype.stopPropagation = dt.prototype.stopPropagation, d("ol.control.Attribution", Pu), d("ol.control.Attribution.render", Ou), Pu.prototype.getCollapsible = Pu.prototype.Zo, Pu.prototype.setCollapsible = Pu.prototype.bp, Pu.prototype.setCollapsed = Pu.prototype.ap, Pu.prototype.getCollapsed = Pu.prototype.Yo, d("ol.control.Control", _u), _u.prototype.getMap = _u.prototype.i, _u.prototype.setMap = _u.prototype.setMap, _u.prototype.setTarget = _u.prototype.c, d("ol.control.FullScreen", wg), d("ol.control.defaults", Yu), d("ol.control.MousePosition", Ng), d("ol.control.MousePosition.render", Lg), Ng.prototype.getCoordinateFormat = Ng.prototype.Ji, Ng.prototype.getProjection = Ng.prototype.Gj, Ng.prototype.setCoordinateFormat = Ng.prototype.Mk, Ng.prototype.setProjection = Ng.prototype.Hj, d("ol.control.OverviewMap", Mg), d("ol.control.OverviewMap.render", Ig), Mg.prototype.getCollapsible = Mg.prototype.gp, Mg.prototype.setCollapsible = Mg.prototype.jp, Mg.prototype.setCollapsed = Mg.prototype.ip, Mg.prototype.getCollapsed = Mg.prototype.fp, Mg.prototype.getOverviewMap = Mg.prototype.Tm, d("ol.control.Rotate", Wu), d("ol.control.Rotate.render", Xu), d("ol.control.ScaleLine", og), og.prototype.getUnits = og.prototype.Ub, d("ol.control.ScaleLine.render", sg), og.prototype.setUnits = og.prototype.D, d("ol.control.Zoom", Hu), d("ol.control.ZoomSlider", Rg), d("ol.control.ZoomSlider.render", _g), d("ol.control.ZoomToExtent", Dg), d("ga.Lang", ub), d("ga.Lang.getCode", ub.Ya), d("ga.Lang.setCode", ub.Lk), d("ga.Lang.translate", ub.translate), d("ga.Lang.de", ub.im), d("ga.Lang.en", ub.km), d("ga.Lang.fr", ub.tm), d("ga.Lang.it", ub.to), d("ga.Lang.rm", ub.Wr), d("ga.Map", mg), mg.prototype.geocode = mg.prototype.vm, mg.prototype.recenterFeature = mg.prototype.Pr, mg.prototype.highlightFeature = mg.prototype.mo, mg.prototype.enableTooltip = mg.prototype.lm, mg.prototype.disableTooltip = mg.prototype.jm, d("ol.View2D", bg), d("ga.style.StylesFromLiterals", rn), rn.prototype.getFeatureStyle = rn.prototype.a, d("ga.layer.create", Vo), St.prototype.changed = St.prototype.u, St.prototype.dispatchEvent = St.prototype.b, St.prototype.getRevision = St.prototype.K, St.prototype.on = St.prototype.I, St.prototype.once = St.prototype.L, St.prototype.un = St.prototype.J, St.prototype.unByKey = St.prototype.M, Wn.prototype.get = Wn.prototype.get, Wn.prototype.getKeys = Wn.prototype.R, Wn.prototype.getProperties = Wn.prototype.N, Wn.prototype.set = Wn.prototype.set, Wn.prototype.setProperties = Wn.prototype.G, Wn.prototype.unset = Wn.prototype.S, Wn.prototype.changed = Wn.prototype.u, Wn.prototype.dispatchEvent = Wn.prototype.b, Wn.prototype.getRevision = Wn.prototype.K, Wn.prototype.on = Wn.prototype.I, Wn.prototype.once = Wn.prototype.L, Wn.prototype.un = Wn.prototype.J, Wn.prototype.unByKey = Wn.prototype.M, Hn.prototype.type = Hn.prototype.type, Hn.prototype.target = Hn.prototype.target, Hn.prototype.preventDefault = Hn.prototype.preventDefault, Hn.prototype.stopPropagation = Hn.prototype.stopPropagation, Fg.prototype.get = Fg.prototype.get, Fg.prototype.getKeys = Fg.prototype.R, Fg.prototype.getProperties = Fg.prototype.N, Fg.prototype.set = Fg.prototype.set, Fg.prototype.setProperties = Fg.prototype.G, Fg.prototype.unset = Fg.prototype.S, Fg.prototype.changed = Fg.prototype.u, Fg.prototype.dispatchEvent = Fg.prototype.b, Fg.prototype.getRevision = Fg.prototype.K, Fg.prototype.on = Fg.prototype.I, Fg.prototype.once = Fg.prototype.L, Fg.prototype.un = Fg.prototype.J, Fg.prototype.unByKey = Fg.prototype.M, Tn.prototype.get = Tn.prototype.get, Tn.prototype.getKeys = Tn.prototype.R, Tn.prototype.getProperties = Tn.prototype.N, Tn.prototype.set = Tn.prototype.set, Tn.prototype.setProperties = Tn.prototype.G, Tn.prototype.unset = Tn.prototype.S, Tn.prototype.changed = Tn.prototype.u, Tn.prototype.dispatchEvent = Tn.prototype.b, Tn.prototype.getRevision = Tn.prototype.K, Tn.prototype.on = Tn.prototype.I, Tn.prototype.once = Tn.prototype.L, Tn.prototype.un = Tn.prototype.J, Tn.prototype.unByKey = Tn.prototype.M, bm.prototype.get = bm.prototype.get, bm.prototype.getKeys = bm.prototype.R, bm.prototype.getProperties = bm.prototype.N, bm.prototype.set = bm.prototype.set, bm.prototype.setProperties = bm.prototype.G, bm.prototype.unset = bm.prototype.S, bm.prototype.changed = bm.prototype.u, bm.prototype.dispatchEvent = bm.prototype.b, bm.prototype.getRevision = bm.prototype.K, bm.prototype.on = bm.prototype.I, bm.prototype.once = bm.prototype.L, bm.prototype.un = bm.prototype.J, bm.prototype.unByKey = bm.prototype.M, Hr.prototype.getTileCoord = Hr.prototype.i, ng.prototype.get = ng.prototype.get, ng.prototype.getKeys = ng.prototype.R, ng.prototype.getProperties = ng.prototype.N, ng.prototype.set = ng.prototype.set, ng.prototype.setProperties = ng.prototype.G, ng.prototype.unset = ng.prototype.S, ng.prototype.changed = ng.prototype.u, ng.prototype.dispatchEvent = ng.prototype.b, ng.prototype.getRevision = ng.prototype.K, ng.prototype.on = ng.prototype.I, ng.prototype.once = ng.prototype.L, ng.prototype.un = ng.prototype.J, ng.prototype.unByKey = ng.prototype.M, ll.prototype.type = ll.prototype.type, ll.prototype.target = ll.prototype.target, ll.prototype.preventDefault = ll.prototype.preventDefault, ll.prototype.stopPropagation = ll.prototype.stopPropagation, _l.prototype.map = _l.prototype.map, _l.prototype.frameState = _l.prototype.frameState, _l.prototype.type = _l.prototype.type, _l.prototype.target = _l.prototype.target, _l.prototype.preventDefault = _l.prototype.preventDefault, _l.prototype.stopPropagation = _l.prototype.stopPropagation;
    Pl.prototype.originalEvent = Pl.prototype.originalEvent;
    Pl.prototype.pixel = Pl.prototype.pixel, Pl.prototype.coordinate = Pl.prototype.coordinate, Pl.prototype.dragging = Pl.prototype.dragging, Pl.prototype.preventDefault = Pl.prototype.preventDefault, Pl.prototype.stopPropagation = Pl.prototype.stopPropagation, Pl.prototype.map = Pl.prototype.map, Pl.prototype.frameState = Pl.prototype.frameState, Pl.prototype.type = Pl.prototype.type, Pl.prototype.target = Pl.prototype.target, Et.prototype.type = Et.prototype.type, Et.prototype.target = Et.prototype.target, Et.prototype.preventDefault = Et.prototype.preventDefault, Et.prototype.stopPropagation = Et.prototype.stopPropagation, lg.prototype.get = lg.prototype.get, lg.prototype.getKeys = lg.prototype.R, lg.prototype.getProperties = lg.prototype.N, lg.prototype.set = lg.prototype.set, lg.prototype.setProperties = lg.prototype.G, lg.prototype.unset = lg.prototype.S, lg.prototype.changed = lg.prototype.u, lg.prototype.dispatchEvent = lg.prototype.b, lg.prototype.getRevision = lg.prototype.K, lg.prototype.on = lg.prototype.I, lg.prototype.once = lg.prototype.L, lg.prototype.un = lg.prototype.J, lg.prototype.unByKey = lg.prototype.M, Zv.prototype.getTileCoord = Zv.prototype.i, Cu.prototype.get = Cu.prototype.get, Cu.prototype.getKeys = Cu.prototype.R, Cu.prototype.getProperties = Cu.prototype.N, Cu.prototype.set = Cu.prototype.set, Cu.prototype.setProperties = Cu.prototype.G, Cu.prototype.unset = Cu.prototype.S, Cu.prototype.changed = Cu.prototype.u, Cu.prototype.dispatchEvent = Cu.prototype.b, Cu.prototype.getRevision = Cu.prototype.K, Cu.prototype.on = Cu.prototype.I, Cu.prototype.once = Cu.prototype.L, Cu.prototype.un = Cu.prototype.J, Cu.prototype.unByKey = Cu.prototype.M, jo.prototype.forEachTileCoord = jo.prototype.Ei, jo.prototype.getMaxZoom = jo.prototype.Ri, jo.prototype.getMinZoom = jo.prototype.Si, jo.prototype.getOrigin = jo.prototype.$a, jo.prototype.getResolution = jo.prototype.aa, jo.prototype.getResolutions = jo.prototype.jk, jo.prototype.getTileCoordExtent = jo.prototype.Na, jo.prototype.getTileCoordForCoordAndResolution = jo.prototype.nf, jo.prototype.getTileCoordForCoordAndZ = jo.prototype.ue, jo.prototype.getTileSize = jo.prototype.gb, jo.prototype.getZForResolution = jo.prototype.Kc, Fi.prototype.getOpacity = Fi.prototype.Rf, Fi.prototype.getRotateWithView = Fi.prototype.Sf, Fi.prototype.getRotation = Fi.prototype.Tf, Fi.prototype.getScale = Fi.prototype.Uf, Fi.prototype.getSnapToPixel = Fi.prototype.mf, Fi.prototype.setOpacity = Fi.prototype.Vf, Fi.prototype.setRotation = Fi.prototype.Wf, Fi.prototype.setScale = Fi.prototype.Xf, en.prototype.getOpacity = en.prototype.Rf, en.prototype.getRotateWithView = en.prototype.Sf, en.prototype.getRotation = en.prototype.Tf, en.prototype.getScale = en.prototype.Uf, en.prototype.getSnapToPixel = en.prototype.mf, en.prototype.setOpacity = en.prototype.Vf, en.prototype.setRotation = en.prototype.Wf, en.prototype.setScale = en.prototype.Xf, nn.prototype.getOpacity = nn.prototype.Rf, nn.prototype.getRotateWithView = nn.prototype.Sf, nn.prototype.getRotation = nn.prototype.Tf, nn.prototype.getScale = nn.prototype.Uf, nn.prototype.getSnapToPixel = nn.prototype.mf, nn.prototype.setOpacity = nn.prototype.Vf, nn.prototype.setRotation = nn.prototype.Wf, nn.prototype.setScale = nn.prototype.Xf, wr.prototype.get = wr.prototype.get, wr.prototype.getKeys = wr.prototype.R, wr.prototype.getProperties = wr.prototype.N, wr.prototype.set = wr.prototype.set, wr.prototype.setProperties = wr.prototype.G, wr.prototype.unset = wr.prototype.S, wr.prototype.changed = wr.prototype.u, wr.prototype.dispatchEvent = wr.prototype.b, wr.prototype.getRevision = wr.prototype.K, wr.prototype.on = wr.prototype.I, wr.prototype.once = wr.prototype.L, wr.prototype.un = wr.prototype.J, wr.prototype.unByKey = wr.prototype.M, uo.prototype.getAttributions = uo.prototype.Da, uo.prototype.getLogo = uo.prototype.Ca, uo.prototype.getProjection = uo.prototype.Ea, uo.prototype.getState = uo.prototype.W, uo.prototype.refresh = uo.prototype.Ba, uo.prototype.setAttributions = uo.prototype.va, uo.prototype.get = uo.prototype.get, uo.prototype.getKeys = uo.prototype.R, uo.prototype.getProperties = uo.prototype.N, uo.prototype.set = uo.prototype.set, uo.prototype.setProperties = uo.prototype.G, uo.prototype.unset = uo.prototype.S, uo.prototype.changed = uo.prototype.u, uo.prototype.dispatchEvent = uo.prototype.b, uo.prototype.getRevision = uo.prototype.K, uo.prototype.on = uo.prototype.I, uo.prototype.once = uo.prototype.L, uo.prototype.un = uo.prototype.J, uo.prototype.unByKey = uo.prototype.M, yo.prototype.getTileGrid = yo.prototype.fb, yo.prototype.refresh = yo.prototype.Ba, yo.prototype.getAttributions = yo.prototype.Da, yo.prototype.getLogo = yo.prototype.Ca, yo.prototype.getProjection = yo.prototype.Ea, yo.prototype.getState = yo.prototype.W, yo.prototype.setAttributions = yo.prototype.va, yo.prototype.get = yo.prototype.get, yo.prototype.getKeys = yo.prototype.R, yo.prototype.getProperties = yo.prototype.N, yo.prototype.set = yo.prototype.set, yo.prototype.setProperties = yo.prototype.G, yo.prototype.unset = yo.prototype.S, yo.prototype.changed = yo.prototype.u, yo.prototype.dispatchEvent = yo.prototype.b, yo.prototype.getRevision = yo.prototype.K, yo.prototype.on = yo.prototype.I, yo.prototype.once = yo.prototype.L, yo.prototype.un = yo.prototype.J, yo.prototype.unByKey = yo.prototype.M, mo.prototype.getTileLoadFunction = mo.prototype.zb, mo.prototype.getTileUrlFunction = mo.prototype.Ab, mo.prototype.getUrls = mo.prototype.Bb, mo.prototype.setTileLoadFunction = mo.prototype.Eb, mo.prototype.setTileUrlFunction = mo.prototype.kb, mo.prototype.setUrl = mo.prototype.rb, mo.prototype.setUrls = mo.prototype.lb, mo.prototype.getTileGrid = mo.prototype.fb, mo.prototype.refresh = mo.prototype.Ba, mo.prototype.getAttributions = mo.prototype.Da, mo.prototype.getLogo = mo.prototype.Ca, mo.prototype.getProjection = mo.prototype.Ea, mo.prototype.getState = mo.prototype.W, mo.prototype.setAttributions = mo.prototype.va, mo.prototype.get = mo.prototype.get, mo.prototype.getKeys = mo.prototype.R, mo.prototype.getProperties = mo.prototype.N, mo.prototype.set = mo.prototype.set, mo.prototype.setProperties = mo.prototype.G, mo.prototype.unset = mo.prototype.S, mo.prototype.changed = mo.prototype.u, mo.prototype.dispatchEvent = mo.prototype.b, mo.prototype.getRevision = mo.prototype.K, mo.prototype.on = mo.prototype.I, mo.prototype.once = mo.prototype.L, mo.prototype.un = mo.prototype.J, mo.prototype.unByKey = mo.prototype.M, Lv.prototype.setRenderReprojectionEdges = Lv.prototype.Wb, Lv.prototype.setTileGridForProjection = Lv.prototype.Zb, Lv.prototype.getTileLoadFunction = Lv.prototype.zb, Lv.prototype.getTileUrlFunction = Lv.prototype.Ab, Lv.prototype.getUrls = Lv.prototype.Bb, Lv.prototype.setTileLoadFunction = Lv.prototype.Eb, Lv.prototype.setTileUrlFunction = Lv.prototype.kb, Lv.prototype.setUrl = Lv.prototype.rb, Lv.prototype.setUrls = Lv.prototype.lb, Lv.prototype.getTileGrid = Lv.prototype.fb, Lv.prototype.refresh = Lv.prototype.Ba, Lv.prototype.getAttributions = Lv.prototype.Da, Lv.prototype.getLogo = Lv.prototype.Ca, Lv.prototype.getProjection = Lv.prototype.Ea, Lv.prototype.getState = Lv.prototype.W, Lv.prototype.setAttributions = Lv.prototype.va, Lv.prototype.get = Lv.prototype.get, Lv.prototype.getKeys = Lv.prototype.R, Lv.prototype.getProperties = Lv.prototype.N, Lv.prototype.set = Lv.prototype.set, Lv.prototype.setProperties = Lv.prototype.G, Lv.prototype.unset = Lv.prototype.S, Lv.prototype.changed = Lv.prototype.u, Lv.prototype.dispatchEvent = Lv.prototype.b, Lv.prototype.getRevision = Lv.prototype.K, Lv.prototype.on = Lv.prototype.I, Lv.prototype.once = Lv.prototype.L, Lv.prototype.un = Lv.prototype.J, Lv.prototype.unByKey = Lv.prototype.M, Cv.prototype.setRenderReprojectionEdges = Cv.prototype.Wb, Cv.prototype.setTileGridForProjection = Cv.prototype.Zb, Cv.prototype.getTileLoadFunction = Cv.prototype.zb, Cv.prototype.getTileUrlFunction = Cv.prototype.Ab, Cv.prototype.getUrls = Cv.prototype.Bb, Cv.prototype.setTileLoadFunction = Cv.prototype.Eb, Cv.prototype.setTileUrlFunction = Cv.prototype.kb, Cv.prototype.setUrl = Cv.prototype.rb, Cv.prototype.setUrls = Cv.prototype.lb, Cv.prototype.getTileGrid = Cv.prototype.fb, Cv.prototype.refresh = Cv.prototype.Ba, Cv.prototype.getAttributions = Cv.prototype.Da, Cv.prototype.getLogo = Cv.prototype.Ca, Cv.prototype.getProjection = Cv.prototype.Ea, Cv.prototype.getState = Cv.prototype.W, Cv.prototype.setAttributions = Cv.prototype.va, Cv.prototype.get = Cv.prototype.get;
    Cv.prototype.getKeys = Cv.prototype.R;
    Cv.prototype.getProperties = Cv.prototype.N, Cv.prototype.set = Cv.prototype.set, Cv.prototype.setProperties = Cv.prototype.G, Cv.prototype.unset = Cv.prototype.S, Cv.prototype.changed = Cv.prototype.u, Cv.prototype.dispatchEvent = Cv.prototype.b, Cv.prototype.getRevision = Cv.prototype.K, Cv.prototype.on = Cv.prototype.I, Cv.prototype.once = Cv.prototype.L, Cv.prototype.un = Cv.prototype.J, Cv.prototype.unByKey = Cv.prototype.M, Mv.prototype.setRenderReprojectionEdges = Mv.prototype.Wb, Mv.prototype.setTileGridForProjection = Mv.prototype.Zb, Mv.prototype.getTileLoadFunction = Mv.prototype.zb, Mv.prototype.getTileUrlFunction = Mv.prototype.Ab, Mv.prototype.getUrls = Mv.prototype.Bb, Mv.prototype.setTileLoadFunction = Mv.prototype.Eb, Mv.prototype.setTileUrlFunction = Mv.prototype.kb, Mv.prototype.setUrl = Mv.prototype.rb, Mv.prototype.setUrls = Mv.prototype.lb, Mv.prototype.getTileGrid = Mv.prototype.fb, Mv.prototype.refresh = Mv.prototype.Ba, Mv.prototype.getAttributions = Mv.prototype.Da, Mv.prototype.getLogo = Mv.prototype.Ca, Mv.prototype.getProjection = Mv.prototype.Ea, Mv.prototype.getState = Mv.prototype.W, Mv.prototype.setAttributions = Mv.prototype.va, Mv.prototype.get = Mv.prototype.get, Mv.prototype.getKeys = Mv.prototype.R, Mv.prototype.getProperties = Mv.prototype.N, Mv.prototype.set = Mv.prototype.set, Mv.prototype.setProperties = Mv.prototype.G, Mv.prototype.unset = Mv.prototype.S, Mv.prototype.changed = Mv.prototype.u, Mv.prototype.dispatchEvent = Mv.prototype.b, Mv.prototype.getRevision = Mv.prototype.K, Mv.prototype.on = Mv.prototype.I, Mv.prototype.once = Mv.prototype.L, Mv.prototype.un = Mv.prototype.J, Mv.prototype.unByKey = Mv.prototype.M, kr.prototype.getAttributions = kr.prototype.Da, kr.prototype.getLogo = kr.prototype.Ca, kr.prototype.getProjection = kr.prototype.Ea, kr.prototype.getState = kr.prototype.W, kr.prototype.refresh = kr.prototype.Ba, kr.prototype.setAttributions = kr.prototype.va, kr.prototype.get = kr.prototype.get, kr.prototype.getKeys = kr.prototype.R, kr.prototype.getProperties = kr.prototype.N, kr.prototype.set = kr.prototype.set, kr.prototype.setProperties = kr.prototype.G, kr.prototype.unset = kr.prototype.S, kr.prototype.changed = kr.prototype.u, kr.prototype.dispatchEvent = kr.prototype.b, kr.prototype.getRevision = kr.prototype.K, kr.prototype.on = kr.prototype.I, kr.prototype.once = kr.prototype.L, kr.prototype.un = kr.prototype.J, kr.prototype.unByKey = kr.prototype.M, Tv.prototype.addFeature = Tv.prototype.Nb, Tv.prototype.addFeatures = Tv.prototype.Bc, Tv.prototype.clear = Tv.prototype.clear, Tv.prototype.forEachFeature = Tv.prototype.Ci, Tv.prototype.forEachFeatureInExtent = Tv.prototype.Rb, Tv.prototype.forEachFeatureIntersectingExtent = Tv.prototype.Di, Tv.prototype.getFeaturesCollection = Tv.prototype.Ni, Tv.prototype.getFeatures = Tv.prototype.Pf, Tv.prototype.getFeaturesAtCoordinate = Tv.prototype.Mi, Tv.prototype.getFeaturesInExtent = Tv.prototype.Ug, Tv.prototype.getClosestFeatureToCoordinate = Tv.prototype.Gi, Tv.prototype.getExtent = Tv.prototype.H, Tv.prototype.getFeatureById = Tv.prototype.Li, Tv.prototype.getFormat = Tv.prototype.bk, Tv.prototype.getUrl = Tv.prototype.ck, Tv.prototype.removeFeature = Tv.prototype.Kb, Tv.prototype.getAttributions = Tv.prototype.Da, Tv.prototype.getLogo = Tv.prototype.Ca, Tv.prototype.getProjection = Tv.prototype.Ea, Tv.prototype.getState = Tv.prototype.W, Tv.prototype.refresh = Tv.prototype.Ba, Tv.prototype.setAttributions = Tv.prototype.va, Tv.prototype.get = Tv.prototype.get, Tv.prototype.getKeys = Tv.prototype.R, Tv.prototype.getProperties = Tv.prototype.N, Tv.prototype.set = Tv.prototype.set, Tv.prototype.setProperties = Tv.prototype.G, Tv.prototype.unset = Tv.prototype.S, Tv.prototype.changed = Tv.prototype.u, Tv.prototype.dispatchEvent = Tv.prototype.b, Tv.prototype.getRevision = Tv.prototype.K, Tv.prototype.on = Tv.prototype.I, Tv.prototype.once = Tv.prototype.L, Tv.prototype.un = Tv.prototype.J, Tv.prototype.unByKey = Tv.prototype.M, _o.prototype.getAttributions = _o.prototype.Da, _o.prototype.getLogo = _o.prototype.Ca, _o.prototype.getProjection = _o.prototype.Ea, _o.prototype.getState = _o.prototype.W, _o.prototype.refresh = _o.prototype.Ba, _o.prototype.setAttributions = _o.prototype.va, _o.prototype.get = _o.prototype.get, _o.prototype.getKeys = _o.prototype.R, _o.prototype.getProperties = _o.prototype.N, _o.prototype.set = _o.prototype.set, _o.prototype.setProperties = _o.prototype.G, _o.prototype.unset = _o.prototype.S, _o.prototype.changed = _o.prototype.u, _o.prototype.dispatchEvent = _o.prototype.b, _o.prototype.getRevision = _o.prototype.K, _o.prototype.on = _o.prototype.I, _o.prototype.once = _o.prototype.L, _o.prototype.un = _o.prototype.J, _o.prototype.unByKey = _o.prototype.M, Do.prototype.type = Do.prototype.type, Do.prototype.target = Do.prototype.target, Do.prototype.preventDefault = Do.prototype.preventDefault, Do.prototype.stopPropagation = Do.prototype.stopPropagation, _v.prototype.getAttributions = _v.prototype.Da, _v.prototype.getLogo = _v.prototype.Ca, _v.prototype.getProjection = _v.prototype.Ea, _v.prototype.getState = _v.prototype.W, _v.prototype.refresh = _v.prototype.Ba, _v.prototype.setAttributions = _v.prototype.va, _v.prototype.get = _v.prototype.get, _v.prototype.getKeys = _v.prototype.R, _v.prototype.getProperties = _v.prototype.N, _v.prototype.set = _v.prototype.set, _v.prototype.setProperties = _v.prototype.G, _v.prototype.unset = _v.prototype.S, _v.prototype.changed = _v.prototype.u, _v.prototype.dispatchEvent = _v.prototype.b, _v.prototype.getRevision = _v.prototype.K, _v.prototype.on = _v.prototype.I, _v.prototype.once = _v.prototype.L, _v.prototype.un = _v.prototype.J, _v.prototype.unByKey = _v.prototype.M, Wc.prototype.getAttributions = Wc.prototype.Da, Wc.prototype.getLogo = Wc.prototype.Ca, Wc.prototype.getProjection = Wc.prototype.Ea, Wc.prototype.getState = Wc.prototype.W, Wc.prototype.refresh = Wc.prototype.Ba, Wc.prototype.setAttributions = Wc.prototype.va, Wc.prototype.get = Wc.prototype.get, Wc.prototype.getKeys = Wc.prototype.R, Wc.prototype.getProperties = Wc.prototype.N, Wc.prototype.set = Wc.prototype.set, Wc.prototype.setProperties = Wc.prototype.G, Wc.prototype.unset = Wc.prototype.S, Wc.prototype.changed = Wc.prototype.u, Wc.prototype.dispatchEvent = Wc.prototype.b, Wc.prototype.getRevision = Wc.prototype.K, Wc.prototype.on = Wc.prototype.I, Wc.prototype.once = Wc.prototype.L, Wc.prototype.un = Wc.prototype.J, Wc.prototype.unByKey = Wc.prototype.M, Pv.prototype.getAttributions = Pv.prototype.Da, Pv.prototype.getLogo = Pv.prototype.Ca, Pv.prototype.getProjection = Pv.prototype.Ea, Pv.prototype.getState = Pv.prototype.W, Pv.prototype.refresh = Pv.prototype.Ba, Pv.prototype.setAttributions = Pv.prototype.va, Pv.prototype.get = Pv.prototype.get, Pv.prototype.getKeys = Pv.prototype.R, Pv.prototype.getProperties = Pv.prototype.N, Pv.prototype.set = Pv.prototype.set, Pv.prototype.setProperties = Pv.prototype.G, Pv.prototype.unset = Pv.prototype.S, Pv.prototype.changed = Pv.prototype.u, Pv.prototype.dispatchEvent = Pv.prototype.b, Pv.prototype.getRevision = Pv.prototype.K, Pv.prototype.on = Pv.prototype.I, Pv.prototype.once = Pv.prototype.L, Pv.prototype.un = Pv.prototype.J, Pv.prototype.unByKey = Pv.prototype.M, Ov.prototype.getAttributions = Ov.prototype.Da, Ov.prototype.getLogo = Ov.prototype.Ca, Ov.prototype.getProjection = Ov.prototype.Ea, Ov.prototype.getState = Ov.prototype.W, Ov.prototype.refresh = Ov.prototype.Ba, Ov.prototype.setAttributions = Ov.prototype.va, Ov.prototype.get = Ov.prototype.get, Ov.prototype.getKeys = Ov.prototype.R, Ov.prototype.getProperties = Ov.prototype.N, Ov.prototype.set = Ov.prototype.set, Ov.prototype.setProperties = Ov.prototype.G, Ov.prototype.unset = Ov.prototype.S, Ov.prototype.changed = Ov.prototype.u, Ov.prototype.dispatchEvent = Ov.prototype.b, Ov.prototype.getRevision = Ov.prototype.K, Ov.prototype.on = Ov.prototype.I, Ov.prototype.once = Ov.prototype.L, Ov.prototype.un = Ov.prototype.J, Ov.prototype.unByKey = Ov.prototype.M, Xc.prototype.getAttributions = Xc.prototype.Da, Xc.prototype.getLogo = Xc.prototype.Ca, Xc.prototype.getProjection = Xc.prototype.Ea, Xc.prototype.getState = Xc.prototype.W, Xc.prototype.refresh = Xc.prototype.Ba, Xc.prototype.setAttributions = Xc.prototype.va, Xc.prototype.get = Xc.prototype.get;
    Xc.prototype.getKeys = Xc.prototype.R;
    Xc.prototype.getProperties = Xc.prototype.N, Xc.prototype.set = Xc.prototype.set, Xc.prototype.setProperties = Xc.prototype.G, Xc.prototype.unset = Xc.prototype.S, Xc.prototype.changed = Xc.prototype.u, Xc.prototype.dispatchEvent = Xc.prototype.b, Xc.prototype.getRevision = Xc.prototype.K, Xc.prototype.on = Xc.prototype.I, Xc.prototype.once = Xc.prototype.L, Xc.prototype.un = Xc.prototype.J, Xc.prototype.unByKey = Xc.prototype.M, Fo.prototype.getAttributions = Fo.prototype.Da, Fo.prototype.getLogo = Fo.prototype.Ca, Fo.prototype.getProjection = Fo.prototype.Ea, Fo.prototype.getState = Fo.prototype.W, Fo.prototype.refresh = Fo.prototype.Ba, Fo.prototype.setAttributions = Fo.prototype.va, Fo.prototype.get = Fo.prototype.get, Fo.prototype.getKeys = Fo.prototype.R, Fo.prototype.getProperties = Fo.prototype.N, Fo.prototype.set = Fo.prototype.set, Fo.prototype.setProperties = Fo.prototype.G, Fo.prototype.unset = Fo.prototype.S, Fo.prototype.changed = Fo.prototype.u, Fo.prototype.dispatchEvent = Fo.prototype.b, Fo.prototype.getRevision = Fo.prototype.K, Fo.prototype.on = Fo.prototype.I, Fo.prototype.once = Fo.prototype.L, Fo.prototype.un = Fo.prototype.J, Fo.prototype.unByKey = Fo.prototype.M, Dv.prototype.setRenderReprojectionEdges = Dv.prototype.Wb, Dv.prototype.setTileGridForProjection = Dv.prototype.Zb, Dv.prototype.getTileLoadFunction = Dv.prototype.zb, Dv.prototype.getTileUrlFunction = Dv.prototype.Ab, Dv.prototype.getUrls = Dv.prototype.Bb, Dv.prototype.setTileLoadFunction = Dv.prototype.Eb, Dv.prototype.setTileUrlFunction = Dv.prototype.kb, Dv.prototype.setUrl = Dv.prototype.rb, Dv.prototype.setUrls = Dv.prototype.lb, Dv.prototype.getTileGrid = Dv.prototype.fb, Dv.prototype.refresh = Dv.prototype.Ba, Dv.prototype.getAttributions = Dv.prototype.Da, Dv.prototype.getLogo = Dv.prototype.Ca, Dv.prototype.getProjection = Dv.prototype.Ea, Dv.prototype.getState = Dv.prototype.W, Dv.prototype.setAttributions = Dv.prototype.va, Dv.prototype.get = Dv.prototype.get, Dv.prototype.getKeys = Dv.prototype.R, Dv.prototype.getProperties = Dv.prototype.N, Dv.prototype.set = Dv.prototype.set, Dv.prototype.setProperties = Dv.prototype.G, Dv.prototype.unset = Dv.prototype.S, Dv.prototype.changed = Dv.prototype.u, Dv.prototype.dispatchEvent = Dv.prototype.b, Dv.prototype.getRevision = Dv.prototype.K, Dv.prototype.on = Dv.prototype.I, Dv.prototype.once = Dv.prototype.L, Dv.prototype.un = Dv.prototype.J, Dv.prototype.unByKey = Dv.prototype.M, Fv.prototype.getAttributions = Fv.prototype.Da, Fv.prototype.getLogo = Fv.prototype.Ca, Fv.prototype.getProjection = Fv.prototype.Ea, Fv.prototype.getState = Fv.prototype.W, Fv.prototype.refresh = Fv.prototype.Ba, Fv.prototype.setAttributions = Fv.prototype.va, Fv.prototype.get = Fv.prototype.get, Fv.prototype.getKeys = Fv.prototype.R, Fv.prototype.getProperties = Fv.prototype.N, Fv.prototype.set = Fv.prototype.set, Fv.prototype.setProperties = Fv.prototype.G, Fv.prototype.unset = Fv.prototype.S, Fv.prototype.changed = Fv.prototype.u, Fv.prototype.dispatchEvent = Fv.prototype.b, Fv.prototype.getRevision = Fv.prototype.K, Fv.prototype.on = Fv.prototype.I, Fv.prototype.once = Fv.prototype.L, Fv.prototype.un = Fv.prototype.J, Fv.prototype.unByKey = Fv.prototype.M, zv.prototype.type = zv.prototype.type, zv.prototype.target = zv.prototype.target, zv.prototype.preventDefault = zv.prototype.preventDefault, zv.prototype.stopPropagation = zv.prototype.stopPropagation, Gv.prototype.setRenderReprojectionEdges = Gv.prototype.Wb, Gv.prototype.setTileGridForProjection = Gv.prototype.Zb, Gv.prototype.getTileLoadFunction = Gv.prototype.zb, Gv.prototype.getTileUrlFunction = Gv.prototype.Ab, Gv.prototype.getUrls = Gv.prototype.Bb, Gv.prototype.setTileLoadFunction = Gv.prototype.Eb, Gv.prototype.setTileUrlFunction = Gv.prototype.kb, Gv.prototype.setUrl = Gv.prototype.rb, Gv.prototype.setUrls = Gv.prototype.lb, Gv.prototype.getTileGrid = Gv.prototype.fb, Gv.prototype.refresh = Gv.prototype.Ba, Gv.prototype.getAttributions = Gv.prototype.Da, Gv.prototype.getLogo = Gv.prototype.Ca, Gv.prototype.getProjection = Gv.prototype.Ea, Gv.prototype.getState = Gv.prototype.W, Gv.prototype.setAttributions = Gv.prototype.va, Gv.prototype.get = Gv.prototype.get, Gv.prototype.getKeys = Gv.prototype.R, Gv.prototype.getProperties = Gv.prototype.N, Gv.prototype.set = Gv.prototype.set, Gv.prototype.setProperties = Gv.prototype.G, Gv.prototype.unset = Gv.prototype.S, Gv.prototype.changed = Gv.prototype.u, Gv.prototype.dispatchEvent = Gv.prototype.b, Gv.prototype.getRevision = Gv.prototype.K, Gv.prototype.on = Gv.prototype.I, Gv.prototype.once = Gv.prototype.L, Gv.prototype.un = Gv.prototype.J, Gv.prototype.unByKey = Gv.prototype.M, go.prototype.type = go.prototype.type, go.prototype.target = go.prototype.target, go.prototype.preventDefault = go.prototype.preventDefault, go.prototype.stopPropagation = go.prototype.stopPropagation, qv.prototype.setRenderReprojectionEdges = qv.prototype.Wb, qv.prototype.setTileGridForProjection = qv.prototype.Zb, qv.prototype.getTileLoadFunction = qv.prototype.zb, qv.prototype.getTileUrlFunction = qv.prototype.Ab, qv.prototype.getUrls = qv.prototype.Bb, qv.prototype.setTileLoadFunction = qv.prototype.Eb, qv.prototype.setTileUrlFunction = qv.prototype.kb, qv.prototype.setUrl = qv.prototype.rb, qv.prototype.setUrls = qv.prototype.lb, qv.prototype.getTileGrid = qv.prototype.fb, qv.prototype.refresh = qv.prototype.Ba, qv.prototype.getAttributions = qv.prototype.Da, qv.prototype.getLogo = qv.prototype.Ca, qv.prototype.getProjection = qv.prototype.Ea, qv.prototype.getState = qv.prototype.W, qv.prototype.setAttributions = qv.prototype.va, qv.prototype.get = qv.prototype.get, qv.prototype.getKeys = qv.prototype.R, qv.prototype.getProperties = qv.prototype.N, qv.prototype.set = qv.prototype.set, qv.prototype.setProperties = qv.prototype.G, qv.prototype.unset = qv.prototype.S, qv.prototype.changed = qv.prototype.u, qv.prototype.dispatchEvent = qv.prototype.b, qv.prototype.getRevision = qv.prototype.K, qv.prototype.on = qv.prototype.I, qv.prototype.once = qv.prototype.L, qv.prototype.un = qv.prototype.J, qv.prototype.unByKey = qv.prototype.M, Wv.prototype.getTileGrid = Wv.prototype.fb, Wv.prototype.refresh = Wv.prototype.Ba, Wv.prototype.getAttributions = Wv.prototype.Da, Wv.prototype.getLogo = Wv.prototype.Ca, Wv.prototype.getProjection = Wv.prototype.Ea, Wv.prototype.getState = Wv.prototype.W, Wv.prototype.setAttributions = Wv.prototype.va, Wv.prototype.get = Wv.prototype.get, Wv.prototype.getKeys = Wv.prototype.R, Wv.prototype.getProperties = Wv.prototype.N, Wv.prototype.set = Wv.prototype.set, Wv.prototype.setProperties = Wv.prototype.G, Wv.prototype.unset = Wv.prototype.S, Wv.prototype.changed = Wv.prototype.u, Wv.prototype.dispatchEvent = Wv.prototype.b, Wv.prototype.getRevision = Wv.prototype.K, Wv.prototype.on = Wv.prototype.I, Wv.prototype.once = Wv.prototype.L, Wv.prototype.un = Wv.prototype.J, Wv.prototype.unByKey = Wv.prototype.M, Xv.prototype.setRenderReprojectionEdges = Xv.prototype.Wb, Xv.prototype.setTileGridForProjection = Xv.prototype.Zb, Xv.prototype.getTileLoadFunction = Xv.prototype.zb, Xv.prototype.getTileUrlFunction = Xv.prototype.Ab, Xv.prototype.getUrls = Xv.prototype.Bb, Xv.prototype.setTileLoadFunction = Xv.prototype.Eb, Xv.prototype.setTileUrlFunction = Xv.prototype.kb, Xv.prototype.setUrl = Xv.prototype.rb, Xv.prototype.setUrls = Xv.prototype.lb, Xv.prototype.getTileGrid = Xv.prototype.fb, Xv.prototype.refresh = Xv.prototype.Ba, Xv.prototype.getAttributions = Xv.prototype.Da, Xv.prototype.getLogo = Xv.prototype.Ca, Xv.prototype.getProjection = Xv.prototype.Ea, Xv.prototype.getState = Xv.prototype.W, Xv.prototype.setAttributions = Xv.prototype.va, Xv.prototype.get = Xv.prototype.get, Xv.prototype.getKeys = Xv.prototype.R, Xv.prototype.getProperties = Xv.prototype.N, Xv.prototype.set = Xv.prototype.set, Xv.prototype.setProperties = Xv.prototype.G, Xv.prototype.unset = Xv.prototype.S, Xv.prototype.changed = Xv.prototype.u, Xv.prototype.dispatchEvent = Xv.prototype.b, Xv.prototype.getRevision = Xv.prototype.K, Xv.prototype.on = Xv.prototype.I, Xv.prototype.once = Xv.prototype.L, Xv.prototype.un = Xv.prototype.J, Xv.prototype.unByKey = Xv.prototype.M, Hv.prototype.getTileGrid = Hv.prototype.fb, Hv.prototype.refresh = Hv.prototype.Ba,
        Hv.prototype.getAttributions = Hv.prototype.Da, Hv.prototype.getLogo = Hv.prototype.Ca, Hv.prototype.getProjection = Hv.prototype.Ea, Hv.prototype.getState = Hv.prototype.W, Hv.prototype.setAttributions = Hv.prototype.va;
    Hv.prototype.get = Hv.prototype.get;
    Hv.prototype.getKeys = Hv.prototype.R, Hv.prototype.getProperties = Hv.prototype.N, Hv.prototype.set = Hv.prototype.set, Hv.prototype.setProperties = Hv.prototype.G, Hv.prototype.unset = Hv.prototype.S, Hv.prototype.changed = Hv.prototype.u, Hv.prototype.dispatchEvent = Hv.prototype.b, Hv.prototype.getRevision = Hv.prototype.K, Hv.prototype.on = Hv.prototype.I, Hv.prototype.once = Hv.prototype.L, Hv.prototype.un = Hv.prototype.J, Hv.prototype.unByKey = Hv.prototype.M, No.prototype.setRenderReprojectionEdges = No.prototype.Wb, No.prototype.setTileGridForProjection = No.prototype.Zb, No.prototype.getTileLoadFunction = No.prototype.zb, No.prototype.getTileUrlFunction = No.prototype.Ab, No.prototype.getUrls = No.prototype.Bb, No.prototype.setTileLoadFunction = No.prototype.Eb, No.prototype.setTileUrlFunction = No.prototype.kb, No.prototype.setUrl = No.prototype.rb, No.prototype.setUrls = No.prototype.lb, No.prototype.getTileGrid = No.prototype.fb, No.prototype.refresh = No.prototype.Ba, No.prototype.getAttributions = No.prototype.Da, No.prototype.getLogo = No.prototype.Ca, No.prototype.getProjection = No.prototype.Ea, No.prototype.getState = No.prototype.W, No.prototype.setAttributions = No.prototype.va, No.prototype.get = No.prototype.get, No.prototype.getKeys = No.prototype.R, No.prototype.getProperties = No.prototype.N, No.prototype.set = No.prototype.set, No.prototype.setProperties = No.prototype.G, No.prototype.unset = No.prototype.S, No.prototype.changed = No.prototype.u, No.prototype.dispatchEvent = No.prototype.b, No.prototype.getRevision = No.prototype.K, No.prototype.on = No.prototype.I, No.prototype.once = No.prototype.L, No.prototype.un = No.prototype.J, No.prototype.unByKey = No.prototype.M, Dr.prototype.type = Dr.prototype.type, Dr.prototype.target = Dr.prototype.target, Dr.prototype.preventDefault = Dr.prototype.preventDefault, Dr.prototype.stopPropagation = Dr.prototype.stopPropagation, Jv.prototype.getTileLoadFunction = Jv.prototype.zb, Jv.prototype.getTileUrlFunction = Jv.prototype.Ab, Jv.prototype.getUrls = Jv.prototype.Bb, Jv.prototype.setTileLoadFunction = Jv.prototype.Eb, Jv.prototype.setTileUrlFunction = Jv.prototype.kb, Jv.prototype.setUrl = Jv.prototype.rb, Jv.prototype.setUrls = Jv.prototype.lb, Jv.prototype.getTileGrid = Jv.prototype.fb, Jv.prototype.refresh = Jv.prototype.Ba, Jv.prototype.getAttributions = Jv.prototype.Da, Jv.prototype.getLogo = Jv.prototype.Ca, Jv.prototype.getProjection = Jv.prototype.Ea, Jv.prototype.getState = Jv.prototype.W, Jv.prototype.setAttributions = Jv.prototype.va, Jv.prototype.get = Jv.prototype.get, Jv.prototype.getKeys = Jv.prototype.R, Jv.prototype.getProperties = Jv.prototype.N, Jv.prototype.set = Jv.prototype.set, Jv.prototype.setProperties = Jv.prototype.G, Jv.prototype.unset = Jv.prototype.S, Jv.prototype.changed = Jv.prototype.u, Jv.prototype.dispatchEvent = Jv.prototype.b, Jv.prototype.getRevision = Jv.prototype.K, Jv.prototype.on = Jv.prototype.I, Jv.prototype.once = Jv.prototype.L, Jv.prototype.un = Jv.prototype.J, Jv.prototype.unByKey = Jv.prototype.M, Go.prototype.setRenderReprojectionEdges = Go.prototype.Wb, Go.prototype.setTileGridForProjection = Go.prototype.Zb, Go.prototype.getTileLoadFunction = Go.prototype.zb, Go.prototype.getTileUrlFunction = Go.prototype.Ab, Go.prototype.getUrls = Go.prototype.Bb, Go.prototype.setTileLoadFunction = Go.prototype.Eb, Go.prototype.setTileUrlFunction = Go.prototype.kb, Go.prototype.setUrl = Go.prototype.rb, Go.prototype.setUrls = Go.prototype.lb, Go.prototype.getTileGrid = Go.prototype.fb, Go.prototype.refresh = Go.prototype.Ba, Go.prototype.getAttributions = Go.prototype.Da, Go.prototype.getLogo = Go.prototype.Ca, Go.prototype.getProjection = Go.prototype.Ea, Go.prototype.getState = Go.prototype.W, Go.prototype.setAttributions = Go.prototype.va, Go.prototype.get = Go.prototype.get, Go.prototype.getKeys = Go.prototype.R, Go.prototype.getProperties = Go.prototype.N, Go.prototype.set = Go.prototype.set, Go.prototype.setProperties = Go.prototype.G, Go.prototype.unset = Go.prototype.S, Go.prototype.changed = Go.prototype.u, Go.prototype.dispatchEvent = Go.prototype.b, Go.prototype.getRevision = Go.prototype.K, Go.prototype.on = Go.prototype.I, Go.prototype.once = Go.prototype.L, Go.prototype.un = Go.prototype.J, Go.prototype.unByKey = Go.prototype.M, tb.prototype.setRenderReprojectionEdges = tb.prototype.Wb, tb.prototype.setTileGridForProjection = tb.prototype.Zb, tb.prototype.getTileLoadFunction = tb.prototype.zb, tb.prototype.getTileUrlFunction = tb.prototype.Ab, tb.prototype.getUrls = tb.prototype.Bb, tb.prototype.setTileLoadFunction = tb.prototype.Eb, tb.prototype.setTileUrlFunction = tb.prototype.kb, tb.prototype.setUrl = tb.prototype.rb, tb.prototype.setUrls = tb.prototype.lb, tb.prototype.getTileGrid = tb.prototype.fb, tb.prototype.refresh = tb.prototype.Ba, tb.prototype.getAttributions = tb.prototype.Da, tb.prototype.getLogo = tb.prototype.Ca, tb.prototype.getProjection = tb.prototype.Ea, tb.prototype.getState = tb.prototype.W, tb.prototype.setAttributions = tb.prototype.va, tb.prototype.get = tb.prototype.get, tb.prototype.getKeys = tb.prototype.R, tb.prototype.getProperties = tb.prototype.N, tb.prototype.set = tb.prototype.set, tb.prototype.setProperties = tb.prototype.G, tb.prototype.unset = tb.prototype.S, tb.prototype.changed = tb.prototype.u, tb.prototype.dispatchEvent = tb.prototype.b, tb.prototype.getRevision = tb.prototype.K, tb.prototype.on = tb.prototype.I, tb.prototype.once = tb.prototype.L, tb.prototype.un = tb.prototype.J, tb.prototype.unByKey = tb.prototype.M, ro.prototype.getTileCoord = ro.prototype.i, ro.prototype.load = ro.prototype.load, hc.prototype.changed = hc.prototype.u, hc.prototype.dispatchEvent = hc.prototype.b, hc.prototype.getRevision = hc.prototype.K, hc.prototype.on = hc.prototype.I, hc.prototype.once = hc.prototype.L, hc.prototype.un = hc.prototype.J, hc.prototype.unByKey = hc.prototype.M, Gf.prototype.changed = Gf.prototype.u, Gf.prototype.dispatchEvent = Gf.prototype.b, Gf.prototype.getRevision = Gf.prototype.K, Gf.prototype.on = Gf.prototype.I, Gf.prototype.once = Gf.prototype.L, Gf.prototype.un = Gf.prototype.J, Gf.prototype.unByKey = Gf.prototype.M, Wf.prototype.changed = Wf.prototype.u, Wf.prototype.dispatchEvent = Wf.prototype.b, Wf.prototype.getRevision = Wf.prototype.K, Wf.prototype.on = Wf.prototype.I, Wf.prototype.once = Wf.prototype.L, Wf.prototype.un = Wf.prototype.J, Wf.prototype.unByKey = Wf.prototype.M, Zf.prototype.changed = Zf.prototype.u, Zf.prototype.dispatchEvent = Zf.prototype.b, Zf.prototype.getRevision = Zf.prototype.K, Zf.prototype.on = Zf.prototype.I, Zf.prototype.once = Zf.prototype.L, Zf.prototype.un = Zf.prototype.J, Zf.prototype.unByKey = Zf.prototype.M, Jf.prototype.changed = Jf.prototype.u, Jf.prototype.dispatchEvent = Jf.prototype.b, Jf.prototype.getRevision = Jf.prototype.K, Jf.prototype.on = Jf.prototype.I, Jf.prototype.once = Jf.prototype.L, Jf.prototype.un = Jf.prototype.J, Jf.prototype.unByKey = Jf.prototype.M, nf.prototype.changed = nf.prototype.u, nf.prototype.dispatchEvent = nf.prototype.b, nf.prototype.getRevision = nf.prototype.K, nf.prototype.on = nf.prototype.I, nf.prototype.once = nf.prototype.L, nf.prototype.un = nf.prototype.J, nf.prototype.unByKey = nf.prototype.M, rf.prototype.changed = rf.prototype.u, rf.prototype.dispatchEvent = rf.prototype.b, rf.prototype.getRevision = rf.prototype.K, rf.prototype.on = rf.prototype.I, rf.prototype.once = rf.prototype.L, rf.prototype.un = rf.prototype.J, rf.prototype.unByKey = rf.prototype.M, of.prototype.changed = of.prototype.u, of.prototype.dispatchEvent = of.prototype.b, of.prototype.getRevision = of.prototype.K, of.prototype.on = of.prototype.I, of.prototype.once = of.prototype.L, of.prototype.un = of.prototype.J, of.prototype.unByKey = of.prototype.M, af.prototype.changed = af.prototype.u, af.prototype.dispatchEvent = af.prototype.b, af.prototype.getRevision = af.prototype.K, af.prototype.on = af.prototype.I, af.prototype.once = af.prototype.L, af.prototype.un = af.prototype.J, af.prototype.unByKey = af.prototype.M, mc.prototype.changed = mc.prototype.u, mc.prototype.dispatchEvent = mc.prototype.b, mc.prototype.getRevision = mc.prototype.K, mc.prototype.on = mc.prototype.I, mc.prototype.once = mc.prototype.L;
    mc.prototype.un = mc.prototype.J;
    mc.prototype.unByKey = mc.prototype.M, Yc.prototype.changed = Yc.prototype.u, Yc.prototype.dispatchEvent = Yc.prototype.b, Yc.prototype.getRevision = Yc.prototype.K, Yc.prototype.on = Yc.prototype.I, Yc.prototype.once = Yc.prototype.L, Yc.prototype.un = Yc.prototype.J, Yc.prototype.unByKey = Yc.prototype.M, Kc.prototype.changed = Kc.prototype.u, Kc.prototype.dispatchEvent = Kc.prototype.b, Kc.prototype.getRevision = Kc.prototype.K, Kc.prototype.on = Kc.prototype.I, Kc.prototype.once = Kc.prototype.L, Kc.prototype.un = Kc.prototype.J, Kc.prototype.unByKey = Kc.prototype.M, Zc.prototype.changed = Zc.prototype.u, Zc.prototype.dispatchEvent = Zc.prototype.b, Zc.prototype.getRevision = Zc.prototype.K, Zc.prototype.on = Zc.prototype.I, Zc.prototype.once = Zc.prototype.L, Zc.prototype.un = Zc.prototype.J, Zc.prototype.unByKey = Zc.prototype.M, Jc.prototype.changed = Jc.prototype.u, Jc.prototype.dispatchEvent = Jc.prototype.b, Jc.prototype.getRevision = Jc.prototype.K, Jc.prototype.on = Jc.prototype.I, Jc.prototype.once = Jc.prototype.L, Jc.prototype.un = Jc.prototype.J, Jc.prototype.unByKey = Jc.prototype.M, jr.prototype.type = jr.prototype.type, jr.prototype.target = jr.prototype.target, jr.prototype.preventDefault = jr.prototype.preventDefault, jr.prototype.stopPropagation = jr.prototype.stopPropagation, ml.prototype.type = ml.prototype.type, ml.prototype.target = ml.prototype.target, ml.prototype.preventDefault = ml.prototype.preventDefault, ml.prototype.stopPropagation = ml.prototype.stopPropagation, Fr.prototype.get = Fr.prototype.get, Fr.prototype.getKeys = Fr.prototype.R, Fr.prototype.getProperties = Fr.prototype.N, Fr.prototype.set = Fr.prototype.set, Fr.prototype.setProperties = Fr.prototype.G, Fr.prototype.unset = Fr.prototype.S, Fr.prototype.changed = Fr.prototype.u, Fr.prototype.dispatchEvent = Fr.prototype.b, Fr.prototype.getRevision = Fr.prototype.K, Fr.prototype.on = Fr.prototype.I, Fr.prototype.once = Fr.prototype.L, Fr.prototype.un = Fr.prototype.J, Fr.prototype.unByKey = Fr.prototype.M, Br.prototype.getExtent = Br.prototype.H, Br.prototype.getMaxResolution = Br.prototype.rc, Br.prototype.getMinResolution = Br.prototype.sc, Br.prototype.getOpacity = Br.prototype.tc, Br.prototype.getVisible = Br.prototype.Ib, Br.prototype.getZIndex = Br.prototype.uc, Br.prototype.setExtent = Br.prototype.Uc, Br.prototype.setMaxResolution = Br.prototype.$c, Br.prototype.setMinResolution = Br.prototype.ad, Br.prototype.setOpacity = Br.prototype.Vc, Br.prototype.setVisible = Br.prototype.Wc, Br.prototype.setZIndex = Br.prototype.Xc, Br.prototype.get = Br.prototype.get, Br.prototype.getKeys = Br.prototype.R, Br.prototype.getProperties = Br.prototype.N, Br.prototype.set = Br.prototype.set, Br.prototype.setProperties = Br.prototype.G, Br.prototype.unset = Br.prototype.S, Br.prototype.changed = Br.prototype.u, Br.prototype.dispatchEvent = Br.prototype.b, Br.prototype.getRevision = Br.prototype.K, Br.prototype.on = Br.prototype.I, Br.prototype.once = Br.prototype.L, Br.prototype.un = Br.prototype.J, Br.prototype.unByKey = Br.prototype.M, zr.prototype.getExtent = zr.prototype.H, zr.prototype.getMaxResolution = zr.prototype.rc, zr.prototype.getMinResolution = zr.prototype.sc, zr.prototype.getOpacity = zr.prototype.tc, zr.prototype.getVisible = zr.prototype.Ib, zr.prototype.getZIndex = zr.prototype.uc, zr.prototype.setExtent = zr.prototype.Uc, zr.prototype.setMaxResolution = zr.prototype.$c, zr.prototype.setMinResolution = zr.prototype.ad, zr.prototype.setOpacity = zr.prototype.Vc, zr.prototype.setVisible = zr.prototype.Wc, zr.prototype.setZIndex = zr.prototype.Xc, zr.prototype.get = zr.prototype.get, zr.prototype.getKeys = zr.prototype.R, zr.prototype.getProperties = zr.prototype.N, zr.prototype.set = zr.prototype.set, zr.prototype.setProperties = zr.prototype.G, zr.prototype.unset = zr.prototype.S, zr.prototype.changed = zr.prototype.u, zr.prototype.dispatchEvent = zr.prototype.b, zr.prototype.getRevision = zr.prototype.K, zr.prototype.on = zr.prototype.I, zr.prototype.once = zr.prototype.L, zr.prototype.un = zr.prototype.J, zr.prototype.unByKey = zr.prototype.M, Wr.prototype.setMap = Wr.prototype.setMap, Wr.prototype.setSource = Wr.prototype.td, Wr.prototype.getExtent = Wr.prototype.H, Wr.prototype.getMaxResolution = Wr.prototype.rc, Wr.prototype.getMinResolution = Wr.prototype.sc, Wr.prototype.getOpacity = Wr.prototype.tc, Wr.prototype.getVisible = Wr.prototype.Ib, Wr.prototype.getZIndex = Wr.prototype.uc, Wr.prototype.setExtent = Wr.prototype.Uc, Wr.prototype.setMaxResolution = Wr.prototype.$c, Wr.prototype.setMinResolution = Wr.prototype.ad, Wr.prototype.setOpacity = Wr.prototype.Vc, Wr.prototype.setVisible = Wr.prototype.Wc, Wr.prototype.setZIndex = Wr.prototype.Xc, Wr.prototype.get = Wr.prototype.get, Wr.prototype.getKeys = Wr.prototype.R, Wr.prototype.getProperties = Wr.prototype.N, Wr.prototype.set = Wr.prototype.set, Wr.prototype.setProperties = Wr.prototype.G, Wr.prototype.unset = Wr.prototype.S, Wr.prototype.changed = Wr.prototype.u, Wr.prototype.dispatchEvent = Wr.prototype.b, Wr.prototype.getRevision = Wr.prototype.K, Wr.prototype.on = Wr.prototype.I, Wr.prototype.once = Wr.prototype.L, Wr.prototype.un = Wr.prototype.J, Wr.prototype.unByKey = Wr.prototype.M, Nv.prototype.getSource = Nv.prototype.ja, Nv.prototype.getStyle = Nv.prototype.C, Nv.prototype.getStyleFunction = Nv.prototype.D, Nv.prototype.setStyle = Nv.prototype.l, Nv.prototype.setMap = Nv.prototype.setMap, Nv.prototype.setSource = Nv.prototype.td, Nv.prototype.getExtent = Nv.prototype.H, Nv.prototype.getMaxResolution = Nv.prototype.rc, Nv.prototype.getMinResolution = Nv.prototype.sc, Nv.prototype.getOpacity = Nv.prototype.tc, Nv.prototype.getVisible = Nv.prototype.Ib, Nv.prototype.getZIndex = Nv.prototype.uc, Nv.prototype.setExtent = Nv.prototype.Uc, Nv.prototype.setMaxResolution = Nv.prototype.$c, Nv.prototype.setMinResolution = Nv.prototype.ad, Nv.prototype.setOpacity = Nv.prototype.Vc, Nv.prototype.setVisible = Nv.prototype.Wc, Nv.prototype.setZIndex = Nv.prototype.Xc, Nv.prototype.get = Nv.prototype.get, Nv.prototype.getKeys = Nv.prototype.R, Nv.prototype.getProperties = Nv.prototype.N, Nv.prototype.set = Nv.prototype.set, Nv.prototype.setProperties = Nv.prototype.G, Nv.prototype.unset = Nv.prototype.S, Nv.prototype.changed = Nv.prototype.u, Nv.prototype.dispatchEvent = Nv.prototype.b, Nv.prototype.getRevision = Nv.prototype.K, Nv.prototype.on = Nv.prototype.I, Nv.prototype.once = Nv.prototype.L, Nv.prototype.un = Nv.prototype.J, Nv.prototype.unByKey = Nv.prototype.M, Vr.prototype.setMap = Vr.prototype.setMap, Vr.prototype.setSource = Vr.prototype.td, Vr.prototype.getExtent = Vr.prototype.H, Vr.prototype.getMaxResolution = Vr.prototype.rc, Vr.prototype.getMinResolution = Vr.prototype.sc, Vr.prototype.getOpacity = Vr.prototype.tc, Vr.prototype.getVisible = Vr.prototype.Ib, Vr.prototype.getZIndex = Vr.prototype.uc, Vr.prototype.setExtent = Vr.prototype.Uc, Vr.prototype.setMaxResolution = Vr.prototype.$c, Vr.prototype.setMinResolution = Vr.prototype.ad, Vr.prototype.setOpacity = Vr.prototype.Vc, Vr.prototype.setVisible = Vr.prototype.Wc, Vr.prototype.setZIndex = Vr.prototype.Xc, Vr.prototype.get = Vr.prototype.get, Vr.prototype.getKeys = Vr.prototype.R, Vr.prototype.getProperties = Vr.prototype.N, Vr.prototype.set = Vr.prototype.set, Vr.prototype.setProperties = Vr.prototype.G, Vr.prototype.unset = Vr.prototype.S, Vr.prototype.changed = Vr.prototype.u, Vr.prototype.dispatchEvent = Vr.prototype.b, Vr.prototype.getRevision = Vr.prototype.K, Vr.prototype.on = Vr.prototype.I, Vr.prototype.once = Vr.prototype.L, Vr.prototype.un = Vr.prototype.J, Vr.prototype.unByKey = Vr.prototype.M, qr.prototype.setMap = qr.prototype.setMap, qr.prototype.setSource = qr.prototype.td, qr.prototype.getExtent = qr.prototype.H, qr.prototype.getMaxResolution = qr.prototype.rc, qr.prototype.getMinResolution = qr.prototype.sc, qr.prototype.getOpacity = qr.prototype.tc, qr.prototype.getVisible = qr.prototype.Ib, qr.prototype.getZIndex = qr.prototype.uc, qr.prototype.setExtent = qr.prototype.Uc, qr.prototype.setMaxResolution = qr.prototype.$c, qr.prototype.setMinResolution = qr.prototype.ad, qr.prototype.setOpacity = qr.prototype.Vc, qr.prototype.setVisible = qr.prototype.Wc, qr.prototype.setZIndex = qr.prototype.Xc, qr.prototype.get = qr.prototype.get;
    qr.prototype.getKeys = qr.prototype.R;
    qr.prototype.getProperties = qr.prototype.N, qr.prototype.set = qr.prototype.set, qr.prototype.setProperties = qr.prototype.G, qr.prototype.unset = qr.prototype.S, qr.prototype.changed = qr.prototype.u, qr.prototype.dispatchEvent = qr.prototype.b, qr.prototype.getRevision = qr.prototype.K, qr.prototype.on = qr.prototype.I, qr.prototype.once = qr.prototype.L, qr.prototype.un = qr.prototype.J, qr.prototype.unByKey = qr.prototype.M, Qp.prototype.getSource = Qp.prototype.ja, Qp.prototype.getStyle = Qp.prototype.C, Qp.prototype.getStyleFunction = Qp.prototype.D, Qp.prototype.setStyle = Qp.prototype.l, Qp.prototype.setMap = Qp.prototype.setMap, Qp.prototype.setSource = Qp.prototype.td, Qp.prototype.getExtent = Qp.prototype.H, Qp.prototype.getMaxResolution = Qp.prototype.rc, Qp.prototype.getMinResolution = Qp.prototype.sc, Qp.prototype.getOpacity = Qp.prototype.tc, Qp.prototype.getVisible = Qp.prototype.Ib, Qp.prototype.getZIndex = Qp.prototype.uc, Qp.prototype.setExtent = Qp.prototype.Uc, Qp.prototype.setMaxResolution = Qp.prototype.$c, Qp.prototype.setMinResolution = Qp.prototype.ad, Qp.prototype.setOpacity = Qp.prototype.Vc, Qp.prototype.setVisible = Qp.prototype.Wc, Qp.prototype.setZIndex = Qp.prototype.Xc, Qp.prototype.get = Qp.prototype.get, Qp.prototype.getKeys = Qp.prototype.R, Qp.prototype.getProperties = Qp.prototype.N, Qp.prototype.set = Qp.prototype.set, Qp.prototype.setProperties = Qp.prototype.G, Qp.prototype.unset = Qp.prototype.S, Qp.prototype.changed = Qp.prototype.u, Qp.prototype.dispatchEvent = Qp.prototype.b, Qp.prototype.getRevision = Qp.prototype.K, Qp.prototype.on = Qp.prototype.I, Qp.prototype.once = Qp.prototype.L, Qp.prototype.un = Qp.prototype.J, Qp.prototype.unByKey = Qp.prototype.M, Zu.prototype.get = Zu.prototype.get, Zu.prototype.getKeys = Zu.prototype.R, Zu.prototype.getProperties = Zu.prototype.N, Zu.prototype.set = Zu.prototype.set, Zu.prototype.setProperties = Zu.prototype.G, Zu.prototype.unset = Zu.prototype.S, Zu.prototype.changed = Zu.prototype.u, Zu.prototype.dispatchEvent = Zu.prototype.b, Zu.prototype.getRevision = Zu.prototype.K, Zu.prototype.on = Zu.prototype.I, Zu.prototype.once = Zu.prototype.L, Zu.prototype.un = Zu.prototype.J, Zu.prototype.unByKey = Zu.prototype.M, ep.prototype.getActive = ep.prototype.f, ep.prototype.getMap = ep.prototype.l, ep.prototype.setActive = ep.prototype.i, ep.prototype.get = ep.prototype.get, ep.prototype.getKeys = ep.prototype.R, ep.prototype.getProperties = ep.prototype.N, ep.prototype.set = ep.prototype.set, ep.prototype.setProperties = ep.prototype.G, ep.prototype.unset = ep.prototype.S, ep.prototype.changed = ep.prototype.u, ep.prototype.dispatchEvent = ep.prototype.b, ep.prototype.getRevision = ep.prototype.K, ep.prototype.on = ep.prototype.I, ep.prototype.once = ep.prototype.L, ep.prototype.un = ep.prototype.J, ep.prototype.unByKey = ep.prototype.M, Im.prototype.getActive = Im.prototype.f, Im.prototype.getMap = Im.prototype.l, Im.prototype.setActive = Im.prototype.i, Im.prototype.get = Im.prototype.get, Im.prototype.getKeys = Im.prototype.R, Im.prototype.getProperties = Im.prototype.N, Im.prototype.set = Im.prototype.set, Im.prototype.setProperties = Im.prototype.G, Im.prototype.unset = Im.prototype.S, Im.prototype.changed = Im.prototype.u, Im.prototype.dispatchEvent = Im.prototype.b, Im.prototype.getRevision = Im.prototype.K, Im.prototype.on = Im.prototype.I, Im.prototype.once = Im.prototype.L, Im.prototype.un = Im.prototype.J, Im.prototype.unByKey = Im.prototype.M, Am.prototype.type = Am.prototype.type, Am.prototype.target = Am.prototype.target, Am.prototype.preventDefault = Am.prototype.preventDefault, Am.prototype.stopPropagation = Am.prototype.stopPropagation, Cp.prototype.type = Cp.prototype.type, Cp.prototype.target = Cp.prototype.target, Cp.prototype.preventDefault = Cp.prototype.preventDefault, Cp.prototype.stopPropagation = Cp.prototype.stopPropagation, cp.prototype.getActive = cp.prototype.f, cp.prototype.getMap = cp.prototype.l, cp.prototype.setActive = cp.prototype.i, cp.prototype.get = cp.prototype.get, cp.prototype.getKeys = cp.prototype.R, cp.prototype.getProperties = cp.prototype.N, cp.prototype.set = cp.prototype.set, cp.prototype.setProperties = cp.prototype.G, cp.prototype.unset = cp.prototype.S, cp.prototype.changed = cp.prototype.u, cp.prototype.dispatchEvent = cp.prototype.b, cp.prototype.getRevision = cp.prototype.K, cp.prototype.on = cp.prototype.I, cp.prototype.once = cp.prototype.L, cp.prototype.un = cp.prototype.J, cp.prototype.unByKey = cp.prototype.M, Mp.prototype.getActive = Mp.prototype.f, Mp.prototype.getMap = Mp.prototype.l, Mp.prototype.setActive = Mp.prototype.i, Mp.prototype.get = Mp.prototype.get, Mp.prototype.getKeys = Mp.prototype.R, Mp.prototype.getProperties = Mp.prototype.N, Mp.prototype.set = Mp.prototype.set, Mp.prototype.setProperties = Mp.prototype.G, Mp.prototype.unset = Mp.prototype.S, Mp.prototype.changed = Mp.prototype.u, Mp.prototype.dispatchEvent = Mp.prototype.b, Mp.prototype.getRevision = Mp.prototype.K, Mp.prototype.on = Mp.prototype.I, Mp.prototype.once = Mp.prototype.L, Mp.prototype.un = Mp.prototype.J, Mp.prototype.unByKey = Mp.prototype.M, dp.prototype.getActive = dp.prototype.f, dp.prototype.getMap = dp.prototype.l, dp.prototype.setActive = dp.prototype.i, dp.prototype.get = dp.prototype.get, dp.prototype.getKeys = dp.prototype.R, dp.prototype.getProperties = dp.prototype.N, dp.prototype.set = dp.prototype.set, dp.prototype.setProperties = dp.prototype.G, dp.prototype.unset = dp.prototype.S, dp.prototype.changed = dp.prototype.u, dp.prototype.dispatchEvent = dp.prototype.b, dp.prototype.getRevision = dp.prototype.K, dp.prototype.on = dp.prototype.I, dp.prototype.once = dp.prototype.L, dp.prototype.un = dp.prototype.J, dp.prototype.unByKey = dp.prototype.M, bp.prototype.getActive = bp.prototype.f, bp.prototype.getMap = bp.prototype.l, bp.prototype.setActive = bp.prototype.i, bp.prototype.get = bp.prototype.get, bp.prototype.getKeys = bp.prototype.R, bp.prototype.getProperties = bp.prototype.N, bp.prototype.set = bp.prototype.set, bp.prototype.setProperties = bp.prototype.G, bp.prototype.unset = bp.prototype.S, bp.prototype.changed = bp.prototype.u, bp.prototype.dispatchEvent = bp.prototype.b, bp.prototype.getRevision = bp.prototype.K, bp.prototype.on = bp.prototype.I, bp.prototype.once = bp.prototype.L, bp.prototype.un = bp.prototype.J, bp.prototype.unByKey = bp.prototype.M, Rm.prototype.getActive = Rm.prototype.f, Rm.prototype.getMap = Rm.prototype.l, Rm.prototype.setActive = Rm.prototype.i, Rm.prototype.get = Rm.prototype.get, Rm.prototype.getKeys = Rm.prototype.R, Rm.prototype.getProperties = Rm.prototype.N, Rm.prototype.set = Rm.prototype.set, Rm.prototype.setProperties = Rm.prototype.G, Rm.prototype.unset = Rm.prototype.S, Rm.prototype.changed = Rm.prototype.u, Rm.prototype.dispatchEvent = Rm.prototype.b, Rm.prototype.getRevision = Rm.prototype.K, Rm.prototype.on = Rm.prototype.I, Rm.prototype.once = Rm.prototype.L, Rm.prototype.un = Rm.prototype.J, Rm.prototype.unByKey = Rm.prototype.M, Rp.prototype.getGeometry = Rp.prototype.Y, Rp.prototype.getActive = Rp.prototype.f, Rp.prototype.getMap = Rp.prototype.l, Rp.prototype.setActive = Rp.prototype.i, Rp.prototype.get = Rp.prototype.get, Rp.prototype.getKeys = Rp.prototype.R, Rp.prototype.getProperties = Rp.prototype.N, Rp.prototype.set = Rp.prototype.set, Rp.prototype.setProperties = Rp.prototype.G, Rp.prototype.unset = Rp.prototype.S, Rp.prototype.changed = Rp.prototype.u, Rp.prototype.dispatchEvent = Rp.prototype.b, Rp.prototype.getRevision = Rp.prototype.K, Rp.prototype.on = Rp.prototype.I, Rp.prototype.once = Rp.prototype.L, Rp.prototype.un = Rp.prototype.J, Rp.prototype.unByKey = Rp.prototype.M, Dm.prototype.type = Dm.prototype.type, Dm.prototype.target = Dm.prototype.target, Dm.prototype.preventDefault = Dm.prototype.preventDefault, Dm.prototype.stopPropagation = Dm.prototype.stopPropagation, Fm.prototype.getActive = Fm.prototype.f, Fm.prototype.getMap = Fm.prototype.l, Fm.prototype.setActive = Fm.prototype.i, Fm.prototype.get = Fm.prototype.get;
    Fm.prototype.getKeys = Fm.prototype.R;
    Fm.prototype.getProperties = Fm.prototype.N, Fm.prototype.set = Fm.prototype.set, Fm.prototype.setProperties = Fm.prototype.G, Fm.prototype.unset = Fm.prototype.S, Fm.prototype.changed = Fm.prototype.u, Fm.prototype.dispatchEvent = Fm.prototype.b, Fm.prototype.getRevision = Fm.prototype.K, Fm.prototype.on = Fm.prototype.I, Fm.prototype.once = Fm.prototype.L, Fm.prototype.un = Fm.prototype.J, Fm.prototype.unByKey = Fm.prototype.M, _p.prototype.getActive = _p.prototype.f, _p.prototype.getMap = _p.prototype.l, _p.prototype.setActive = _p.prototype.i, _p.prototype.get = _p.prototype.get, _p.prototype.getKeys = _p.prototype.R, _p.prototype.getProperties = _p.prototype.N, _p.prototype.set = _p.prototype.set, _p.prototype.setProperties = _p.prototype.G, _p.prototype.unset = _p.prototype.S, _p.prototype.changed = _p.prototype.u, _p.prototype.dispatchEvent = _p.prototype.b, _p.prototype.getRevision = _p.prototype.K, _p.prototype.on = _p.prototype.I, _p.prototype.once = _p.prototype.L, _p.prototype.un = _p.prototype.J, _p.prototype.unByKey = _p.prototype.M, Op.prototype.getActive = Op.prototype.f, Op.prototype.getMap = Op.prototype.l, Op.prototype.setActive = Op.prototype.i, Op.prototype.get = Op.prototype.get, Op.prototype.getKeys = Op.prototype.R, Op.prototype.getProperties = Op.prototype.N, Op.prototype.set = Op.prototype.set, Op.prototype.setProperties = Op.prototype.G, Op.prototype.unset = Op.prototype.S, Op.prototype.changed = Op.prototype.u, Op.prototype.dispatchEvent = Op.prototype.b, Op.prototype.getRevision = Op.prototype.K, Op.prototype.on = Op.prototype.I, Op.prototype.once = Op.prototype.L, Op.prototype.un = Op.prototype.J, Op.prototype.unByKey = Op.prototype.M, Km.prototype.type = Km.prototype.type, Km.prototype.target = Km.prototype.target, Km.prototype.preventDefault = Km.prototype.preventDefault, Km.prototype.stopPropagation = Km.prototype.stopPropagation, $m.prototype.getActive = $m.prototype.f, $m.prototype.getMap = $m.prototype.l, $m.prototype.setActive = $m.prototype.i, $m.prototype.get = $m.prototype.get, $m.prototype.getKeys = $m.prototype.R, $m.prototype.getProperties = $m.prototype.N, $m.prototype.set = $m.prototype.set, $m.prototype.setProperties = $m.prototype.G, $m.prototype.unset = $m.prototype.S, $m.prototype.changed = $m.prototype.u, $m.prototype.dispatchEvent = $m.prototype.b, $m.prototype.getRevision = $m.prototype.K, $m.prototype.on = $m.prototype.I, $m.prototype.once = $m.prototype.L, $m.prototype.un = $m.prototype.J, $m.prototype.unByKey = $m.prototype.M, Fp.prototype.getActive = Fp.prototype.f, Fp.prototype.getMap = Fp.prototype.l, Fp.prototype.setActive = Fp.prototype.i, Fp.prototype.get = Fp.prototype.get, Fp.prototype.getKeys = Fp.prototype.R, Fp.prototype.getProperties = Fp.prototype.N, Fp.prototype.set = Fp.prototype.set, Fp.prototype.setProperties = Fp.prototype.G, Fp.prototype.unset = Fp.prototype.S, Fp.prototype.changed = Fp.prototype.u, Fp.prototype.dispatchEvent = Fp.prototype.b, Fp.prototype.getRevision = Fp.prototype.K, Fp.prototype.on = Fp.prototype.I, Fp.prototype.once = Fp.prototype.L, Fp.prototype.un = Fp.prototype.J, Fp.prototype.unByKey = Fp.prototype.M, Bp.prototype.getActive = Bp.prototype.f, Bp.prototype.getMap = Bp.prototype.l, Bp.prototype.setActive = Bp.prototype.i, Bp.prototype.get = Bp.prototype.get, Bp.prototype.getKeys = Bp.prototype.R, Bp.prototype.getProperties = Bp.prototype.N, Bp.prototype.set = Bp.prototype.set, Bp.prototype.setProperties = Bp.prototype.G, Bp.prototype.unset = Bp.prototype.S, Bp.prototype.changed = Bp.prototype.u, Bp.prototype.dispatchEvent = Bp.prototype.b, Bp.prototype.getRevision = Bp.prototype.K, Bp.prototype.on = Bp.prototype.I, Bp.prototype.once = Bp.prototype.L, Bp.prototype.un = Bp.prototype.J, Bp.prototype.unByKey = Bp.prototype.M, qp.prototype.getActive = qp.prototype.f, qp.prototype.getMap = qp.prototype.l, qp.prototype.setActive = qp.prototype.i, qp.prototype.get = qp.prototype.get, qp.prototype.getKeys = qp.prototype.R, qp.prototype.getProperties = qp.prototype.N, qp.prototype.set = qp.prototype.set, qp.prototype.setProperties = qp.prototype.G, qp.prototype.unset = qp.prototype.S, qp.prototype.changed = qp.prototype.u, qp.prototype.dispatchEvent = qp.prototype.b, qp.prototype.getRevision = qp.prototype.K, qp.prototype.on = qp.prototype.I, qp.prototype.once = qp.prototype.L, qp.prototype.un = qp.prototype.J, qp.prototype.unByKey = qp.prototype.M, lv.prototype.type = lv.prototype.type, lv.prototype.target = lv.prototype.target, lv.prototype.preventDefault = lv.prototype.preventDefault, lv.prototype.stopPropagation = lv.prototype.stopPropagation, uv.prototype.getActive = uv.prototype.f, uv.prototype.getMap = uv.prototype.l, uv.prototype.setActive = uv.prototype.i, uv.prototype.get = uv.prototype.get, uv.prototype.getKeys = uv.prototype.R, uv.prototype.getProperties = uv.prototype.N, uv.prototype.set = uv.prototype.set, uv.prototype.setProperties = uv.prototype.G, uv.prototype.unset = uv.prototype.S, uv.prototype.changed = uv.prototype.u, uv.prototype.dispatchEvent = uv.prototype.b, uv.prototype.getRevision = uv.prototype.K, uv.prototype.on = uv.prototype.I, uv.prototype.once = uv.prototype.L, uv.prototype.un = uv.prototype.J, uv.prototype.unByKey = uv.prototype.M, fv.prototype.getActive = fv.prototype.f, fv.prototype.getMap = fv.prototype.l, fv.prototype.setActive = fv.prototype.i, fv.prototype.get = fv.prototype.get, fv.prototype.getKeys = fv.prototype.R, fv.prototype.getProperties = fv.prototype.N, fv.prototype.set = fv.prototype.set, fv.prototype.setProperties = fv.prototype.G, fv.prototype.unset = fv.prototype.S, fv.prototype.changed = fv.prototype.u, fv.prototype.dispatchEvent = fv.prototype.b, fv.prototype.getRevision = fv.prototype.K, fv.prototype.on = fv.prototype.I, fv.prototype.once = fv.prototype.L, fv.prototype.un = fv.prototype.J, fv.prototype.unByKey = fv.prototype.M, mv.prototype.type = mv.prototype.type, mv.prototype.target = mv.prototype.target, mv.prototype.preventDefault = mv.prototype.preventDefault, mv.prototype.stopPropagation = mv.prototype.stopPropagation, vv.prototype.getActive = vv.prototype.f, vv.prototype.getMap = vv.prototype.l, vv.prototype.setActive = vv.prototype.i, vv.prototype.get = vv.prototype.get, vv.prototype.getKeys = vv.prototype.R, vv.prototype.getProperties = vv.prototype.N, vv.prototype.set = vv.prototype.set, vv.prototype.setProperties = vv.prototype.G, vv.prototype.unset = vv.prototype.S, vv.prototype.changed = vv.prototype.u, vv.prototype.dispatchEvent = vv.prototype.b, vv.prototype.getRevision = vv.prototype.K, vv.prototype.on = vv.prototype.I, vv.prototype.once = vv.prototype.L, vv.prototype.un = vv.prototype.J, vv.prototype.unByKey = vv.prototype.M, Zt.prototype.get = Zt.prototype.get, Zt.prototype.getKeys = Zt.prototype.R, Zt.prototype.getProperties = Zt.prototype.N, Zt.prototype.set = Zt.prototype.set, Zt.prototype.setProperties = Zt.prototype.G, Zt.prototype.unset = Zt.prototype.S, Zt.prototype.changed = Zt.prototype.u, Zt.prototype.dispatchEvent = Zt.prototype.b, Zt.prototype.getRevision = Zt.prototype.K, Zt.prototype.on = Zt.prototype.I, Zt.prototype.once = Zt.prototype.L, Zt.prototype.un = Zt.prototype.J, Zt.prototype.unByKey = Zt.prototype.M, Qt.prototype.getClosestPoint = Qt.prototype.Sb, Qt.prototype.intersectsCoordinate = Qt.prototype.Cb, Qt.prototype.getExtent = Qt.prototype.H, Qt.prototype.rotate = Qt.prototype.rotate, Qt.prototype.scale = Qt.prototype.scale, Qt.prototype.simplify = Qt.prototype.$b, Qt.prototype.transform = Qt.prototype.Db, Qt.prototype.get = Qt.prototype.get, Qt.prototype.getKeys = Qt.prototype.R, Qt.prototype.getProperties = Qt.prototype.N, Qt.prototype.set = Qt.prototype.set, Qt.prototype.setProperties = Qt.prototype.G, Qt.prototype.unset = Qt.prototype.S, Qt.prototype.changed = Qt.prototype.u, Qt.prototype.dispatchEvent = Qt.prototype.b, Qt.prototype.getRevision = Qt.prototype.K, Qt.prototype.on = Qt.prototype.I, Qt.prototype.once = Qt.prototype.L, Qt.prototype.un = Qt.prototype.J, Qt.prototype.unByKey = Qt.prototype.M;
    wm.prototype.getFirstCoordinate = wm.prototype.lc;
    wm.prototype.getLastCoordinate = wm.prototype.mc, wm.prototype.getLayout = wm.prototype.nc, wm.prototype.rotate = wm.prototype.rotate, wm.prototype.scale = wm.prototype.scale, wm.prototype.getClosestPoint = wm.prototype.Sb, wm.prototype.intersectsCoordinate = wm.prototype.Cb, wm.prototype.getExtent = wm.prototype.H, wm.prototype.simplify = wm.prototype.$b, wm.prototype.get = wm.prototype.get, wm.prototype.getKeys = wm.prototype.R, wm.prototype.getProperties = wm.prototype.N, wm.prototype.set = wm.prototype.set, wm.prototype.setProperties = wm.prototype.G, wm.prototype.unset = wm.prototype.S, wm.prototype.changed = wm.prototype.u, wm.prototype.dispatchEvent = wm.prototype.b, wm.prototype.getRevision = wm.prototype.K, wm.prototype.on = wm.prototype.I, wm.prototype.once = wm.prototype.L, wm.prototype.un = wm.prototype.J, wm.prototype.unByKey = wm.prototype.M, Un.prototype.getClosestPoint = Un.prototype.Sb, Un.prototype.intersectsCoordinate = Un.prototype.Cb, Un.prototype.getExtent = Un.prototype.H, Un.prototype.rotate = Un.prototype.rotate, Un.prototype.scale = Un.prototype.scale, Un.prototype.simplify = Un.prototype.$b, Un.prototype.transform = Un.prototype.Db, Un.prototype.get = Un.prototype.get, Un.prototype.getKeys = Un.prototype.R, Un.prototype.getProperties = Un.prototype.N, Un.prototype.set = Un.prototype.set, Un.prototype.setProperties = Un.prototype.G,
        Un.prototype.unset = Un.prototype.S, Un.prototype.changed = Un.prototype.u, Un.prototype.dispatchEvent = Un.prototype.b, Un.prototype.getRevision = Un.prototype.K, Un.prototype.on = Un.prototype.I, Un.prototype.once = Un.prototype.L, Un.prototype.un = Un.prototype.J, Un.prototype.unByKey = Un.prototype.M, Ve.prototype.getFirstCoordinate = Ve.prototype.lc, Ve.prototype.getLastCoordinate = Ve.prototype.mc, Ve.prototype.getLayout = Ve.prototype.nc, Ve.prototype.rotate = Ve.prototype.rotate, Ve.prototype.scale = Ve.prototype.scale, Ve.prototype.getClosestPoint = Ve.prototype.Sb, Ve.prototype.intersectsCoordinate = Ve.prototype.Cb, Ve.prototype.getExtent = Ve.prototype.H, Ve.prototype.simplify = Ve.prototype.$b, Ve.prototype.transform = Ve.prototype.Db, Ve.prototype.get = Ve.prototype.get, Ve.prototype.getKeys = Ve.prototype.R, Ve.prototype.getProperties = Ve.prototype.N, Ve.prototype.set = Ve.prototype.set, Ve.prototype.setProperties = Ve.prototype.G, Ve.prototype.unset = Ve.prototype.S, Ve.prototype.changed = Ve.prototype.u, Ve.prototype.dispatchEvent = Ve.prototype.b, Ve.prototype.getRevision = Ve.prototype.K, Ve.prototype.on = Ve.prototype.I, Ve.prototype.once = Ve.prototype.L, Ve.prototype.un = Ve.prototype.J, Ve.prototype.unByKey = Ve.prototype.M, Fe.prototype.getFirstCoordinate = Fe.prototype.lc, Fe.prototype.getLastCoordinate = Fe.prototype.mc, Fe.prototype.getLayout = Fe.prototype.nc, Fe.prototype.rotate = Fe.prototype.rotate, Fe.prototype.scale = Fe.prototype.scale, Fe.prototype.getClosestPoint = Fe.prototype.Sb, Fe.prototype.intersectsCoordinate = Fe.prototype.Cb, Fe.prototype.getExtent = Fe.prototype.H, Fe.prototype.simplify = Fe.prototype.$b, Fe.prototype.transform = Fe.prototype.Db, Fe.prototype.get = Fe.prototype.get, Fe.prototype.getKeys = Fe.prototype.R, Fe.prototype.getProperties = Fe.prototype.N, Fe.prototype.set = Fe.prototype.set, Fe.prototype.setProperties = Fe.prototype.G, Fe.prototype.unset = Fe.prototype.S, Fe.prototype.changed = Fe.prototype.u, Fe.prototype.dispatchEvent = Fe.prototype.b, Fe.prototype.getRevision = Fe.prototype.K, Fe.prototype.on = Fe.prototype.I, Fe.prototype.once = Fe.prototype.L, Fe.prototype.un = Fe.prototype.J, Fe.prototype.unByKey = Fe.prototype.M, Be.prototype.getFirstCoordinate = Be.prototype.lc, Be.prototype.getLastCoordinate = Be.prototype.mc, Be.prototype.getLayout = Be.prototype.nc, Be.prototype.rotate = Be.prototype.rotate, Be.prototype.scale = Be.prototype.scale, Be.prototype.getClosestPoint = Be.prototype.Sb, Be.prototype.intersectsCoordinate = Be.prototype.Cb, Be.prototype.getExtent = Be.prototype.H, Be.prototype.simplify = Be.prototype.$b, Be.prototype.transform = Be.prototype.Db, Be.prototype.get = Be.prototype.get, Be.prototype.getKeys = Be.prototype.R, Be.prototype.getProperties = Be.prototype.N, Be.prototype.set = Be.prototype.set, Be.prototype.setProperties = Be.prototype.G, Be.prototype.unset = Be.prototype.S, Be.prototype.changed = Be.prototype.u, Be.prototype.dispatchEvent = Be.prototype.b, Be.prototype.getRevision = Be.prototype.K, Be.prototype.on = Be.prototype.I, Be.prototype.once = Be.prototype.L, Be.prototype.un = Be.prototype.J, Be.prototype.unByKey = Be.prototype.M, we.prototype.getFirstCoordinate = we.prototype.lc, we.prototype.getLastCoordinate = we.prototype.mc, we.prototype.getLayout = we.prototype.nc, we.prototype.rotate = we.prototype.rotate, we.prototype.scale = we.prototype.scale, we.prototype.getClosestPoint = we.prototype.Sb, we.prototype.intersectsCoordinate = we.prototype.Cb, we.prototype.getExtent = we.prototype.H, we.prototype.simplify = we.prototype.$b, we.prototype.transform = we.prototype.Db, we.prototype.get = we.prototype.get, we.prototype.getKeys = we.prototype.R, we.prototype.getProperties = we.prototype.N, we.prototype.set = we.prototype.set, we.prototype.setProperties = we.prototype.G, we.prototype.unset = we.prototype.S, we.prototype.changed = we.prototype.u, we.prototype.dispatchEvent = we.prototype.b, we.prototype.getRevision = we.prototype.K, we.prototype.on = we.prototype.I, we.prototype.once = we.prototype.L, we.prototype.un = we.prototype.J, we.prototype.unByKey = we.prototype.M, ni.prototype.getFirstCoordinate = ni.prototype.lc, ni.prototype.getLastCoordinate = ni.prototype.mc, ni.prototype.getLayout = ni.prototype.nc, ni.prototype.rotate = ni.prototype.rotate, ni.prototype.scale = ni.prototype.scale, ni.prototype.getClosestPoint = ni.prototype.Sb, ni.prototype.intersectsCoordinate = ni.prototype.Cb, ni.prototype.getExtent = ni.prototype.H, ni.prototype.simplify = ni.prototype.$b, ni.prototype.transform = ni.prototype.Db, ni.prototype.get = ni.prototype.get, ni.prototype.getKeys = ni.prototype.R, ni.prototype.getProperties = ni.prototype.N, ni.prototype.set = ni.prototype.set, ni.prototype.setProperties = ni.prototype.G, ni.prototype.unset = ni.prototype.S, ni.prototype.changed = ni.prototype.u, ni.prototype.dispatchEvent = ni.prototype.b, ni.prototype.getRevision = ni.prototype.K, ni.prototype.on = ni.prototype.I, ni.prototype.once = ni.prototype.L, ni.prototype.un = ni.prototype.J, ni.prototype.unByKey = ni.prototype.M, se.prototype.getFirstCoordinate = se.prototype.lc, se.prototype.getLastCoordinate = se.prototype.mc, se.prototype.getLayout = se.prototype.nc, se.prototype.rotate = se.prototype.rotate, se.prototype.scale = se.prototype.scale, se.prototype.getClosestPoint = se.prototype.Sb, se.prototype.intersectsCoordinate = se.prototype.Cb, se.prototype.getExtent = se.prototype.H, se.prototype.simplify = se.prototype.$b, se.prototype.transform = se.prototype.Db, se.prototype.get = se.prototype.get, se.prototype.getKeys = se.prototype.R, se.prototype.getProperties = se.prototype.N, se.prototype.set = se.prototype.set, se.prototype.setProperties = se.prototype.G, se.prototype.unset = se.prototype.S, se.prototype.changed = se.prototype.u, se.prototype.dispatchEvent = se.prototype.b, se.prototype.getRevision = se.prototype.K, se.prototype.on = se.prototype.I, se.prototype.once = se.prototype.L, se.prototype.un = se.prototype.J, se.prototype.unByKey = se.prototype.M, Ze.prototype.getFirstCoordinate = Ze.prototype.lc, Ze.prototype.getLastCoordinate = Ze.prototype.mc, Ze.prototype.getLayout = Ze.prototype.nc, Ze.prototype.rotate = Ze.prototype.rotate, Ze.prototype.scale = Ze.prototype.scale, Ze.prototype.getClosestPoint = Ze.prototype.Sb, Ze.prototype.intersectsCoordinate = Ze.prototype.Cb, Ze.prototype.getExtent = Ze.prototype.H, Ze.prototype.simplify = Ze.prototype.$b, Ze.prototype.transform = Ze.prototype.Db, Ze.prototype.get = Ze.prototype.get, Ze.prototype.getKeys = Ze.prototype.R, Ze.prototype.getProperties = Ze.prototype.N, Ze.prototype.set = Ze.prototype.set, Ze.prototype.setProperties = Ze.prototype.G, Ze.prototype.unset = Ze.prototype.S, Ze.prototype.changed = Ze.prototype.u, Ze.prototype.dispatchEvent = Ze.prototype.b, Ze.prototype.getRevision = Ze.prototype.K, Ze.prototype.on = Ze.prototype.I, Ze.prototype.once = Ze.prototype.L;
    Ze.prototype.un = Ze.prototype.J;
    Ze.prototype.unByKey = Ze.prototype.M, od.prototype.readFeatures = od.prototype.Ia, ad.prototype.readFeatures = ad.prototype.Ia, od.prototype.readFeatures = od.prototype.Ia, _u.prototype.get = _u.prototype.get, _u.prototype.getKeys = _u.prototype.R, _u.prototype.getProperties = _u.prototype.N, _u.prototype.set = _u.prototype.set, _u.prototype.setProperties = _u.prototype.G, _u.prototype.unset = _u.prototype.S, _u.prototype.changed = _u.prototype.u, _u.prototype.dispatchEvent = _u.prototype.b, _u.prototype.getRevision = _u.prototype.K, _u.prototype.on = _u.prototype.I, _u.prototype.once = _u.prototype.L, _u.prototype.un = _u.prototype.J, _u.prototype.unByKey = _u.prototype.M, Pu.prototype.getMap = Pu.prototype.i, Pu.prototype.setMap = Pu.prototype.setMap, Pu.prototype.setTarget = Pu.prototype.c, Pu.prototype.get = Pu.prototype.get, Pu.prototype.getKeys = Pu.prototype.R, Pu.prototype.getProperties = Pu.prototype.N, Pu.prototype.set = Pu.prototype.set, Pu.prototype.setProperties = Pu.prototype.G, Pu.prototype.unset = Pu.prototype.S, Pu.prototype.changed = Pu.prototype.u, Pu.prototype.dispatchEvent = Pu.prototype.b, Pu.prototype.getRevision = Pu.prototype.K, Pu.prototype.on = Pu.prototype.I, Pu.prototype.once = Pu.prototype.L, Pu.prototype.un = Pu.prototype.J, Pu.prototype.unByKey = Pu.prototype.M, wg.prototype.getMap = wg.prototype.i, wg.prototype.setMap = wg.prototype.setMap, wg.prototype.setTarget = wg.prototype.c, wg.prototype.get = wg.prototype.get, wg.prototype.getKeys = wg.prototype.R, wg.prototype.getProperties = wg.prototype.N, wg.prototype.set = wg.prototype.set, wg.prototype.setProperties = wg.prototype.G, wg.prototype.unset = wg.prototype.S, wg.prototype.changed = wg.prototype.u, wg.prototype.dispatchEvent = wg.prototype.b, wg.prototype.getRevision = wg.prototype.K, wg.prototype.on = wg.prototype.I, wg.prototype.once = wg.prototype.L, wg.prototype.un = wg.prototype.J, wg.prototype.unByKey = wg.prototype.M, Ng.prototype.getMap = Ng.prototype.i, Ng.prototype.setMap = Ng.prototype.setMap, Ng.prototype.setTarget = Ng.prototype.c, Ng.prototype.get = Ng.prototype.get, Ng.prototype.getKeys = Ng.prototype.R, Ng.prototype.getProperties = Ng.prototype.N, Ng.prototype.set = Ng.prototype.set, Ng.prototype.setProperties = Ng.prototype.G, Ng.prototype.unset = Ng.prototype.S, Ng.prototype.changed = Ng.prototype.u, Ng.prototype.dispatchEvent = Ng.prototype.b, Ng.prototype.getRevision = Ng.prototype.K, Ng.prototype.on = Ng.prototype.I, Ng.prototype.once = Ng.prototype.L, Ng.prototype.un = Ng.prototype.J, Ng.prototype.unByKey = Ng.prototype.M, Mg.prototype.getMap = Mg.prototype.i, Mg.prototype.setMap = Mg.prototype.setMap, Mg.prototype.setTarget = Mg.prototype.c, Mg.prototype.get = Mg.prototype.get, Mg.prototype.getKeys = Mg.prototype.R, Mg.prototype.getProperties = Mg.prototype.N, Mg.prototype.set = Mg.prototype.set, Mg.prototype.setProperties = Mg.prototype.G, Mg.prototype.unset = Mg.prototype.S, Mg.prototype.changed = Mg.prototype.u, Mg.prototype.dispatchEvent = Mg.prototype.b, Mg.prototype.getRevision = Mg.prototype.K, Mg.prototype.on = Mg.prototype.I, Mg.prototype.once = Mg.prototype.L, Mg.prototype.un = Mg.prototype.J, Mg.prototype.unByKey = Mg.prototype.M, Wu.prototype.getMap = Wu.prototype.i, Wu.prototype.setMap = Wu.prototype.setMap, Wu.prototype.setTarget = Wu.prototype.c, Wu.prototype.get = Wu.prototype.get, Wu.prototype.getKeys = Wu.prototype.R, Wu.prototype.getProperties = Wu.prototype.N, Wu.prototype.set = Wu.prototype.set, Wu.prototype.setProperties = Wu.prototype.G, Wu.prototype.unset = Wu.prototype.S, Wu.prototype.changed = Wu.prototype.u, Wu.prototype.dispatchEvent = Wu.prototype.b, Wu.prototype.getRevision = Wu.prototype.K, Wu.prototype.on = Wu.prototype.I, Wu.prototype.once = Wu.prototype.L, Wu.prototype.un = Wu.prototype.J, Wu.prototype.unByKey = Wu.prototype.M, og.prototype.getMap = og.prototype.i, og.prototype.setMap = og.prototype.setMap, og.prototype.setTarget = og.prototype.c, og.prototype.get = og.prototype.get, og.prototype.getKeys = og.prototype.R, og.prototype.getProperties = og.prototype.N, og.prototype.set = og.prototype.set, og.prototype.setProperties = og.prototype.G, og.prototype.unset = og.prototype.S, og.prototype.changed = og.prototype.u, og.prototype.dispatchEvent = og.prototype.b, og.prototype.getRevision = og.prototype.K, og.prototype.on = og.prototype.I, og.prototype.once = og.prototype.L, og.prototype.un = og.prototype.J, og.prototype.unByKey = og.prototype.M, Hu.prototype.getMap = Hu.prototype.i, Hu.prototype.setMap = Hu.prototype.setMap, Hu.prototype.setTarget = Hu.prototype.c, Hu.prototype.get = Hu.prototype.get, Hu.prototype.getKeys = Hu.prototype.R, Hu.prototype.getProperties = Hu.prototype.N, Hu.prototype.set = Hu.prototype.set, Hu.prototype.setProperties = Hu.prototype.G, Hu.prototype.unset = Hu.prototype.S, Hu.prototype.changed = Hu.prototype.u, Hu.prototype.dispatchEvent = Hu.prototype.b, Hu.prototype.getRevision = Hu.prototype.K, Hu.prototype.on = Hu.prototype.I, Hu.prototype.once = Hu.prototype.L, Hu.prototype.un = Hu.prototype.J, Hu.prototype.unByKey = Hu.prototype.M, Rg.prototype.getMap = Rg.prototype.i, Rg.prototype.setMap = Rg.prototype.setMap, Rg.prototype.setTarget = Rg.prototype.c, Rg.prototype.get = Rg.prototype.get, Rg.prototype.getKeys = Rg.prototype.R, Rg.prototype.getProperties = Rg.prototype.N, Rg.prototype.set = Rg.prototype.set, Rg.prototype.setProperties = Rg.prototype.G, Rg.prototype.unset = Rg.prototype.S, Rg.prototype.changed = Rg.prototype.u, Rg.prototype.dispatchEvent = Rg.prototype.b, Rg.prototype.getRevision = Rg.prototype.K, Rg.prototype.on = Rg.prototype.I, Rg.prototype.once = Rg.prototype.L, Rg.prototype.un = Rg.prototype.J, Rg.prototype.unByKey = Rg.prototype.M, Dg.prototype.getMap = Dg.prototype.i, Dg.prototype.setMap = Dg.prototype.setMap, Dg.prototype.setTarget = Dg.prototype.c, Dg.prototype.get = Dg.prototype.get, Dg.prototype.getKeys = Dg.prototype.R, Dg.prototype.getProperties = Dg.prototype.N, Dg.prototype.set = Dg.prototype.set, Dg.prototype.setProperties = Dg.prototype.G, Dg.prototype.unset = Dg.prototype.S, Dg.prototype.changed = Dg.prototype.u, Dg.prototype.dispatchEvent = Dg.prototype.b, Dg.prototype.getRevision = Dg.prototype.K, Dg.prototype.on = Dg.prototype.I, Dg.prototype.once = Dg.prototype.L, Dg.prototype.un = Dg.prototype.J, Dg.prototype.unByKey = Dg.prototype.M, mg.prototype.addControl = mg.prototype.zg, mg.prototype.addInteraction = mg.prototype.oi, mg.prototype.addLayer = mg.prototype.$d, mg.prototype.addOverlay = mg.prototype.ae, mg.prototype.beforeRender = mg.prototype.mb, mg.prototype.forEachFeatureAtPixel = mg.prototype.ne, mg.prototype.forEachLayerAtPixel = mg.prototype.zj, mg.prototype.hasFeatureAtPixel = mg.prototype.jj, mg.prototype.getEventCoordinate = mg.prototype.Ki, mg.prototype.getEventPixel = mg.prototype.pe, mg.prototype.getTarget = mg.prototype.Ff, mg.prototype.getTargetElement = mg.prototype.Hc, mg.prototype.getCoordinateFromPixel = mg.prototype.Za, mg.prototype.getControls = mg.prototype.Hi, mg.prototype.getOverlays = mg.prototype.Vi, mg.prototype.getOverlayById = mg.prototype.Ui, mg.prototype.getInteractions = mg.prototype.Pi, mg.prototype.getLayerGroup = mg.prototype.Fc, mg.prototype.getLayers = mg.prototype.ze, mg.prototype.getPixelFromCoordinate = mg.prototype.Qa, mg.prototype.getSize = mg.prototype.bb, mg.prototype.getView = mg.prototype.$, mg.prototype.getViewport = mg.prototype.Yi, mg.prototype.renderSync = mg.prototype.Fk, mg.prototype.render = mg.prototype.render, mg.prototype.removeControl = mg.prototype.Ck, mg.prototype.removeInteraction = mg.prototype.Dk, mg.prototype.removeLayer = mg.prototype.dg, mg.prototype.removeOverlay = mg.prototype.eg, mg.prototype.setLayerGroup = mg.prototype.Zh, mg.prototype.setSize = mg.prototype.hg, mg.prototype.setTarget = mg.prototype.wh, mg.prototype.setView = mg.prototype.Yk, mg.prototype.updateSize = mg.prototype.wd, mg.prototype.get = mg.prototype.get, mg.prototype.getKeys = mg.prototype.R, mg.prototype.getProperties = mg.prototype.N, mg.prototype.set = mg.prototype.set, mg.prototype.setProperties = mg.prototype.G;
    mg.prototype.unset = mg.prototype.S;
    mg.prototype.changed = mg.prototype.u, mg.prototype.dispatchEvent = mg.prototype.b, mg.prototype.getRevision = mg.prototype.K, mg.prototype.on = mg.prototype.I, mg.prototype.once = mg.prototype.L, mg.prototype.un = mg.prototype.J, mg.prototype.unByKey = mg.prototype.M, bg.prototype.constrainCenter = bg.prototype.ce, bg.prototype.constrainResolution = bg.prototype.constrainResolution, bg.prototype.constrainRotation = bg.prototype.constrainRotation, bg.prototype.getCenter = bg.prototype.cb, bg.prototype.calculateExtent = bg.prototype.Cc, bg.prototype.getMaxResolution = bg.prototype.Cj, bg.prototype.getMinResolution = bg.prototype.Dj, bg.prototype.getProjection = bg.prototype.Ej, bg.prototype.getResolution = bg.prototype.aa, bg.prototype.getResolutions = bg.prototype.Fj, bg.prototype.getRotation = bg.prototype.Ra, bg.prototype.getZoom = bg.prototype.ah, bg.prototype.fit = bg.prototype.Ad, bg.prototype.centerOn = bg.prototype.wi, bg.prototype.rotate = bg.prototype.rotate, bg.prototype.setCenter = bg.prototype.qb, bg.prototype.setResolution = bg.prototype.Xb, bg.prototype.setRotation = bg.prototype.Ld, bg.prototype.setZoom = bg.prototype.ig, bg.prototype.get = bg.prototype.get, bg.prototype.getKeys = bg.prototype.R, bg.prototype.getProperties = bg.prototype.N, bg.prototype.set = bg.prototype.set, bg.prototype.setProperties = bg.prototype.G, bg.prototype.unset = bg.prototype.S, bg.prototype.changed = bg.prototype.u, bg.prototype.dispatchEvent = bg.prototype.b, bg.prototype.getRevision = bg.prototype.K, bg.prototype.on = bg.prototype.I, bg.prototype.once = bg.prototype.L, bg.prototype.un = bg.prototype.J, bg.prototype.unByKey = bg.prototype.M
}(),
function(t, e, i) {
    function n(t, e) { return typeof t === e }

    function r() {
        var t, e, i, r, o, s, a;
        for (var h in b)
            if (b.hasOwnProperty(h)) {
                if (t = [], e = b[h], e.name && (t.push(e.name.toLowerCase()), e.options && e.options.aliases && e.options.aliases.length))
                    for (i = 0; i < e.options.aliases.length; i++) t.push(e.options.aliases[i].toLowerCase());
                for (r = n(e.fn, "function") ? e.fn() : e.fn, o = 0; o < t.length; o++) s = t[o], a = s.split("."), 1 === a.length ? x[a[0]] = r : (!x[a[0]] || x[a[0]] instanceof Boolean || (x[a[0]] = new Boolean(x[a[0]])), x[a[0]][a[1]] = r), v.push((r ? "" : "no-") + a.join("-"))
            }
    }

    function o(t) {
        var e = E.className,
            i = x._config.classPrefix || "";
        if (S && (e = e.baseVal), x._config.enableJSClass) {
            var n = new RegExp("(^|\\s)" + i + "no-js(\\s|$)");
            e = e.replace(n, "$1" + i + "js$2")
        }
        x._config.enableClasses && (e += " " + i + t.join(" " + i), S ? E.className.baseVal = e : E.className = e)
    }

    function s() { return "function" != typeof e.createElement ? e.createElement(arguments[0]) : S ? e.createElementNS.call(e, "http://www.w3.org/2000/svg", arguments[0]) : e.createElement.apply(e, arguments) }

    function a(t) { return t.replace(/([a-z])-([a-z])/g, function(t, e, i) { return e + i.toUpperCase() }).replace(/^-/, "") }

    function h() { var t = e.body; return t || (t = s(S ? "svg" : "body"), t.fake = !0), t }

    function l(t, i, n, r) {
        var o, a, l, u, p = "modernizr",
            c = s("div"),
            f = h();
        if (parseInt(n, 10))
            for (; n--;) l = s("div"), l.id = r ? r[n] : p + (n + 1), c.appendChild(l);
        return o = s("style"), o.type = "text/css", o.id = "s" + p, (f.fake ? f : c).appendChild(o), f.appendChild(c), o.styleSheet ? o.styleSheet.cssText = t : o.appendChild(e.createTextNode(t)), c.id = p, f.fake && (f.style.background = "", f.style.overflow = "hidden", u = E.style.overflow, E.style.overflow = "hidden", E.appendChild(f)), a = i(c, t), f.fake ? (f.parentNode.removeChild(f), E.style.overflow = u, E.offsetHeight) : c.parentNode.removeChild(c), !!a
    }

    function u(t, e) { return !!~("" + t).indexOf(e) }

    function p(t, e) { return function() { return t.apply(e, arguments) } }

    function c(t, e, i) {
        var r;
        for (var o in t)
            if (t[o] in e) return i === !1 ? t[o] : (r = e[t[o]], n(r, "function") ? p(r, i || e) : r);
        return !1
    }

    function f(t) { return t.replace(/([A-Z])/g, function(t, e) { return "-" + e.toLowerCase() }).replace(/^ms-/, "-ms-") }

    function g(e, n) {
        var r = e.length;
        if ("CSS" in t && "supports" in t.CSS) {
            for (; r--;)
                if (t.CSS.supports(f(e[r]), n)) return !0;
            return !1
        }
        if ("CSSSupportsRule" in t) { for (var o = []; r--;) o.push("(" + f(e[r]) + ":" + n + ")"); return o = o.join(" or "), l("@supports (" + o + ") { #modernizr { position: absolute; } }", function(t) { return "absolute" == getComputedStyle(t, null).position }) }
        return i
    }

    function d(t, e, r, o) {
        function h() { p && (delete A.style, delete A.modElem) }
        if (o = !n(o, "undefined") && o, !n(r, "undefined")) { var l = g(t, r); if (!n(l, "undefined")) return l }
        for (var p, c, f, d, y, m = ["modernizr", "tspan", "samp"]; !A.style && m.length;) p = !0, A.modElem = s(m.shift()), A.style = A.modElem.style;
        for (f = t.length, c = 0; c < f; c++)
            if (d = t[c], y = A.style[d], u(d, "-") && (d = a(d)), A.style[d] !== i) { if (o || n(r, "undefined")) return h(), "pfx" != e || d; try { A.style[d] = r } catch (t) {} if (A.style[d] != y) return h(), "pfx" != e || d }
        return h(), !1
    }

    function y(t, e, i, r, o) {
        var s = t.charAt(0).toUpperCase() + t.slice(1),
            a = (t + " " + M.join(s + " ") + s).split(" ");
        return n(e, "string") || n(e, "undefined") ? d(a, e, r, o) : (a = (t + " " + k.join(s + " ") + s).split(" "), c(a, e, i))
    }

    function m(t, e, n) { return y(t, i, i, e, n) }
    var v = [],
        b = [],
        w = {
            _version: "3.3.1",
            _config: { classPrefix: "", enableClasses: !0, enableJSClass: !0, usePrefixes: !0 },
            _q: [],
            on: function(t, e) {
                var i = this;
                setTimeout(function() { e(i[t]) }, 0)
            },
            addTest: function(t, e, i) { b.push({ name: t, fn: e, options: i }) },
            addAsyncTest: function(t) { b.push({ name: null, fn: t }) }
        },
        x = function() {};
    x.prototype = w, x = new x;
    var E = e.documentElement,
        S = "svg" === E.nodeName.toLowerCase();
    x.addTest("canvas", function() { var t = s("canvas"); return !(!t.getContext || !t.getContext("2d")) });
    var N = w._config.usePrefixes ? " -webkit- -moz- -o- -ms- ".split(" ") : ["", ""];
    w._prefixes = N;
    var L = w.testStyles = l;
    x.addTest("touchevents", function() {
        var i;
        if ("ontouchstart" in t || t.DocumentTouch && e instanceof DocumentTouch) i = !0;
        else {
            var n = ["@media (", N.join("touch-enabled),("), "heartz", ")", "{#modernizr{top:9px;position:absolute}}"].join("");
            L(n, function(t) { i = 9 === t.offsetTop })
        }
        return i
    });
    var C = "Moz O ms Webkit",
        M = w._config.usePrefixes ? C.split(" ") : [];
    w._cssomPrefixes = M;
    var I = function(e) {
        var n, r = N.length,
            o = t.CSSRule;
        if ("undefined" == typeof o) return i;
        if (!e) return !1;
        if (e = e.replace(/^@/, ""), n = e.replace(/-/g, "_").toUpperCase() + "_RULE", n in o) return "@" + e;
        for (var s = 0; s < r; s++) {
            var a = N[s],
                h = a.toUpperCase() + "_" + n;
            if (h in o) return "@-" + a.toLowerCase() + "-" + e
        }
        return !1
    };
    w.atRule = I;
    var k = w._config.usePrefixes ? C.toLowerCase().split(" ") : [];
    w._domPrefixes = k;
    var T = { elem: s("modernizr") };
    x._q.push(function() { delete T.elem });
    var A = { style: T.elem.style };
    x._q.unshift(function() { delete A.style }), w.testAllProps = y, w.testAllProps = m, x.addTest("cssanimations", m("animationName", "a", !0)), x.addTest("csstransitions", m("transition", "all", !0));
    var R = w.prefixed = function(t, e, i) { return 0 === t.indexOf("@") ? I(t) : (t.indexOf("-") != -1 && (t = a(t)), e ? y(t, e, i) : y(t, "pfx")) },
        _ = R("URL", t, !1);
    _ = _ && t[_], x.addTest("bloburls", _ && "revokeObjectURL" in _ && "createObjectURL" in _), r(), o(v), delete w.addTest, delete w.addAsyncTest;
    for (var P = 0; P < x._q.length; P++) x._q[P]();
    t.Modernizr = x
}(window, document);
var modifyStyle = new ol.style.Style({ image: new ol.style.Circle({ radius: 7, fill: new ol.style.Fill({ color: "red" }) }) }),
    lineStyle = new ol.style.Style({ stroke: new ol.style.Stroke({ color: "rgba(255,0,0,0.2)", width: 3 }) }),
    drawStyle = function(t, e) {
        var i = "rgba(255, 0, 0, 0.1)",
            n = "white",
            r = 5,
            o = "rgba(255, 0, 0, 1.0)";
        illegalStyle ? (i = "rgba(255,0,0,0.6)", n = "red", t && (r = 2 == t.getGeometry().getCoordinates()[0].length ? 6 : 4)) : canFinishStyle && (i = "rgba(255,255,255,0.7)");
        var s = [new ol.style.Style({ fill: new ol.style.Fill({ color: i }) }), new ol.style.Style({ stroke: new ol.style.Stroke({ color: n, width: r }), geometry: function(t) { if ("Polygon" === t.getGeometry().getType()) return new ol.geom.LineString(t.getGeometry().getCoordinates()[0]) } }), new ol.style.Style({ stroke: new ol.style.Stroke({ color: o, width: 3 }), geometry: function(t) { if ("Polygon" === t.getGeometry().getType()) return new ol.geom.LineString(t.getGeometry().getCoordinates()[0]) } })];
        return s
    };
(function(t) {
    function e(t) { if (t.length) { if (1 === t.length) return "string" == typeof t[0] ? document.createTextNode(t[0]) : t[0]; for (var e, i = document.createDocumentFragment(), n = t.length, r = -1; ++r < n;) e = t[r], i.appendChild("string" == typeof e ? document.createTextNode(e) : e); return i } throw new Error("DOM Exception 8") }
    Document.prototype.after = Element.prototype.after = function() { this.parentNode && this.parentNode.insertBefore(e(arguments), this.nextSibling) }, "Text" in this && (Text.prototype.after = Element.prototype.after), Document.prototype.append = Element.prototype.append = function() { this.appendChild(e(arguments)) }, Document.prototype.before = Element.prototype.before = function() { this.parentNode && this.parentNode.insertBefore(e(arguments), this) }, "Text" in this && (Text.prototype.before = Element.prototype.before), Document.prototype.prepend = Element.prototype.prepend = function() { this.insertBefore(e(arguments), this.firstChild) }, Document.prototype.replaceWith = Element.prototype.replaceWith = function() { this.parentNode && this.parentNode.replaceChild(e(arguments), this) }, "Text" in this && (Text.prototype.replaceWith = Element.prototype.replaceWith)
}).call("object" == typeof window && window || "object" == typeof self && self || "object" == typeof global && global || {});
var DEFAULT_KML_NAME = "perimeter",
    MAX_LENGTH_KML_NAME = 30,
    fence = [63e3, 302e3, 48e4, 837e3],
    extents = [42e4, 3e4, 9e5, 35e4],
    fencePolygone = turf.polygon([
        [
            [48e4, 302e3],
            [837e3, 302e3],
            [837e3, 63e3],
            [48e4, 63e3],
            [48e4, 302e3]
        ]
    ]),
    extent100 = turf.polygon([
        [
            [55e4, 302e3],
            [795e3, 302e3],
            [795e3, 254e3],
            [83e4, 254e3],
            [83e4, 206e3],
            [836800, 206e3],
            [836800, 158e3],
            [83e4, 158e3],
            [83e4, 11e4],
            [76e4, 11e4],
            [76e4, 62e3],
            [48e4, 62e3],
            [48e4, 254e3],
            [55e4, 254e3],
            [55e4, 302e3]
        ]
    ]),
    extent50 = turf.polygon([
        [
            [655e3, 302e3],
            [76e4, 302e3],
            [76e4, 278e3],
            [795e3, 278e3],
            [795e3, 23e4],
            [83e4, 23e4],
            [83e4, 206e3],
            [865e3, 206e3],
            [865e3, 158e3],
            [83e4, 158e3],
            [83e4, 11e4],
            [76e4, 11e4],
            [76e4, 62e3],
            [69e4, 62e3],
            [69e4, 86e3],
            [655e3, 86e3],
            [655e3, 62e3],
            [55e4, 62e3],
            [55e4, 11e4],
            [48e4, 11e4],
            [48e4, 182e3],
            [515e3, 182e3],
            [515e3, 23e4],
            [55e4, 23e4],
            [55e4, 278e3],
            [655e3, 278e3],
            [655e3, 302e3]
        ]
    ]),
    extent25 = turf.polygon([
        [
            [48e4, 11e4],
            [48e4, 158e3],
            [497500, 158e3],
            [497500, 182e3],
            [515e3, 182e3],
            [515e3, 206e3],
            [532500, 206e3],
            [532500, 23e4],
            [55e4, 23e4],
            [55e4, 266e3],
            [602500, 266e3],
            [602500, 278e3],
            [672500, 278e3],
            [672500, 302e3],
            [707500, 302e3],
            [707500, 29e4],
            [76e4, 29e4],
            [76e4, 278e3],
            [777500, 278e3],
            [777500, 218e3],
            [795e3, 218e3],
            [795e3, 206e3],
            [812500, 206e3],
            [812500, 218e3],
            [83e4, 218e3],
            [83e4, 206e3],
            [847500, 206e3],
            [847500, 158e3],
            [812500, 158e3],
            [812500, 122e3],
            [795e3, 122e3],
            [795e3, 134e3],
            [777500, 134e3],
            [777500, 122e3],
            [76e4, 122e3],
            [76e4, 134e3],
            [742500, 134e3],
            [742500, 98e3],
            [725e3, 98e3],
            [725e3, 86e3],
            [742500, 86e3],
            [742500, 74e3],
            [707500, 74e3],
            [707500, 86e3],
            [69e4, 86e3],
            [69e4, 11e4],
            [672500, 11e4],
            [672500, 122e3],
            [655e3, 122e3],
            [655e3, 86e3],
            [602500, 86e3],
            [602500, 74e3],
            [567500, 74e3],
            [567500, 86e3],
            [55e4, 86e3],
            [55e4, 134e3],
            [515e3, 134e3],
            [515e3, 11e4],
            [48e4, 11e4]
        ]
    ]),
    TILE25 = 409e3,
    TILE50 = 1638400,
    TILE100 = 6553600,
    TILE300 = 6724e4,
    TILE500 = 16384e4,
    startCoordinate, firstCoordinate, currentCoordinate, illegalModify = !1,
    illegalStyle = !1,
    canFinishStyle = !1,
    lingua = null,
    perimetersArray = [],
    vectorLayerStyle = new ol.style.Style({ fill: new ol.style.Fill({ color: "rgba(255,255,255,0.3)" }), stroke: new ol.style.Stroke({ color: "rgba(255, 0, 0, 1.0)", width: 3 }) }),
    vectorSource = new ol.source.Vector,
    vectorLayer = new ol.layer.Vector({ source: vectorSource, style: vectorLayerStyle }),
    fenceSource = new ol.source.Vector,
    fenceLayer = new ol.layer.Vector({ source: fenceSource, style: new ol.style.Style({ stroke: new ol.style.Stroke({ color: "rgba(0, 0, 0, 0.2)", width: 6 }) }) }),
    fenceFeature = new ol.Feature({ geometry: new ol.geom.Polygon(fencePolygone.geometry.coordinates) });
fenceFeatureForderground = fenceFeature.clone(), fenceFeatureForderground.setStyle(new ol.style.Style({ stroke: new ol.style.Stroke({ color: "rgba(255, 255, 255, 1)", width: 4 }) })), $(document).ready(function() {
        internationalize(function() { checkBrowser() });
        var t = document.createElement("img");
        t.src = "/favicon.png";
        var e = ga.layer.create("ch.swisstopo.pixelkarte-farbe"),
            i = new ol.Map({ layers: [e, vectorLayer], target: "map", interactions: ol.interaction.defaults({ shiftDragZoom: !1, doubleClickZoom: !1 }).extend([getDragNdropInteraction()]), view: new ol.View({ center: [67e4, 185e3], zoom: 9, minZoom: 8, maxZoom: 16, extent: extents }), logo: t, controls: ol.control.defaults({ zoom: !1, rotate: !1, attributionOptions: { collapsible: !1 } }).extend([new ol.control.ScaleLine({ units: "metric", target: document.getElementById("scaleline-id") }), new ol.control.MousePosition({ coordinateFormat: setMouseCoords(0), target: "mouseposition", undefinedHTML: "-&nbsp;" })]), loadTilesWhileAnimating: !0, loadTilesWhileInteracting: !0 });
        fenceSource.addFeature(fenceFeatureForderground), fenceSource.addFeature(fenceFeature), i.addLayer(fenceLayer), i.addLayer(vectorLayer), addInteractions(i);
        addGuiActions(i), $("#loaderId").delay(250).fadeOut(750, function() { $("#loaderId").remove() })
    }),
    function() {
        function t(t) {
            var e = "    ";
            if (isNaN(parseInt(t))) e = t;
            else switch (t) {
                case 1:
                    e = " ";
                    break;
                case 2:
                    e = "  ";
                    break;
                case 3:
                    e = "   ";
                    break;
                case 4:
                    e = "    ";
                    break;
                case 5:
                    e = "     ";
                    break;
                case 6:
                    e = "      ";
                    break;
                case 7:
                    e = "       ";
                    break;
                case 8:
                    e = "        ";
                    break;
                case 9:
                    e = "         ";
                    break;
                case 10:
                    e = "          ";
                    break;
                case 11:
                    e = "           ";
                    break;
                case 12:
                    e = "            "
            }
            var i = ["\n"];
            for (ix = 0; ix < 100; ix++) i.push(i[ix] + e);
            return i
        }

        function e() { this.step = "    ", this.shift = t(this.step) }

        function i(t, e) { return e - (t.replace(/\(/g, "").length - t.replace(/\)/g, "").length) }

        function n(t, e) { return t.replace(/\s{1,}/g, " ").replace(/ AND /gi, "~::~" + e + e + "AND ").replace(/ BETWEEN /gi, "~::~" + e + "BETWEEN ").replace(/ CASE /gi, "~::~" + e + "CASE ").replace(/ ELSE /gi, "~::~" + e + "ELSE ").replace(/ END /gi, "~::~" + e + "END ").replace(/ FROM /gi, "~::~FROM ").replace(/ GROUP\s{1,}BY/gi, "~::~GROUP BY ").replace(/ HAVING /gi, "~::~HAVING ").replace(/ IN /gi, " IN ").replace(/ JOIN /gi, "~::~JOIN ").replace(/ CROSS~::~{1,}JOIN /gi, "~::~CROSS JOIN ").replace(/ INNER~::~{1,}JOIN /gi, "~::~INNER JOIN ").replace(/ LEFT~::~{1,}JOIN /gi, "~::~LEFT JOIN ").replace(/ RIGHT~::~{1,}JOIN /gi, "~::~RIGHT JOIN ").replace(/ ON /gi, "~::~" + e + "ON ").replace(/ OR /gi, "~::~" + e + e + "OR ").replace(/ ORDER\s{1,}BY/gi, "~::~ORDER BY ").replace(/ OVER /gi, "~::~" + e + "OVER ").replace(/\(\s{0,}SELECT /gi, "~::~(SELECT ").replace(/\)\s{0,}SELECT /gi, ")~::~SELECT ").replace(/ THEN /gi, " THEN~::~" + e).replace(/ UNION /gi, "~::~UNION~::~").replace(/ USING /gi, "~::~USING ").replace(/ WHEN /gi, "~::~" + e + "WHEN ").replace(/ WHERE /gi, "~::~WHERE ").replace(/ WITH /gi, "~::~WITH ").replace(/ ALL /gi, " ALL ").replace(/ AS /gi, " AS ").replace(/ ASC /gi, " ASC ").replace(/ DESC /gi, " DESC ").replace(/ DISTINCT /gi, " DISTINCT ").replace(/ EXISTS /gi, " EXISTS ").replace(/ NOT /gi, " NOT ").replace(/ NULL /gi, " NULL ").replace(/ LIKE /gi, " LIKE ").replace(/\s{0,}SELECT /gi, "SELECT ").replace(/\s{0,}UPDATE /gi, "UPDATE ").replace(/ SET /gi, " SET ").replace(/~::~{1,}/g, "~::~").split("~::~") }
        e.prototype.xml = function(e, i) {
            var n = e.replace(/>\s{0,}</g, "><").replace(/</g, "~::~<").replace(/\s*xmlns\:/g, "~::~xmlns:").replace(/\s*xmlns\=/g, "~::~xmlns=").split("~::~"),
                r = n.length,
                o = !1,
                s = 0,
                a = "",
                h = 0,
                l = i ? t(i) : this.shift;
            for (h = 0; h < r; h++) n[h].search(/<!/) > -1 ? (a += l[s] + n[h], o = !0, (n[h].search(/-->/) > -1 || n[h].search(/\]>/) > -1 || n[h].search(/!DOCTYPE/) > -1) && (o = !1)) : n[h].search(/-->/) > -1 || n[h].search(/\]>/) > -1 ? (a += n[h], o = !1) : /^<\w/.exec(n[h - 1]) && /^<\/\w/.exec(n[h]) && /^<[\w:\-\.\,]+/.exec(n[h - 1]) == /^<\/[\w:\-\.\,]+/.exec(n[h])[0].replace("/", "") ? (a += n[h], o || s--) : n[h].search(/<\w/) > -1 && n[h].search(/<\//) == -1 && n[h].search(/\/>/) == -1 ? a = a += o ? n[h] : l[s++] + n[h] : n[h].search(/<\w/) > -1 && n[h].search(/<\//) > -1 ? a = a += o ? n[h] : l[s] + n[h] : n[h].search(/<\//) > -1 ? a = a += o ? n[h] : l[--s] + n[h] : n[h].search(/\/>/) > -1 ? a = a += o ? n[h] : l[s] + n[h] : a += n[h].search(/<\?/) > -1 ? l[s] + n[h] : n[h].search(/xmlns\:/) > -1 || n[h].search(/xmlns\=/) > -1 ? l[s] + n[h] : n[h];
            return "\n" == a[0] ? a.slice(1) : a
        }, e.prototype.json = function(t, e) { var e = e ? e : this.step; return "undefined" == typeof JSON ? t : "string" == typeof t ? JSON.stringify(JSON.parse(t), null, e) : "object" == typeof t ? JSON.stringify(t, null, e) : t }, e.prototype.css = function(e, i) {
            var n = e.replace(/\s{1,}/g, " ").replace(/\{/g, "{~::~").replace(/\}/g, "~::~}~::~").replace(/\;/g, ";~::~").replace(/\/\*/g, "~::~/*").replace(/\*\//g, "*/~::~").replace(/~::~\s{0,}~::~/g, "~::~").split("~::~"),
                r = n.length,
                o = 0,
                s = "",
                a = 0,
                h = i ? t(i) : this.shift;
            for (a = 0; a < r; a++) s += /\{/.exec(n[a]) ? h[o++] + n[a] : /\}/.exec(n[a]) ? h[--o] + n[a] : /\*\\/.exec(n[a]) ? h[o] + n[a] : h[o] + n[a];
            return s.replace(/^\n{1,}/, "")
        }, e.prototype.sql = function(e, r) {
            var o = e.replace(/\s{1,}/g, " ").replace(/\'/gi, "~::~'").split("~::~"),
                s = o.length,
                a = [],
                h = 0,
                l = this.step,
                u = 0,
                p = "",
                c = 0,
                f = r ? t(r) : this.shift;
            for (c = 0; c < s; c++) a = c % 2 ? a.concat(o[c]) : a.concat(n(o[c], l));
            for (s = a.length, c = 0; c < s; c++) { u = i(a[c], u), /\s{0,}\s{0,}SELECT\s{0,}/.exec(a[c]) && (a[c] = a[c].replace(/\,/g, ",\n" + l + l)), /\s{0,}\s{0,}SET\s{0,}/.exec(a[c]) && (a[c] = a[c].replace(/\,/g, ",\n" + l + l)), /\s{0,}\(\s{0,}SELECT\s{0,}/.exec(a[c]) ? (h++, p += f[h] + a[c]) : /\'/.exec(a[c]) ? (u < 1 && h && h--, p += a[c]) : (p += f[h] + a[c], u < 1 && h && h--) }
            return p = p.replace(/^\n{1,}/, "").replace(/\n{1,}/g, "\n")
        }, e.prototype.xmlmin = function(t, e) { var i = e ? t : t.replace(/\<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)\>/g, "").replace(/[ \r\n\t]{1,}xmlns/g, " xmlns"); return i.replace(/>\s{0,}</g, "><") }, e.prototype.jsonmin = function(t) { return "undefined" == typeof JSON ? t : JSON.stringify(JSON.parse(t), null, 0) }, e.prototype.cssmin = function(t, e) { var i = e ? t : t.replace(/\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\//g, ""); return i.replace(/\s{1,}/g, " ").replace(/\{\s{1,}/g, "{").replace(/\}\s{1,}/g, "}").replace(/\;\s{1,}/g, ";").replace(/\/\*\s{1,}/g, "/*").replace(/\*\/\s{1,}/g, "*/") }, e.prototype.sqlmin = function(t) { return t.replace(/\s{1,}/g, " ").replace(/\s{1,}\(/, "(").replace(/\s{1,}\)/, ")") }, window.vkbeautify = new e
    }();